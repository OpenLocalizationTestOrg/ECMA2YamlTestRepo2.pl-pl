### YamlMime:ManagedReference
items:
- uid: System.Collections.Hashtable
  id: Hashtable
  children:
  - System.Collections.Hashtable.#ctor
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary)
  - System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)
  - System.Collections.Hashtable.#ctor(System.Int32)
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)
  - System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)
  - System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)
  - System.Collections.Hashtable.#ctor(System.Int32,System.Single)
  - System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)
  - System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  - System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  - System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  - System.Collections.Hashtable.Add(System.Object,System.Object)
  - System.Collections.Hashtable.Clear
  - System.Collections.Hashtable.Clone
  - System.Collections.Hashtable.comparer
  - System.Collections.Hashtable.Contains(System.Object)
  - System.Collections.Hashtable.ContainsKey(System.Object)
  - System.Collections.Hashtable.ContainsValue(System.Object)
  - System.Collections.Hashtable.CopyTo(System.Array,System.Int32)
  - System.Collections.Hashtable.Count
  - System.Collections.Hashtable.EqualityComparer
  - System.Collections.Hashtable.GetEnumerator
  - System.Collections.Hashtable.GetHash(System.Object)
  - System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Collections.Hashtable.hcp
  - System.Collections.Hashtable.IsFixedSize
  - System.Collections.Hashtable.IsReadOnly
  - System.Collections.Hashtable.IsSynchronized
  - System.Collections.Hashtable.Item(System.Object)
  - System.Collections.Hashtable.KeyEquals(System.Object,System.Object)
  - System.Collections.Hashtable.Keys
  - System.Collections.Hashtable.OnDeserialization(System.Object)
  - System.Collections.Hashtable.Remove(System.Object)
  - System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)
  - System.Collections.Hashtable.SyncRoot
  - System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator
  - System.Collections.Hashtable.Values
  langs:
  - csharp
  name: Hashtable
  nameWithType: Hashtable
  fullName: System.Collections.Hashtable
  type: Class
  summary: "Reprezentuje kolekcję pary klucz wartość, które są podzielone na podstawie kodu skrótu klucza.       Aby przejrzeć kod źródłowy .NET Framework dla tego typu, zobacz [źródło odwołania](http://referencesource.microsoft.com/#mscorlib/system/collections/hashtable.cs#10fefb6e0ae510dd)."
  remarks: "> [!NOTE]> Tak, aby wyświetlić kod źródłowy .NET Framework dla tego typu, zobacz [źródło odwołania](http://referencesource.microsoft.com/#mscorlib/system/collections/hashtable.cs#10fefb6e0ae510dd). Można przejrzeć kod źródłowy w tryb online, Pobierz odwołanie do wyświetlenia w trybie offline i kroków opisanych źródeł (w tym poprawek i aktualizacji) podczas debugowania. zobacz [instrukcje](http://referencesource.microsoft.com/).       Każdy element jest parę klucza i wartości przechowywane w <xref:System.Collections.DictionaryEntry>obiektu.</xref:System.Collections.DictionaryEntry> Klucz nie może być `null`, ale może być wartością.       Obiekty używane jako klucze przez tablicę skrótów są wymagane do przesłonięcia <xref:System.Object.GetHashCode%2A?displayProperty=fullName>— Metoda (lub <xref:System.Collections.IHashCodeProvider>interface) i <xref:System.Object.Equals%2A?displayProperty=fullName>— Metoda (lub <xref:System.Collections.IComparer>interfejs).</xref:System.Collections.IComparer> </xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Collections.IHashCodeProvider> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> Implementacja metody i interfejsy musi obsługiwać uwzględniana wielkość liter, ten sam sposób; w przeciwnym razie wartość tablicy skrótów może działać niepoprawnie. Na przykład podczas tworzenia obiektu Hashtable, należy użyć <xref:System.Collections.CaseInsensitiveHashCodeProvider>klasy (lub dowolna bez uwzględniania wielkości liter <xref:System.Collections.IHashCodeProvider>implementacji) z <xref:System.Collections.CaseInsensitiveComparer>klasy (lub dowolna bez uwzględniania wielkości liter <xref:System.Collections.IComparer>implementacji).</xref:System.Collections.IComparer> </xref:System.Collections.CaseInsensitiveComparer> </xref:System.Collections.IHashCodeProvider> </xref:System.Collections.CaseInsensitiveHashCodeProvider>       Ponadto te metody musi mieć takie same wyniki wywołanego z takimi samymi parametrami, podczas gdy ten klucz istnieje w kolekcji Hashtable. Alternatywą jest użycie konstruktora Hashtable o <xref:System.Collections.IEqualityComparer>parametru.</xref:System.Collections.IEqualityComparer> Jeśli klucza równości zostały po prostu równości odwołań, dziedziczone wykonania <xref:System.Object.GetHashCode%2A?displayProperty=fullName>i <xref:System.Object.Equals%2A?displayProperty=fullName>będą wystarczające.</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName>       Obiekty klucza musi być niezmienne tak długo, jak są używane jako klucze w kolekcji Hashtable.       Gdy element zostanie dodany do tabeli skrótów, element jest umieszczany w pojemniku oparte na wartość skrótu klucza. Kolejne wyszukiwań klucza umożliwia wyszukiwanie tylko jednego określonego zasobnik, w związku z tym znacznie zmniejszyć liczbę kluczy porównania wymagane do znalezienia elementu skrótu klucza.       Wartość współczynnika ładowania obiektu Hashtable określa maksymalny stosunek elementów zasobników. Mniejsze obciążenie czynniki spowodować godziny szybszy średni wyszukiwania kosztem zużycie pamięci. Domyślny współczynnik obciążenia 1.0 zazwyczaj zapewnia równowagę między szybkość i rozmiar. Współczynnik różne obciążenia można również określić podczas tworzenia tabeli skrótów.       Po dodaniu elementów do tablicy skrótów, zwiększa współczynnik rzeczywiste obciążenie tablicy skrótów. Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, liczba przedziałów w Hashtable zwiększa się automatycznie na najmniejszą liczbę pierwszych, która jest większa niż dwa razy bieżąca liczba zasobników Hashtable.       Każdy obiekt klucza w tablicy skrótów podać jego własnej funkcji skrótu, którego dostęp można uzyskać przez wywołanie metody <xref:System.Collections.Hashtable.GetHash%2A>.</xref:System.Collections.Hashtable.GetHash%2A> Jednak żadnego obiekt implementujący <xref:System.Collections.IHashCodeProvider>mogą zostać przekazane do konstruktora obiektu Hashtable, a ta funkcja skrótu jest używany dla wszystkich obiektów w tabeli.</xref:System.Collections.IHashCodeProvider>       Pojemność tablicy skrótów jest liczba elementów, które może przechowywać Hashtable. Po dodaniu elementów do tablicy skrótów, pojemność jest automatycznie zwiększana co jest wymagane przez; Ponowna alokacja.       W przypadku bardzo dużych obiektów Hashtable może zwiększyć maksymalną pojemność do 2 miliardów elementów w 64-bitowym systemie ustawiając `enabled` atrybutu elementu konfiguracji, aby `true` w środowisku czasu wykonywania.       `foreach` Instrukcji języka C# (`For Each` w języku Visual Basic) zwraca obiekt typu elementów w kolekcji. Ponieważ każdy element tablicy skrótów parę klucz/wartość, typ elementu nie jest typu klucza lub typ wartości. Zamiast tego typu jest <xref:System.Collections.DictionaryEntry>.</xref:System.Collections.DictionaryEntry> Na przykład: [!code-cpp [System.Collections.Hashtable_ClassExample#01](~/add/codesnippet/cpp/t-system.collections.has_1.cpp)][!code-cs[System.Collections.Hashtable_ClassExample#01](~/add/codesnippet/csharp/t-system.collections.has_1.cs)][!code-vb[System.Collections.Hashtable_ClassExample#01](~/add/codesnippet/visualbasic/t-system.collections.has_1.vb) ] `foreach` instrukcja jest otokę moduł wyliczający, który zezwala tylko odczyt z bez zapisywania do kolekcji.           Ponieważ serializacji i deserializacji moduł wyliczający dla obiektu Hashtable może spowodować elementy, aby stać się zmienić kolejności, nie jest możliwe kontynuowanie wyliczenia bez wywoływania <xref:System.Collections.IEnumerator.Reset%2A>metody.</xref:System.Collections.IEnumerator.Reset%2A>      > [!NOTE] > Ponieważ klucze mogą być dziedziczone i ich zachowanie zmieniona, ich bezwzględną unikatowości nie może zagwarantować porównania przy użyciu <xref:System.Type.Equals%2A>metody.</xref:System.Type.Equals%2A>"
  example:
  - "The following example shows how to create, initialize and perform various functions to a Hashtable and how to print out its keys and values.  \n  \n [!code-cpp[System.Collections.Hashtable_ClassExample#00](~/add/codesnippet/cpp/t-system.collections.has_2.cpp)]\n [!code-cs[System.Collections.Hashtable_ClassExample#00](~/add/codesnippet/csharp/t-system.collections.has_2.cs)]\n [!code-vb[System.Collections.Hashtable_ClassExample#00](~/add/codesnippet/visualbasic/t-system.collections.has_2.vb)]"
  syntax:
    content: >-
      [System.Diagnostics.DebuggerDisplay("Count = {Count}")]

      [System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Hashtable/HashtableDebugView))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public class Hashtable : ICloneable, System.Collections.IDictionary, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable
  inheritance:
  - System.Object
  implements:
  - System.Collections.IDictionary
  - System.ICloneable
  - System.Runtime.Serialization.IDeserializationCallback
  - System.Runtime.Serialization.ISerializable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor
  id: '#ctor'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable()
  nameWithType: Hashtable.Hashtable()
  fullName: System.Collections.Hashtable.Hashtable()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicjuje nową, pustą wystąpienie <xref href=&quot;System.Collections.Hashtable&quot;> </xref> przy użyciu domyślnego początkowa pojemność, załadowanie współczynnik dostawcy kodu wyznaczania wartości skrótu i porównania."
  remarks: "Pojemność tablicy skrótów służy do obliczania optymalną liczbę zasobników tabeli skrótu na podstawie współczynnika obciążenia. Pojemność jest automatycznie zwiększana zgodnie z wymaganiami.       Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.       Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.       Dostawca kodu skrótu zrezygnuje skrótu kluczy w <xref:System.Collections.Hashtable>obiektu.</xref:System.Collections.Hashtable> Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable>muszą być unikatowe.</xref:System.Collections.Hashtable> Implementacja klucza <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName> jest domyślna funkcja porównująca       Ten konstruktor jest operacją O(1)."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctor#1](~/add/codesnippet/cpp/m-system.collections.has_4_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctor#1](~/add/codesnippet/csharp/m-system.collections.has_4_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctor#1](~/add/codesnippet/visualbasic/m-system.collections.has_4_1.vb)]"
  syntax:
    content: public Hashtable ();
    parameters: []
  overload: System.Collections.Hashtable.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary)
  id: '#ctor(System.Collections.IDictionary)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary)
  nameWithType: Hashtable.Hashtable(IDictionary)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Collections.Hashtable&quot;> </xref> przez skopiowanie elementy z określonego słownika do nowego <xref href=&quot;System.Collections.Hashtable&quot;> </xref> obiektu. Nowy <xref href=&quot;System.Collections.Hashtable&quot;> </xref> obiekt ma początkowej pojemności równa liczbie elementów kopiowanych i używa domyślną wartość współczynnika ładowania, dostawcy kodu wyznaczania wartości skrótu i porównania."
  remarks: "Początkowa pojemność wynosi liczba elementów w słowniku źródła. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.       Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.       Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.       Dostawca kodu skrótu zrezygnuje skrótu kluczy w <xref:System.Collections.Hashtable>obiektu.</xref:System.Collections.Hashtable> Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable>muszą być unikatowe.</xref:System.Collections.Hashtable> Implementacja klucza <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName> jest domyślna funkcja porównująca       Nowe elementy <xref:System.Collections.Hashtable>są sortowane w takiej samej kolejności, w której moduł wyliczający iteruje <xref:System.Collections.IDictionary>obiektu.</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       Ten konstruktor jest O (`n`) operację, której `n` jest liczba elementów w `d` parametru."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/cpp/m-system.collections.has_1_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/csharp/m-system.collections.has_1_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/visualbasic/m-system.collections.has_1_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>Obiektu można skopiować do nowego <xref href=&quot;System.Collections.Hashtable&quot;> </xref> obiektu.</xref:System.Collections.IDictionary>"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)
  id: '#ctor(System.Collections.IEqualityComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IEqualityComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicjuje nową, pustą wystąpienie <xref href=&quot;System.Collections.Hashtable&quot;> </xref> przy użyciu domyślnego początkowa pojemność i obciążenia współczynnik i określonego <xref:System.Collections.IEqualityComparer>obiektu.</xref:System.Collections.IEqualityComparer>"
  remarks: "Pojemność tablicy skrótów służy do obliczania optymalną liczbę zasobników tabeli skrótu na podstawie współczynnika obciążenia. Pojemność jest automatycznie zwiększana zgodnie z wymaganiami.       Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.       Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.       <xref:System.Collections.IEqualityComparer>Obiekt zawiera zarówno dostawcę kodu wyznaczania wartości skrótu i modułu porównującego.</xref:System.Collections.IEqualityComparer> Jeśli <xref:System.Collections.IEqualityComparer>jest używany w <xref:System.Collections.Hashtable>konstruktora, obiekty używane jako klucze w <xref:System.Collections.Hashtable>obiektu nie są wymagane w celu zastąpienia <xref:System.Object.GetHashCode%2A?displayProperty=fullName>i <xref:System.Object.Equals%2A?displayProperty=fullName>metody.</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       Kody skrótów kluczy w <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> zrezygnuje dostawcy kodu wyznaczania wartości skrótu Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable>muszą być unikatowe.</xref:System.Collections.Hashtable> Implementacja klucza <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName> jest domyślna funkcja porównująca       <xref:System.Collections.IEqualityComparer>Umożliwia obsługę scenariuszy takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.</xref:System.Collections.IEqualityComparer>       Ten konstruktor jest operacją O(1)."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctor#1](~/add/codesnippet/cpp/m-system.collections.has_5_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctor#1](~/add/codesnippet/csharp/m-system.collections.has_5_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctor#1](~/add/codesnippet/visualbasic/m-system.collections.has_5_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IEqualityComparer equalityComparer);
    parameters:
    - id: equalityComparer
      type: System.Collections.IEqualityComparer
      description: "<xref:System.Collections.IEqualityComparer>Obiektu, który definiuje dostawcy kodu wyznaczania wartości skrótu i modułu porównującego do użycia z <xref href=&quot;System.Collections.Hashtable&quot;> </xref> obiektu.</xref:System.Collections.IEqualityComparer>       - lub - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> do używania domyślnego dostawcy kodu wyznaczania wartości skrótu i domyślna funkcja porównująca. Domyślny dostawca kod skrótu jest implementacją każdy klucz &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; i wdrożenia każdego klucza jest domyślna funkcja porównująca &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;."
  overload: System.Collections.Hashtable.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32)
  nameWithType: Hashtable.Hashtable(Int32)
  fullName: System.Collections.Hashtable.Hashtable(Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicjuje nową, pustą wystąpienie <xref href=&quot;System.Collections.Hashtable&quot;> </xref> przy użyciu określonej pojemności początkowa i domyślną wartość współczynnika ładowania, dostawcy kodu wyznaczania wartości skrótu i porównania."
  remarks: "Określanie początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Hashtable>obiektu.</xref:System.Collections.Hashtable> Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.       Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.       Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.       Kody skrótów kluczy w <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> zrezygnuje dostawcy kodu wyznaczania wartości skrótu Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable>muszą być unikatowe.</xref:System.Collections.Hashtable> Implementacja klucza <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName> jest domyślna funkcja porównująca       Ten konstruktor jest O (`n`) operację, której `n` jest `capacity`."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/cpp/m-system.collections.has_2_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/csharp/m-system.collections.has_2_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/visualbasic/m-system.collections.has_2_1.vb)]"
  syntax:
    content: public Hashtable (int capacity);
    parameters:
    - id: capacity
      type: System.Int32
      description: "Przybliżoną liczbę elementów który <xref href=&quot;System.Collections.Hashtable&quot;> </xref> początkowo może zawierać obiektu."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>jest mniejsza od zera."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)
  id: '#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,IEqualityComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Collections.Hashtable&quot;> </xref> przez skopiowanie elementy z określonego słownika na nowy <xref href=&quot;System.Collections.Hashtable&quot;> </xref> obiektu. Nowy <xref href=&quot;System.Collections.Hashtable&quot;> </xref> obiekt ma początkowej pojemności równa liczbie elementów kopiowanych i korzysta z domyślnego współczynnika ładowania i określonego <xref:System.Collections.IEqualityComparer>obiektu.</xref:System.Collections.IEqualityComparer>"
  remarks: "Początkowa pojemność wynosi liczba elementów w słowniku źródła. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.       Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.       Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.       <xref:System.Collections.IEqualityComparer>Obiekt zawiera zarówno dostawcę kodu wyznaczania wartości skrótu i modułu porównującego.</xref:System.Collections.IEqualityComparer> Jeśli <xref:System.Collections.IEqualityComparer>jest używany w <xref:System.Collections.Hashtable>konstruktora, obiekty używane jako klucze w <xref:System.Collections.Hashtable>obiektu nie są wymagane w celu zastąpienia <xref:System.Object.GetHashCode%2A?displayProperty=fullName>i <xref:System.Object.Equals%2A?displayProperty=fullName>metody.</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       Kody skrótów kluczy w <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> zrezygnuje dostawcy kodu wyznaczania wartości skrótu Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable>muszą być unikatowe.</xref:System.Collections.Hashtable> Implementacja klucza <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName> jest domyślna funkcja porównująca       <xref:System.Collections.IEqualityComparer>Umożliwia obsługę scenariuszy takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.</xref:System.Collections.IEqualityComparer>       Nowe elementy <xref:System.Collections.Hashtable>są sortowane w takiej samej kolejności, w której moduł wyliczający iteruje <xref:System.Collections.IDictionary>obiektu.</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       Ten konstruktor jest O (`n`) operację, której `n` jest liczba elementów w `d` parametru."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/cpp/81cd87de-02b7-42cc-8fdd-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/csharp/81cd87de-02b7-42cc-8fdd-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/visualbasic/81cd87de-02b7-42cc-8fdd-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d, System.Collections.IEqualityComparer equalityComparer);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>Obiektu można skopiować do nowego <xref href=&quot;System.Collections.Hashtable&quot;> </xref> obiektu.</xref:System.Collections.IDictionary>"
    - id: equalityComparer
      type: System.Collections.IEqualityComparer
      description: "<xref:System.Collections.IEqualityComparer>Obiektu, który definiuje dostawcy kodu wyznaczania wartości skrótu i modułu porównującego do użycia z <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.IEqualityComparer>       - lub - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> do używania domyślnego dostawcy kodu wyznaczania wartości skrótu i domyślna funkcja porównująca. Domyślny dostawca kod skrótu jest implementacją każdy klucz &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; i wdrożenia każdego klucza jest domyślna funkcja porównująca &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)
  id: '#ctor(System.Collections.IDictionary,System.Single)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary,Single)
  nameWithType: Hashtable.Hashtable(IDictionary,Single)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Collections.Hashtable&quot;> </xref> przez skopiowanie elementy z określonego słownika do nowego <xref href=&quot;System.Collections.Hashtable&quot;> </xref> obiektu. Nowy <xref href=&quot;System.Collections.Hashtable&quot;> </xref> obiekt ma początkowej pojemności równa liczbie elementów kopiowanych i używa współczynnik obciążenia i domyślny dostawca kod skrótu i porównania."
  remarks: "Początkowa pojemność wynosi liczba elementów w słowniku źródła. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.       Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci. Współczynnik obciążenia 1.0 jest równowagę między szybkość i rozmiar.       Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.       Dostawca kodu skrótu zrezygnuje skrótu kluczy w <xref:System.Collections.Hashtable>obiektu.</xref:System.Collections.Hashtable> Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable>muszą być unikatowe.</xref:System.Collections.Hashtable> Implementacja klucza <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName> jest domyślna funkcja porównująca       Nowe elementy <xref:System.Collections.Hashtable>są sortowane w takiej samej kolejności, w której moduł wyliczający iteruje <xref:System.Collections.IDictionary>obiektu.</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       Ten konstruktor jest O (`n`) operację, której `n` jest liczba elementów w `d` parametru."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cs[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/csharp/fb1cfbc8-7454-4619-a6e7-_1.cs)]\n [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/cpp/fb1cfbc8-7454-4619-a6e7-_1.cpp)]\n [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/visualbasic/fb1cfbc8-7454-4619-a6e7-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d, float loadFactor);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>Obiektu można skopiować do nowego <xref href=&quot;System.Collections.Hashtable&quot;> </xref> obiektu.</xref:System.Collections.IDictionary>"
    - id: loadFactor
      type: System.Single
      description: "Liczba z zakresu od 0,1 do 1,0 pomnożona przez wartość domyślną, która zapewnia najlepszą wydajność. Wynik jest maksymalny stosunek elementów zasobników."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>loadFactor</code>jest mniejsza niż 0,1.       - lub - <code>loadFactor</code> jest większa niż 1,0."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)
  id: '#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IHashCodeProvider,IComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicjuje nową, pustą wystąpienie <xref href=&quot;System.Collections.Hashtable&quot;> </xref> przy użyciu domyślnego początkowa pojemność i załadować współczynnik oraz skrót określonego dostawcy kodu i porównania."
  remarks: "Pojemność tablicy skrótów służy do obliczania optymalną liczbę zasobników tabeli skrótu na podstawie współczynnika obciążenia. Pojemność jest automatycznie zwiększana zgodnie z wymaganiami.       Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.       Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.       Dostawca kodu skrótu zrezygnuje skrótu kluczy w <xref:System.Collections.Hashtable>obiektu.</xref:System.Collections.Hashtable> Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable>muszą być unikatowe.</xref:System.Collections.Hashtable> Implementacja klucza <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName> jest domyślna funkcja porównująca       Dostawca kodu niestandardowego wyznaczania wartości skrótu i Niestandardowa funkcja porównująca umożliwiają scenariuszy, takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.       Ten konstruktor jest operacją O(1)."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctor#1](~/add/codesnippet/cpp/1ff65986-0234-4702-94b7-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctor#1](~/add/codesnippet/csharp/1ff65986-0234-4702-94b7-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctor#1](~/add/codesnippet/visualbasic/1ff65986-0234-4702-94b7-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
    parameters:
    - id: hcp
      type: System.Collections.IHashCodeProvider
      description: "<xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref> Obiektu, który dostarcza skrót kodów dla wszystkich kluczy w <xref href=&quot;System.Collections.Hashtable&quot;> </xref> obiektu.       - lub - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Aby użyć domyślnego dostawcy kodu wyznaczania wartości skrótu, która jest implementacją każdy klucz &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;."
    - id: comparer
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>Obiekt ma być używany do określenia, czy dwa klucze są takie same.</xref:System.Collections.IComparer>       - lub - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> do używania domyślna funkcja porównująca, która jest implementacją każdy klucz &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;."
  overload: System.Collections.Hashtable.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)
  id: '#ctor(System.Int32,System.Collections.IEqualityComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(Int32,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,IEqualityComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicjuje nową, pustą wystąpienie <xref href=&quot;System.Collections.Hashtable&quot;> </xref> przy użyciu określonej pojemności początkowej i <xref:System.Collections.IEqualityComparer>, a domyślna wartość współczynnika ładowania.</xref:System.Collections.IEqualityComparer>"
  remarks: "Określanie początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Hashtable>obiektu.</xref:System.Collections.Hashtable> Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.       Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.       Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.       <xref:System.Collections.IEqualityComparer>Obiekt zawiera zarówno dostawcę kodu wyznaczania wartości skrótu i modułu porównującego.</xref:System.Collections.IEqualityComparer> Jeśli <xref:System.Collections.IEqualityComparer>jest używany w <xref:System.Collections.Hashtable>konstruktora, obiekty używane jako klucze w <xref:System.Collections.Hashtable>nie są wymagane w celu zastąpienia <xref:System.Object.GetHashCode%2A?displayProperty=fullName>i <xref:System.Object.Equals%2A?displayProperty=fullName>metody.</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       Kody skrótów kluczy w <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> zrezygnuje dostawcy kodu wyznaczania wartości skrótu Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable>muszą być unikatowe.</xref:System.Collections.Hashtable> Implementacja klucza <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName> jest domyślna funkcja porównująca       <xref:System.Collections.IEqualityComparer>Umożliwia obsługę scenariuszy takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.</xref:System.Collections.IEqualityComparer>       Ten konstruktor jest O (`n`) operację, której `n` jest `capacity` parametru."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/cpp/5067e9ac-cd98-4da8-9418-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/csharp/5067e9ac-cd98-4da8-9418-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/visualbasic/5067e9ac-cd98-4da8-9418-_1.vb)]"
  syntax:
    content: public Hashtable (int capacity, System.Collections.IEqualityComparer equalityComparer);
    parameters:
    - id: capacity
      type: System.Int32
      description: "Przybliżoną liczbę elementów który <xref href=&quot;System.Collections.Hashtable&quot;> </xref> początkowo może zawierać obiektu."
    - id: equalityComparer
      type: System.Collections.IEqualityComparer
      description: "<xref:System.Collections.IEqualityComparer>Obiektu, który definiuje dostawcy kodu wyznaczania wartości skrótu i modułu porównującego do użycia z <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.IEqualityComparer>       - lub - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> do używania domyślnego dostawcy kodu wyznaczania wartości skrótu i domyślna funkcja porównująca. Domyślny dostawca kod skrótu jest implementacją każdy klucz &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; i wdrożenia każdego klucza jest domyślna funkcja porównująca &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>jest mniejsza od zera."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single)
  id: '#ctor(System.Int32,System.Single)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32,Single)
  nameWithType: Hashtable.Hashtable(Int32,Single)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicjuje nową, pustą wystąpienie <xref href=&quot;System.Collections.Hashtable&quot;> </xref> przy użyciu określonej pojemności początkowej i obciążenia i domyślny dostawca kodu wyznaczania wartości skrótu oraz porównania."
  remarks: "Określanie początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Hashtable>obiektu.</xref:System.Collections.Hashtable> Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.       Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci. Współczynnik obciążenia 1.0 jest równowagę między szybkość i rozmiar.       Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.       Kody skrótów kluczy w <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> zrezygnuje dostawcy kodu wyznaczania wartości skrótu Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable>muszą być unikatowe.</xref:System.Collections.Hashtable> Implementacja klucza <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName> jest domyślna funkcja porównująca       Ten konstruktor jest O (`n`) operację, której `n` jest `capacity` parametru."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/cpp/m-system.collections.has_8_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/csharp/m-system.collections.has_8_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/visualbasic/m-system.collections.has_8_1.vb)]"
  syntax:
    content: public Hashtable (int capacity, float loadFactor);
    parameters:
    - id: capacity
      type: System.Int32
      description: "Przybliżoną liczbę elementów który <xref href=&quot;System.Collections.Hashtable&quot;> </xref> początkowo może zawierać obiektu."
    - id: loadFactor
      type: System.Single
      description: "Liczba z zakresu od 0,1 do 1,0 pomnożona przez wartość domyślną, która zapewnia najlepszą wydajność. Wynik jest maksymalny stosunek elementów zasobników."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>jest mniejsza od zera.       - lub - <code>loadFactor</code> jest mniejsza niż 0,1.       - lub - <code>loadFactor</code> jest większa niż 1,0."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>capacity</code>powoduje przepełnienie."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: '#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(SerializationInfo,StreamingContext)
  nameWithType: Hashtable.Hashtable(SerializationInfo,StreamingContext)
  fullName: System.Collections.Hashtable.Hashtable(SerializationInfo,StreamingContext)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicjuje nową, pustą wystąpienie <xref href=&quot;System.Collections.Hashtable&quot;> </xref> klasy, która jest możliwy do serializacji przy użyciu określonego <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> i <xref:System.Runtime.Serialization.StreamingContext>obiektów.</xref:System.Runtime.Serialization.StreamingContext>"
  remarks: "Pojemność tablicy skrótów służy do obliczania optymalną liczbę zasobników tabeli skrótu na podstawie współczynnika obciążenia. Pojemność jest automatycznie zwiększana zgodnie z wymaganiami.       Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.       Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.       Dostawca kodu skrótu zrezygnuje skrótu kluczy w <xref:System.Collections.Hashtable>obiektu.</xref:System.Collections.Hashtable> Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable>muszą być unikatowe.</xref:System.Collections.Hashtable> Implementacja klucza <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName> jest domyślna funkcja porównująca       Ten konstruktor jest O (`n`) operację, której `n` <xref:System.Collections.Hashtable.Count%2A>.</xref:System.Collections.Hashtable.Count%2A>       Ponieważ serializację i deserializację moduł wyliczający dla <xref:System.Collections.Hashtable>może spowodować się stać się zmienić kolejności elementów, nie jest możliwe kontynuować wyliczenia bez wywoływania <xref:System.Collections.IEnumerator.Reset%2A>metody.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.Hashtable>"
  syntax:
    content: protected Hashtable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "A <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> obiektu zawierającego informacje o wymaganych do zserializowania <xref href=&quot;System.Collections.Hashtable&quot;> </xref> obiektu."
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "A <xref:System.Runtime.Serialization.StreamingContext>obiekt zawierający źródłowy i docelowy serializowanego strumienia skojarzonego z <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Runtime.Serialization.StreamingContext>"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>info</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  id: '#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,IHashCodeProvider,IComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Collections.Hashtable&quot;> </xref> przez skopiowanie elementy z określonego słownika do nowego <xref href=&quot;System.Collections.Hashtable&quot;> </xref> obiektu. Nowy <xref href=&quot;System.Collections.Hashtable&quot;> </xref> obiekt ma początkowej pojemności równa liczbie elementów kopiowanych i używa domyślny współczynnik obciążenia oraz skrót określonego dostawcy kodu i porównania. Ten interfejs API jest przestarzały. Aby zamiast, zobacz &lt;xref:System.Collections.Hashtable.%23ctor%2A&gt;."
  remarks: "Początkowa pojemność wynosi liczba elementów w słowniku źródła. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.       Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.       Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.       Dostawca kodu skrótu zrezygnuje skrótu kluczy w <xref:System.Collections.Hashtable>obiektu.</xref:System.Collections.Hashtable> Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable>muszą być unikatowe.</xref:System.Collections.Hashtable> Implementacja klucza <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName> jest domyślna funkcja porównująca       Dostawca kodu niestandardowego wyznaczania wartości skrótu i Niestandardowa funkcja porównująca umożliwiają scenariuszy, takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.       Nowe elementy <xref:System.Collections.Hashtable>są sortowane w takiej samej kolejności, w której moduł wyliczający iteruje <xref:System.Collections.IDictionary>obiektu.</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       Ten konstruktor jest O (`n`) operację, której `n` jest liczba elementów w `d` parametru."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/cpp/9a30e378-7c34-4854-b12f-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/csharp/9a30e378-7c34-4854-b12f-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/visualbasic/9a30e378-7c34-4854-b12f-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>Obiektu można skopiować do nowego <xref href=&quot;System.Collections.Hashtable&quot;> </xref> obiektu.</xref:System.Collections.IDictionary>"
    - id: hcp
      type: System.Collections.IHashCodeProvider
      description: "<xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref> Obiektu, który dostarcza skrót kodów dla wszystkich kluczy w <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.       - lub - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Aby użyć domyślnego dostawcy kodu wyznaczania wartości skrótu, która jest implementacją każdy klucz &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;."
    - id: comparer
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>Obiekt ma być używany do określenia, czy dwa klucze są takie same.</xref:System.Collections.IComparer>       - lub - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> do używania domyślna funkcja porównująca, która jest implementacją każdy klucz &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)
  id: '#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary,Single,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,Single,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single,IEqualityComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Collections.Hashtable&quot;> </xref> przez skopiowanie elementy z określonego słownika do nowego <xref href=&quot;System.Collections.Hashtable&quot;> </xref> obiektu. Nowy <xref href=&quot;System.Collections.Hashtable&quot;> </xref> obiekt ma początkowej pojemności równa liczbie elementów kopiowanych i używa współczynnik obciążenia i <xref:System.Collections.IEqualityComparer>obiektu.</xref:System.Collections.IEqualityComparer>"
  remarks: "Początkowa pojemność wynosi liczba elementów w słowniku źródła. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.       Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci. Współczynnik obciążenia 1.0 jest równowagę między szybkość i rozmiar.       Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.       <xref:System.Collections.IEqualityComparer>Obiekt zawiera zarówno dostawcę kodu wyznaczania wartości skrótu i modułu porównującego.</xref:System.Collections.IEqualityComparer> Jeśli <xref:System.Collections.IEqualityComparer>jest używany w <xref:System.Collections.Hashtable>konstruktora, obiekty używane jako klucze w <xref:System.Collections.Hashtable>obiektu nie są wymagane w celu zastąpienia <xref:System.Object.GetHashCode%2A?displayProperty=fullName>i <xref:System.Object.Equals%2A?displayProperty=fullName>metody.</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       Kody skrótów kluczy w <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> zrezygnuje dostawcy kodu wyznaczania wartości skrótu Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable>muszą być unikatowe.</xref:System.Collections.Hashtable> Implementacja klucza <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName> jest domyślna funkcja porównująca       <xref:System.Collections.IEqualityComparer>Umożliwia obsługę scenariuszy takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.</xref:System.Collections.IEqualityComparer>       Nowe elementy <xref:System.Collections.Hashtable>są sortowane w takiej samej kolejności, w której moduł wyliczający iteruje <xref:System.Collections.IDictionary>obiektu.</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       Ten konstruktor jest O (`n`) operację, której `n` jest liczba elementów w `d` parametru."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cs[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/csharp/a92f83be-9de4-470a-8cbb-_1.cs)]\n [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/cpp/a92f83be-9de4-470a-8cbb-_1.cpp)]\n [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/visualbasic/a92f83be-9de4-470a-8cbb-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d, float loadFactor, System.Collections.IEqualityComparer equalityComparer);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>Obiektu można skopiować do nowego <xref href=&quot;System.Collections.Hashtable&quot;> </xref> obiektu.</xref:System.Collections.IDictionary>"
    - id: loadFactor
      type: System.Single
      description: "Liczba z zakresu od 0,1 do 1,0 pomnożona przez wartość domyślną, która zapewnia najlepszą wydajność. Wynik jest maksymalny stosunek elementów zasobników."
    - id: equalityComparer
      type: System.Collections.IEqualityComparer
      description: "<xref:System.Collections.IEqualityComparer>Obiektu, który definiuje dostawcy kodu wyznaczania wartości skrótu i modułu porównującego do użycia z <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.IEqualityComparer>       - lub - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> do używania domyślnego dostawcy kodu wyznaczania wartości skrótu i domyślna funkcja porównująca. Domyślny dostawca kod skrótu jest implementacją każdy klucz &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; i wdrożenia każdego klucza jest domyślna funkcja porównująca &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>loadFactor</code>jest mniejsza niż 0,1.       - lub - <code>loadFactor</code> jest większa niż 1,0."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  id: '#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(Int32,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,IHashCodeProvider,IComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicjuje nową, pustą wystąpienie <xref href=&quot;System.Collections.Hashtable&quot;> </xref> przy użyciu określonej pojemności początkowej, dostawcy kodu skrótu porównania i domyślny współczynnik obciążenia."
  remarks: "Określanie początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Hashtable>obiektu.</xref:System.Collections.Hashtable> Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.       Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci.       Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.       Kody skrótów kluczy w <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> zrezygnuje dostawcy kodu wyznaczania wartości skrótu Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable>muszą być unikatowe.</xref:System.Collections.Hashtable> Implementacja klucza <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName> jest domyślna funkcja porównująca       Dostawca kodu niestandardowego wyznaczania wartości skrótu i Niestandardowa funkcja porównująca umożliwiają scenariuszy, takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.       Ten konstruktor jest O (`n`) operację, której `n` jest `capacity` parametru."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/cpp/2154dba0-3cc6-41f7-aa9b-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/csharp/2154dba0-3cc6-41f7-aa9b-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/visualbasic/2154dba0-3cc6-41f7-aa9b-_1.vb)]"
  syntax:
    content: public Hashtable (int capacity, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
    parameters:
    - id: capacity
      type: System.Int32
      description: "Przybliżoną liczbę elementów który <xref href=&quot;System.Collections.Hashtable&quot;> </xref> początkowo może zawierać obiektu."
    - id: hcp
      type: System.Collections.IHashCodeProvider
      description: "<xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref> Obiektu, który dostarcza skrót kodów dla wszystkich kluczy w <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.       - lub - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Aby użyć domyślnego dostawcy kodu wyznaczania wartości skrótu, która jest implementacją każdy klucz &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;."
    - id: comparer
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>Obiekt ma być używany do określenia, czy dwa klucze są takie same.</xref:System.Collections.IComparer>       - lub - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> do używania domyślna funkcja porównująca, która jest implementacją każdy klucz &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>jest mniejsza od zera."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)
  id: '#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32,Single,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(Int32,Single,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single,IEqualityComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicjuje nową, pustą wystąpienie <xref href=&quot;System.Collections.Hashtable&quot;> </xref> przy użyciu określonej pojemności początkowej, współczynnik ładowania i <xref:System.Collections.IEqualityComparer>obiektu.</xref:System.Collections.IEqualityComparer>"
  remarks: "Określanie początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Hashtable>obiektu.</xref:System.Collections.Hashtable> Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.       Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci. Współczynnik obciążenia 1.0 jest równowagę między szybkość i rozmiar.       Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.       <xref:System.Collections.IEqualityComparer>Obiekt zawiera zarówno dostawcę kodu wyznaczania wartości skrótu i modułu porównującego.</xref:System.Collections.IEqualityComparer> Jeśli <xref:System.Collections.IEqualityComparer>jest używany w <xref:System.Collections.Hashtable>konstruktora, obiekty używane jako klucze w <xref:System.Collections.Hashtable>nie są wymagane w celu zastąpienia <xref:System.Object.GetHashCode%2A?displayProperty=fullName>i <xref:System.Object.Equals%2A?displayProperty=fullName>metody.</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       Kody skrótów kluczy w <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> zrezygnuje dostawcy kodu wyznaczania wartości skrótu Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable>muszą być unikatowe.</xref:System.Collections.Hashtable> Implementacja klucza <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName> jest domyślna funkcja porównująca       <xref:System.Collections.IEqualityComparer>Umożliwia obsługę scenariuszy takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.</xref:System.Collections.IEqualityComparer>       Ten konstruktor jest O (`n`) operację, której `n` jest `capacity` parametru."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/cpp/30b60c47-7bce-44a2-8d17-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/csharp/30b60c47-7bce-44a2-8d17-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/visualbasic/30b60c47-7bce-44a2-8d17-_1.vb)]"
  syntax:
    content: public Hashtable (int capacity, float loadFactor, System.Collections.IEqualityComparer equalityComparer);
    parameters:
    - id: capacity
      type: System.Int32
      description: "Przybliżoną liczbę elementów który <xref href=&quot;System.Collections.Hashtable&quot;> </xref> początkowo może zawierać obiektu."
    - id: loadFactor
      type: System.Single
      description: "Liczba z zakresu od 0,1 do 1,0 pomnożona przez wartość domyślną, która zapewnia najlepszą wydajność. Wynik jest maksymalny stosunek elementów zasobników."
    - id: equalityComparer
      type: System.Collections.IEqualityComparer
      description: "<xref:System.Collections.IEqualityComparer>Obiektu, który definiuje dostawcy kodu wyznaczania wartości skrótu i modułu porównującego do użycia z <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.IEqualityComparer>       - lub - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> do używania domyślnego dostawcy kodu wyznaczania wartości skrótu i domyślna funkcja porównująca. Domyślny dostawca kod skrótu jest implementacją każdy klucz &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt; i wdrożenia każdego klucza jest domyślna funkcja porównująca &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>jest mniejsza od zera.       - lub - <code>loadFactor</code> jest mniejsza niż 0,1.       - lub - <code>loadFactor</code> jest większa niż 1,0."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  id: '#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Collections.Hashtable&quot;> </xref> przez skopiowanie elementy z określonego słownika do nowego <xref href=&quot;System.Collections.Hashtable&quot;> </xref> obiektu. Nowy <xref href=&quot;System.Collections.Hashtable&quot;> </xref> obiekt ma początkowej pojemności równa liczbie elementów kopiowanych i używa współczynnik określonego obciążenia, dostawcy kodu wyznaczania wartości skrótu i porównania."
  remarks: "Początkowa pojemność wynosi liczba elementów w słowniku źródła. Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.       Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci. Współczynnik obciążenia 1.0 jest równowagę między szybkość i rozmiar.       Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.       Dostawca kodu skrótu zrezygnuje skrótu kluczy w <xref:System.Collections.Hashtable>obiektu.</xref:System.Collections.Hashtable> Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable>muszą być unikatowe.</xref:System.Collections.Hashtable> Implementacja klucza <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName> jest domyślna funkcja porównująca       Dostawca kodu niestandardowego wyznaczania wartości skrótu i Niestandardowa funkcja porównująca umożliwiają scenariuszy, takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.       Nowe elementy <xref:System.Collections.Hashtable>są sortowane w takiej samej kolejności, w której moduł wyliczający iteruje <xref:System.Collections.IDictionary>obiektu.</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       Ten konstruktor jest O (`n`) operację, której `n` jest liczba elementów w `d` parametru."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cs[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/csharp/c67b166f-bc6a-49e5-9bd7-_1.cs)]\n [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/cpp/c67b166f-bc6a-49e5-9bd7-_1.cpp)]\n [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/visualbasic/c67b166f-bc6a-49e5-9bd7-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>Obiektu można skopiować do nowego <xref href=&quot;System.Collections.Hashtable&quot;> </xref> obiektu.</xref:System.Collections.IDictionary>"
    - id: loadFactor
      type: System.Single
      description: "Liczba z zakresu od 0,1 do 1,0 pomnożona przez wartość domyślną, która zapewnia najlepszą wydajność. Wynik jest maksymalny stosunek elementów zasobników."
    - id: hcp
      type: System.Collections.IHashCodeProvider
      description: "<xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref> Obiektu, który dostarcza skrót kodów dla wszystkich kluczy w <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.       - lub - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Aby użyć domyślnego dostawcy kodu wyznaczania wartości skrótu, która jest implementacją każdy klucz &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;."
    - id: comparer
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>Obiekt ma być używany do określenia, czy dwa klucze są takie same.</xref:System.Collections.IComparer>       - lub - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> do używania domyślna funkcja porównująca, która jest implementacją każdy klucz &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>loadFactor</code>jest mniejsza niż 0,1.       - lub - <code>loadFactor</code> jest większa niż 1,0."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  id: '#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32,Single,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(Int32,Single,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single,IHashCodeProvider,IComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicjuje nową, pustą wystąpienie <xref href=&quot;System.Collections.Hashtable&quot;> </xref> przy użyciu określonej pojemności początkowej, załadowanie współczynnik dostawcy kodu wyznaczania wartości skrótu i porównania."
  remarks: "Określanie początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Hashtable>obiektu.</xref:System.Collections.Hashtable> Pojemność jest automatycznie zwiększyć zgodnie z potrzebami, na podstawie współczynnika obciążenia.       Współczynnik obciążenia to maksymalny stosunek elementów zasobników. Mniejsze współczynnik obciążenia oznacza szybsze wyszukiwanie kosztem zużycie pamięci. Współczynnik obciążenia 1.0 jest równowagę między szybkość i rozmiar.       Gdy współczynnik rzeczywiste obciążenie osiągnie współczynnik określonego obciążenia, Liczba zasobników, automatycznie zostaje zwiększona do najmniejszą liczbę pierwszych większym niż dwa razy bieżąca liczba zasobników.       Kody skrótów kluczy w <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> zrezygnuje dostawcy kodu wyznaczania wartości skrótu Domyślny dostawca kod skrótu jest implementacją klucza <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>       Moduł porównujący Określa, czy dwa klucze są takie same. Każdy klucz w <xref:System.Collections.Hashtable>muszą być unikatowe.</xref:System.Collections.Hashtable> Implementacja klucza <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName> jest domyślna funkcja porównująca       Dostawca kodu niestandardowego wyznaczania wartości skrótu i Niestandardowa funkcja porównująca umożliwiają scenariuszy, takich jak podczas wyszukiwania z ciągami bez uwzględniania wielkości liter.       Ten konstruktor jest O (`n`) operację, której `n` jest `capacity` parametru."
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/cpp/86ed2545-c9ee-4654-a1a4-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/csharp/86ed2545-c9ee-4654-a1a4-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/visualbasic/86ed2545-c9ee-4654-a1a4-_1.vb)]"
  syntax:
    content: public Hashtable (int capacity, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
    parameters:
    - id: capacity
      type: System.Int32
      description: "Przybliżoną liczbę elementów który <xref href=&quot;System.Collections.Hashtable&quot;> </xref> początkowo może zawierać obiektu."
    - id: loadFactor
      type: System.Single
      description: "Liczba z zakresu od 0,1 do 1,0 pomnożona przez wartość domyślną, która zapewnia najlepszą wydajność. Wynik jest maksymalny stosunek elementów zasobników."
    - id: hcp
      type: System.Collections.IHashCodeProvider
      description: "<xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref> Obiektu, który dostarcza skrót kodów dla wszystkich kluczy w <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.       - lub - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Aby użyć domyślnego dostawcy kodu wyznaczania wartości skrótu, która jest implementacją każdy klucz &lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;."
    - id: comparer
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>Obiekt ma być używany do określenia, czy dwa klucze są takie same.</xref:System.Collections.IComparer>       - lub - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> do używania domyślna funkcja porównująca, która jest implementacją każdy klucz &lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;."
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>jest mniejsza od zera.       - lub - <code>loadFactor</code> jest mniejsza niż 0,1.       - lub - <code>loadFactor</code> jest większa niż 1,0."
  platform:
  - net462
- uid: System.Collections.Hashtable.Add(System.Object,System.Object)
  id: Add(System.Object,System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Add(Object,Object)
  nameWithType: Hashtable.Add(Object,Object)
  fullName: System.Collections.Hashtable.Add(Object,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Dodaje element z określonym kluczem i wartością w <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
  remarks: "Klucz nie może być `null`, ale może być wartością.       Zazwyczaj obiekt, który ma korelacja stanu i jego wartość kodu skrótu nie zostać użyta jako klucz. Na przykład ciąg obiekty są lepszym rozwiązaniem niż obiekty StringBuilder do użycia jako klucze.       Można również użyć <xref:System.Collections.Hashtable.Item%2A>Właściwości, aby dodać nowe elementy za pomocą ustawienia wartości klucza, który nie istnieje w <xref:System.Collections.Hashtable>, na przykład `myCollection[&quot;myNonexistentKey&quot;] = myValue`.</xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable.Item%2A> Jednak jeśli określony klucz już istnieje w <xref:System.Collections.Hashtable>, ustawienie <xref:System.Collections.Hashtable.Item%2A>stara wartość jest zastąpienie właściwości.</xref:System.Collections.Hashtable.Item%2A> </xref:System.Collections.Hashtable> Z kolei metody Add nie modyfikuje istniejące elementy.       Jeśli <xref:System.Collections.Hashtable.Count%2A>jest mniejsza niż pojemność <xref:System.Collections.Hashtable>, ta metoda jest operacją O(1).</xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable.Count%2A> Jeśli pojemność wymaga zwiększenia w celu uwzględnienia nowego elementu, ta metoda staje się O (`n`) operację, której `n` <xref:System.Collections.Hashtable.Count%2A>.</xref:System.Collections.Hashtable.Count%2A>"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Hashtable>.  \n  \n [!code-cpp[Classic Hashtable.Add Example#1](~/add/codesnippet/cpp/m-system.collections.has_6_1.cpp)]\n [!code-cs[Classic Hashtable.Add Example#1](~/add/codesnippet/csharp/m-system.collections.has_6_1.cs)]\n [!code-vb[Classic Hashtable.Add Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_6_1.vb)]"
  syntax:
    content: public virtual void Add (object key, object value);
    parameters:
    - id: key
      type: System.Object
      description: "Klucz elementu do dodania."
    - id: value
      type: System.Object
      description: "Wartość elementu do dodania. Wartość może być <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Hashtable.Add*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Element z tym samym kluczem już istnieje w <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.Hashtable&quot;> </xref> Jest tylko do odczytu.       - lub - <xref href=&quot;System.Collections.Hashtable&quot;> </xref> ma stały rozmiar."
  platform:
  - net462
- uid: System.Collections.Hashtable.Clear
  id: Clear
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Clear()
  nameWithType: Hashtable.Clear()
  fullName: System.Collections.Hashtable.Clear()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Usuwa wszystkie elementy z <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
  remarks: "<xref:System.Collections.Hashtable.Count%2A>jest ustawiany na zero, a ponadto są również zwalniane odwołania do innych obiektów z elementów kolekcji.</xref:System.Collections.Hashtable.Count%2A> Pojemność pozostaje niezmieniona.       Ta metoda jest O (`n`) operację, której `n` <xref:System.Collections.Hashtable.Count%2A>.</xref:System.Collections.Hashtable.Count%2A>"
  example:
  - "The following example shows how to clear the values of the <xref:System.Collections.Hashtable>.  \n  \n [!code-cpp[Classic Hashtable.Clear Example#1](~/add/codesnippet/cpp/m-system.collections.has_10_1.cpp)]\n [!code-vb[Classic Hashtable.Clear Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_10_1.vb)]\n [!code-cs[Classic Hashtable.Clear Example#1](~/add/codesnippet/csharp/m-system.collections.has_10_1.cs)]"
  syntax:
    content: public virtual void Clear ();
    parameters: []
  overload: System.Collections.Hashtable.Clear*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.Hashtable&quot;> </xref> Jest tylko do odczytu."
  platform:
  - net462
- uid: System.Collections.Hashtable.Clone
  id: Clone
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Clone()
  nameWithType: Hashtable.Clone()
  fullName: System.Collections.Hashtable.Clone()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Tworzy kopię pobieżną <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
  remarks: "Kopię pobieżną kolekcji kopiuje elementy kolekcji, czy są typy odwołanie lub wartość, ale nie kopiuje obiektów, które dotyczą odwołania. Odwołania do nowej kolekcji wskazują te same obiekty, które wskazują odwołania w oryginalnej kolekcji.       Z kolei głęboką kopię kolekcji kopiuje elementy i wszystkich bezpośrednio lub pośrednio odwołuje się elementów.       <xref:System.Collections.Hashtable>Klonowanie ma tej samej liczby, samej pojemności, te same <xref:System.Collections.IHashCodeProvider>implementacji i tej samej <xref:System.Collections.IComparer>implementacji jako oryginalny <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> </xref:System.Collections.IComparer> </xref:System.Collections.IHashCodeProvider> </xref:System.Collections.Hashtable>       Ta metoda jest O (`n`) operację, której `n` <xref:System.Collections.Hashtable.Count%2A>.</xref:System.Collections.Hashtable.Count%2A>"
  syntax:
    content: public virtual object Clone ();
    parameters: []
    return:
      type: System.Object
      description: "Kopia pobieżna <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
  overload: System.Collections.Hashtable.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.comparer
  id: comparer
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: comparer
  nameWithType: Hashtable.comparer
  fullName: System.Collections.Hashtable.comparer
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Pobiera lub ustawia <xref:System.Collections.IComparer>do użycia na potrzeby <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.IComparer>"
  remarks: "Pobieranie wartości tej właściwości jest operacją O(1)."
  syntax:
    content: protected System.Collections.IComparer comparer { get; set; }
    return:
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>Do użycia na potrzeby <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.IComparer>"
  overload: System.Collections.Hashtable.comparer*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Właściwość jest ustawiona na wartość, ale tablicy skrótów został utworzony przy użyciu <xref:System.Collections.IEqualityComparer>.</xref:System.Collections.IEqualityComparer>"
  platform:
  - net462
- uid: System.Collections.Hashtable.Contains(System.Object)
  id: Contains(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Contains(Object)
  nameWithType: Hashtable.Contains(Object)
  fullName: System.Collections.Hashtable.Contains(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Określa, czy <xref href=&quot;System.Collections.Hashtable&quot;> </xref> zawiera określony klucz."
  remarks: "Zawiera implementuje <xref:System.Collections.IDictionary.Contains%2A?displayProperty=fullName>.</xref:System.Collections.IDictionary.Contains%2A?displayProperty=fullName> Zachowuje się dokładnie jako <xref:System.Collections.Hashtable.ContainsKey%2A>.</xref:System.Collections.Hashtable.ContainsKey%2A>       Ta metoda jest operacją O(1).       Począwszy od programu .NET Framework 2.0, ta metoda używa kolekcji obiektów <xref:System.Object.Equals%2A>i <xref:System.IComparable.CompareTo%2A>metody `item` ustalenie, czy element istnieje.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> We wcześniejszych wersjach programu .NET Framework, oznaczanie został utworzony przy użyciu <xref:System.Object.Equals%2A>i <xref:System.IComparable.CompareTo%2A>metody `item` parametrów dla obiektów w kolekcji.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  example:
  - "The following example shows how to determine whether the <xref:System.Collections.Hashtable> contains a specific element.  \n  \n [!code-cpp[Classic Hashtable.Contains Example#1](~/add/codesnippet/cpp/m-system.collections.has_12_1.cpp)]\n [!code-cs[Classic Hashtable.Contains Example#1](~/add/codesnippet/csharp/m-system.collections.has_12_1.cs)]\n [!code-vb[Classic Hashtable.Contains Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_12_1.vb)]"
  syntax:
    content: public virtual bool Contains (object key);
    parameters:
    - id: key
      type: System.Object
      description: "Klucz do zlokalizowania w <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli <xref href=&quot;System.Collections.Hashtable&quot;> </xref> zawiera element z określonym kluczem, a w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Hashtable.Contains*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.ContainsKey(System.Object)
  id: ContainsKey(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: ContainsKey(Object)
  nameWithType: Hashtable.ContainsKey(Object)
  fullName: System.Collections.Hashtable.ContainsKey(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Określa, czy <xref href=&quot;System.Collections.Hashtable&quot;> </xref> zawiera określony klucz."
  remarks: "Ta metoda działa dokładnie tak jak <xref:System.Collections.Hashtable.Contains%2A>.</xref:System.Collections.Hashtable.Contains%2A>       Ta metoda jest operacją O(1).       Począwszy od programu .NET Framework 2.0, ta metoda używa kolekcji obiektów <xref:System.Object.Equals%2A>i <xref:System.IComparable.CompareTo%2A>metody `item` ustalenie, czy element istnieje.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> We wcześniejszych wersjach programu .NET Framework, oznaczanie został utworzony przy użyciu <xref:System.Object.Equals%2A>i <xref:System.IComparable.CompareTo%2A>metody `item` parametrów dla obiektów w kolekcji.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  example:
  - "The following example shows how to determine whether the <xref:System.Collections.Hashtable> contains a specific element.  \n  \n [!code-cpp[Classic Hashtable.Contains Example#1](~/add/codesnippet/cpp/m-system.collections.has_7_1.cpp)]\n [!code-cs[Classic Hashtable.Contains Example#1](~/add/codesnippet/csharp/m-system.collections.has_7_1.cs)]\n [!code-vb[Classic Hashtable.Contains Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_7_1.vb)]"
  syntax:
    content: public virtual bool ContainsKey (object key);
    parameters:
    - id: key
      type: System.Object
      description: "Klucz do zlokalizowania w <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli <xref href=&quot;System.Collections.Hashtable&quot;> </xref> zawiera element z określonym kluczem, a w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Hashtable.ContainsKey*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.ContainsValue(System.Object)
  id: ContainsValue(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: ContainsValue(Object)
  nameWithType: Hashtable.ContainsValue(Object)
  fullName: System.Collections.Hashtable.ContainsValue(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Określa, czy <xref href=&quot;System.Collections.Hashtable&quot;> </xref> zawiera określoną wartość."
  remarks: "Wartości elementów <xref:System.Collections.Hashtable>są porównywane przy użyciu określonej wartości <xref:System.Object.Equals%2A?displayProperty=fullName>metody.</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Collections.Hashtable>       Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym ta metoda jest O (`n`) operację, której `n` <xref:System.Collections.Hashtable.Count%2A>.</xref:System.Collections.Hashtable.Count%2A>       Począwszy od programu .NET Framework 2.0, ta metoda używa kolekcji obiektów <xref:System.Object.Equals%2A>i <xref:System.IComparable.CompareTo%2A>metody `item` ustalenie, czy element istnieje.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> We wcześniejszych wersjach programu .NET Framework, oznaczanie został utworzony przy użyciu <xref:System.Object.Equals%2A>i <xref:System.IComparable.CompareTo%2A>metody `item` parametrów dla obiektów w kolekcji.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  example:
  - "The following example shows how to determine whether the <xref:System.Collections.Hashtable> contains a specific element.  \n  \n [!code-cpp[Classic Hashtable.Contains Example#1](~/add/codesnippet/cpp/m-system.collections.has_9_1.cpp)]\n [!code-cs[Classic Hashtable.Contains Example#1](~/add/codesnippet/csharp/m-system.collections.has_9_1.cs)]\n [!code-vb[Classic Hashtable.Contains Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_9_1.vb)]"
  syntax:
    content: public virtual bool ContainsValue (object value);
    parameters:
    - id: value
      type: System.Object
      description: "Wartość do zlokalizowania w <xref href=&quot;System.Collections.Hashtable&quot;> </xref>. Wartość może być <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli <xref href=&quot;System.Collections.Hashtable&quot;> </xref> zawiera element z określonym <code> value </code>; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Hashtable.ContainsValue*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.CopyTo(System.Array,System.Int32)
  id: CopyTo(System.Array,System.Int32)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: CopyTo(Array,Int32)
  nameWithType: Hashtable.CopyTo(Array,Int32)
  fullName: System.Collections.Hashtable.CopyTo(Array,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Kopie <xref href=&quot;System.Collections.Hashtable&quot;> </xref> elementów na jednowymiarowe <xref:System.Array>wystąpienia pod określonym indeksem.</xref:System.Array>"
  remarks: "<xref:System.Array>w tej samej kolejności, w której moduł wyliczający iteruje <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> </xref:System.Array> są kopiowane elementy       Aby skopiować tylko klucze w <xref:System.Collections.Hashtable>, użyj `Hashtable.Keys.CopyTo`.</xref:System.Collections.Hashtable>       Aby skopiować tylko wartości w <xref:System.Collections.Hashtable>, użyj `Hashtable.Values.CopyTo`.</xref:System.Collections.Hashtable>       Ta metoda jest O (`n`) operację, której `n` <xref:System.Collections.Hashtable.Count%2A>.</xref:System.Collections.Hashtable.Count%2A>"
  example:
  - "The following example shows how to copy the list of keys or the list of values in a <xref:System.Collections.Hashtable> into a one-dimensional <xref:System.Array>.  \n  \n [!code-cs[Classic Hashtable.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.has_0_1.cs)]\n [!code-vb[Classic Hashtable.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_0_1.vb)]\n [!code-cpp[Classic Hashtable.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.has_0_1.cpp)]"
  syntax:
    content: public virtual void CopyTo (Array array, int arrayIndex);
    parameters:
    - id: array
      type: System.Array
      description: "Jednowymiarowa <xref:System.Array>czyli miejsce docelowe <xref:System.Collections.DictionaryEntry>obiektów kopiowanych ze <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.DictionaryEntry> </xref:System.Array> <xref:System.Array>Musi mieć indeksowania liczony od zera.</xref:System.Array>"
    - id: arrayIndex
      type: System.Int32
      description: "Liczony od zera indeks w `array` od rozpoczyna się kopiowanie które."
  overload: System.Collections.Hashtable.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>arrayIndex</code>jest mniejsza od zera."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>jest wielowymiarowy.       - lub - liczba elementów w źródle <xref href=&quot;System.Collections.Hashtable&quot;> </xref> jest większa niż dostępne miejsce od <code>arrayIndex</code> do końca tablicy docelowej <code>array</code>."
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "Typ źródła <xref href=&quot;System.Collections.Hashtable&quot;> </xref> nie można automatycznie rzutować na typ docelowy <code> array </code>."
  platform:
  - net462
- uid: System.Collections.Hashtable.Count
  id: Count
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Count
  nameWithType: Hashtable.Count
  fullName: System.Collections.Hashtable.Count
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Pobiera liczbę par klucz/wartość zawartych w <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
  remarks: "Pobieranie wartości tej właściwości jest operacją O(1)."
  syntax:
    content: public virtual int Count { get; }
    return:
      type: System.Int32
      description: "Liczba par klucz/wartość zawartych w <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
  overload: System.Collections.Hashtable.Count*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.EqualityComparer
  id: EqualityComparer
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: EqualityComparer
  nameWithType: Hashtable.EqualityComparer
  fullName: System.Collections.Hashtable.EqualityComparer
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Pobiera <xref:System.Collections.IEqualityComparer>do użycia na potrzeby <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.IEqualityComparer>"
  remarks: "<xref:System.Collections.IEqualityComparer>Zawiera modułu porównującego i dostawcy kodu wyznaczania wartości skrótu.</xref:System.Collections.IEqualityComparer> Jeśli <xref:System.Collections.IEqualityComparer>jest używany w <xref:System.Collections.Hashtable>konstruktora, obiekty używane jako klucze w <xref:System.Collections.Hashtable>nie są wymagane w celu zastąpienia <xref:System.Object.GetHashCode%2A?displayProperty=fullName>i <xref:System.Object.Equals%2A?displayProperty=fullName>metody.</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       Pobieranie wartości tej właściwości jest operacją O(1)."
  syntax:
    content: protected System.Collections.IEqualityComparer EqualityComparer { get; }
    return:
      type: System.Collections.IEqualityComparer
      description: "<xref:System.Collections.IEqualityComparer>Do użycia na potrzeby <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.IEqualityComparer>"
  overload: System.Collections.Hashtable.EqualityComparer*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Właściwość jest ustawiona na wartość, ale tablicy skrótów został utworzony przy użyciu <xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref> i <xref:System.Collections.IComparer>.</xref:System.Collections.IComparer>"
  platform:
  - net462
- uid: System.Collections.Hashtable.GetEnumerator
  id: GetEnumerator
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: Hashtable.GetEnumerator()
  fullName: System.Collections.Hashtable.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Zwraca <xref:System.Collections.IDictionaryEnumerator>który iteruje <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.IDictionaryEnumerator>"
  remarks: "[Visual Basic, C#]       `foreach` Instrukcji języka C# (`for each` w języku Visual Basic) ukrywa złożoność wyliczenia.  W związku z tym przy użyciu `foreach` jest zalecane, zamiast bezpośrednie manipulowanie modułu wyliczającego.       Moduły wyliczające może służyć do odczytywania danych w kolekcji, ale nie może służyć do modyfikowania kolekcji źródłowej.       Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A>również wprowadzono moduł wyliczający wróć do tej pozycji.</xref:System.Collections.IEnumerator.Reset%2A>  W tym miejscu <xref:System.Collections.IEnumerator.Current%2A>jest niezdefiniowany.</xref:System.Collections.IEnumerator.Current%2A> W związku z tym należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A>można poprawić modułu wyliczającego pierwszy element do kolekcji przed odczytaniem wartość <xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>zwraca ten sam obiekt do momentu <xref:System.Collections.IEnumerator.MoveNext%2A>lub <xref:System.Collections.IEnumerator.Reset%2A>jest wywoływana.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>Ustawia <xref:System.Collections.IEnumerator.Current%2A>do następnego elementu.</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A>przekazuje końcem kolekcji, moduł wyliczający jest umieszczony za ostatnim elementem w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A>zwraca `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Gdy moduł wyliczający jest w tym miejscu kolejnych wywołań <xref:System.Collections.IEnumerator.MoveNext%2A>zwracają również `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> Jeśli przez ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A>zwrócił `false`, <xref:System.Collections.IEnumerator.Current%2A>jest niezdefiniowany.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Aby ustawić <xref:System.Collections.IEnumerator.Current%2A>pierwszy element w kolekcji, należy wywołać, <xref:System.Collections.IEnumerator.Reset%2A>następuje <xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A>       Moduł wyliczający pozostaje ważny tak długo, jak kolekcji pozostaje niezmieniona. Jeśli wprowadzono zmiany w kolekcji, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający jest bezpowrotnie nieważne i jego zachowanie jest niezdefiniowana.       Moduł wyliczający nie ma wyłączny dostęp do kolekcji; w związku z tym wyliczania kolekcji leżą nie jest bezpieczne procedury wątku.  W celu zagwarantowania bezpieczeństwa wątków podczas wyliczania, można zablokować kolekcję podczas całej wyliczenia.  Aby zezwolić na dostęp przez wiele wątków do odczytu i zapisu do kolekcji, musi implementować własne synchronizacji.       Ta metoda jest operacją O(1).       Ponieważ serializację i deserializację moduł wyliczający dla <xref:System.Collections.Hashtable>może spowodować się stać się zmienić kolejności elementów, nie jest możliwe kontynuować wyliczenia bez wywoływania <xref:System.Collections.IEnumerator.Reset%2A>metody.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.Hashtable>"
  example:
  - "The following example compares the use of GetEnumerator and `foreach` to enumerate the contents of a <xref:System.Collections.Hashtable>.  \n  \n [!code-cpp[Classic Hashtable Example#2](~/add/codesnippet/cpp/m-system.collections.has_3_1.cpp)]\n [!code-cs[Classic Hashtable Example#2](~/add/codesnippet/csharp/m-system.collections.has_3_1.cs)]\n [!code-vb[Classic Hashtable Example#2](~/add/codesnippet/visualbasic/m-system.collections.has_3_1.vb)]"
  syntax:
    content: public virtual System.Collections.IDictionaryEnumerator GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IDictionaryEnumerator
      description: "An <xref:System.Collections.IDictionaryEnumerator> for the <xref href=&quot;System.Collections.Hashtable&quot;></xref>.</xref:System.Collections.IDictionaryEnumerator>"
  overload: System.Collections.Hashtable.GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.GetHash(System.Object)
  id: GetHash(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: GetHash(Object)
  nameWithType: Hashtable.GetHash(Object)
  fullName: System.Collections.Hashtable.GetHash(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Zwraca wartość skrótu dla określonego klucza."
  remarks: "Jeśli utworzono tabelę wyznaczania wartości skrótu z określonym <xref:System.Collections.IHashCodeProvider>implementacji, ta metoda używa tego dostawcy Kod skrótu; w przeciwnym razie używa <xref:System.Object.GetHashCode%2A?displayProperty=fullName>Implementacja `key`.</xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.IHashCodeProvider>       Ta metoda jest operacją O(1)."
  syntax:
    content: protected virtual int GetHash (object key);
    parameters:
    - id: key
      type: System.Object
      description: "<xref:System.Object>Dla której ma zostać zwrócone skrótu.</xref:System.Object>"
    return:
      type: System.Int32
      description: "Wartość skrótu dla <code> key </code>."
  overload: System.Collections.Hashtable.GetHash*
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: GetObjectData(SerializationInfo,StreamingContext)
  nameWithType: Hashtable.GetObjectData(SerializationInfo,StreamingContext)
  fullName: System.Collections.Hashtable.GetObjectData(SerializationInfo,StreamingContext)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Implementuje <xref href=&quot;System.Runtime.Serialization.ISerializable&quot;> </xref> interfejsu i zwraca dane potrzebne do serializacji <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
  remarks: "Ta metoda jest O (`n`) operację, której `n` <xref:System.Collections.Hashtable.Count%2A>.</xref:System.Collections.Hashtable.Count%2A>"
  syntax:
    content: public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "A <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> obiektu zawierającego informacje o wymaganych do zserializowania <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "A <xref:System.Runtime.Serialization.StreamingContext>obiekt zawierający źródłowy i docelowy serializowanego strumienia skojarzonego z <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Runtime.Serialization.StreamingContext>"
  overload: System.Collections.Hashtable.GetObjectData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>info</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kolekcja została zmodyfikowana."
  platform:
  - net462
- uid: System.Collections.Hashtable.hcp
  id: hcp
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: hcp
  nameWithType: Hashtable.hcp
  fullName: System.Collections.Hashtable.hcp
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Pobiera lub ustawia obiekt, który można rozdzielić skrótu."
  remarks: "Pobieranie wartości tej właściwości jest operacją O(1)."
  syntax:
    content: protected System.Collections.IHashCodeProvider hcp { get; set; }
    return:
      type: System.Collections.IHashCodeProvider
      description: "Obiekt, który można rozdzielić skrótu."
  overload: System.Collections.Hashtable.hcp*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Właściwość jest ustawiona na wartość, ale tablicy skrótów został utworzony przy użyciu <xref:System.Collections.IEqualityComparer>.</xref:System.Collections.IEqualityComparer>"
  platform:
  - net462
- uid: System.Collections.Hashtable.IsFixedSize
  id: IsFixedSize
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: IsFixedSize
  nameWithType: Hashtable.IsFixedSize
  fullName: System.Collections.Hashtable.IsFixedSize
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Pobiera wartość wskazującą czy <xref href=&quot;System.Collections.Hashtable&quot;> </xref> ma stały rozmiar."
  remarks: "Kolekcja o stałym rozmiarze nie zezwala na dodawanie i usuwanie elementów po utworzeniu kolekcji, ale umożliwia modyfikowanie istniejących elementów.       Kolekcja o stałym rozmiarze jest po prostu kolekcji z otoką, który uniemożliwia Dodawanie i usuwanie elementów; w związku z tym zmian w źródłowej kolekcji, włączając Dodawanie lub usuwanie elementów z kolekcji o stałym rozmiarze odzwierciedla te zmiany.       Pobieranie wartości tej właściwości jest operacją O(1)."
  syntax:
    content: public virtual bool IsFixedSize { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli <xref href=&quot;System.Collections.Hashtable&quot;> </xref> ma ustalony rozmiar; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Wartość domyślna to <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Hashtable.IsFixedSize*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.IsReadOnly
  id: IsReadOnly
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: IsReadOnly
  nameWithType: Hashtable.IsReadOnly
  fullName: System.Collections.Hashtable.IsReadOnly
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Pobiera wartość wskazującą czy <xref href=&quot;System.Collections.Hashtable&quot;> </xref> jest tylko do odczytu."
  remarks: "Kolekcja, która jest tylko do odczytu uniemożliwia dodawania, usuwania lub modyfikowania elementów po utworzeniu kolekcji.       Kolekcja, która jest tylko do odczytu jest po prostu kolekcji z otoką, co uniemożliwia ich modyfikowania kolekcji; w związku z tym jeśli wprowadzono zmiany w źródłowej kolekcji, kolekcji tylko do odczytu odzwierciedla te zmiany.       Pobieranie wartości tej właściwości jest operacją O(1)."
  syntax:
    content: public virtual bool IsReadOnly { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli <xref href=&quot;System.Collections.Hashtable&quot;> </xref> jest tylko do odczytu; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Wartość domyślna to <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Hashtable.IsReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.IsSynchronized
  id: IsSynchronized
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: IsSynchronized
  nameWithType: Hashtable.IsSynchronized
  fullName: System.Collections.Hashtable.IsSynchronized
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Pobiera wartość wskazującą czy uzyskują dostęp do <xref href=&quot;System.Collections.Hashtable&quot;> </xref> jest synchronizowane (wielowątkowość)."
  remarks: "A <xref:System.Collections.Hashtable>może obsługiwać jeden moduł zapisujący i wielu czytników współbieżnie.</xref:System.Collections.Hashtable> Aby obsługiwać wiele składników zapisywania, wszystkie operacje muszą być wykonywane przez otoki zwrócony przez <xref:System.Collections.Hashtable.Synchronized%2A>metody.</xref:System.Collections.Hashtable.Synchronized%2A>       Wyliczanie za pomocą kolekcji leżą nie jest procedurą bezpieczne wątku. Nawet jeśli kolekcja jest synchronizowane, inne wątki mogą modyfikować kolekcji, co powoduje, że moduł wyliczający, który ma zostać zgłoszony wyjątek. W celu zagwarantowania bezpieczeństwa wątków podczas wyliczania, możesz zablokować kolekcji podczas wyliczania całego lub przechwytują wyjątki wynikające ze zmian wprowadzonych przez inne wątki.       W poniższym przykładzie pokazano, jak można zablokować za pomocą kolekcji <xref:System.Collections.Hashtable.SyncRoot%2A>podczas wyliczania całego: [!code-cpp [klasycznego Hashtable.IsSynchronized przykład&#2;](~/add/codesnippet/cpp/p-system.collections.has_1_1.cpp)][!code-vb[klasycznego Hashtable.IsSynchronized przykład&#2;](~/add/codesnippet/visualbasic/p-system.collections.has_1_1.vb)][!code-cs[klasycznego Hashtable.IsSynchronized przykład&#2;](~/add/codesnippet/csharp/p-system.collections.has_1_1.cs) ]     </xref:System.Collections.Hashtable.SyncRoot%2A>"
  example:
  - "The following example shows how to synchronize a <xref:System.Collections.Hashtable>, determine if a <xref:System.Collections.Hashtable> is synchronized, and use a synchronized <xref:System.Collections.Hashtable>.  \n  \n [!code-cs[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/csharp/p-system.collections.has_1_2.cs)]\n [!code-cpp[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/cpp/p-system.collections.has_1_2.cpp)]\n [!code-vb[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/visualbasic/p-system.collections.has_1_2.vb)]"
  syntax:
    content: public virtual bool IsSynchronized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli dostęp do <xref href=&quot;System.Collections.Hashtable&quot;> </xref> jest synchronizowane (wielowątkowość); w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Wartość domyślna to <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Hashtable.IsSynchronized*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.Item(System.Object)
  id: Item(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Item(Object)
  nameWithType: Hashtable.Item(Object)
  fullName: System.Collections.Hashtable.Item(Object)
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Pobiera lub ustawia wartość skojarzoną z określonym kluczem."
  remarks: "Ta właściwość umożliwia dostęp do określonego elementu w kolekcji przy użyciu następującej składni: `myCollection[key]`.       Umożliwia także właściwości elementu można dodawać nowe elementy za pomocą ustawienia wartości klucza, który nie istnieje w <xref:System.Collections.Hashtable>, na przykład `myCollection[&quot;myNonexistentKey&quot;] = myValue`.</xref:System.Collections.Hashtable> Jednak jeśli określony klucz już istnieje w <xref:System.Collections.Hashtable>, ustawienie właściwości elementu zastępuje stara wartość.</xref:System.Collections.Hashtable> Z kolei <xref:System.Collections.Hashtable.Add%2A>— Metoda nie modyfikuje istniejące elementy.</xref:System.Collections.Hashtable.Add%2A>       Klucz nie może być `null`, ale może być wartością. Aby odróżnić `null` który jest zwracany, ponieważ nie odnaleziono określonego klucza i `null` który jest zwracany, ponieważ wartość określony klucz jest `null`, użyj <xref:System.Collections.Hashtable.Contains%2A>— Metoda lub <xref:System.Collections.Hashtable.ContainsKey%2A>metodę, aby określić, czy klucz znajduje się na liście.</xref:System.Collections.Hashtable.ContainsKey%2A> </xref:System.Collections.Hashtable.Contains%2A>       Pobieranie wartości tej właściwości jest operacją O(1); Ustawienie właściwości jest również O(1) operacji.       Używa języka C# do definiowania indeksatory zamiast implementacja słowa kluczowego <xref:System.Collections.IList.Item%2A>Właściwości.</xref:System.Collections.IList.Item%2A> Visual Basic implementuje element jako domyślna właściwość, która zapewnia te same funkcje indeksowania."
  syntax:
    content: public virtual object this[object key] { get; set; }
    parameters:
    - id: key
      type: System.Object
      description: "Klucz wartości, których można pobrać lub ustawić."
    return:
      type: System.Object
      description: "Wartość skojarzona z określonym kluczem. Jeśli określony klucz nie zostanie znaleziony, próby pobrania jej zwraca <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, a próba skonfigurowania go tworzy nowy element przy użyciu określonego klucza."
  overload: System.Collections.Hashtable.Item*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Właściwość jest ustawiona i <xref href=&quot;System.Collections.Hashtable&quot;> </xref> jest tylko do odczytu.       - lub - właściwość jest ustawiona, <code> key </code> nie istnieje w kolekcji i <xref href=&quot;System.Collections.Hashtable&quot;> </xref> ma stały rozmiar."
  platform:
  - net462
- uid: System.Collections.Hashtable.KeyEquals(System.Object,System.Object)
  id: KeyEquals(System.Object,System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: KeyEquals(Object,Object)
  nameWithType: Hashtable.KeyEquals(Object,Object)
  fullName: System.Collections.Hashtable.KeyEquals(Object,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Porównuje określony <xref:System.Object>z określonym kluczem w <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Object>"
  remarks: "Jeśli utworzono tabelę wyznaczania wartości skrótu z określonym <xref:System.Collections.IComparer>implementacji, ta metoda używa tego porównania; będący, <xref:System.Collections.IComparer.Compare%2A>(`item`, `key`).</xref:System.Collections.IComparer.Compare%2A> </xref:System.Collections.IComparer> W przeciwnym razie używa `item.Equals(key)`.       Ta metoda jest operacją O(1)."
  syntax:
    content: protected virtual bool KeyEquals (object item, object key);
    parameters:
    - id: item
      type: System.Object
      description: "<xref:System.Object>Do porównania z `key`.</xref:System.Object>"
    - id: key
      type: System.Object
      description: "Klucz w <xref href=&quot;System.Collections.Hashtable&quot;> </xref> do porównania z `item`."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>if <code>item</code> and <code>key</code> are equal; otherwise, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>."
  overload: System.Collections.Hashtable.KeyEquals*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>item</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>key</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.Keys
  id: Keys
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Keys
  nameWithType: Hashtable.Keys
  fullName: System.Collections.Hashtable.Keys
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Pobiera <xref:System.Collections.ICollection>zawierającą klucze ze słownika <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.ICollection>"
  remarks: "Kolejność kluczy w <xref:System.Collections.ICollection>jest nieokreślony, ale takiej samej kolejności jak skojarzone wartości w <xref:System.Collections.ICollection>zwrócony przez <xref:System.Collections.Hashtable.Values%2A>metody.</xref:System.Collections.Hashtable.Values%2A> </xref:System.Collections.ICollection> </xref:System.Collections.ICollection>       Zwrócona <xref:System.Collections.ICollection>nie jest statyczna kopia; zamiast tego <xref:System.Collections.ICollection>odwołuje się do kluczy w oryginalnym <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> </xref:System.Collections.ICollection> </xref:System.Collections.ICollection> Dlatego zmiany <xref:System.Collections.Hashtable>zostaną odzwierciedlone w <xref:System.Collections.ICollection>.</xref:System.Collections.ICollection> w dalszym ciągu</xref:System.Collections.Hashtable>       Pobieranie wartości tej właściwości jest operacją O(1)."
  syntax:
    content: public virtual System.Collections.ICollection Keys { get; }
    return:
      type: System.Collections.ICollection
      description: "<xref:System.Collections.ICollection>Zawierającą klucze ze słownika <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.ICollection>"
  overload: System.Collections.Hashtable.Keys*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.OnDeserialization(System.Object)
  id: OnDeserialization(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: OnDeserialization(Object)
  nameWithType: Hashtable.OnDeserialization(Object)
  fullName: System.Collections.Hashtable.OnDeserialization(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Implementuje <xref href=&quot;System.Runtime.Serialization.ISerializable&quot;> </xref> interfejsu i zgłasza zdarzenie deserializacji po zakończeniu wykonywania deserializacji."
  remarks: "Ta metoda jest O (`n`) operację, której `n` <xref:System.Collections.Hashtable.Count%2A>.</xref:System.Collections.Hashtable.Count%2A>       Ponieważ serializację i deserializację moduł wyliczający dla <xref:System.Collections.Hashtable>może spowodować się stać się zmienić kolejności elementów, nie jest możliwe kontynuować wyliczenia bez wywoływania <xref:System.Collections.IEnumerator.Reset%2A>metody.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.Hashtable>"
  syntax:
    content: public virtual void OnDeserialization (object sender);
    parameters:
    - id: sender
      type: System.Object
      description: "Źródło zdarzenia deserializacji."
  overload: System.Collections.Hashtable.OnDeserialization*
  exceptions:
  - type: System.Runtime.Serialization.SerializationException
    commentId: T:System.Runtime.Serialization.SerializationException
    description: "<xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> Obiekt skojarzony z bieżącym <xref href=&quot;System.Collections.Hashtable&quot;> </xref> jest nieprawidłowy."
  platform:
  - net462
- uid: System.Collections.Hashtable.Remove(System.Object)
  id: Remove(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Remove(Object)
  nameWithType: Hashtable.Remove(Object)
  fullName: System.Collections.Hashtable.Remove(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Usuwa element z określonym kluczem z <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
  remarks: "Jeśli <xref:System.Collections.Hashtable>nie zawiera element z określonym kluczem <xref:System.Collections.Hashtable>pozostaje niezmieniona.</xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> Nie wyjątek.       Ta metoda jest operacją O(1)."
  example:
  - "The following example shows how to remove elements from the <xref:System.Collections.Hashtable>.  \n  \n [!code-cpp[Classic Hashtable.Remove Example#1](~/add/codesnippet/cpp/m-system.collections.has_13_1.cpp)]\n [!code-cs[Classic Hashtable.Remove Example#1](~/add/codesnippet/csharp/m-system.collections.has_13_1.cs)]\n [!code-vb[Classic Hashtable.Remove Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_13_1.vb)]"
  syntax:
    content: public virtual void Remove (object key);
    parameters:
    - id: key
      type: System.Object
      description: "Klucz elementu do usunięcia."
  overload: System.Collections.Hashtable.Remove*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.Hashtable&quot;> </xref> Jest tylko do odczytu.       - lub - <xref href=&quot;System.Collections.Hashtable&quot;> </xref> ma stały rozmiar."
  platform:
  - net462
- uid: System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)
  id: Synchronized(System.Collections.Hashtable)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Synchronized(Hashtable)
  nameWithType: Hashtable.Synchronized(Hashtable)
  fullName: System.Collections.Hashtable.Synchronized(Hashtable)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Zwraca zsynchronizowane otoki (wątkowo) dla <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
  remarks: "Metoda Synchronized jest wielowątkowość dla wielu czytników i modułów zapisujących. Ponadto zsynchronizowane otoki gwarantuje, że jest tylko jeden moduł zapisujący zapisywania naraz.       Wyliczanie za pomocą kolekcji leżą nie jest procedurą wątkowo. Nawet jeśli kolekcja jest synchronizowane, inne wątki mogą modyfikować kolekcji, co powoduje, że moduł wyliczający, który ma zostać zgłoszony wyjątek. W celu zagwarantowania bezpieczeństwa wątków podczas wyliczania, możesz zablokować kolekcji podczas wyliczania całego lub przechwytują wyjątki wynikające ze zmian wprowadzonych przez inne wątki.       W poniższym przykładzie pokazano, jak można zablokować za pomocą kolekcji <xref:System.Collections.Hashtable.SyncRoot%2A>podczas wyliczania całego: [!code-cpp [klasycznego Hashtable.IsSynchronized przykład&#2;](~/add/codesnippet/cpp/m-system.collections.has_11_1.cpp)][!code-vb[klasycznego Hashtable.IsSynchronized przykład&#2;](~/add/codesnippet/visualbasic/m-system.collections.has_11_1.vb)][!code-cs[klasycznego Hashtable.IsSynchronized przykład&#2;](~/add/codesnippet/csharp/m-system.collections.has_11_1.cs) ] ta metoda jest operacją O(1).    </xref:System.Collections.Hashtable.SyncRoot%2A>"
  example:
  - "The following example shows how to synchronize a <xref:System.Collections.Hashtable>, determine if a <xref:System.Collections.Hashtable> is synchronized, and use a synchronized <xref:System.Collections.Hashtable>.  \n  \n [!code-cs[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/csharp/m-system.collections.has_11_2.cs)]\n [!code-cpp[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/cpp/m-system.collections.has_11_2.cpp)]\n [!code-vb[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_11_2.vb)]"
  syntax:
    content: public static System.Collections.Hashtable Synchronized (System.Collections.Hashtable table);
    parameters:
    - id: table
      type: System.Collections.Hashtable
      description: "<xref href=&quot;System.Collections.Hashtable&quot;> </xref> Do synchronizacji."
    return:
      type: System.Collections.Hashtable
      description: "A zsynchronizowane (wątkowo) otoki dla <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
  overload: System.Collections.Hashtable.Synchronized*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>table</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.SyncRoot
  id: SyncRoot
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: SyncRoot
  nameWithType: Hashtable.SyncRoot
  fullName: System.Collections.Hashtable.SyncRoot
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Pobiera obiekt, który może służyć do synchronizujący dostęp do <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
  remarks: "Aby utworzyć zsynchronizowaną wersję <xref:System.Collections.Hashtable>, użyj <xref:System.Collections.Hashtable.Synchronized%2A>metody.</xref:System.Collections.Hashtable.Synchronized%2A> </xref:System.Collections.Hashtable> Jednak klasy pochodne zapewniają własne zsynchronizowanej wersji <xref:System.Collections.Hashtable>za pomocą właściwości SyncRoot.</xref:System.Collections.Hashtable> Synchronizowanie kodu musi wykonywać operacje na SyncRoot z <xref:System.Collections.Hashtable>, bezpośrednio na <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> Zapewnia to poprawne działanie kolekcje, które pochodzą od innych obiektów. W szczególności przechowuje prawidłowego synchronizacji z innych wątków, które mogą być jednocześnie modyfikowanie <xref:System.Collections.Hashtable>obiektu.</xref:System.Collections.Hashtable>       Wyliczanie za pomocą kolekcji leżą nie jest procedurą bezpieczne wątku. Nawet jeśli kolekcja jest synchronizowane, inne wątki mogą modyfikować kolekcji, co powoduje, że moduł wyliczający, który ma zostać zgłoszony wyjątek. W celu zagwarantowania bezpieczeństwa wątków podczas wyliczania, możesz zablokować kolekcji podczas wyliczania całego lub przechwytują wyjątki wynikające ze zmian wprowadzonych przez inne wątki.       Poniższy przykład kodu pokazuje, jak można zablokować kolekcji przy użyciu SyncRoot podczas wyliczania całego: [!code-cpp [klasycznego Hashtable.IsSynchronized przykład&#2;](~/add/codesnippet/cpp/p-system.collections.has_0_1.cpp)][!code-vb[klasycznego Hashtable.IsSynchronized przykład&#2;](~/add/codesnippet/visualbasic/p-system.collections.has_0_1.vb)][!code-cs[klasycznego Hashtable.IsSynchronized przykład&#2;    ](~/add/codesnippet/csharp/p-system.collections.has_0_1.cs)]"
  syntax:
    content: public virtual object SyncRoot { get; }
    return:
      type: System.Object
      description: "Obiekt, który może służyć do synchronizujący dostęp do <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
  overload: System.Collections.Hashtable.SyncRoot*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator
  id: System#Collections#IEnumerable#GetEnumerator
  isEii: true
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: System.Collections.IEnumerable.GetEnumerator()
  nameWithType: Hashtable.System.Collections.IEnumerable.GetEnumerator()
  fullName: System.Collections.Hashtable.System.Collections.IEnumerable.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Zwraca moduł wyliczający, który iteruje po kolekcji."
  remarks: "[Visual Basic, C#]       `foreach` Instrukcji języka C# (`for each` w języku Visual Basic) ukrywa złożoność wyliczenia.  W związku z tym przy użyciu `foreach` jest zalecane, zamiast bezpośrednie manipulowanie modułu wyliczającego.       Moduły wyliczające może służyć do odczytywania danych w kolekcji, ale nie może służyć do modyfikowania kolekcji źródłowej.       Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A>również wprowadzono moduł wyliczający wróć do tej pozycji.</xref:System.Collections.IEnumerator.Reset%2A> At to pozycja, wywoływania <xref:System.Collections.IEnumerator.Current%2A>zgłasza wyjątek.</xref:System.Collections.IEnumerator.Current%2A> W związku z tym należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A>można poprawić modułu wyliczającego pierwszy element do kolekcji przed odczytaniem wartość <xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>zwraca ten sam obiekt do momentu <xref:System.Collections.IEnumerator.MoveNext%2A>lub <xref:System.Collections.IEnumerator.Reset%2A>jest wywoływana.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>Ustawia <xref:System.Collections.IEnumerator.Current%2A>do następnego elementu.</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A>przekazuje końcem kolekcji, moduł wyliczający jest umieszczony za ostatnim elementem w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A>zwraca `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Gdy moduł wyliczający jest w tym miejscu kolejnych wywołań <xref:System.Collections.IEnumerator.MoveNext%2A>zwracają również `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> Jeśli przez ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A>zwrócił `false`, wywoływania <xref:System.Collections.IEnumerator.Current%2A>zgłasza wyjątek.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Aby ustawić <xref:System.Collections.IEnumerator.Current%2A>pierwszy element w kolekcji, należy wywołać, <xref:System.Collections.IEnumerator.Reset%2A>następuje <xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A>       Moduł wyliczający pozostaje ważny tak długo, jak kolekcji pozostaje niezmieniona. Jeśli wprowadzono zmiany w kolekcji, takie jak dodawanie, modyfikowanie lub usuwanie elementów, modułu wyliczającego można unieważniona i następnego wywołania lub <xref:System.Collections.IEnumerator.MoveNext%2A> <xref:System.Collections.IEnumerator.Reset%2A>zgłasza <xref:System.InvalidOperationException>.</xref:System.InvalidOperationException> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Jeśli kolekcja jest zmodyfikowany między <xref:System.Collections.IEnumerator.MoveNext%2A>i <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A>zwraca element, który ma ustawioną, nawet wtedy, gdy moduł wyliczający jest już unieważnione.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A>       Moduł wyliczający nie ma wyłączny dostęp do kolekcji; w związku z tym wyliczania kolekcji leżą nie jest bezpieczne procedury wątku. Nawet jeśli kolekcja jest synchronizowane, inne wątki mogą modyfikować kolekcji, co powoduje, że moduł wyliczający, który ma zostać zgłoszony wyjątek. W celu zagwarantowania bezpieczeństwa wątków podczas wyliczania, możesz zablokować kolekcji podczas wyliczania całego lub przechwytują wyjątki wynikające ze zmian wprowadzonych przez inne wątki.       Ta metoda jest operacją O(1)."
  syntax:
    content: System.Collections.IEnumerator IEnumerable.GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "<xref:System.Collections.IEnumerator>Który może służyć do iterowania po kolekcji.</xref:System.Collections.IEnumerator>"
  overload: System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.Values
  id: Values
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Values
  nameWithType: Hashtable.Values
  fullName: System.Collections.Hashtable.Values
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Pobiera <xref:System.Collections.ICollection>zawierający wartości w <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.ICollection>"
  remarks: "Kolejność wartości na liście <xref:System.Collections.ICollection>jest nieokreślony, ale takiej samej kolejności jak skojarzonych kluczy w <xref:System.Collections.ICollection>zwrócony przez <xref:System.Collections.Hashtable.Keys%2A>— Metoda.</xref:System.Collections.Hashtable.Keys%2A> </xref:System.Collections.ICollection> </xref:System.Collections.ICollection>       Zwrócona <xref:System.Collections.ICollection>nie jest statyczna kopia; zamiast tego <xref:System.Collections.ICollection>odwołuje się do wartości w oryginalnym <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> </xref:System.Collections.ICollection> </xref:System.Collections.ICollection> Dlatego zmiany <xref:System.Collections.Hashtable>zostaną odzwierciedlone w <xref:System.Collections.ICollection>.</xref:System.Collections.ICollection> w dalszym ciągu</xref:System.Collections.Hashtable>       Pobieranie wartości tej właściwości jest operacją O(1)."
  syntax:
    content: public virtual System.Collections.ICollection Values { get; }
    return:
      type: System.Collections.ICollection
      description: "<xref:System.Collections.ICollection>Zawierający wartości w <xref href=&quot;System.Collections.Hashtable&quot;> </xref>.</xref:System.Collections.ICollection>"
  overload: System.Collections.Hashtable.Values*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.InvalidCastException
  isExternal: true
  name: System.InvalidCastException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Runtime.Serialization.SerializationException
  isExternal: true
  name: System.Runtime.Serialization.SerializationException
- uid: System.Collections.Hashtable.#ctor
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable()
  nameWithType: Hashtable.Hashtable()
  fullName: System.Collections.Hashtable.Hashtable()
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary)
  nameWithType: Hashtable.Hashtable(IDictionary)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary)
- uid: System.Collections.IDictionary
  parent: System.Collections
  isExternal: true
  name: IDictionary
  nameWithType: IDictionary
  fullName: System.Collections.IDictionary
- uid: System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IEqualityComparer)
- uid: System.Collections.IEqualityComparer
  parent: System.Collections
  isExternal: true
  name: IEqualityComparer
  nameWithType: IEqualityComparer
  fullName: System.Collections.IEqualityComparer
- uid: System.Collections.Hashtable.#ctor(System.Int32)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32)
  nameWithType: Hashtable.Hashtable(Int32)
  fullName: System.Collections.Hashtable.Hashtable(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,IEqualityComparer)
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary,Single)
  nameWithType: Hashtable.Hashtable(IDictionary,Single)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IHashCodeProvider,IComparer)
- uid: System.Collections.IHashCodeProvider
  parent: System.Collections
  isExternal: false
  name: IHashCodeProvider
  nameWithType: IHashCodeProvider
  fullName: System.Collections.IHashCodeProvider
- uid: System.Collections.IComparer
  parent: System.Collections
  isExternal: true
  name: IComparer
  nameWithType: IComparer
  fullName: System.Collections.IComparer
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(Int32,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,IEqualityComparer)
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32,Single)
  nameWithType: Hashtable.Hashtable(Int32,Single)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single)
- uid: System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(SerializationInfo,StreamingContext)
  nameWithType: Hashtable.Hashtable(SerializationInfo,StreamingContext)
  fullName: System.Collections.Hashtable.Hashtable(SerializationInfo,StreamingContext)
- uid: System.Runtime.Serialization.SerializationInfo
  parent: System.Runtime.Serialization
  isExternal: false
  name: SerializationInfo
  nameWithType: SerializationInfo
  fullName: System.Runtime.Serialization.SerializationInfo
- uid: System.Runtime.Serialization.StreamingContext
  parent: System.Runtime.Serialization
  isExternal: true
  name: StreamingContext
  nameWithType: StreamingContext
  fullName: System.Runtime.Serialization.StreamingContext
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,IHashCodeProvider,IComparer)
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary,Single,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,Single,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single,IEqualityComparer)
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(Int32,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,IHashCodeProvider,IComparer)
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32,Single,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(Int32,Single,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single,IEqualityComparer)
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32,Single,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(Int32,Single,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single,IHashCodeProvider,IComparer)
- uid: System.Collections.Hashtable.Add(System.Object,System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Add(Object,Object)
  nameWithType: Hashtable.Add(Object,Object)
  fullName: System.Collections.Hashtable.Add(Object,Object)
- uid: System.Collections.Hashtable.Clear
  parent: System.Collections.Hashtable
  isExternal: false
  name: Clear()
  nameWithType: Hashtable.Clear()
  fullName: System.Collections.Hashtable.Clear()
- uid: System.Collections.Hashtable.Clone
  parent: System.Collections.Hashtable
  isExternal: false
  name: Clone()
  nameWithType: Hashtable.Clone()
  fullName: System.Collections.Hashtable.Clone()
- uid: System.Collections.Hashtable.comparer
  parent: System.Collections.Hashtable
  isExternal: false
  name: comparer
  nameWithType: Hashtable.comparer
  fullName: System.Collections.Hashtable.comparer
- uid: System.Collections.Hashtable.Contains(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Contains(Object)
  nameWithType: Hashtable.Contains(Object)
  fullName: System.Collections.Hashtable.Contains(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Collections.Hashtable.ContainsKey(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: ContainsKey(Object)
  nameWithType: Hashtable.ContainsKey(Object)
  fullName: System.Collections.Hashtable.ContainsKey(Object)
- uid: System.Collections.Hashtable.ContainsValue(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: ContainsValue(Object)
  nameWithType: Hashtable.ContainsValue(Object)
  fullName: System.Collections.Hashtable.ContainsValue(Object)
- uid: System.Collections.Hashtable.CopyTo(System.Array,System.Int32)
  parent: System.Collections.Hashtable
  isExternal: false
  name: CopyTo(Array,Int32)
  nameWithType: Hashtable.CopyTo(Array,Int32)
  fullName: System.Collections.Hashtable.CopyTo(Array,Int32)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: System.Collections.Hashtable.Count
  parent: System.Collections.Hashtable
  isExternal: false
  name: Count
  nameWithType: Hashtable.Count
  fullName: System.Collections.Hashtable.Count
- uid: System.Collections.Hashtable.EqualityComparer
  parent: System.Collections.Hashtable
  isExternal: false
  name: EqualityComparer
  nameWithType: Hashtable.EqualityComparer
  fullName: System.Collections.Hashtable.EqualityComparer
- uid: System.Collections.Hashtable.GetEnumerator
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetEnumerator()
  nameWithType: Hashtable.GetEnumerator()
  fullName: System.Collections.Hashtable.GetEnumerator()
- uid: System.Collections.IDictionaryEnumerator
  parent: System.Collections
  isExternal: true
  name: IDictionaryEnumerator
  nameWithType: IDictionaryEnumerator
  fullName: System.Collections.IDictionaryEnumerator
- uid: System.Collections.Hashtable.GetHash(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetHash(Object)
  nameWithType: Hashtable.GetHash(Object)
  fullName: System.Collections.Hashtable.GetHash(Object)
- uid: System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetObjectData(SerializationInfo,StreamingContext)
  nameWithType: Hashtable.GetObjectData(SerializationInfo,StreamingContext)
  fullName: System.Collections.Hashtable.GetObjectData(SerializationInfo,StreamingContext)
- uid: System.Collections.Hashtable.hcp
  parent: System.Collections.Hashtable
  isExternal: false
  name: hcp
  nameWithType: Hashtable.hcp
  fullName: System.Collections.Hashtable.hcp
- uid: System.Collections.Hashtable.IsFixedSize
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsFixedSize
  nameWithType: Hashtable.IsFixedSize
  fullName: System.Collections.Hashtable.IsFixedSize
- uid: System.Collections.Hashtable.IsReadOnly
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsReadOnly
  nameWithType: Hashtable.IsReadOnly
  fullName: System.Collections.Hashtable.IsReadOnly
- uid: System.Collections.Hashtable.IsSynchronized
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsSynchronized
  nameWithType: Hashtable.IsSynchronized
  fullName: System.Collections.Hashtable.IsSynchronized
- uid: System.Collections.Hashtable.Item(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Item(Object)
  nameWithType: Hashtable.Item(Object)
  fullName: System.Collections.Hashtable.Item(Object)
- uid: System.Collections.Hashtable.KeyEquals(System.Object,System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: KeyEquals(Object,Object)
  nameWithType: Hashtable.KeyEquals(Object,Object)
  fullName: System.Collections.Hashtable.KeyEquals(Object,Object)
- uid: System.Collections.Hashtable.Keys
  parent: System.Collections.Hashtable
  isExternal: false
  name: Keys
  nameWithType: Hashtable.Keys
  fullName: System.Collections.Hashtable.Keys
- uid: System.Collections.ICollection
  parent: System.Collections
  isExternal: true
  name: ICollection
  nameWithType: ICollection
  fullName: System.Collections.ICollection
- uid: System.Collections.Hashtable.OnDeserialization(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: OnDeserialization(Object)
  nameWithType: Hashtable.OnDeserialization(Object)
  fullName: System.Collections.Hashtable.OnDeserialization(Object)
- uid: System.Collections.Hashtable.Remove(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Remove(Object)
  nameWithType: Hashtable.Remove(Object)
  fullName: System.Collections.Hashtable.Remove(Object)
- uid: System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Synchronized(Hashtable)
  nameWithType: Hashtable.Synchronized(Hashtable)
  fullName: System.Collections.Hashtable.Synchronized(Hashtable)
- uid: System.Collections.Hashtable
  parent: System.Collections
  isExternal: false
  name: Hashtable
  nameWithType: Hashtable
  fullName: System.Collections.Hashtable
- uid: System.Collections.Hashtable.SyncRoot
  parent: System.Collections.Hashtable
  isExternal: false
  name: SyncRoot
  nameWithType: Hashtable.SyncRoot
  fullName: System.Collections.Hashtable.SyncRoot
- uid: System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator
  parent: System.Collections.Hashtable
  isExternal: false
  name: System.Collections.IEnumerable.GetEnumerator()
  nameWithType: Hashtable.System.Collections.IEnumerable.GetEnumerator()
  fullName: System.Collections.Hashtable.System.Collections.IEnumerable.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Collections.Hashtable.Values
  parent: System.Collections.Hashtable
  isExternal: false
  name: Values
  nameWithType: Hashtable.Values
  fullName: System.Collections.Hashtable.Values
- uid: System.Collections.Hashtable.#ctor*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable
  nameWithType: Hashtable.Hashtable
- uid: System.Collections.Hashtable.Add*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Add
  nameWithType: Hashtable.Add
- uid: System.Collections.Hashtable.Clear*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Clear
  nameWithType: Hashtable.Clear
- uid: System.Collections.Hashtable.Clone*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Clone
  nameWithType: Hashtable.Clone
- uid: System.Collections.Hashtable.comparer*
  parent: System.Collections.Hashtable
  isExternal: false
  name: comparer
  nameWithType: Hashtable.comparer
- uid: System.Collections.Hashtable.Contains*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Contains
  nameWithType: Hashtable.Contains
- uid: System.Collections.Hashtable.ContainsKey*
  parent: System.Collections.Hashtable
  isExternal: false
  name: ContainsKey
  nameWithType: Hashtable.ContainsKey
- uid: System.Collections.Hashtable.ContainsValue*
  parent: System.Collections.Hashtable
  isExternal: false
  name: ContainsValue
  nameWithType: Hashtable.ContainsValue
- uid: System.Collections.Hashtable.CopyTo*
  parent: System.Collections.Hashtable
  isExternal: false
  name: CopyTo
  nameWithType: Hashtable.CopyTo
- uid: System.Collections.Hashtable.Count*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Count
  nameWithType: Hashtable.Count
- uid: System.Collections.Hashtable.EqualityComparer*
  parent: System.Collections.Hashtable
  isExternal: false
  name: EqualityComparer
  nameWithType: Hashtable.EqualityComparer
- uid: System.Collections.Hashtable.GetEnumerator*
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetEnumerator
  nameWithType: Hashtable.GetEnumerator
- uid: System.Collections.Hashtable.GetHash*
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetHash
  nameWithType: Hashtable.GetHash
- uid: System.Collections.Hashtable.GetObjectData*
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetObjectData
  nameWithType: Hashtable.GetObjectData
- uid: System.Collections.Hashtable.hcp*
  parent: System.Collections.Hashtable
  isExternal: false
  name: hcp
  nameWithType: Hashtable.hcp
- uid: System.Collections.Hashtable.IsFixedSize*
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsFixedSize
  nameWithType: Hashtable.IsFixedSize
- uid: System.Collections.Hashtable.IsReadOnly*
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsReadOnly
  nameWithType: Hashtable.IsReadOnly
- uid: System.Collections.Hashtable.IsSynchronized*
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsSynchronized
  nameWithType: Hashtable.IsSynchronized
- uid: System.Collections.Hashtable.Item*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Item
  nameWithType: Hashtable.Item
- uid: System.Collections.Hashtable.KeyEquals*
  parent: System.Collections.Hashtable
  isExternal: false
  name: KeyEquals
  nameWithType: Hashtable.KeyEquals
- uid: System.Collections.Hashtable.Keys*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Keys
  nameWithType: Hashtable.Keys
- uid: System.Collections.Hashtable.OnDeserialization*
  parent: System.Collections.Hashtable
  isExternal: false
  name: OnDeserialization
  nameWithType: Hashtable.OnDeserialization
- uid: System.Collections.Hashtable.Remove*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Remove
  nameWithType: Hashtable.Remove
- uid: System.Collections.Hashtable.Synchronized*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Synchronized
  nameWithType: Hashtable.Synchronized
- uid: System.Collections.Hashtable.SyncRoot*
  parent: System.Collections.Hashtable
  isExternal: false
  name: SyncRoot
  nameWithType: Hashtable.SyncRoot
- uid: System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator*
  parent: System.Collections.Hashtable
  isExternal: false
  name: System.Collections.IEnumerable.GetEnumerator
  nameWithType: Hashtable.System.Collections.IEnumerable.GetEnumerator
- uid: System.Collections.Hashtable.Values*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Values
  nameWithType: Hashtable.Values
