### YamlMime:ManagedReference
items:
- uid: System.Windows.Rect
  id: Rect
  children:
  - System.Windows.Rect.#ctor(System.Windows.Size)
  - System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Point)
  - System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Size)
  - System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Vector)
  - System.Windows.Rect.#ctor(System.Double,System.Double,System.Double,System.Double)
  - System.Windows.Rect.Bottom
  - System.Windows.Rect.BottomLeft
  - System.Windows.Rect.BottomRight
  - System.Windows.Rect.Contains(System.Windows.Point)
  - System.Windows.Rect.Contains(System.Windows.Rect)
  - System.Windows.Rect.Contains(System.Double,System.Double)
  - System.Windows.Rect.Empty
  - System.Windows.Rect.Equals(System.Object)
  - System.Windows.Rect.Equals(System.Windows.Rect)
  - System.Windows.Rect.Equals(System.Windows.Rect,System.Windows.Rect)
  - System.Windows.Rect.GetHashCode
  - System.Windows.Rect.Height
  - System.Windows.Rect.Inflate(System.Windows.Size)
  - System.Windows.Rect.Inflate(System.Double,System.Double)
  - System.Windows.Rect.Inflate(System.Windows.Rect,System.Windows.Size)
  - System.Windows.Rect.Inflate(System.Windows.Rect,System.Double,System.Double)
  - System.Windows.Rect.Intersect(System.Windows.Rect)
  - System.Windows.Rect.Intersect(System.Windows.Rect,System.Windows.Rect)
  - System.Windows.Rect.IntersectsWith(System.Windows.Rect)
  - System.Windows.Rect.IsEmpty
  - System.Windows.Rect.Left
  - System.Windows.Rect.Location
  - System.Windows.Rect.Offset(System.Windows.Vector)
  - System.Windows.Rect.Offset(System.Double,System.Double)
  - System.Windows.Rect.Offset(System.Windows.Rect,System.Windows.Vector)
  - System.Windows.Rect.Offset(System.Windows.Rect,System.Double,System.Double)
  - System.Windows.Rect.op_Equality(System.Windows.Rect,System.Windows.Rect)
  - System.Windows.Rect.op_Inequality(System.Windows.Rect,System.Windows.Rect)
  - System.Windows.Rect.Parse(System.String)
  - System.Windows.Rect.Right
  - System.Windows.Rect.Scale(System.Double,System.Double)
  - System.Windows.Rect.Size
  - System.Windows.Rect.System#IFormattable#ToString(System.String,System.IFormatProvider)
  - System.Windows.Rect.Top
  - System.Windows.Rect.TopLeft
  - System.Windows.Rect.TopRight
  - System.Windows.Rect.ToString
  - System.Windows.Rect.ToString(System.IFormatProvider)
  - System.Windows.Rect.Transform(System.Windows.Media.Matrix)
  - System.Windows.Rect.Transform(System.Windows.Rect,System.Windows.Media.Matrix)
  - System.Windows.Rect.Union(System.Windows.Point)
  - System.Windows.Rect.Union(System.Windows.Rect)
  - System.Windows.Rect.Union(System.Windows.Rect,System.Windows.Point)
  - System.Windows.Rect.Union(System.Windows.Rect,System.Windows.Rect)
  - System.Windows.Rect.Width
  - System.Windows.Rect.X
  - System.Windows.Rect.Y
  langs:
  - csharp
  name: Rect
  nameWithType: Rect
  fullName: System.Windows.Rect
  type: Struct
  summary: "Opisuje szerokości, wysokości i lokalizacji prostokąta."
  remarks: "<a name=&quot;xamlAttributeUsage_Duration&quot;></a>## Użycie atrybutu XAML ```   <object property=&quot;x,y,width,height&quot;/>   ``` <a name=&quot;xamlValues_MinWidth&quot;> </a> ## wartości XAML *x* <xref:System.Double?displayProperty=fullName> lokalizacji współrzędną x lewej krawędzi prostokąta.</xref:System.Double?displayProperty=fullName>                 *y* <xref:System.Double?displayProperty=fullName> lokalizację współrzędną y górnej krawędzi prostokąta.</xref:System.Double?displayProperty=fullName>           *szerokość* <xref:System.Double?displayProperty=fullName> ujemna wartość, która reprezentuje <xref:System.Windows.Rect.Width%2A>prostokąta.</xref:System.Windows.Rect.Width%2A> </xref:System.Double?displayProperty=fullName>           *wysokość* <xref:System.Double?displayProperty=fullName> ujemna wartość, która reprezentuje <xref:System.Windows.Rect.Height%2A>prostokąta.</xref:System.Windows.Rect.Height%2A> </xref:System.Double?displayProperty=fullName>    "
  example:
  - "The following example shows how to use a Rect structure to specify the dimensions and location of a rectangle using XAML.  \n  \n [!code-cs[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/csharp/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.cs#rectexamplewholepage)]\n [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/visualbasic/geometriesmiscsnippets/rectexample.vb#rectexamplewholepage)]\n [!code-xml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/xaml/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.xaml#rectexamplewholepage)]  \n  \n The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: >-
      [System.ComponentModel.TypeConverter(typeof(System.Windows.RectConverter))]

      [System.Windows.Markup.ValueSerializer(typeof(System.Windows.Converters.RectValueSerializer))]

      public struct Rect : IFormattable
  inheritance:
  - System.ValueType
  implements:
  - System.IFormattable
  platform:
  - net462
- uid: System.Windows.Rect.#ctor(System.Windows.Size)
  id: '#ctor(System.Windows.Size)'
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Rect(Size)
  nameWithType: Rect.Rect(Size)
  fullName: System.Windows.Rect.Rect(Size)
  type: Constructor
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Windows.Rect&quot;> </xref> struktury o określonym rozmiarze, który znajduje się pod adresem (0,0)."
  remarks: ''
  example:
  - "The following example shows how to create a new <xref:System.Windows.Rect> structure by using the Rect constructor.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample2_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample2_csharp)]"
  syntax:
    content: public Rect (System.Windows.Size size);
    parameters:
    - id: size
      type: System.Windows.Size
      description: "A <xref href=&quot;System.Windows.Size&quot;> </xref> struktury, która określa szerokość i wysokość prostokąta."
  overload: System.Windows.Rect.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Point)
  id: '#ctor(System.Windows.Point,System.Windows.Point)'
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Rect(Point,Point)
  nameWithType: Rect.Rect(Point,Point)
  fullName: System.Windows.Rect.Rect(Point,Point)
  type: Constructor
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Windows.Rect&quot;> </xref> struktury, która jest dokładnie wystarczająco duże, aby zawiera dwa określone punkty."
  remarks: ''
  example:
  - "The following example shows how to create a new <xref:System.Windows.Rect> structure by using the Rect constructor.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample3_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample3_csharp)]"
  syntax:
    content: public Rect (System.Windows.Point point1, System.Windows.Point point2);
    parameters:
    - id: point1
      type: System.Windows.Point
      description: "Pierwszy punkt nowy prostokąt musi zawierać."
    - id: point2
      type: System.Windows.Point
      description: "Drugi punkt nowy prostokąt musi zawierać."
  overload: System.Windows.Rect.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Size)
  id: '#ctor(System.Windows.Point,System.Windows.Size)'
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Rect(Point,Size)
  nameWithType: Rect.Rect(Point,Size)
  fullName: System.Windows.Rect.Rect(Point,Size)
  type: Constructor
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Windows.Rect&quot;> </xref> struktury, która jest w lokalizacji określonej lewego górnego narożnika określona szerokość i wysokość."
  remarks: ''
  example:
  - "The following example shows how to create a new <xref:System.Windows.Rect> structure by using the Rect constructor.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample4_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample4_csharp)]"
  syntax:
    content: public Rect (System.Windows.Point location, System.Windows.Size size);
    parameters:
    - id: location
      type: System.Windows.Point
      description: "Punkt, który określa lokalizację, w lewym górnym rogu prostokąta."
    - id: size
      type: System.Windows.Size
      description: "A <xref href=&quot;System.Windows.Size&quot;> </xref> struktury, która określa szerokość i wysokość prostokąta."
  overload: System.Windows.Rect.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Vector)
  id: '#ctor(System.Windows.Point,System.Windows.Vector)'
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Rect(Point,Vector)
  nameWithType: Rect.Rect(Point,Vector)
  fullName: System.Windows.Rect.Rect(Point,Vector)
  type: Constructor
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Windows.Rect&quot;> </xref> dokładnie wystarczająco duże, aby zawierają określony punkt i sumę określonego punktu i wektor określonej struktury."
  remarks: ''
  example:
  - "The following example shows how to create a new <xref:System.Windows.Rect> structure by using the Rect constructor.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample5_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample5_csharp)]"
  syntax:
    content: public Rect (System.Windows.Point point, System.Windows.Vector vector);
    parameters:
    - id: point
      type: System.Windows.Point
      description: "Pierwszy punkt prostokąta musi zawierać."
    - id: vector
      type: System.Windows.Vector
      description: "Wartość przesunięcia określony punkt. Prostokąt wynikowy będzie dokładnie wystarczająco duże, aby zawierają zarówno punktów."
  overload: System.Windows.Rect.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.#ctor(System.Double,System.Double,System.Double,System.Double)
  id: '#ctor(System.Double,System.Double,System.Double,System.Double)'
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Rect(Double,Double,Double,Double)
  nameWithType: Rect.Rect(Double,Double,Double,Double)
  fullName: System.Windows.Rect.Rect(Double,Double,Double,Double)
  type: Constructor
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Windows.Rect&quot;> </xref> struktury, która ma współrzędną x współrzędną y, szerokość i wysokość."
  remarks: "Poniższy przykład przedstawia sposób tworzenia nowego <xref:System.Windows.Rect>struktury przy użyciu konstruktora Rect.</xref:System.Windows.Rect>       [!code-cs[RectExamples_snip #CreateRectExample6_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample6_csharp)]"
  syntax:
    content: public Rect (double x, double y, double width, double height);
    parameters:
    - id: x
      type: System.Double
      description: "Współrzędna x górnego lewego rogu prostokąta."
    - id: y
      type: System.Double
      description: "Współrzędna y górnego lewego rogu prostokąta."
    - id: width
      type: System.Double
      description: "Szerokość krawędzi prostokąta."
    - id: height
      type: System.Double
      description: "Wysokość prostokąta."
  overload: System.Windows.Rect.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>width</code>jest wartością ujemną.       - lub - <code>height</code> jest wartością ujemną."
  platform:
  - net462
- uid: System.Windows.Rect.Bottom
  id: Bottom
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Bottom
  nameWithType: Rect.Bottom
  fullName: System.Windows.Rect.Bottom
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Pobiera wartość osi y dolnej krawędzi prostokąta."
  remarks: "Wartość osi y dolnej krawędzi prostokąta jest równa sumie <xref:System.Windows.Rect.Y%2A>i <xref:System.Windows.Rect.Height%2A>Właściwości.</xref:System.Windows.Rect.Height%2A> </xref:System.Windows.Rect.Y%2A>"
  example:
  - "The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public double Bottom { get; }
    return:
      type: System.Double
      description: "Wartość osi y dolnej krawędzi prostokąta. Jeśli prostokąt jest puste, wartość jest <xref:System.Double>.</xref:System.Double>"
  overload: System.Windows.Rect.Bottom*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.BottomLeft
  id: BottomLeft
  parent: System.Windows.Rect
  langs:
  - csharp
  name: BottomLeft
  nameWithType: Rect.BottomLeft
  fullName: System.Windows.Rect.BottomLeft
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Pobiera pozycję lewym dolnym rogu prostokąta"
  remarks: "Położenie lewym dolnym rogu prostokąta jest równe (<xref:System.Windows.Rect.X%2A>, <xref:System.Windows.Rect.Y%2A>+ <xref:System.Windows.Rect.Height%2A>).</xref:System.Windows.Rect.Height%2A> </xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.X%2A>"
  example:
  - "The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public System.Windows.Point BottomLeft { get; }
    return:
      type: System.Windows.Point
      description: "Pozycja lewym dolnym rogu prostokąta."
  overload: System.Windows.Rect.BottomLeft*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.BottomRight
  id: BottomRight
  parent: System.Windows.Rect
  langs:
  - csharp
  name: BottomRight
  nameWithType: Rect.BottomRight
  fullName: System.Windows.Rect.BottomRight
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Pobiera pozycję prawego dolnego rogu prostokąta."
  remarks: "Pozycja w prawym dolnym rogu prostokąta jest równa (<xref:System.Windows.Rect.X%2A> + <xref:System.Windows.Rect.Width%2A>, <xref:System.Windows.Rect.Y%2A>+ <xref:System.Windows.Rect.Height%2A>).</xref:System.Windows.Rect.Height%2A> </xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.Width%2A> </xref:System.Windows.Rect.X%2A>"
  example:
  - "The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public System.Windows.Point BottomRight { get; }
    return:
      type: System.Windows.Point
      description: "Pozycja prawym dolnym rogu prostokąta."
  overload: System.Windows.Rect.BottomRight*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Contains(System.Windows.Point)
  id: Contains(System.Windows.Point)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Contains(Point)
  nameWithType: Rect.Contains(Point)
  fullName: System.Windows.Rect.Contains(Point)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Wskazuje, czy w prostokącie określonego punktu."
  remarks: ''
  example:
  - "The following example shows how to use the Contains method to determine if the rectangle contains the specified <xref:System.Windows.Point>.  \n  \n [!code-cs[RectExamples_snip#ContainsExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#containsexample1_csharp)]"
  syntax:
    content: public bool Contains (System.Windows.Point point);
    parameters:
    - id: point
      type: System.Windows.Point
      description: "Punkt do sprawdzenia."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli w prostokącie określonego punktu; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Rect.Contains*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Contains(System.Windows.Rect)
  id: Contains(System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Contains(Rect)
  nameWithType: Rect.Contains(Rect)
  fullName: System.Windows.Rect.Contains(Rect)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Wskazuje, czy w prostokącie określonego prostokąta."
  remarks: ''
  example:
  - "The following example shows how to use the Contains method to determine if one rectangle is contained by another rectangle.  \n  \n [!code-cs[RectExamples_snip#ContainsExample2_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#containsexample2_csharp)]"
  syntax:
    content: public bool Contains (System.Windows.Rect rect);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "Prostokąt do sprawdzenia."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli <code> rect </code> jest całkowicie zawartej przez prostokąt; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Rect.Contains*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Contains(System.Double,System.Double)
  id: Contains(System.Double,System.Double)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Contains(Double,Double)
  nameWithType: Rect.Contains(Double,Double)
  fullName: System.Windows.Rect.Contains(Double,Double)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Wskazuje, czy prostokąt zawiera współrzędną x i współrzędną y."
  remarks: ''
  example:
  - "The following example shows how to use the Contains method to determine if the rectangle contains the point specified by the given x-coordinate and y-coordinate.  \n  \n [!code-cs[RectExamples_snip#ContainsExample3_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#containsexample3_csharp)]"
  syntax:
    content: public bool Contains (double x, double y);
    parameters:
    - id: x
      type: System.Double
      description: "Współrzędna x punktu do sprawdzenia."
    - id: y
      type: System.Double
      description: "Współrzędna y punktu do sprawdzenia."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli (<code>x</code>, <code> y </code>) znajduje się w prostokącie przeciwnym <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Rect.Contains*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Empty
  id: Empty
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Empty
  nameWithType: Rect.Empty
  fullName: System.Windows.Rect.Empty
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Pobiera wartość specjalne, która reprezentuje prostokąt bez pozycji i obszar."
  remarks: "Unikaj obliczenia matematyczne obejmujące prostokąty puste. Ponieważ oba <xref:System.Windows.Rect.X%2A>i <xref:System.Windows.Rect.Y%2A>wartości nieskończone, procesora, operacji są znacznie ograniczone przez te operacje.</xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.X%2A> Porównania obejmujące te wartości nie będzie miało wpływ na wydajność aplikacji."
  syntax:
    content: public static System.Windows.Rect Empty { get; }
    return:
      type: System.Windows.Rect
      description: "Pusty prostokąt, który ma <> </> *> i <> </> *> wartości właściwości <xref:System.Double.PositiveInfinity>i ma <> </> *> i <> </> *> wartości właściwości <xref:System.Double.NegativeInfinity>.</xref:System.Double.NegativeInfinity> </xref:System.Double.PositiveInfinity>"
  overload: System.Windows.Rect.Empty*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Equals(System.Object)
  id: Equals(System.Object)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Equals(Object)
  nameWithType: Rect.Equals(Object)
  fullName: System.Windows.Rect.Equals(Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Wskazuje, czy określony obiekt jest taki sam, jak bieżący prostokąt."
  remarks: "Ta operacja testów dla obiekt równości.       W to porównanie dwóch wystąpień <xref:System.Double.NaN?displayProperty=fullName>są traktowane jako równe.</xref:System.Double.NaN?displayProperty=fullName>      > [!NOTE] > Pozycja prostokąta i wymiary są opisane przez <xref:System.Double>wartości.</xref:System.Double> Ponieważ <xref:System.Double>wartości mogą tracić dokładność, gdy wykonywane są operacje, porównanie dwóch wartości, które są logicznie równe może zakończyć się niepowodzeniem.</xref:System.Double>"
  example:
  - "The following example shows how to use the Equals method to determine if a rectangle is equal to a specified object.  \n  \n [!code-cs[RectExamples_snip#EqualsExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#equalsexample1_csharp)]"
  syntax:
    content: public override bool Equals (object o);
    parameters:
    - id: o
      type: System.Object
      description: "Obiekt do porównania z bieżącym prostokąta."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli <code> o </code> jest <xref href=&quot;System.Windows.Rect&quot;> </xref> i ma tę samą <> </> *> i <> </> *> wartości jako bieżący prostokąt; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Rect.Equals*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Equals(System.Windows.Rect)
  id: Equals(System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Equals(Rect)
  nameWithType: Rect.Equals(Rect)
  fullName: System.Windows.Rect.Equals(Rect)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Wskazuje, czy określony prostokąt jest taki sam, jak bieżący prostokąt."
  remarks: "Ta operacja testów dla obiekt równości.       W to porównanie dwóch wystąpień <xref:System.Double.NaN?displayProperty=fullName>są traktowane jako równe.</xref:System.Double.NaN?displayProperty=fullName>      > [!NOTE] > Pozycja prostokąta i wymiary są opisane przez <xref:System.Double>wartości.</xref:System.Double> Ponieważ <xref:System.Double>wartości mogą tracić dokładność, gdy wykonywane są operacje, porównanie dwóch wartości, które są logicznie równe może zakończyć się niepowodzeniem.</xref:System.Double>"
  example:
  - "The following example shows how to use the Equals method to determine if a rectangle is equal to a specified rectangle.  \n  \n [!code-cs[RectExamples_snip#EqualsExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#equalsexample1_csharp)]"
  syntax:
    content: public bool Equals (System.Windows.Rect value);
    parameters:
    - id: value
      type: System.Windows.Rect
      description: "Prostokąt do porównania z bieżącym prostokąta."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli określony prostokącie ma taką samą <> </> *> i <> </> *> wartości jako bieżący prostokąt; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Rect.Equals*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Equals(System.Windows.Rect,System.Windows.Rect)
  id: Equals(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Equals(Rect,Rect)
  nameWithType: Rect.Equals(Rect,Rect)
  fullName: System.Windows.Rect.Equals(Rect,Rect)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Wskazuje, czy określony prostokąty są takie same."
  remarks: "Ta operacja testów dla obiekt równości.       W to porównanie dwóch wystąpień <xref:System.Double.NaN?displayProperty=fullName>są traktowane jako równe.</xref:System.Double.NaN?displayProperty=fullName>      > [!NOTE] > Pozycja prostokąta i wymiary są opisane przez <xref:System.Double>wartości.</xref:System.Double> Ponieważ <xref:System.Double>wartości mogą tracić dokładność, gdy wykonywane są operacje, porównanie dwóch wartości, które są logicznie równe może zakończyć się niepowodzeniem.</xref:System.Double>"
  example:
  - "The following example shows how to use the Equals method to determine if one rectangle is equal to another.  \n  \n [!code-cs[RectExamples_snip#EqualsExample2_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#equalsexample2_csharp)]"
  syntax:
    content: public static bool Equals (System.Windows.Rect rect1, System.Windows.Rect rect2);
    parameters:
    - id: rect1
      type: System.Windows.Rect
      description: "Pierwszy prostokąta do porównania."
    - id: rect2
      type: System.Windows.Rect
      description: "Drugi prostokąta do porównania."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli prostokątów mają taki sam <> </> *> i <> </> *> wartości; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Rect.Equals*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.GetHashCode
  id: GetHashCode
  parent: System.Windows.Rect
  langs:
  - csharp
  name: GetHashCode()
  nameWithType: Rect.GetHashCode()
  fullName: System.Windows.Rect.GetHashCode()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Tworzy wartość skrótu dla prostokąta."
  remarks: "Ta metoda tworzy skrótu za pomocą <xref:System.Windows.Rect.X%2A>, <xref:System.Windows.Rect.Y%2A>, <xref:System.Windows.Rect.Width%2A>, i <xref:System.Windows.Rect.Height%2A>wartości właściwości.</xref:System.Windows.Rect.Height%2A> </xref:System.Windows.Rect.Width%2A> </xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.X%2A>"
  example:
  - "The following example shows how to use the GetHashCode method to get the hash code of a <xref:System.Windows.Rect>.  \n  \n [!code-cs[RectExamples_snip#GetHashCodeExample_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#gethashcodeexample_csharp)]"
  syntax:
    content: public override int GetHashCode ();
    parameters: []
    return:
      type: System.Int32
      description: "Wartość skrótu dla bieżącego <xref href=&quot;System.Windows.Rect&quot;> </xref> struktury."
  overload: System.Windows.Rect.GetHashCode*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Height
  id: Height
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Height
  nameWithType: Rect.Height
  fullName: System.Windows.Rect.Height
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Pobiera lub Ustawia wysokość prostokąta."
  remarks: "<xref:System.Windows.Rect.Empty%2A>Prostokąt ma wysokość <xref:System.Double.NegativeInfinity>.</xref:System.Double.NegativeInfinity> </xref:System.Windows.Rect.Empty%2A> <xref:System.Windows.Rect.Empty%2A>Prostokąt jest tylko do odczytu; nie można zmienić wysokość.</xref:System.Windows.Rect.Empty%2A>"
  example:
  - "The following example shows how to use a <xref:System.Windows.Rect> structure to specify the dimensions and location of a rectangle using XAML.  \n  \n [!code-cs[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/csharp/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.cs#rectexamplewholepage)]\n [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/visualbasic/geometriesmiscsnippets/rectexample.vb#rectexamplewholepage)]\n [!code-xml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/xaml/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.xaml#rectexamplewholepage)]  \n  \n The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public double Height { get; set; }
    return:
      type: System.Double
      description: "Liczba dodatnia, który reprezentuje wysokość prostokąta. Wartość domyślna to 0."
  overload: System.Windows.Rect.Height*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Wysokość ma ustawioną wartość ujemną."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Wysokość jest ustawiona na <xref:System.Windows.Rect.Empty*>prostokąta.</xref:System.Windows.Rect.Empty*>"
  platform:
  - net462
- uid: System.Windows.Rect.Inflate(System.Windows.Size)
  id: Inflate(System.Windows.Size)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Inflate(Size)
  nameWithType: Rect.Inflate(Size)
  fullName: System.Windows.Rect.Inflate(Size)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Rozwija prostokąt przy użyciu określonego <xref href=&quot;System.Windows.Size&quot;> </xref>, we wszystkich kierunkach."
  remarks: "<xref:System.Windows.Rect.Width%2A>Wynikowy prostokąta zwiększa się o dwa razy <xref:System.Windows.Size.Width%2A>określonego <xref:System.Windows.Size>struktury, ponieważ są zwiększony po lewej i prawej krawędzi prostokąta.</xref:System.Windows.Size> </xref:System.Windows.Size.Width%2A> </xref:System.Windows.Rect.Width%2A> Podobnie <xref:System.Windows.Rect.Height%2A>Wynikowy prostokąta zwiększa się o dwa razy <xref:System.Windows.Size.Height%2A>określonego <xref:System.Windows.Size>struktury.</xref:System.Windows.Size> </xref:System.Windows.Size.Height%2A> </xref:System.Windows.Rect.Height%2A>"
  example:
  - "The following example shows how to use the Inflate method to increase the size of a rectangle.  \n  \n [!code-cs[RectExamples_snip#InflateExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#inflateexample1_csharp)]"
  syntax:
    content: public void Inflate (System.Windows.Size size);
    parameters:
    - id: size
      type: System.Windows.Size
      description: "Określa, aby rozwinąć prostokąta. <xref href=&quot;System.Windows.Size&quot;> </xref> Struktury <> </> *> właściwość określa zwiększające prostokąta <> </> *> i <> </> *> właściwości. <xref href=&quot;System.Windows.Size&quot;> </xref> Struktury <> </> *> właściwość określa zwiększające prostokąta <> </> *> i <> </> *> właściwości."
  overload: System.Windows.Rect.Inflate*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Ta metoda jest wywoływana na &lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt; prostokąta."
  platform:
  - net462
- uid: System.Windows.Rect.Inflate(System.Double,System.Double)
  id: Inflate(System.Double,System.Double)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Inflate(Double,Double)
  nameWithType: Rect.Inflate(Double,Double)
  fullName: System.Windows.Rect.Inflate(Double,Double)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Powiększa się lub zmniejsza prostokąt przy użyciu określonej ilości szerokość i wysokość, we wszystkich kierunkach."
  remarks: "<xref:System.Windows.Rect.Width%2A>z wynikowy prostokąt jest zwiększenia lub zmniejszenia dwukrotnie przesunięcie określonej szerokości, ponieważ nie jest stosowana do lewej i prawej krawędzi prostokąta.</xref:System.Windows.Rect.Width%2A> Podobnie <xref:System.Windows.Rect.Height%2A>z wynikowy prostokąt jest zwiększenia lub zmniejszenia dwukrotnie określonej wysokości.</xref:System.Windows.Rect.Height%2A>       Jeśli określona szerokość i wysokość prostokąta zmniejszyć przez ponad bieżącym <xref:System.Windows.Rect.Width%2A>lub <xref:System.Windows.Rect.Height%2A>— nadanie prostokąta obszaru ujemna — prostokąt staje się <xref:System.Windows.Rect.Empty%2A>prostokąta.</xref:System.Windows.Rect.Empty%2A> </xref:System.Windows.Rect.Height%2A> </xref:System.Windows.Rect.Width%2A>"
  example:
  - "The following example shows how to use the Inflate method to change the size of a rectangle.  \n  \n [!code-cs[RectExamples_snip#InflateExample2_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#inflateexample2_csharp)]"
  syntax:
    content: public void Inflate (double width, double height);
    parameters:
    - id: width
      type: System.Double
      description: "Wartość, o której ma zostać zwiększania lub zmniejszania po lewej i prawej krawędzi prostokąta."
    - id: height
      type: System.Double
      description: "Wartość, o której ma zostać zwiększania lub zmniejszania górnej i dolnej krawędzi prostokąta."
  overload: System.Windows.Rect.Inflate*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Ta metoda jest wywoływana na &lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt; prostokąta."
  platform:
  - net462
- uid: System.Windows.Rect.Inflate(System.Windows.Rect,System.Windows.Size)
  id: Inflate(System.Windows.Rect,System.Windows.Size)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Inflate(Rect,Size)
  nameWithType: Rect.Inflate(Rect,Size)
  fullName: System.Windows.Rect.Inflate(Rect,Size)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Zwraca prostokąt będącą wynikiem rozszerzanie prostokąt określony przez określony <xref href=&quot;System.Windows.Size&quot;> </xref>, we wszystkich kierunkach."
  remarks: "<xref:System.Windows.Rect.Width%2A>Wynikowy prostokąta zwiększa się o dwa razy <xref:System.Windows.Size.Width%2A>określonego <xref:System.Windows.Size>struktury, ponieważ są zwiększony po lewej i prawej krawędzi prostokąta.</xref:System.Windows.Size> </xref:System.Windows.Size.Width%2A> </xref:System.Windows.Rect.Width%2A> Podobnie <xref:System.Windows.Rect.Height%2A>Wynikowy prostokąta zwiększa się o dwa razy <xref:System.Windows.Size.Height%2A>określonego <xref:System.Windows.Size>struktury.</xref:System.Windows.Size> </xref:System.Windows.Size.Height%2A> </xref:System.Windows.Rect.Height%2A>"
  example:
  - "The following example shows how to use the Inflate method to change the size of a rectangle.  \n  \n [!code-cs[RectExamples_snip#InflateExample3_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#inflateexample3_csharp)]"
  syntax:
    content: public static System.Windows.Rect Inflate (System.Windows.Rect rect, System.Windows.Size size);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "<xref href=&quot;System.Windows.Rect&quot;> </xref> Struktury do zmodyfikowania."
    - id: size
      type: System.Windows.Size
      description: "Określa, aby rozwinąć prostokąta. <xref href=&quot;System.Windows.Size&quot;> </xref> Struktury <> </> *> właściwość określa zwiększające prostokąta <> </> *> i <> </> *> właściwości. <xref href=&quot;System.Windows.Size&quot;> </xref> Struktury <> </> *> właściwość określa zwiększające prostokąta <> </> *> i <> </> *> właściwości."
    return:
      type: System.Windows.Rect
      description: "Wynikowa prostokąta."
  overload: System.Windows.Rect.Inflate*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>rect</code>jest &lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt; prostokąta."
  platform:
  - net462
- uid: System.Windows.Rect.Inflate(System.Windows.Rect,System.Double,System.Double)
  id: Inflate(System.Windows.Rect,System.Double,System.Double)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Inflate(Rect,Double,Double)
  nameWithType: Rect.Inflate(Rect,Double,Double)
  fullName: System.Windows.Rect.Inflate(Rect,Double,Double)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Tworzy prostokąt będącą wynikiem rozszerzania lub zmniejszanie prostokąt określony przez szerokość i wysokość podana, we wszystkich kierunkach."
  remarks: "<xref:System.Windows.Rect.Width%2A>z wynikowy prostokąt jest zwiększenia lub zmniejszenia dwukrotnie przesunięcie określonej szerokości, ponieważ nie jest stosowana do lewej i prawej krawędzi prostokąta.</xref:System.Windows.Rect.Width%2A> Podobnie <xref:System.Windows.Rect.Height%2A>z wynikowy prostokąt jest zwiększenia lub zmniejszenia dwukrotnie określonej wysokości.</xref:System.Windows.Rect.Height%2A>       Jeśli określonych modyfikatorów szerokości lub wysokości zmniejszyć prostokąt o ponad bieżącym <xref:System.Windows.Rect.Width%2A>lub <xref:System.Windows.Rect.Height%2A>— nadanie prostokąta obszaru ujemna — ta metoda zwraca <xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>.</xref:System.Windows.Rect.Empty%2A?displayProperty=fullName> </xref:System.Windows.Rect.Height%2A> </xref:System.Windows.Rect.Width%2A>"
  example:
  - "The following example shows how to use the Inflate method to change the size of a rectangle.  \n  \n [!code-cs[RectExamples_snip#InflateExample4_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#inflateexample4_csharp)]"
  syntax:
    content: public static System.Windows.Rect Inflate (System.Windows.Rect rect, double width, double height);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "<xref href=&quot;System.Windows.Rect&quot;> </xref> Struktury do zmodyfikowania."
    - id: width
      type: System.Double
      description: "Wartość, o której ma zostać zwiększania lub zmniejszania po lewej i prawej krawędzi prostokąta."
    - id: height
      type: System.Double
      description: "Wartość, o której ma zostać zwiększania lub zmniejszania górnej i dolnej krawędzi prostokąta."
    return:
      type: System.Windows.Rect
      description: "Wynikowa prostokąta."
  overload: System.Windows.Rect.Inflate*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>rect</code>jest &lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt; prostokąta."
  platform:
  - net462
- uid: System.Windows.Rect.Intersect(System.Windows.Rect)
  id: Intersect(System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Intersect(Rect)
  nameWithType: Rect.Intersect(Rect)
  fullName: System.Windows.Rect.Intersect(Rect)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Odnajduje przecięciu bieżący prostokąt i prostokąt określony i zapisuje wynik jako bieżący prostokąt."
  remarks: "Jeśli przecięcia nie istnieje, bieżący prostokąt staje się <xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>.</xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>"
  example:
  - "The following example shows how to use the Intersect method to find the intersection of two rectangles and store the result as a rectangle.  \n  \n [!code-cs[RectExamples_snip#IntersectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#intersectexample1_csharp)]"
  syntax:
    content: public void Intersect (System.Windows.Rect rect);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "Prostokąt intersect bieżący prostokąt."
  overload: System.Windows.Rect.Intersect*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Intersect(System.Windows.Rect,System.Windows.Rect)
  id: Intersect(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Intersect(Rect,Rect)
  nameWithType: Rect.Intersect(Rect,Rect)
  fullName: System.Windows.Rect.Intersect(Rect,Rect)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Zwraca część wspólną prostokąty określony."
  remarks: "Poniższy przykład pokazuje, jak Znajdź część wspólną dwóch prostokątów przy użyciu metody Intersect.       [!code-cs[RectExamples_snip #IntersectExample2_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#intersectexample2_csharp)]"
  syntax:
    content: public static System.Windows.Rect Intersect (System.Windows.Rect rect1, System.Windows.Rect rect2);
    parameters:
    - id: rect1
      type: System.Windows.Rect
      description: "Pierwszy prostokąta do porównania."
    - id: rect2
      type: System.Windows.Rect
      description: "Drugi prostokąta do porównania."
    return:
      type: System.Windows.Rect
      description: "Część wspólną dwóch prostokątów lub &lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt; Jeśli przecięcia nie istnieje."
  overload: System.Windows.Rect.Intersect*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.IntersectsWith(System.Windows.Rect)
  id: IntersectsWith(System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: IntersectsWith(Rect)
  nameWithType: Rect.IntersectsWith(Rect)
  fullName: System.Windows.Rect.IntersectsWith(Rect)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Wskazuje, czy określony prostokąt przecina bieżący prostokąt."
  remarks: ''
  example:
  - "The following example shows how to use the IntersectsWith method to determine if two rectangles intersect.  \n  \n [!code-cs[RectExamples_snip#IntersectsWithExample_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#intersectswithexample_csharp)]"
  syntax:
    content: public bool IntersectsWith (System.Windows.Rect rect);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "Prostokąt do sprawdzenia."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli określona prostokąt przecina bieżący prostokąt; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Rect.IntersectsWith*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.IsEmpty
  id: IsEmpty
  parent: System.Windows.Rect
  langs:
  - csharp
  name: IsEmpty
  nameWithType: Rect.IsEmpty
  fullName: System.Windows.Rect.IsEmpty
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Pobiera wartość wskazującą, czy jest prostokąt <xref:System.Windows.Rect.Empty*>prostokąta.</xref:System.Windows.Rect.Empty*>"
  remarks: "Ta właściwość nie należy używać do testowania zero obszaru; Prostokąt z obszaru zero nie jest <xref:System.Windows.Rect.Empty%2A>prostokąta.</xref:System.Windows.Rect.Empty%2A> Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Rect.Empty%2A>Właściwości.</xref:System.Windows.Rect.Empty%2A>"
  syntax:
    content: public bool IsEmpty { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli jest prostokąt <xref:System.Windows.Rect.Empty*>prostokąt; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.Rect.Empty*>"
  overload: System.Windows.Rect.IsEmpty*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Left
  id: Left
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Left
  nameWithType: Rect.Left
  fullName: System.Windows.Rect.Left
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Pobiera wartość osi x lewej krawędzi prostokąta."
  remarks: "Pobieranie tej właściwości jest odpowiednikiem pobierania <xref:System.Windows.Rect.X%2A>Właściwości.</xref:System.Windows.Rect.X%2A>"
  example:
  - "The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public double Left { get; }
    return:
      type: System.Double
      description: "Wartości na osi x lewej krawędzi prostokąta."
  overload: System.Windows.Rect.Left*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Location
  id: Location
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Location
  nameWithType: Rect.Location
  fullName: System.Windows.Rect.Location
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Pobiera lub Ustawia położenie górnego lewego rogu prostokąta."
  remarks: "Pozycja lewego górnego rogu prostokąta jest równe (<xref:System.Windows.Rect.X%2A>, <xref:System.Windows.Rect.Y%2A>).</xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.X%2A>"
  example:
  - "The following example shows how to use a <xref:System.Windows.Rect> structure to specify the dimensions and location of a rectangle using XAML.  \n  \n [!code-cs[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/csharp/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.cs#rectexamplewholepage)]\n [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/visualbasic/geometriesmiscsnippets/rectexample.vb#rectexamplewholepage)]\n [!code-xml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/xaml/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.xaml#rectexamplewholepage)]  \n  \n The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public System.Windows.Point Location { get; set; }
    return:
      type: System.Windows.Point
      description: "Pozycja lewego górnego rogu prostokąta. Wartość domyślna to (0, 0)."
  overload: System.Windows.Rect.Location*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Lokalizacja jest ustawiana na <xref:System.Windows.Rect.Empty*>prostokąta.</xref:System.Windows.Rect.Empty*>"
  platform:
  - net462
- uid: System.Windows.Rect.Offset(System.Windows.Vector)
  id: Offset(System.Windows.Vector)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Offset(Vector)
  nameWithType: Rect.Offset(Vector)
  fullName: System.Windows.Rect.Offset(Vector)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Przenosi prostokąt określony wektor."
  remarks: "Wywołanie tej metody na pusty prostokąt (<xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>) nie jest dozwolone.</xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>       Należy pamiętać, że wywołanie metody przesunięcie będzie miał wpływ tylko jeśli zmienisz <xref:System.Windows.Rect.X%2A>i <xref:System.Windows.Rect.Y%2A>właściwości bezpośrednio.</xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.X%2A> Ponieważ <xref:System.Windows.Rect>jest typem wartości, jeśli odwołanie <xref:System.Windows.Rect>obiektu za pomocą właściwości lub indeksatora, możesz uzyskać kopię obiektu, nie odwołania do obiektu.</xref:System.Windows.Rect> </xref:System.Windows.Rect> Jeśli spróbujesz zmienić <xref:System.Windows.Rect.X%2A>lub <xref:System.Windows.Rect.Y%2A>na właściwość lub indeksator odwołanie, występuje błąd kompilatora.</xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.X%2A> Podobnie wywołanie przesunięcie na właściwość lub indeksator nie spowoduje zmiany obiektu źródłowego.  Jeśli chcesz zmienić wartość <xref:System.Windows.Rect>który jest określany jako właściwość lub indeksator, Utwórz nową <xref:System.Windows.Rect>, zmodyfikuj jego pola, a następnie przypisz <xref:System.Windows.Rect>do właściwości lub indeksatora.</xref:System.Windows.Rect> </xref:System.Windows.Rect> </xref:System.Windows.Rect>"
  example:
  - "The following example shows how to use the Offset method to change the position of a rectangle.  \n  \n [!code-cs[RectExamples_snip#OffsetExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#offsetexample1_csharp)]"
  syntax:
    content: public void Offset (System.Windows.Vector offsetVector);
    parameters:
    - id: offsetVector
      type: System.Windows.Vector
      description: "Wektor określający kwoty poziome i pionowe prostokąt."
  overload: System.Windows.Rect.Offset*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Ta metoda jest wywoływana na &lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt; prostokąta."
  platform:
  - net462
- uid: System.Windows.Rect.Offset(System.Double,System.Double)
  id: Offset(System.Double,System.Double)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Offset(Double,Double)
  nameWithType: Rect.Offset(Double,Double)
  fullName: System.Windows.Rect.Offset(Double,Double)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Przesuwa prostokąt podana poziomie i w pionie."
  remarks: "Wywołanie tej metody na pusty prostokąt (<xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>) nie jest dozwolone.</xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>       Należy pamiętać, że wywołanie metody przesunięcie będzie miał wpływ tylko jeśli zmienisz <xref:System.Windows.Rect.X%2A>i <xref:System.Windows.Rect.Y%2A>właściwości bezpośrednio.</xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.X%2A> Ponieważ <xref:System.Windows.Rect>jest typem wartości, jeśli odwołanie <xref:System.Windows.Rect>obiektu za pomocą właściwości lub indeksatora, możesz uzyskać kopię obiektu, nie odwołania do obiektu.</xref:System.Windows.Rect> </xref:System.Windows.Rect> Jeśli spróbujesz zmienić <xref:System.Windows.Rect.X%2A>lub <xref:System.Windows.Rect.Y%2A>na właściwość lub indeksator odwołanie, występuje błąd kompilatora.</xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.X%2A> Podobnie wywołanie przesunięcie na właściwość lub indeksator nie spowoduje zmiany obiektu źródłowego.  Jeśli chcesz zmienić wartość <xref:System.Windows.Rect>który jest określany jako właściwość lub indeksator, Utwórz nową <xref:System.Windows.Rect>, zmodyfikuj jego pola, a następnie przypisz <xref:System.Windows.Rect>do właściwości lub indeksatora.</xref:System.Windows.Rect> </xref:System.Windows.Rect> </xref:System.Windows.Rect>"
  example:
  - "The following example shows how to use the Offset method to change the position of a rectangle.  \n  \n [!code-cs[RectExamples_snip#OffsetExample2_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#offsetexample2_csharp)]"
  syntax:
    content: public void Offset (double offsetX, double offsetY);
    parameters:
    - id: offsetX
      type: System.Double
      description: "Kwota można przesuwać w poziomie."
    - id: offsetY
      type: System.Double
      description: "Kwota można przesuwać w pionie."
  overload: System.Windows.Rect.Offset*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Ta metoda jest wywoływana na &lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt; prostokąta."
  platform:
  - net462
- uid: System.Windows.Rect.Offset(System.Windows.Rect,System.Windows.Vector)
  id: Offset(System.Windows.Rect,System.Windows.Vector)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Offset(Rect,Vector)
  nameWithType: Rect.Offset(Rect,Vector)
  fullName: System.Windows.Rect.Offset(Rect,Vector)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Zwraca prostokąt jest przesuwane z prostokąt określony przy użyciu określonego wektora."
  remarks: "Wywołanie tej metody za pomocą pusty prostokąt (<xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>) nie jest dozwolone.</xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>"
  example:
  - "The following example shows how to use the Offset method to change the position of a rectangle.  \n  \n [!code-cs[RectExamples_snip#OffsetExample3_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#offsetexample3_csharp)]"
  syntax:
    content: public static System.Windows.Rect Offset (System.Windows.Rect rect, System.Windows.Vector offsetVector);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "Prostokąt oryginalnego."
    - id: offsetVector
      type: System.Windows.Vector
      description: "Wektor określający przesunięć poziome i pionowe nowy prostokąt."
    return:
      type: System.Windows.Rect
      description: "Wynikowa prostokąta."
  overload: System.Windows.Rect.Offset*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>rect</code>jest &lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt;."
  platform:
  - net462
- uid: System.Windows.Rect.Offset(System.Windows.Rect,System.Double,System.Double)
  id: Offset(System.Windows.Rect,System.Double,System.Double)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Offset(Rect,Double,Double)
  nameWithType: Rect.Offset(Rect,Double,Double)
  fullName: System.Windows.Rect.Offset(Rect,Double,Double)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Zwraca prostokąt jest przesuwane z prostokąt określony przy użyciu określonej ilości poziomie i w pionie."
  remarks: "Wywołanie tej metody za pomocą pusty prostokąt (<xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>) nie jest dozwolone.</xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>"
  example:
  - "The following example shows how to use the Offset method to change the position of a rectangle.  \n  \n [!code-cs[RectExamples_snip#OffsetExample4_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#offsetexample4_csharp)]"
  syntax:
    content: public static System.Windows.Rect Offset (System.Windows.Rect rect, double offsetX, double offsetY);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "Przenieść prostokąt."
    - id: offsetX
      type: System.Double
      description: "Przesunięcie w poziomie dla nowego prostokąta."
    - id: offsetY
      type: System.Double
      description: "Przesunięcie w pionie nowe prostokąta."
    return:
      type: System.Windows.Rect
      description: "Wynikowa prostokąta."
  overload: System.Windows.Rect.Offset*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>rect</code>jest &lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt;."
  platform:
  - net462
- uid: System.Windows.Rect.op_Equality(System.Windows.Rect,System.Windows.Rect)
  id: op_Equality(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: op_Equality(Rect,Rect)
  nameWithType: Rect.op_Equality(Rect,Rect)
  fullName: System.Windows.Rect.op_Equality(Rect,Rect)
  type: Operator
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Porównuje dwa prostokąty dokładnie pod kątem równości."
  remarks: "Ta operacja testów dla obiekt równości.       W to porównanie dwóch wystąpień <xref:System.Double.NaN?displayProperty=fullName>są traktowane jako równe.</xref:System.Double.NaN?displayProperty=fullName>      > [!NOTE] > Pozycja prostokąta i wymiary są opisane przez <xref:System.Double>wartości.</xref:System.Double> Ponieważ <xref:System.Double>wartości mogą tracić dokładność, gdy wykonywane są operacje, porównanie dwóch wartości, które są logicznie równe może zakończyć się niepowodzeniem.</xref:System.Double>"
  example:
  - "The following example shows how to use the Equality operator to determine if two rectangles are exactly equal.  \n  \n [!code-cs[RectExamples_snip#OverloadedEqualityOperatorExample](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#overloadedequalityoperatorexample)]\n [!code-vb[RectExamples_snip#OverloadedEqualityOperatorExample](~/add/codesnippet/visualbasic/rectexamples_snip/rectexample.vb#overloadedequalityoperatorexample)]"
  syntax:
    content: public static bool op_Equality (System.Windows.Rect rect1, System.Windows.Rect rect2);
    parameters:
    - id: rect1
      type: System.Windows.Rect
      description: "Pierwszy prostokąta do porównania."
    - id: rect2
      type: System.Windows.Rect
      description: "Drugi prostokąta do porównania."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli prostokątów mają taki sam <> </> *> i <> </> *> wartości; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Rect.op_Equality*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.op_Inequality(System.Windows.Rect,System.Windows.Rect)
  id: op_Inequality(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: op_Inequality(Rect,Rect)
  nameWithType: Rect.op_Inequality(Rect,Rect)
  fullName: System.Windows.Rect.op_Inequality(Rect,Rect)
  type: Operator
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Porównuje dwa prostokąty pod kątem nierówności."
  remarks: "Ta operacja testów dla obiekt nierówności.       W to porównanie dwóch wystąpień <xref:System.Double.NaN?displayProperty=fullName>są traktowane jako równe.</xref:System.Double.NaN?displayProperty=fullName>      > [!NOTE] > Pozycja prostokąta i wymiary są opisane przez <xref:System.Double>wartości.</xref:System.Double> Ponieważ <xref:System.Double>wartości mogą tracić dokładność, gdy wykonywane są operacje, porównanie dwóch wartości, które są logicznie równe może zakończyć się niepowodzeniem.</xref:System.Double>"
  example:
  - "The following example shows how to use the Inequality operator to determine if two rectangles are not exactly equal.  \n  \n [!code-cs[RectExamples_snip#OverloadedInequalityOperatorExample](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#overloadedinequalityoperatorexample)]\n [!code-vb[RectExamples_snip#OverloadedInequalityOperatorExample](~/add/codesnippet/visualbasic/rectexamples_snip/rectexample.vb#overloadedinequalityoperatorexample)]"
  syntax:
    content: public static bool op_Inequality (System.Windows.Rect rect1, System.Windows.Rect rect2);
    parameters:
    - id: rect1
      type: System.Windows.Rect
      description: "Pierwszy prostokąta do porównania."
    - id: rect2
      type: System.Windows.Rect
      description: "Drugi prostokąta do porównania."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli prostokątów nie mają takie same <> </> *> i <> </> *> wartości; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Rect.op_Inequality*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Parse(System.String)
  id: Parse(System.String)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Parse(String)
  nameWithType: Rect.Parse(String)
  fullName: System.Windows.Rect.Parse(String)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Tworzy nowy prostokąt z reprezentacji określonego ciągu."
  remarks: ''
  example:
  - "The following example shows how to use the Parse method to convert a string representation of a rectangle into a <xref:System.Windows.Rect> structure.  \n  \n [!code-cs[RectExamples_snip#ParseExample](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#parseexample)]\n [!code-vb[RectExamples_snip#ParseExample](~/add/codesnippet/visualbasic/rectexamples_snip/rectexample.vb#parseexample)]"
  syntax:
    content: public static System.Windows.Rect Parse (string source);
    parameters:
    - id: source
      type: System.String
      description: "Reprezentacja ciągu prostokąta w formularzu &quot;x, y, szerokość, wysokość&quot;."
    return:
      type: System.Windows.Rect
      description: "Wynikowa prostokąta."
  overload: System.Windows.Rect.Parse*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Right
  id: Right
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Right
  nameWithType: Rect.Right
  fullName: System.Windows.Rect.Right
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Pobiera wartość osi x z prawej krawędzi prostokąta."
  remarks: "Wartość osi x po prawej stronie prostokąta jest równa sumie <xref:System.Windows.Rect.X%2A>i <xref:System.Windows.Rect.Width%2A>Właściwości.</xref:System.Windows.Rect.Width%2A> </xref:System.Windows.Rect.X%2A>"
  example:
  - "The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public double Right { get; }
    return:
      type: System.Double
      description: "Wartości na osi x prawej krawędzi prostokąta."
  overload: System.Windows.Rect.Right*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Scale(System.Double,System.Double)
  id: Scale(System.Double,System.Double)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Scale(Double,Double)
  nameWithType: Rect.Scale(Double,Double)
  fullName: System.Windows.Rect.Scale(Double,Double)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Mnoży przez określony rozmiar bieżący prostokąt x i y wartości."
  remarks: ''
  example:
  - "The following example shows how to use the Scale method to multiply the width and height of a rectangle by the specified amount.  \n  \n [!code-cs[RectExamples_snip#ScaleExample_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#scaleexample_csharp)]"
  syntax:
    content: public void Scale (double scaleX, double scaleY);
    parameters:
    - id: scaleX
      type: System.Double
      description: "Współczynnik skali w kierunku x."
    - id: scaleY
      type: System.Double
      description: "Współczynnik skali w kierunku y."
  overload: System.Windows.Rect.Scale*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Size
  id: Size
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Size
  nameWithType: Rect.Size
  fullName: System.Windows.Rect.Size
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Pobiera lub ustawia szerokość i wysokość prostokąta."
  remarks: ''
  example:
  - "The following example shows how to use a <xref:System.Windows.Rect> structure to specify the dimensions and location of a rectangle using XAML.  \n  \n [!code-cs[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/csharp/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.cs#rectexamplewholepage)]\n [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/visualbasic/geometriesmiscsnippets/rectexample.vb#rectexamplewholepage)]\n [!code-xml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/xaml/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.xaml#rectexamplewholepage)]  \n  \n The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public System.Windows.Size Size { get; set; }
    return:
      type: System.Windows.Size
      description: "A <xref href=&quot;System.Windows.Size&quot;> </xref> struktury, która określa szerokość i wysokość prostokąta."
  overload: System.Windows.Rect.Size*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Rozmiar jest ustawiony na <xref:System.Windows.Rect.Empty*>prostokąta.</xref:System.Windows.Rect.Empty*>"
  platform:
  - net462
- uid: System.Windows.Rect.System#IFormattable#ToString(System.String,System.IFormatProvider)
  id: System#IFormattable#ToString(System.String,System.IFormatProvider)
  isEii: true
  parent: System.Windows.Rect
  langs:
  - csharp
  name: System.IFormattable.ToString(String,IFormatProvider)
  nameWithType: Rect.System.IFormattable.ToString(String,IFormatProvider)
  fullName: System.Windows.Rect.System.IFormattable.ToString(String,IFormatProvider)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Formatuje wartość bieżącego wystąpienia przy użyciu określonego formatu."
  remarks: "Ten element jest jawną implementacją elementu interfejsu. Można go używać tylko wtedy, gdy <xref:System.Windows.Rect>wystąpienia jest rzutowane na <xref:System.IFormattable>interfejsu.</xref:System.IFormattable> </xref:System.Windows.Rect>"
  syntax:
    content: string IFormattable.ToString (string format, IFormatProvider provider);
    parameters:
    - id: format
      type: System.String
      description: "Format, który ma być używany.       - lub - odwołanie o wartości null (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref> w języku Visual Basic) Aby użyć domyślnego formatu zdefiniowany dla typu <xref:System.IFormattable>implementacji.</xref:System.IFormattable>"
    - id: provider
      type: System.IFormatProvider
      description: "Dostawcę, który ma być używany do formatowania wartości.       - lub - odwołanie o wartości null (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref> w języku Visual Basic) można uzyskać informacji formatujące z bieżących ustawień regionalnych systemu operacyjnego."
    return:
      type: System.String
      description: "Reprezentacja ciągu prostokąta."
  overload: System.Windows.Rect.System#IFormattable#ToString*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Top
  id: Top
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Top
  nameWithType: Rect.Top
  fullName: System.Windows.Rect.Top
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Pobiera pozycję osi y górnej krawędzi prostokąta."
  remarks: "Pobieranie tej właściwości jest odpowiednikiem pobierania <xref:System.Windows.Rect.Y%2A>Właściwości.</xref:System.Windows.Rect.Y%2A>"
  example:
  - "The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public double Top { get; }
    return:
      type: System.Double
      description: "Położenie y górnej krawędzi prostokąta."
  overload: System.Windows.Rect.Top*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.TopLeft
  id: TopLeft
  parent: System.Windows.Rect
  langs:
  - csharp
  name: TopLeft
  nameWithType: Rect.TopLeft
  fullName: System.Windows.Rect.TopLeft
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Pobiera pozycję górnego lewego rogu prostokąta."
  remarks: "Pozycja lewego górnego rogu prostokąta jest równe (<xref:System.Windows.Rect.X%2A>, <xref:System.Windows.Rect.Y%2A>).</xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.X%2A>"
  example:
  - "The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public System.Windows.Point TopLeft { get; }
    return:
      type: System.Windows.Point
      description: "Pozycja lewego górnego rogu prostokąta."
  overload: System.Windows.Rect.TopLeft*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.TopRight
  id: TopRight
  parent: System.Windows.Rect
  langs:
  - csharp
  name: TopRight
  nameWithType: Rect.TopRight
  fullName: System.Windows.Rect.TopRight
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Pobiera pozycję prawym górnym rogu prostokąta."
  remarks: "Pozycja w prawym górnym rogu prostokąta jest równa (<xref:System.Windows.Rect.X%2A> + <xref:System.Windows.Rect.Width%2A>, <xref:System.Windows.Rect.Y%2A>).</xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.Width%2A> </xref:System.Windows.Rect.X%2A>"
  example:
  - "The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public System.Windows.Point TopRight { get; }
    return:
      type: System.Windows.Point
      description: "Pozycja w prawym górnym rogu prostokąta."
  overload: System.Windows.Rect.TopRight*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.ToString
  id: ToString
  parent: System.Windows.Rect
  langs:
  - csharp
  name: ToString()
  nameWithType: Rect.ToString()
  fullName: System.Windows.Rect.ToString()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Zwraca reprezentację ciągu prostokąta."
  remarks: ''
  example:
  - "The following example shows how to use the ToString method to get a string representation of a <xref:System.Windows.Rect> structure.  \n  \n [!code-cs[RectExamples_snip#ToStringExample_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#tostringexample_csharp)]"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: 'Reprezentacja ciągu bieżącego prostokąta. The string has the following form: &quot;<>*>,<>*>,<>*>,<>*>&quot;.'
  overload: System.Windows.Rect.ToString*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.ToString(System.IFormatProvider)
  id: ToString(System.IFormatProvider)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: ToString(IFormatProvider)
  nameWithType: Rect.ToString(IFormatProvider)
  fullName: System.Windows.Rect.ToString(IFormatProvider)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Zwraca reprezentację ciągu prostokąt przy użyciu dostawcy określonego formatu."
  syntax:
    content: public string ToString (IFormatProvider provider);
    parameters:
    - id: provider
      type: System.IFormatProvider
      description: "Informacje dotyczące formatowania specyficzne dla kultury."
    return:
      type: System.String
      description: "Reprezentacja ciągu bieżącego prostokąta, który jest określany przez dostawcę określonego formatu."
  overload: System.Windows.Rect.ToString*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Transform(System.Windows.Media.Matrix)
  id: Transform(System.Windows.Media.Matrix)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Transform(Matrix)
  nameWithType: Rect.Transform(Matrix)
  fullName: System.Windows.Rect.Transform(Matrix)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Przekształca prostokąt za pomocą określonej macierzy."
  remarks: ''
  example:
  - "The following example shows how to use the Transform method to transform a <xref:System.Windows.Rect> structure by using a <xref:System.Windows.Media.Matrix>.  \n  \n [!code-cs[RectExamples_snip#TransformExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#transformexample1_csharp)]"
  syntax:
    content: public void Transform (System.Windows.Media.Matrix matrix);
    parameters:
    - id: matrix
      type: System.Windows.Media.Matrix
      description: "Macierz określa przekształcenie do zastosowania."
  overload: System.Windows.Rect.Transform*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Transform(System.Windows.Rect,System.Windows.Media.Matrix)
  id: Transform(System.Windows.Rect,System.Windows.Media.Matrix)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Transform(Rect,Matrix)
  nameWithType: Rect.Transform(Rect,Matrix)
  fullName: System.Windows.Rect.Transform(Rect,Matrix)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Zwraca prostokąt będącą wynikiem zastosowania wskazana macierz matrix na prostokąt określony."
  remarks: ''
  example:
  - "The following example shows how to use the Transform method to create a new <xref:System.Windows.Rect> structure that results from applying a <xref:System.Windows.Media.Matrix> to an existing rectangle.  \n  \n [!code-cs[RectExamples_snip#TransformExample2_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#transformexample2_csharp)]"
  syntax:
    content: public static System.Windows.Rect Transform (System.Windows.Rect rect, System.Windows.Media.Matrix matrix);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "Prostokąt, który stanowi podstawę do transformacji."
    - id: matrix
      type: System.Windows.Media.Matrix
      description: "Macierz określa przekształcenie do zastosowania."
    return:
      type: System.Windows.Rect
      description: "Prostokąt będącą wynikiem operacji."
  overload: System.Windows.Rect.Transform*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Union(System.Windows.Point)
  id: Union(System.Windows.Point)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Union(Point)
  nameWithType: Rect.Union(Point)
  fullName: System.Windows.Rect.Union(Point)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Rozwija bieżący prostokąt wystarczająco dokładnie zawierają określony punkt."
  remarks: ''
  example:
  - "The following example shows how to use the Union method to expand the current rectangle exactly enough to contain a given <xref:System.Windows.Point>.  \n  \n [!code-cs[RectExamples_snip#UnionExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#unionexample1_csharp)]"
  syntax:
    content: public void Union (System.Windows.Point point);
    parameters:
    - id: point
      type: System.Windows.Point
      description: "Punkt do uwzględnienia."
  overload: System.Windows.Rect.Union*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Union(System.Windows.Rect)
  id: Union(System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Union(Rect)
  nameWithType: Rect.Union(Rect)
  fullName: System.Windows.Rect.Union(Rect)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Rozwija bieżący prostokąt wystarczająco dokładnie zawierać określonego prostokąta."
  remarks: ''
  example:
  - "The following example shows how to use the Union method to expand the current rectangle exactly enough to contain the specified rectangle.  \n  \n [!code-cs[RectExamples_snip#UnionExample2_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#unionexample2_csharp)]"
  syntax:
    content: public void Union (System.Windows.Rect rect);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "Prostokąt do uwzględnienia."
  overload: System.Windows.Rect.Union*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Union(System.Windows.Rect,System.Windows.Point)
  id: Union(System.Windows.Rect,System.Windows.Point)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Union(Rect,Point)
  nameWithType: Rect.Union(Rect,Point)
  fullName: System.Windows.Rect.Union(Rect,Point)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Tworzy prostokąt jest dokładnie wystarczająco duże, aby dołączyć prostokąt określony a określonym punktem."
  remarks: ''
  example:
  - "The following example shows how to use the Union method to create a rectangle that is exactly large enough to contain a given rectangle and a given <xref:System.Windows.Point>.  \n  \n [!code-cs[RectExamples_snip#UnionExample3_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#unionexample3_csharp)]"
  syntax:
    content: public static System.Windows.Rect Union (System.Windows.Rect rect, System.Windows.Point point);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "Prostokąt do uwzględnienia."
    - id: point
      type: System.Windows.Point
      description: "Punkt do uwzględnienia."
    return:
      type: System.Windows.Rect
      description: "Prostokąt jest dokładnie wystarczająco duży, aby zawierać prostokąt określony a określonym punktem."
  overload: System.Windows.Rect.Union*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Union(System.Windows.Rect,System.Windows.Rect)
  id: Union(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Union(Rect,Rect)
  nameWithType: Rect.Union(Rect,Rect)
  fullName: System.Windows.Rect.Union(Rect,Rect)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Tworzy prostokąt dokładnie dostatecznie dużego zawiera dwa prostokąty określony."
  remarks: ''
  example:
  - "The following example shows how to use the Union method to create a rectangle that is exactly large enough to contain two given rectangles.  \n  \n [!code-cs[RectExamples_snip#UnionExample4_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#unionexample4_csharp)]"
  syntax:
    content: public static System.Windows.Rect Union (System.Windows.Rect rect1, System.Windows.Rect rect2);
    parameters:
    - id: rect1
      type: System.Windows.Rect
      description: "Pierwszy prostokąta do uwzględnienia."
    - id: rect2
      type: System.Windows.Rect
      description: "Drugi prostokąta do uwzględnienia."
    return:
      type: System.Windows.Rect
      description: "Wynikowa prostokąta."
  overload: System.Windows.Rect.Union*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Width
  id: Width
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Width
  nameWithType: Rect.Width
  fullName: System.Windows.Rect.Width
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Pobiera lub ustawia szerokość prostokąta."
  remarks: "<xref:System.Windows.Rect.Empty%2A>Prostokąt ma szerokość <xref:System.Double.NegativeInfinity>.</xref:System.Double.NegativeInfinity> </xref:System.Windows.Rect.Empty%2A> <xref:System.Windows.Rect.Empty%2A>Prostokąt jest tylko do odczytu; nie można zmienić jego szerokości.</xref:System.Windows.Rect.Empty%2A>"
  example:
  - "The following example shows how to use a <xref:System.Windows.Rect> structure to specify the dimensions and location of a rectangle using XAML.  \n  \n [!code-cs[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/csharp/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.cs#rectexamplewholepage)]\n [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/visualbasic/geometriesmiscsnippets/rectexample.vb#rectexamplewholepage)]\n [!code-xml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/xaml/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.xaml#rectexamplewholepage)]  \n  \n The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public double Width { get; set; }
    return:
      type: System.Double
      description: "Liczba dodatnia, który reprezentuje szerokość prostokąta. Wartość domyślna to 0."
  overload: System.Windows.Rect.Width*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Szerokość ma ustawioną wartość ujemną."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Szerokość jest ustawiona na <xref:System.Windows.Rect.Empty*>prostokąta.</xref:System.Windows.Rect.Empty*>"
  platform:
  - net462
- uid: System.Windows.Rect.X
  id: X
  parent: System.Windows.Rect
  langs:
  - csharp
  name: X
  nameWithType: Rect.X
  fullName: System.Windows.Rect.X
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Pobiera lub ustawia wartości osi x lewej krawędzi prostokąta."
  remarks: "Pobieranie tej właściwości jest odpowiednikiem pobierania <xref:System.Windows.Rect.Left%2A>Właściwości.</xref:System.Windows.Rect.Left%2A>"
  example:
  - "The following example shows how to use a <xref:System.Windows.Rect> structure to specify the dimensions and location of a rectangle using XAML.  \n  \n [!code-cs[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/csharp/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.cs#rectexamplewholepage)]\n [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/visualbasic/geometriesmiscsnippets/rectexample.vb#rectexamplewholepage)]\n [!code-xml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/xaml/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.xaml#rectexamplewholepage)]  \n  \n The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public double X { get; set; }
    return:
      type: System.Double
      description: "Wartości na osi x lewej krawędzi prostokąta."
  overload: System.Windows.Rect.X*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "X jest ustawiona na <xref:System.Windows.Rect.Empty*>prostokąta.</xref:System.Windows.Rect.Empty*>"
  platform:
  - net462
- uid: System.Windows.Rect.Y
  id: Y
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Y
  nameWithType: Rect.Y
  fullName: System.Windows.Rect.Y
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Pobiera lub ustawia wartość y górnej krawędzi prostokąta."
  remarks: "Pobieranie tej właściwości jest odpowiednikiem pobierania <xref:System.Windows.Rect.Top%2A>Właściwości.</xref:System.Windows.Rect.Top%2A>"
  example:
  - "The following example shows how to use a <xref:System.Windows.Rect> structure to specify the dimensions and location of a rectangle using XAML.  \n  \n [!code-cs[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/csharp/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.cs#rectexamplewholepage)]\n [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/visualbasic/geometriesmiscsnippets/rectexample.vb#rectexamplewholepage)]\n [!code-xml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/xaml/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.xaml#rectexamplewholepage)]  \n  \n The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public double Y { get; set; }
    return:
      type: System.Double
      description: "Wartość osi y górnej krawędzi prostokąta."
  overload: System.Windows.Rect.Y*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Ustawiono Y <xref:System.Windows.Rect.Empty*>prostokąta.</xref:System.Windows.Rect.Empty*>"
  platform:
  - net462
references:
- uid: System.ValueType
  isExternal: false
  name: System.ValueType
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Windows.Rect.#ctor(System.Windows.Size)
  parent: System.Windows.Rect
  isExternal: false
  name: Rect(Size)
  nameWithType: Rect.Rect(Size)
  fullName: System.Windows.Rect.Rect(Size)
- uid: System.Windows.Size
  parent: System.Windows
  isExternal: false
  name: Size
  nameWithType: Size
  fullName: System.Windows.Size
- uid: System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Point)
  parent: System.Windows.Rect
  isExternal: false
  name: Rect(Point,Point)
  nameWithType: Rect.Rect(Point,Point)
  fullName: System.Windows.Rect.Rect(Point,Point)
- uid: System.Windows.Point
  parent: System.Windows
  isExternal: false
  name: Point
  nameWithType: Point
  fullName: System.Windows.Point
- uid: System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Size)
  parent: System.Windows.Rect
  isExternal: false
  name: Rect(Point,Size)
  nameWithType: Rect.Rect(Point,Size)
  fullName: System.Windows.Rect.Rect(Point,Size)
- uid: System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Vector)
  parent: System.Windows.Rect
  isExternal: false
  name: Rect(Point,Vector)
  nameWithType: Rect.Rect(Point,Vector)
  fullName: System.Windows.Rect.Rect(Point,Vector)
- uid: System.Windows.Vector
  parent: System.Windows
  isExternal: false
  name: Vector
  nameWithType: Vector
  fullName: System.Windows.Vector
- uid: System.Windows.Rect.#ctor(System.Double,System.Double,System.Double,System.Double)
  parent: System.Windows.Rect
  isExternal: false
  name: Rect(Double,Double,Double,Double)
  nameWithType: Rect.Rect(Double,Double,Double,Double)
  fullName: System.Windows.Rect.Rect(Double,Double,Double,Double)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Windows.Rect.Bottom
  parent: System.Windows.Rect
  isExternal: false
  name: Bottom
  nameWithType: Rect.Bottom
  fullName: System.Windows.Rect.Bottom
- uid: System.Windows.Rect.BottomLeft
  parent: System.Windows.Rect
  isExternal: false
  name: BottomLeft
  nameWithType: Rect.BottomLeft
  fullName: System.Windows.Rect.BottomLeft
- uid: System.Windows.Rect.BottomRight
  parent: System.Windows.Rect
  isExternal: false
  name: BottomRight
  nameWithType: Rect.BottomRight
  fullName: System.Windows.Rect.BottomRight
- uid: System.Windows.Rect.Contains(System.Windows.Point)
  parent: System.Windows.Rect
  isExternal: false
  name: Contains(Point)
  nameWithType: Rect.Contains(Point)
  fullName: System.Windows.Rect.Contains(Point)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Rect.Contains(System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: Contains(Rect)
  nameWithType: Rect.Contains(Rect)
  fullName: System.Windows.Rect.Contains(Rect)
- uid: System.Windows.Rect
  parent: System.Windows
  isExternal: false
  name: Rect
  nameWithType: Rect
  fullName: System.Windows.Rect
- uid: System.Windows.Rect.Contains(System.Double,System.Double)
  parent: System.Windows.Rect
  isExternal: false
  name: Contains(Double,Double)
  nameWithType: Rect.Contains(Double,Double)
  fullName: System.Windows.Rect.Contains(Double,Double)
- uid: System.Windows.Rect.Empty
  parent: System.Windows.Rect
  isExternal: false
  name: Empty
  nameWithType: Rect.Empty
  fullName: System.Windows.Rect.Empty
- uid: System.Windows.Rect.Equals(System.Object)
  parent: System.Windows.Rect
  isExternal: false
  name: Equals(Object)
  nameWithType: Rect.Equals(Object)
  fullName: System.Windows.Rect.Equals(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.Rect.Equals(System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: Equals(Rect)
  nameWithType: Rect.Equals(Rect)
  fullName: System.Windows.Rect.Equals(Rect)
- uid: System.Windows.Rect.Equals(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: Equals(Rect,Rect)
  nameWithType: Rect.Equals(Rect,Rect)
  fullName: System.Windows.Rect.Equals(Rect,Rect)
- uid: System.Windows.Rect.GetHashCode
  parent: System.Windows.Rect
  isExternal: false
  name: GetHashCode()
  nameWithType: Rect.GetHashCode()
  fullName: System.Windows.Rect.GetHashCode()
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.Rect.Height
  parent: System.Windows.Rect
  isExternal: false
  name: Height
  nameWithType: Rect.Height
  fullName: System.Windows.Rect.Height
- uid: System.Windows.Rect.Inflate(System.Windows.Size)
  parent: System.Windows.Rect
  isExternal: false
  name: Inflate(Size)
  nameWithType: Rect.Inflate(Size)
  fullName: System.Windows.Rect.Inflate(Size)
- uid: System.Windows.Rect.Inflate(System.Double,System.Double)
  parent: System.Windows.Rect
  isExternal: false
  name: Inflate(Double,Double)
  nameWithType: Rect.Inflate(Double,Double)
  fullName: System.Windows.Rect.Inflate(Double,Double)
- uid: System.Windows.Rect.Inflate(System.Windows.Rect,System.Windows.Size)
  parent: System.Windows.Rect
  isExternal: false
  name: Inflate(Rect,Size)
  nameWithType: Rect.Inflate(Rect,Size)
  fullName: System.Windows.Rect.Inflate(Rect,Size)
- uid: System.Windows.Rect.Inflate(System.Windows.Rect,System.Double,System.Double)
  parent: System.Windows.Rect
  isExternal: false
  name: Inflate(Rect,Double,Double)
  nameWithType: Rect.Inflate(Rect,Double,Double)
  fullName: System.Windows.Rect.Inflate(Rect,Double,Double)
- uid: System.Windows.Rect.Intersect(System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: Intersect(Rect)
  nameWithType: Rect.Intersect(Rect)
  fullName: System.Windows.Rect.Intersect(Rect)
- uid: System.Windows.Rect.Intersect(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: Intersect(Rect,Rect)
  nameWithType: Rect.Intersect(Rect,Rect)
  fullName: System.Windows.Rect.Intersect(Rect,Rect)
- uid: System.Windows.Rect.IntersectsWith(System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: IntersectsWith(Rect)
  nameWithType: Rect.IntersectsWith(Rect)
  fullName: System.Windows.Rect.IntersectsWith(Rect)
- uid: System.Windows.Rect.IsEmpty
  parent: System.Windows.Rect
  isExternal: false
  name: IsEmpty
  nameWithType: Rect.IsEmpty
  fullName: System.Windows.Rect.IsEmpty
- uid: System.Windows.Rect.Left
  parent: System.Windows.Rect
  isExternal: false
  name: Left
  nameWithType: Rect.Left
  fullName: System.Windows.Rect.Left
- uid: System.Windows.Rect.Location
  parent: System.Windows.Rect
  isExternal: false
  name: Location
  nameWithType: Rect.Location
  fullName: System.Windows.Rect.Location
- uid: System.Windows.Rect.Offset(System.Windows.Vector)
  parent: System.Windows.Rect
  isExternal: false
  name: Offset(Vector)
  nameWithType: Rect.Offset(Vector)
  fullName: System.Windows.Rect.Offset(Vector)
- uid: System.Windows.Rect.Offset(System.Double,System.Double)
  parent: System.Windows.Rect
  isExternal: false
  name: Offset(Double,Double)
  nameWithType: Rect.Offset(Double,Double)
  fullName: System.Windows.Rect.Offset(Double,Double)
- uid: System.Windows.Rect.Offset(System.Windows.Rect,System.Windows.Vector)
  parent: System.Windows.Rect
  isExternal: false
  name: Offset(Rect,Vector)
  nameWithType: Rect.Offset(Rect,Vector)
  fullName: System.Windows.Rect.Offset(Rect,Vector)
- uid: System.Windows.Rect.Offset(System.Windows.Rect,System.Double,System.Double)
  parent: System.Windows.Rect
  isExternal: false
  name: Offset(Rect,Double,Double)
  nameWithType: Rect.Offset(Rect,Double,Double)
  fullName: System.Windows.Rect.Offset(Rect,Double,Double)
- uid: System.Windows.Rect.op_Equality(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: op_Equality(Rect,Rect)
  nameWithType: Rect.op_Equality(Rect,Rect)
  fullName: System.Windows.Rect.op_Equality(Rect,Rect)
- uid: System.Windows.Rect.op_Inequality(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: op_Inequality(Rect,Rect)
  nameWithType: Rect.op_Inequality(Rect,Rect)
  fullName: System.Windows.Rect.op_Inequality(Rect,Rect)
- uid: System.Windows.Rect.Parse(System.String)
  parent: System.Windows.Rect
  isExternal: false
  name: Parse(String)
  nameWithType: Rect.Parse(String)
  fullName: System.Windows.Rect.Parse(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.Rect.Right
  parent: System.Windows.Rect
  isExternal: false
  name: Right
  nameWithType: Rect.Right
  fullName: System.Windows.Rect.Right
- uid: System.Windows.Rect.Scale(System.Double,System.Double)
  parent: System.Windows.Rect
  isExternal: false
  name: Scale(Double,Double)
  nameWithType: Rect.Scale(Double,Double)
  fullName: System.Windows.Rect.Scale(Double,Double)
- uid: System.Windows.Rect.Size
  parent: System.Windows.Rect
  isExternal: false
  name: Size
  nameWithType: Rect.Size
  fullName: System.Windows.Rect.Size
- uid: System.Windows.Rect.System#IFormattable#ToString(System.String,System.IFormatProvider)
  parent: System.Windows.Rect
  isExternal: false
  name: System.IFormattable.ToString(String,IFormatProvider)
  nameWithType: Rect.System.IFormattable.ToString(String,IFormatProvider)
  fullName: System.Windows.Rect.System.IFormattable.ToString(String,IFormatProvider)
- uid: System.IFormatProvider
  parent: System
  isExternal: true
  name: IFormatProvider
  nameWithType: IFormatProvider
  fullName: System.IFormatProvider
- uid: System.Windows.Rect.Top
  parent: System.Windows.Rect
  isExternal: false
  name: Top
  nameWithType: Rect.Top
  fullName: System.Windows.Rect.Top
- uid: System.Windows.Rect.TopLeft
  parent: System.Windows.Rect
  isExternal: false
  name: TopLeft
  nameWithType: Rect.TopLeft
  fullName: System.Windows.Rect.TopLeft
- uid: System.Windows.Rect.TopRight
  parent: System.Windows.Rect
  isExternal: false
  name: TopRight
  nameWithType: Rect.TopRight
  fullName: System.Windows.Rect.TopRight
- uid: System.Windows.Rect.ToString
  parent: System.Windows.Rect
  isExternal: false
  name: ToString()
  nameWithType: Rect.ToString()
  fullName: System.Windows.Rect.ToString()
- uid: System.Windows.Rect.ToString(System.IFormatProvider)
  parent: System.Windows.Rect
  isExternal: false
  name: ToString(IFormatProvider)
  nameWithType: Rect.ToString(IFormatProvider)
  fullName: System.Windows.Rect.ToString(IFormatProvider)
- uid: System.Windows.Rect.Transform(System.Windows.Media.Matrix)
  parent: System.Windows.Rect
  isExternal: false
  name: Transform(Matrix)
  nameWithType: Rect.Transform(Matrix)
  fullName: System.Windows.Rect.Transform(Matrix)
- uid: System.Windows.Media.Matrix
  parent: System.Windows.Media
  isExternal: false
  name: Matrix
  nameWithType: Matrix
  fullName: System.Windows.Media.Matrix
- uid: System.Windows.Rect.Transform(System.Windows.Rect,System.Windows.Media.Matrix)
  parent: System.Windows.Rect
  isExternal: false
  name: Transform(Rect,Matrix)
  nameWithType: Rect.Transform(Rect,Matrix)
  fullName: System.Windows.Rect.Transform(Rect,Matrix)
- uid: System.Windows.Rect.Union(System.Windows.Point)
  parent: System.Windows.Rect
  isExternal: false
  name: Union(Point)
  nameWithType: Rect.Union(Point)
  fullName: System.Windows.Rect.Union(Point)
- uid: System.Windows.Rect.Union(System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: Union(Rect)
  nameWithType: Rect.Union(Rect)
  fullName: System.Windows.Rect.Union(Rect)
- uid: System.Windows.Rect.Union(System.Windows.Rect,System.Windows.Point)
  parent: System.Windows.Rect
  isExternal: false
  name: Union(Rect,Point)
  nameWithType: Rect.Union(Rect,Point)
  fullName: System.Windows.Rect.Union(Rect,Point)
- uid: System.Windows.Rect.Union(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: Union(Rect,Rect)
  nameWithType: Rect.Union(Rect,Rect)
  fullName: System.Windows.Rect.Union(Rect,Rect)
- uid: System.Windows.Rect.Width
  parent: System.Windows.Rect
  isExternal: false
  name: Width
  nameWithType: Rect.Width
  fullName: System.Windows.Rect.Width
- uid: System.Windows.Rect.X
  parent: System.Windows.Rect
  isExternal: false
  name: X
  nameWithType: Rect.X
  fullName: System.Windows.Rect.X
- uid: System.Windows.Rect.Y
  parent: System.Windows.Rect
  isExternal: false
  name: Y
  nameWithType: Rect.Y
  fullName: System.Windows.Rect.Y
- uid: System.Windows.Rect.#ctor*
  parent: System.Windows.Rect
  isExternal: false
  name: Rect
  nameWithType: Rect.Rect
- uid: System.Windows.Rect.Bottom*
  parent: System.Windows.Rect
  isExternal: false
  name: Bottom
  nameWithType: Rect.Bottom
- uid: System.Windows.Rect.BottomLeft*
  parent: System.Windows.Rect
  isExternal: false
  name: BottomLeft
  nameWithType: Rect.BottomLeft
- uid: System.Windows.Rect.BottomRight*
  parent: System.Windows.Rect
  isExternal: false
  name: BottomRight
  nameWithType: Rect.BottomRight
- uid: System.Windows.Rect.Contains*
  parent: System.Windows.Rect
  isExternal: false
  name: Contains
  nameWithType: Rect.Contains
- uid: System.Windows.Rect.Empty*
  parent: System.Windows.Rect
  isExternal: false
  name: Empty
  nameWithType: Rect.Empty
- uid: System.Windows.Rect.Equals*
  parent: System.Windows.Rect
  isExternal: false
  name: Equals
  nameWithType: Rect.Equals
- uid: System.Windows.Rect.GetHashCode*
  parent: System.Windows.Rect
  isExternal: false
  name: GetHashCode
  nameWithType: Rect.GetHashCode
- uid: System.Windows.Rect.Height*
  parent: System.Windows.Rect
  isExternal: false
  name: Height
  nameWithType: Rect.Height
- uid: System.Windows.Rect.Inflate*
  parent: System.Windows.Rect
  isExternal: false
  name: Inflate
  nameWithType: Rect.Inflate
- uid: System.Windows.Rect.Intersect*
  parent: System.Windows.Rect
  isExternal: false
  name: Intersect
  nameWithType: Rect.Intersect
- uid: System.Windows.Rect.IntersectsWith*
  parent: System.Windows.Rect
  isExternal: false
  name: IntersectsWith
  nameWithType: Rect.IntersectsWith
- uid: System.Windows.Rect.IsEmpty*
  parent: System.Windows.Rect
  isExternal: false
  name: IsEmpty
  nameWithType: Rect.IsEmpty
- uid: System.Windows.Rect.Left*
  parent: System.Windows.Rect
  isExternal: false
  name: Left
  nameWithType: Rect.Left
- uid: System.Windows.Rect.Location*
  parent: System.Windows.Rect
  isExternal: false
  name: Location
  nameWithType: Rect.Location
- uid: System.Windows.Rect.Offset*
  parent: System.Windows.Rect
  isExternal: false
  name: Offset
  nameWithType: Rect.Offset
- uid: System.Windows.Rect.op_Equality*
  parent: System.Windows.Rect
  isExternal: false
  name: op_Equality
  nameWithType: Rect.op_Equality
- uid: System.Windows.Rect.op_Inequality*
  parent: System.Windows.Rect
  isExternal: false
  name: op_Inequality
  nameWithType: Rect.op_Inequality
- uid: System.Windows.Rect.Parse*
  parent: System.Windows.Rect
  isExternal: false
  name: Parse
  nameWithType: Rect.Parse
- uid: System.Windows.Rect.Right*
  parent: System.Windows.Rect
  isExternal: false
  name: Right
  nameWithType: Rect.Right
- uid: System.Windows.Rect.Scale*
  parent: System.Windows.Rect
  isExternal: false
  name: Scale
  nameWithType: Rect.Scale
- uid: System.Windows.Rect.Size*
  parent: System.Windows.Rect
  isExternal: false
  name: Size
  nameWithType: Rect.Size
- uid: System.Windows.Rect.System#IFormattable#ToString*
  parent: System.Windows.Rect
  isExternal: false
  name: System.IFormattable.ToString
  nameWithType: Rect.System.IFormattable.ToString
- uid: System.Windows.Rect.Top*
  parent: System.Windows.Rect
  isExternal: false
  name: Top
  nameWithType: Rect.Top
- uid: System.Windows.Rect.TopLeft*
  parent: System.Windows.Rect
  isExternal: false
  name: TopLeft
  nameWithType: Rect.TopLeft
- uid: System.Windows.Rect.TopRight*
  parent: System.Windows.Rect
  isExternal: false
  name: TopRight
  nameWithType: Rect.TopRight
- uid: System.Windows.Rect.ToString*
  parent: System.Windows.Rect
  isExternal: false
  name: ToString
  nameWithType: Rect.ToString
- uid: System.Windows.Rect.Transform*
  parent: System.Windows.Rect
  isExternal: false
  name: Transform
  nameWithType: Rect.Transform
- uid: System.Windows.Rect.Union*
  parent: System.Windows.Rect
  isExternal: false
  name: Union
  nameWithType: Rect.Union
- uid: System.Windows.Rect.Width*
  parent: System.Windows.Rect
  isExternal: false
  name: Width
  nameWithType: Rect.Width
- uid: System.Windows.Rect.X*
  parent: System.Windows.Rect
  isExternal: false
  name: X
  nameWithType: Rect.X
- uid: System.Windows.Rect.Y*
  parent: System.Windows.Rect
  isExternal: false
  name: Y
  nameWithType: Rect.Y
