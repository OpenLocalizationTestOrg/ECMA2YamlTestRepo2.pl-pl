### YamlMime:ManagedReference
items:
- uid: System.AppDomain
  id: AppDomain
  children:
  - System.AppDomain.ActivationContext
  - System.AppDomain.AppendPrivatePath(System.String)
  - System.AppDomain.ApplicationIdentity
  - System.AppDomain.ApplicationTrust
  - System.AppDomain.ApplyPolicy(System.String)
  - System.AppDomain.AssemblyLoad
  - System.AppDomain.AssemblyResolve
  - System.AppDomain.BaseDirectory
  - System.AppDomain.ClearPrivatePath
  - System.AppDomain.ClearShadowCopyPath
  - System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  - System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.CreateDomain(System.String)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  - System.AppDomain.CreateInstance(System.String,System.String)
  - System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceFrom(System.String,System.String)
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CurrentDomain
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  - System.AppDomain.DomainManager
  - System.AppDomain.DomainUnload
  - System.AppDomain.DynamicDirectory
  - System.AppDomain.Evidence
  - System.AppDomain.ExecuteAssembly(System.String)
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.ExecuteAssembly(System.String,System.String[])
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.ExecuteAssemblyByName(System.String)
  - System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.FirstChanceException
  - System.AppDomain.FriendlyName
  - System.AppDomain.GetAssemblies
  - System.AppDomain.GetCurrentThreadId
  - System.AppDomain.GetData(System.String)
  - System.AppDomain.GetType
  - System.AppDomain.Id
  - System.AppDomain.InitializeLifetimeService
  - System.AppDomain.IsCompatibilitySwitchSet(System.String)
  - System.AppDomain.IsDefaultAppDomain
  - System.AppDomain.IsFinalizingForUnload
  - System.AppDomain.IsFullyTrusted
  - System.AppDomain.IsHomogenous
  - System.AppDomain.Load(System.Byte[])
  - System.AppDomain.Load(System.Reflection.AssemblyName)
  - System.AppDomain.Load(System.String)
  - System.AppDomain.Load(System.Byte[],System.Byte[])
  - System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  - System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  - System.AppDomain.MonitoringIsEnabled
  - System.AppDomain.MonitoringSurvivedMemorySize
  - System.AppDomain.MonitoringSurvivedProcessMemorySize
  - System.AppDomain.MonitoringTotalAllocatedMemorySize
  - System.AppDomain.MonitoringTotalProcessorTime
  - System.AppDomain.PermissionSet
  - System.AppDomain.ProcessExit
  - System.AppDomain.ReflectionOnlyAssemblyResolve
  - System.AppDomain.ReflectionOnlyGetAssemblies
  - System.AppDomain.RelativeSearchPath
  - System.AppDomain.ResourceResolve
  - System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  - System.AppDomain.SetCachePath(System.String)
  - System.AppDomain.SetData(System.String,System.Object)
  - System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  - System.AppDomain.SetDynamicBase(System.String)
  - System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  - System.AppDomain.SetShadowCopyFiles
  - System.AppDomain.SetShadowCopyPath(System.String)
  - System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  - System.AppDomain.SetupInformation
  - System.AppDomain.ShadowCopyFiles
  - System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  - System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  - System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  - System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  - System.AppDomain.ToString
  - System.AppDomain.TypeResolve
  - System.AppDomain.UnhandledException
  - System.AppDomain.Unload(System.AppDomain)
  langs:
  - csharp
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
  type: Class
  summary: "Reprezentuje domenę aplikacji, która jest izolowanym środowisku, gdy wykonanie aplikacji. Ta klasa nie może być dziedziczona."
  remarks: "Domeny aplikacji, które są reprezentowane przez obiekty elementu AppDomain, pomagają granic izolacji, zwalnianie i zabezpieczeń wykonywania kodu zarządzanego.      -Użyj domeny aplikacji do izolowania zadań, które mogą spowodować przerwanie procesu. Jeśli stan elementu AppDomain, który wykonuje zadanie staje się niestabilny, można można zwolnić elementu AppDomain bez wpływu na proces. Jest to ważne w przypadku, gdy proces musi zostać uruchomiony dłuższe okresy bez ponownego uruchamiania. Domeny aplikacji służy również do izolowania zadania, które nie powinny udostępniać dane.      — Jeśli zestaw jest ładowany do domyślnej domeny aplikacji, nie może być usunięte z pamięci procesu jest uruchomiona. Jednak po otwarciu druga domena aplikacji do ładowania i wykonywania zestawu zestaw jest zwolniony podczas tej domeny aplikacji zostanie zwolniona. Ten sposób można zminimalizować zestaw roboczy procesy długotrwałe, czasami używające duże biblioteki dll.       Wielu domen aplikacji można uruchomić w ramach jednego procesu; jednak nie istnieje sygnałowych domeny aplikacji i wątków. Kilka wątków może należeć do domeny pojedynczej aplikacji, a podczas danego wątku nie jest ograniczona do domeny pojedynczej aplikacji, w dowolnym momencie, wątek wykonuje się w domenie pojedynczej aplikacji.       Domeny aplikacji są tworzone przy użyciu <xref:System.AppDomain.CreateDomain%2A>metody.</xref:System.AppDomain.CreateDomain%2A> Wystąpienia elementu AppDomain są używane do ładowania i wykonywania zestawów (<xref:System.Reflection.Assembly>).</xref:System.Reflection.Assembly> Gdy elementu AppDomain nie jest już w użyciu, może być usunięty z pamięci.       Klasa elementu AppDomain implementuje zestaw zdarzeń, które umożliwiają aplikacjom odpowiadać, jeśli zestaw ładowany jest, gdy domeny aplikacji zostanie zwolniony, lub gdy jest nieobsługiwany wyjątek.       Aby uzyskać więcej informacji na temat używania domeny aplikacji, zobacz [domen aplikacji](~/add/includes/ajax-current-ext-md.md).       Ta klasa implementuje <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, i <xref:System.Security.IEvidenceFactory>interfejsów.</xref:System.Security.IEvidenceFactory> </xref:System._AppDomain> </xref:System.MarshalByRefObject>       Nigdy nie należy tworzyć otoka może być zastosowana zdalnie dla obiekt AppDomain. Dzięki temu można opublikować zdalne odwołanie do tego elementu AppDomain, takie jak udostępnianie metody <xref:System.AppDomain.CreateInstance%2A>dostępu zdalnego i efektywnie niszczenie zabezpieczenia dostępu kodu dla tego elementu AppDomain.</xref:System.AppDomain.CreateInstance%2A> Złośliwe klientów łączących się z elementu AppDomain zdalny może uzyskać dostęp do wszystkich zasobów, które samego elementu AppDomain ma dostęp do. Nie należy tworzyć może być zastosowana zdalnie otoki dla dowolnego typu, rozszerzający <xref:System.MarshalByRefObject>i implementującej metody, które mogłyby zostać użyte przez złośliwe klientów do obejścia zabezpieczeń systemu.</xref:System.MarshalByRefObject>      > [!CAUTION] > Wartością domyślną dla <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName>jest właściwość `false`.</xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName> To ustawienie jest niebezpieczne dla usług. Aby zapobiec usług pobierania częściowo zaufanego kodu, ustaw tę właściwość na `true`."
  example:
  - "This example shows how to create a new AppDomain, instantiate a type in that new AppDomain, and communicate with that type’s object. In addition, this example shows how to unload the AppDomain causing the object to be garbage collected.  \n  \n [!code-vb[AppDomainX#1](~/add/codesnippet/visualbasic/t-system.appdomain_1.vb)]\n [!code-cs[AppDomainX#1](~/add/codesnippet/csharp/t-system.appdomain_1.cs)]\n [!code-cpp[AppDomainX#1](~/add/codesnippet/cpp/t-system.appdomain_1.cpp)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]

      [System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  implements:
  - System._AppDomain
  - System.Security.IEvidenceFactory
  inheritedMembers:
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.AppDomain.ActivationContext
  id: ActivationContext
  parent: System.AppDomain
  langs:
  - csharp
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
  fullName: System.AppDomain.ActivationContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera kontekst aktywacji dla bieżącej domeny aplikacji."
  syntax:
    content: public ActivationContext ActivationContext { get; }
    return:
      type: System.ActivationContext
      description: "Obiekt, który reprezentuje kontekst aktywacji dla bieżącej domeny aplikacji lub <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Jeśli domena nie kontekstu aktywacji."
  overload: System.AppDomain.ActivationContext*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AppendPrivatePath(System.String)
  id: AppendPrivatePath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: AppendPrivatePath(String)
  nameWithType: AppDomain.AppendPrivatePath(String)
  fullName: System.AppDomain.AppendPrivatePath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Dołącza określony katalog do ścieżki prywatnej listy."
  remarks: "Użycie tej właściwości nie jest zalecane, ponieważ może go zmienić ścieżki próbkowania dla zestawów, po ma został już załadowany. Użyj <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>Właściwości zamiast.</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>       Ścieżki prywatnej lub ścieżka względna wyszukiwania jest ścieżka względna katalogu podstawowego, której mechanizm rozpoznawania zestawów sondy dla zestawy prywatne."
  syntax:
    content: public void AppendPrivatePath (string path);
    parameters:
    - id: path
      type: System.String
      description: "Nazwa katalogu do dołączenia ścieżkę prywatną."
  overload: System.AppDomain.AppendPrivatePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.ApplicationIdentity
  id: ApplicationIdentity
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
  fullName: System.AppDomain.ApplicationIdentity
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera tożsamość aplikacji w domenie aplikacji."
  syntax:
    content: public ApplicationIdentity ApplicationIdentity { get; }
    return:
      type: System.ApplicationIdentity
      description: "Obiekt, który identyfikuje aplikację w domenie aplikacji."
  overload: System.AppDomain.ApplicationIdentity*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ApplicationTrust
  id: ApplicationTrust
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
  fullName: System.AppDomain.ApplicationTrust
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera informacje opisujące uprawnienia przyznane aplikacji i określa, czy aplikacja ma poziom zaufania, który umożliwia jego uruchomienie."
  syntax:
    content: public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }
    return:
      type: System.Security.Policy.ApplicationTrust
      description: "Obiekt hermetyzujący informacje o uprawnienia i zaufania dla aplikacji w domenie aplikacji."
  overload: System.AppDomain.ApplicationTrust*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ApplyPolicy(System.String)
  id: ApplyPolicy(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplyPolicy(String)
  nameWithType: AppDomain.ApplyPolicy(String)
  fullName: System.AppDomain.ApplyPolicy(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Zwraca nazwy wyświetlanej zestawu po zastosowaniu zasady."
  remarks: "ApplyPolicy, którego metoda przyjmuje zestawu nazwę wyświetlaną i zwraca nazwę wyświetlaną po zastosowaniu zasad. Jest to przydatne, jeśli zachodzi konieczność załadowania zestawu za pomocą zasad, ponieważ kontekstu reflection-only nie można stosować zasady."
  syntax:
    content: public string ApplyPolicy (string assemblyName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Zestaw do nazwy wyświetlanej, w formularzu dostarczonych przez &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt; właściwości."
    return:
      type: System.String
      description: "Ciąg zawierający zestaw wyświetlana nazwa, po zastosowaniu zasady."
  overload: System.AppDomain.ApplyPolicy*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AssemblyLoad
  id: AssemblyLoad
  parent: System.AppDomain
  langs:
  - csharp
  name: AssemblyLoad
  nameWithType: AppDomain.AssemblyLoad
  fullName: System.AppDomain.AssemblyLoad
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Występuje, gdy zestaw jest ładowany."
  remarks: "<xref:System.AssemblyLoadEventHandler>Delegowanie dla to zdarzenie wskazuje, jaki zestaw został załadowany.</xref:System.AssemblyLoadEventHandler>       Aby zarejestrować program obsługi zdarzeń dla tego zdarzenia, musi mieć wymagane uprawnienia lub <xref:System.Security.SecurityException>jest generowany.</xref:System.Security.SecurityException>       Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [zdarzenia](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following sample demonstrates the AssemblyLoad event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_AssemblyLoad#1](~/add/codesnippet/csharp/e-system.appdomain.assem_1_1.cs)]\n [!code-vb[AppDomain_AssemblyLoad#1](~/add/codesnippet/visualbasic/e-system.appdomain.assem_1_1.vb)]\n [!code-cpp[AppDomain_AssemblyLoad#1](~/add/codesnippet/cpp/e-system.appdomain.assem_1_1.cpp)]"
  syntax:
    content: public event AssemblyLoadEventHandler AssemblyLoad;
    return:
      type: System.AssemblyLoadEventHandler
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AssemblyResolve
  id: AssemblyResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: AssemblyResolve
  nameWithType: AppDomain.AssemblyResolve
  fullName: System.AppDomain.AssemblyResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Występuje, gdy rozpoznawania zestawu nie powiodło się."
  remarks: "Jest on odpowiedzialny za <xref:System.ResolveEventHandler>dla tego zdarzenia do zwrócenia zestawu określoną przez <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>Właściwości, lub aby zwrócić wartość null, jeśli zestaw nie został rozpoznany.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName> </xref:System.ResolveEventHandler> Zestaw muszą być załadowane do kontekstu wykonywania; Jeśli jest on ładowany do kontekstu reflection-only, obciążenia, który spowodował się tego zdarzenia nie powiedzie się.       Aby uzyskać wskazówki, użyj tego zdarzenia, zobacz [rozwiązywanie Załadowań zestawów](~/add/includes/ajax-current-ext-md.md).       Począwszy od [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>właściwość zwraca żądane ładowanie zestawu, którego nie można rozpoznać zestawu.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> Moduł ładujący może być na przykład nie można załadować zależności zestawu żądania, ponieważ zestaw żądania i jego zależności nie znajdują się w ścieżce sondowania. Znajomość tożsamości zestawu żądania mogą być przydatne, lokalizowanie zależności lub do identyfikowania poprawną wersję, jeśli dostępny jest więcej niż jedną wersję zależności. Aby uzyskać więcej informacji zobacz <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>      > [!IMPORTANT] > Począwszy od [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], <xref:System.ResolveEventHandler>zdarzenie jest wywoływane dla wszystkich zestawów, w tym zestawy zasobów.</xref:System.ResolveEventHandler> W starszych wersjach zdarzenie nie zostało zgłoszone dla zestawy zasobów. Jeśli system operacyjny jest zlokalizowana, program obsługi może być wywołana wiele razy: raz dla każdej kultury w łańcuchu powrotu.       Dla tego zdarzenia <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>właściwość zwraca nazwę zestawu, przed zastosowaniem zasad.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>      > [!IMPORTANT] > Jeśli więcej niż jeden program obsługi zdarzeń jest zarejestrowany dla tego zdarzenia, handlersarecalled zdarzeń w kolejności, dopóki program obsługi zdarzeń zwraca wartość, która nie jest `null`. Programy obsługi zdarzeń kolejne są ignorowane.       Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [zdarzenia](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following sample demonstrates the AssemblyResolve event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cpp[AssemblyResolve#1](~/add/codesnippet/cpp/e-system.appdomain.assem_0_1.cpp)]\n [!code-cs[AssemblyResolve#1](~/add/codesnippet/csharp/e-system.appdomain.assem_0_1.cs)]\n [!code-vb[AssemblyResolve#1](~/add/codesnippet/visualbasic/e-system.appdomain.assem_0_1.vb)]"
  syntax:
    content: public event ResolveEventHandler AssemblyResolve;
    return:
      type: System.ResolveEventHandler
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.BaseDirectory
  id: BaseDirectory
  parent: System.AppDomain
  langs:
  - csharp
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
  fullName: System.AppDomain.BaseDirectory
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera katalog podstawowy, używaną do sondowania dla zestawów mechanizm rozpoznawania zestawów."
  remarks: "Ta właściwość odpowiada <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>Właściwości.</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName> Można również pobrać, przy użyciu <xref:System.AppDomain.GetData%2A>metody z ciągiem &quot;APPBASE&quot;.</xref:System.AppDomain.GetData%2A>"
  example:
  - "The following code example creates a new application domain, specifying a base directory to use when searching for assemblies to load into the domain. The example then uses the BaseDirectory property to obtain the base directory path, for display to the console.  \n  \n [!code-cs[ADSetup#1](~/add/codesnippet/csharp/p-system.appdomain.based_1.cs)]\n [!code-cpp[ADSetup#1](~/add/codesnippet/cpp/p-system.appdomain.based_1.cpp)]\n [!code-vb[ADSetup#1](~/add/codesnippet/visualbasic/p-system.appdomain.based_1.vb)]"
  syntax:
    content: public string BaseDirectory { get; }
    return:
      type: System.String
      description: "Katalog podstawowy mechanizm rozpoznawania zestawów używa do sondowania dla zestawów."
  overload: System.AppDomain.BaseDirectory*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.ClearPrivatePath
  id: ClearPrivatePath
  parent: System.AppDomain
  langs:
  - csharp
  name: ClearPrivatePath()
  nameWithType: AppDomain.ClearPrivatePath()
  fullName: System.AppDomain.ClearPrivatePath()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Resetuje ścieżki, który określa lokalizację zestawy prywatne do ciągu pustego (&quot;&quot;)."
  remarks: "Prywatne ścieżka jest ścieżką względną wobec katalogu podstawowego, wyszukująca zlokalizować zestawy prywatne środowisko uruchomieniowe języka wspólnego.       Aby uzyskać więcej informacji zobacz <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>.</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>"
  example:
  - "The following code example demonstrates how to use the ClearPrivatePath method to remove all entries from the list of private paths to search when assemblies are loaded.  \n  \n This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[ADClearPrivatePath#1](~/add/codesnippet/cpp/m-system.appdomain.clear_1.cpp)]\n [!code-cs[ADClearPrivatePath#1](~/add/codesnippet/csharp/m-system.appdomain.clear_1.cs)]\n [!code-vb[ADClearPrivatePath#1](~/add/codesnippet/visualbasic/m-system.appdomain.clear_1.vb)]"
  syntax:
    content: public void ClearPrivatePath ();
    parameters: []
  overload: System.AppDomain.ClearPrivatePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.ClearShadowCopyPath
  id: ClearShadowCopyPath
  parent: System.AppDomain
  langs:
  - csharp
  name: ClearShadowCopyPath()
  nameWithType: AppDomain.ClearShadowCopyPath()
  fullName: System.AppDomain.ClearShadowCopyPath()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Resetuje listę katalogów zawierających zestawów w tle kopiowane do ciągu pustego (&quot;&quot;)."
  remarks: "Ścieżka kopii tle jest lista katalogów, do którego skopiowane zestawów w tle są przechowywane.       Aby uzyskać więcej informacji, zobacz <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>i [Kopiowanie zestawów w tle](~/add/includes/ajax-current-ext-md.md).</xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>"
  syntax:
    content: public void ClearShadowCopyPath ();
    parameters: []
  overload: System.AppDomain.ClearShadowCopyPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  id: CreateComInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateComInstanceFrom(String,String)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Tworzy nowe wystąpienie określonego typu modelu COM. Parametry, określ nazwę pliku, który zawiera zestaw zawierający ten typ i nazwa typu."
  remarks: "Użyj tej metody do tworzenia obiektów zdalnie, nie można załadować typu lokalnie.       Musi być zwracana wartość do odkodowania dostępu do rzeczywistego obiektu.       A<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName> atrybutu o wartości `true` należy zastosować jawnie lub domyślnie na typ COM dla tej metody można utworzyć wystąpienia tego typu; w przeciwnym razie <xref:System.TypeLoadException>jest generowany.</xref:System.TypeLoadException> </xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>"
  example:
  - "The following sample demonstrates  \n  \n [!code-cs[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/csharp/m-system.appdomain.creat_4_1.cs)]\n [!code-vb[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_4_1.vb)]\n [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/cpp/m-system.appdomain.creat_4_1.cpp)]"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Nazwa pliku zawierającego zestawu, który definiuje żądanego typu."
    - id: typeName
      type: System.String
      description: "Nazwa żądanego typu."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Obiekt będący otoki dla nowego wystąpienia określonego przez <code> typeName </code>. Wartość zwracana musi odkodowania dostępu do rzeczywistego obiektu."
  overload: System.AppDomain.CreateComInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "Nie można załadować typu."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Znaleziono nie publicznego konstruktora bez parametrów."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>Nie znaleziono."
  - type: System.MemberAccessException
    commentId: T:System.MemberAccessException
    description: "<code>typeName</code>jest klasą abstrakcyjną.       - lub - tego elementu członkowskiego został wywołany z mechanizmem późnego wiązania."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>assemblyName</code>to ciąg pusty (&quot;&quot;)."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>nie jest prawidłowym zestawem."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Obiekt COM, który jest on określany jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Tworzy nowe wystąpienie określonego typu modelu COM. Parametry, określ nazwę pliku, który zawiera zestaw zawierający ten typ i nazwa typu."
  remarks: "Użyj tej metody do tworzenia obiektów zdalnie, nie można załadować typu lokalnie.       Musi być zwracana wartość do odkodowania dostępu do rzeczywistego obiektu.       A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>atrybutu o wartości `true` należy zastosować jawnie lub domyślnie na typ COM dla tej metody można utworzyć wystąpienia tego typu; w przeciwnym razie <xref:System.TypeLoadException>jest generowany.</xref:System.TypeLoadException> </xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Nazwa pliku zawierającego zestawu, który definiuje żądanego typu."
    - id: typeName
      type: System.String
      description: "Nazwa żądanego typu."
    - id: hashValue
      type: System.Byte[]
      description: "Reprezentuje wartość obliczona wartość skrótu."
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "Reprezentuje siła algorytmu wyznaczania wartości skrótu używanego przez manifest zestawu."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Obiekt będący otoki dla nowego wystąpienia określonego przez <code> typeName </code>. Wartość zwracana musi odkodowania dostępu do rzeczywistego obiektu."
  overload: System.AppDomain.CreateComInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "Nie można załadować typu."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Znaleziono nie publicznego konstruktora bez parametrów."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>Nie znaleziono."
  - type: System.MemberAccessException
    commentId: T:System.MemberAccessException
    description: "<code>typeName</code>jest klasą abstrakcyjną.       - lub - tego elementu członkowskiego został wywołany z mechanizmem późnego wiązania."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>assemblyFile</code>jest pustym ciągiem (&quot;&quot;)."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>nie jest prawidłowym zestawem."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Obiekt COM, który jest on określany jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String)
  id: CreateDomain(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String)
  nameWithType: AppDomain.CreateDomain(String)
  fullName: System.AppDomain.CreateDomain(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Tworzy nową domenę aplikacji o określonej nazwie."
  remarks: "`friendlyName` Parametr służy do identyfikowania domeny w sposób zrozumiały dla człowieka. Ten ciąg powinny być dostosowane do wyświetlania na interfejsy użytkownika.       Używa tego przeciążenia metody <xref:System.AppDomainSetup>informacji z domyślnej domeny aplikacji.</xref:System.AppDomainSetup>"
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_1_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/m-system.appdomain.creat_1_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/m-system.appdomain.creat_1_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName);
    parameters:
    - id: friendlyName
      type: System.String
      description: "Przyjazna nazwa domeny."
    return:
      type: System.AppDomain
      description: "Domena nowo utworzonej aplikacji."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  id: CreateDomain(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence)
  nameWithType: AppDomain.CreateDomain(String,Evidence)
  fullName: System.AppDomain.CreateDomain(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Tworzy nową domenę aplikacji o podanej nazwie przy użyciu dostarczonego dowód."
  remarks: "This method overload uses the <xref:System.AppDomainSetup> information from the default application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the CreateDomain overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_0_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/m-system.appdomain.creat_0_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/m-system.appdomain.creat_0_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);
    parameters:
    - id: friendlyName
      type: System.String
      description: "Przyjazna nazwa domeny. Przyjazna nazwa mogą być wyświetlane w interfejsach użytkownika, aby zidentyfikować domenę. Aby uzyskać więcej informacji zobacz <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Dowód, że ustalana jest tożsamość kodu, który jest uruchamiany w domenie aplikacji. Przekaż <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> do używania dowody bieżącej domeny aplikacji."
    return:
      type: System.AppDomain
      description: "Domena nowo utworzonej aplikacji."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,AppDomainSetup)
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Tworzy nową domenę aplikacji przy użyciu określonej nazwy, dowód i informacje o konfiguracji domeny aplikacji."
  remarks: "If `info` is not supplied, this method overload uses the <xref:System.AppDomainSetup> information from the default application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/f22a5c12-7605-4011-8d1c-_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/f22a5c12-7605-4011-8d1c-_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/f22a5c12-7605-4011-8d1c-_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);
    parameters:
    - id: friendlyName
      type: System.String
      description: "Przyjazna nazwa domeny. Przyjazna nazwa mogą być wyświetlane w interfejsach użytkownika, aby zidentyfikować domenę. Aby uzyskać więcej informacji zobacz <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Dowód, że ustalana jest tożsamość kodu, który jest uruchamiany w domenie aplikacji. Przekaż <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> do używania dowody bieżącej domeny aplikacji."
    - id: info
      type: System.AppDomainSetup
      description: "Obiekt zawierający informacje o inicjowania domeny aplikacji."
    return:
      type: System.AppDomain
      description: "Domena nowo utworzonej aplikacji."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Tworzy nową domenę aplikacji przy użyciu określonej nazwy, dowód, informacje o konfiguracji domeny aplikacji, domyślny zestaw uprawnień i tablicy całkowicie zaufanych zestawów."
  remarks: "Należy ustawić <xref:System.AppDomainSetup.ApplicationBase%2A>Właściwość <xref:System.AppDomainSetup>obiekt, który można podać `info`.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.ApplicationBase%2A> W przeciwnym wypadku jest zwracany wyjątek.       Jeśli `securityInfo` jest nie zostanie podany, jest używany dowód z bieżącej domeny aplikacji.       Informacje przewidziane `grantSet` i `fullTrustAssemblies` służy do tworzenia <xref:System.Security.Policy.ApplicationTrust>obiektu dla nowej domeny aplikacji.</xref:System.Security.Policy.ApplicationTrust>"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, System.Security.Policy.StrongName[] fullTrustAssemblies);
    parameters:
    - id: friendlyName
      type: System.String
      description: "Przyjazna nazwa domeny. Przyjazna nazwa mogą być wyświetlane w interfejsach użytkownika, aby zidentyfikować domenę. Aby uzyskać więcej informacji zobacz opis <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Dowód, że ustalana jest tożsamość kodu, który jest uruchamiany w domenie aplikacji. Przekaż <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> do używania dowody bieżącej domeny aplikacji."
    - id: info
      type: System.AppDomainSetup
      description: "Obiekt zawierający informacje o inicjowania domeny aplikacji."
    - id: grantSet
      type: System.Security.PermissionSet
      description: "Uprawnienia domyślne, czyli ustawić przyznanych do wszystkich zestawów załadowanych do nowej domeny aplikacji, które nie mają określonego przyznaje."
    - id: fullTrustAssemblies
      type: System.Security.Policy.StrongName[]
      description: "Tablica silnych nazw reprezentujący zestawy uznany w pełni zaufany w nowej domenie aplikacji."
    return:
      type: System.AppDomain
      description: "Domena nowo utworzonej aplikacji."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Domena aplikacji jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>.       - lub - <xref:System.AppDomainSetup.ApplicationBase*>właściwość nie jest ustawiona na <xref href=&quot;System.AppDomainSetup&quot;> </xref> obiekt, który jest dostarczany do <code> info </code>.</xref:System.AppDomainSetup.ApplicationBase*>"
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,String,String,Boolean)
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Tworzy nową domenę aplikacji o podanej nazwie, przy użyciu dowód, podstawowa ścieżka aplikacji, ścieżka względna wyszukiwania i parametr, który określa, czy zestaw kopii w tle ma być załadowane do tej domeny aplikacji."
  remarks: "If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A>and [Shadow Copying Assemblies](~/add/includes/ajax-current-ext-md.md).  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/9bed52ed-b275-4e3a-b9e6-_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/9bed52ed-b275-4e3a-b9e6-_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/9bed52ed-b275-4e3a-b9e6-_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);
    parameters:
    - id: friendlyName
      type: System.String
      description: "Przyjazna nazwa domeny. Przyjazna nazwa mogą być wyświetlane w interfejsach użytkownika, aby zidentyfikować domenę. Aby uzyskać więcej informacji zobacz <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Dowód, że ustalana jest tożsamość kodu, który jest uruchamiany w domenie aplikacji. Przekaż <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> do używania dowody bieżącej domeny aplikacji."
    - id: appBasePath
      type: System.String
      description: "Katalog podstawowy mechanizm rozpoznawania zestawów używa do sondowania dla zestawów. Aby uzyskać więcej informacji zobacz <xref:System.AppDomain.BaseDirectory*>.</xref:System.AppDomain.BaseDirectory*>"
    - id: appRelativeSearchPath
      type: System.String
      description: "Ścieżka względna katalogu podstawowego, której mechanizm rozpoznawania zestawów powinny sondować zestawy prywatne. Aby uzyskać więcej informacji zobacz <xref:System.AppDomain.RelativeSearchPath*>.</xref:System.AppDomain.RelativeSearchPath*>"
    - id: shadowCopyFiles
      type: System.Boolean
      description: "Jeśli <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, zestawu kopii w tle jest ładowany do tej domeny aplikacji."
    return:
      type: System.AppDomain
      description: "Domena nowo utworzonej aplikacji."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Tworzy nową domenę aplikacji o podanej nazwie, przy użyciu dowód, podstawowa ścieżka aplikacji, ścieżka względna wyszukiwania i parametr, który określa, czy zestaw kopii w tle ma być załadowane do tej domeny aplikacji. Określa metody wywołania zwrotnego, które jest wywoływane, gdy domena aplikacji została zainicjowana i tablicę argumentów ciągów do przekazania metody wywołania zwrotnego."
  remarks: "The method represented by `adInit` is executed in the context of the newly created application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A>and [Shadow Copying Assemblies](~/add/includes/ajax-current-ext-md.md).  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);
    parameters:
    - id: friendlyName
      type: System.String
      description: "Przyjazna nazwa domeny. Przyjazna nazwa mogą być wyświetlane w interfejsach użytkownika, aby zidentyfikować domenę. Aby uzyskać więcej informacji zobacz <xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "Dowód, że ustalana jest tożsamość kodu, który jest uruchamiany w domenie aplikacji. Przekaż <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> do używania dowody bieżącej domeny aplikacji."
    - id: appBasePath
      type: System.String
      description: "Katalog podstawowy mechanizm rozpoznawania zestawów używa do sondowania dla zestawów. Aby uzyskać więcej informacji zobacz <xref:System.AppDomain.BaseDirectory*>.</xref:System.AppDomain.BaseDirectory*>"
    - id: appRelativeSearchPath
      type: System.String
      description: "Ścieżka względna katalogu podstawowego, której mechanizm rozpoznawania zestawów powinny sondować zestawy prywatne. Aby uzyskać więcej informacji zobacz <xref:System.AppDomain.RelativeSearchPath*>.</xref:System.AppDomain.RelativeSearchPath*>"
    - id: shadowCopyFiles
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby załadować zestawu kopii w tle do domeny aplikacji."
    - id: adInit
      type: System.AppDomainInitializer
      description: "<xref href=&quot;System.AppDomainInitializer&quot;> </xref> Delegata, który reprezentuje metodę wywołania zwrotnego do wywołania, gdy nowy <xref href=&quot;System.AppDomain&quot;> </xref> obiekt został zainicjowany."
    - id: adInitArgs
      type: System.String[]
      description: "Tablica argumenty typu string do przekazania do wywołania zwrotnego reprezentowany przez `adInit`, gdy nowy <xref href=&quot;System.AppDomain&quot;> </xref> obiekt został zainicjowany."
    return:
      type: System.AppDomain
      description: "Domena nowo utworzonej aplikacji."
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String)
  id: CreateInstance(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String)
  nameWithType: AppDomain.CreateInstance(String,String)
  fullName: System.AppDomain.CreateInstance(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Tworzy nowe wystąpienie określonego typu zdefiniowane w określonym zestawie."
  remarks: "Ta metoda wywołuje konstruktor domyślny `typeName`.       Zobacz <xref:System.Reflection.AssemblyName>dla formatu `assemblyName`.</xref:System.Reflection.AssemblyName>       Próba wywołania elementu CreateInstance na docelowa domena aplikacji, która nie jest bieżącej domeny aplikacji spowoduje pomyślne ładowania zestawu w docelowej domenie aplikacji. Ponieważ <xref:System.Reflection.Assembly>nie jest <xref:System.MarshalByRefObject>, gdy ta metoda próbuje zwrócić <xref:System.Reflection.Assembly>załadować zestawu do bieżącej domeny aplikacji, środowisko uruchomieniowe języka wspólnego próbuje załadować zestawu do bieżącej domeny aplikacji i obciążenie może się nie powieść.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> Zestaw, który jest ładowany do bieżącej domeny aplikacji mogą się różnić od zestawu, który został wcześniej załadowany Jeśli domen aplikacji dwa ustawienia ścieżki są różne."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Nazwa wyświetlana zestawu. Zobacz &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; właściwości."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Obiekt będący otoki dla nowego wystąpienia określonego przez <code> typeName </code>. Wartość zwracana musi odkodowania dostępu do rzeczywistego obiektu."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>nie jest prawidłowym zestawem.       - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <code>assemblyName</code> został skompilowany przy użyciu nowszej wersji."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>Nie znaleziono."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Obiekt wywołujący nie ma uprawnienia do wywoływania tego konstruktora."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Brak pasującego konstruktora publicznego został znaleziony."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>Nie znaleziono w <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "To wystąpienie jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  id: CreateInstance(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Tworzy nowe wystąpienie określonego typu zdefiniowane w określonym zestawie. Parametr określa tablicę z atrybutami aktywacji."
  remarks: "Ta metoda wywołuje konstruktor domyślny `typeName`.       Zobacz <xref:System.Reflection.AssemblyName>dla formatu `assemblyName`.</xref:System.Reflection.AssemblyName>       Próba wywołania <xref:System.AppDomain.CreateInstance%2A>w celu pomyślnego ładowania zestawu w docelowej domenie aplikacji spowoduje domeny aplikacji, która nie jest bieżącej domeny aplikacji.</xref:System.AppDomain.CreateInstance%2A> Ponieważ <xref:System.Reflection.Assembly>nie jest <xref:System.MarshalByRefObject>, gdy ta metoda próbuje zwrócić <xref:System.Reflection.Assembly>załadować zestawu do bieżącej domeny aplikacji, środowisko uruchomieniowe języka wspólnego próbuje załadować zestawu do bieżącej domeny aplikacji i obciążenie może się nie powieść.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> Zestaw, który jest ładowany do bieżącej domeny aplikacji mogą się różnić od zestawu, który został wcześniej załadowany Jeśli domen aplikacji dwa ustawienia ścieżki są różne."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Nazwa wyświetlana zestawu. Zobacz &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; właściwości."
    - id: activationAttributes
      type: System.Object[]
      description: "Tablica jeden lub więcej atrybutów, które mogą uczestniczyć w aktywacji. Zazwyczaj tablicę, która zawiera jedną <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.       Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest starsze technologia, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Obiekt będący otoki dla nowego wystąpienia określonego przez <code> typeName </code>. Wartość zwracana musi odkodowania dostępu do rzeczywistego obiektu."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>nie jest prawidłowym zestawem.       - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <code>assemblyName</code> został skompilowany przy użyciu nowszej wersji."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>Nie znaleziono."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Obiekt wywołujący nie ma uprawnienia do wywoływania tego konstruktora."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Brak pasującego konstruktora publicznego został znaleziony."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>Nie znaleziono w <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "To wystąpienie jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Tworzy nowe wystąpienie określonego typu zdefiniowane w określonym zestawie. Parametry określają integratora, flag powiązań, argumenty konstruktora, sposób interpretowania argumentów i atrybuty activation opcjonalne informacje specyficzne dla kultury."
  remarks: "Zobacz <xref:System.Reflection.AssemblyName>dla formatu `assemblyName`.</xref:System.Reflection.AssemblyName>       Próba wywołania <xref:System.AppDomain.CreateInstance%2A>w celu pomyślnego ładowania zestawu w docelowej domenie aplikacji spowoduje domeny aplikacji, która nie jest bieżącej domeny aplikacji.</xref:System.AppDomain.CreateInstance%2A> Ponieważ <xref:System.Reflection.Assembly>nie jest <xref:System.MarshalByRefObject>, gdy ta metoda próbuje zwrócić <xref:System.Reflection.Assembly>załadować zestawu do bieżącej domeny aplikacji, środowisko uruchomieniowe języka wspólnego próbuje załadować zestawu do bieżącej domeny aplikacji i obciążenie może się nie powieść.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> Zestaw, który jest ładowany do bieżącej domeny aplikacji mogą się różnić od zestawu, który został wcześniej załadowany Jeśli domen aplikacji dwa ustawienia ścieżki są różne."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Nazwa wyświetlana zestawu. Zobacz &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; właściwości."
    - id: ignoreCase
      type: System.Boolean
      description: "Wartość logiczna określająca, czy można wykonać wyszukiwanie z uwzględnieniem wielkości liter, czy nie."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Kombinacja zero lub więcej flag bitowych, które mają wpływ na wyszukiwanie `typeName` konstruktora. Jeśli `bindingAttr` jest zero, wyszukiwanie jest przeprowadzane konstruktorów publicznych."
    - id: binder
      type: System.Reflection.Binder
      description: "Obiekt, który umożliwia powiązanie koercja argumentu typy wywołania elementów członkowskich i pobieranie <xref:System.Reflection.MemberInfo>obiektów za pomocą odbicia.</xref:System.Reflection.MemberInfo> Jeśli `binder` jest wartość null, jest używany domyślny integrator."
    - id: args
      type: System.Object[]
      description: "Argumenty do przekazania do konstruktora. Ta tablica argumentów musi zgodne w polu numer zamówienia i wpisz parametry konstruktora do wywołania. Jeśli domyślny konstruktor jest preferowana, `args` musi być pustą tablicą ani mieć wartości null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Informacje specyficzne dla kultury, które kontroluje koercja z `args` typom posiadanie zadeklarowanym dla `typeName` konstruktora. Jeśli `culture` jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref:System.Globalization.CultureInfo>służy bieżącego wątku.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Tablica jeden lub więcej atrybutów, które mogą uczestniczyć w aktywacji. Zazwyczaj tablicę, która zawiera jedną <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.       Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Obiekt będący otoki dla nowego wystąpienia określonego przez <code> typeName </code>. Wartość zwracana musi odkodowania dostępu do rzeczywistego obiektu."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>nie jest prawidłowym zestawem.       - lub - <code>assemblyName</code> został skompilowany przy użyciu nowszej wersji środowiska CLR niż wersja, który jest aktualnie załadowany."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>Nie znaleziono."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Obiekt wywołujący nie ma uprawnienia do wywoływania tego konstruktora."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nie odnaleziono pasującego konstruktora został."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>Nie znaleziono w <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "To wystąpienie jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Tworzy nowe wystąpienie określonego typu zdefiniowane w określonym zestawie. Parametry określają integratora, flag powiązań, argumenty konstruktora, informacje specyficzne dla kultury sposób interpretowania argumenty aktywacji i atrybuty autoryzacji do utworzenia typu."
  remarks: "Zobacz <xref:System.Reflection.AssemblyName>dla formatu `assemblyName`.</xref:System.Reflection.AssemblyName>       Próba wywołania <xref:System.AppDomain.CreateInstance%2A>w celu pomyślnego ładowania zestawu w docelowej domenie aplikacji spowoduje domeny aplikacji, która nie jest bieżącej domeny aplikacji.</xref:System.AppDomain.CreateInstance%2A> Ponieważ <xref:System.Reflection.Assembly>nie jest <xref:System.MarshalByRefObject>, gdy ta metoda próbuje zwrócić <xref:System.Reflection.Assembly>załadować zestawu do bieżącej domeny aplikacji, środowisko uruchomieniowe języka wspólnego próbuje załadować zestawu do bieżącej domeny aplikacji i obciążenie może się nie powieść.</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> Zestaw, który jest ładowany do bieżącej domeny aplikacji mogą się różnić od zestawu, który został wcześniej załadowany Jeśli domen aplikacji dwa ustawienia ścieżki są różne."
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Nazwa wyświetlana zestawu. Zobacz &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; właściwości."
    - id: ignoreCase
      type: System.Boolean
      description: "Wartość logiczna określająca, czy można wykonać wyszukiwanie z uwzględnieniem wielkości liter, czy nie."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Kombinacja zero lub więcej flag bitowych, które mają wpływ na wyszukiwanie `typeName` konstruktora. Jeśli `bindingAttr` jest zero, wyszukiwanie jest przeprowadzane konstruktorów publicznych."
    - id: binder
      type: System.Reflection.Binder
      description: "Obiekt, który umożliwia powiązanie koercja argumentu typy wywołania elementów członkowskich i pobieranie <xref:System.Reflection.MemberInfo>obiektów za pomocą odbicia.</xref:System.Reflection.MemberInfo> Jeśli `binder` jest wartość null, jest używany domyślny integrator."
    - id: args
      type: System.Object[]
      description: "Argumenty do przekazania do konstruktora. Ta tablica argumentów musi zgodne w polu numer zamówienia i wpisz parametry konstruktora do wywołania. Jeśli domyślny konstruktor jest preferowana, `args` musi być pustą tablicą ani mieć wartości null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Informacje specyficzne dla kultury, które kontroluje koercja z `args` typom posiadanie zadeklarowanym dla `typeName` konstruktora. Jeśli `culture` jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref:System.Globalization.CultureInfo>służy bieżącego wątku.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Tablica jeden lub więcej atrybutów, które mogą uczestniczyć w aktywacji. Zazwyczaj tablicę, która zawiera jedną <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.       Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest starsze technologia, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Informacje używane do tworzenia autoryzacji `typeName`."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Obiekt będący otoki dla nowego wystąpienia określonego przez <code> typeName </code>. Wartość zwracana musi odkodowania dostępu do rzeczywistego obiektu."
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>nie jest prawidłowym zestawem.       - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <code>assemblyName</code> został skompilowany przy użyciu nowszej wersji."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>Nie znaleziono."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Obiekt wywołujący nie ma uprawnienia do wywoływania tego konstruktora."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nie odnaleziono pasującego konstruktora został."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <xref href=&quot;System.MarshalByRefObject&quot;> </xref>.       -or-       <code>securityAttributes</code> is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Gdy starszą zasadę nie jest włączone, <code> securityAttributes </code> powinien być<xref uid=&quot;langword_csharp_null.&quot; name=&quot;null.&quot; href=&quot;&quot;></xref>"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>Nie znaleziono w <code>assemblyName</code>."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "To wystąpienie jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  id: CreateInstanceAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Tworzy nowe wystąpienie określonego typu. Parametry określają zestawu, w którym zdefiniowano typ i nazwę typu."
  remarks: "Jest to metoda wygody, łączącą <xref:System.AppDomain.CreateInstance%2A>i <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A> Ta metoda wywołuje konstruktor domyślny `typeName`.       Zobacz <xref:System.Reflection.AssemblyName>dla formatu `assemblyName`.</xref:System.Reflection.AssemblyName> Zobacz <xref:System.Type.FullName%2A?displayProperty=fullName>Właściwość format `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Aby wywołanie z wczesnym wiązaniem metody `M` obiektu typu `T1` który został zwrócony przez CreateInstanceAndUnwrap, a ta metoda powoduje, że wywołania z wczesnym wiązaniem metod typu obiektu `T2` w zestawie `C` niż bieżący zestaw lub zestawu zawierającego `T1`, zestawu `C` jest ładowany do bieżącej domeny aplikacji. Ładowanie tego występuje nawet wtedy, gdy wywołanie z wczesnym wiązaniem `T1.M()` została wprowadzona w treści <xref:System.Reflection.Emit.DynamicMethod>, lub w innym kodzie dynamicznie generowanym.</xref:System.Reflection.Emit.DynamicMethod> Jeśli bieżąca domena jest domeną domyślną, zestawu `C` nie może być zwolnione, do czasu zakończenia procesu. Jeśli bieżąca domena później próbuje załadować zestawu `C`, obciążenie może zakończyć się niepowodzeniem."
  example:
  - "The following code example shows the simplest way to execute code in another application domain. The example defines a class named `Worker` that inherits from <xref:System.MarshalByRefObject>. The `Worker` class defines a method that displays the name of the application domain in which it is executing. The example creates instances of `Worker` in the default application domain and in a new application domain.  \n  \n> [!NOTE]\n>  The assembly that contains `Worker` must be loaded into both application domains, but it can load other assemblies that exist only in the new application domain.  \n  \n [!code-cpp[CreateInstanceAndUnwrap2#1](~/add/codesnippet/cpp/m-system.appdomain.creat_2_1.cpp)]\n [!code-cs[CreateInstanceAndUnwrap2#1](~/add/codesnippet/csharp/m-system.appdomain.creat_2_1.cs)]\n [!code-vb[CreateInstanceAndUnwrap2#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_2_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Nazwa wyświetlana zestawu. Zobacz &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; właściwości."
    return:
      type: System.Object
      description: "Wystąpienie obiektu określonego przez <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Brak pasującego konstruktora publicznego został znaleziony."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>Nie znaleziono w <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>Nie znaleziono."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Obiekt wywołujący nie ma uprawnienia do wywoływania tego konstruktora."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>nie jest prawidłowym zestawem.       - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <code>assemblyName</code> został skompilowany przy użyciu nowszej wersji."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Tworzy nowe wystąpienie określonego typu. Parametry określają zestawu, w którym zdefiniowano typ, nazwa typu, a tablica atrybutów aktywacji."
  remarks: "Jest to metoda wygody, łączącą <xref:System.AppDomain.CreateInstance%2A>i <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A> Ta metoda wywołuje konstruktor domyślny `typeName`.       Zobacz <xref:System.Reflection.AssemblyName>dla formatu `assemblyName`.</xref:System.Reflection.AssemblyName> Zobacz <xref:System.Type.FullName%2A?displayProperty=fullName>Właściwość format `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Aby wywołania z wczesnym wiązaniem do metody `M` obiektu typu `T1` zwrócony przez <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, i metoda zgłasza wywołania z wczesnym wiązaniem metod typu obiektu `T2` w zestawie `C` niż bieżący zestaw lub zestawu zawierającego `T1`, zestawu `C` jest ładowany do bieżącej domeny aplikacji.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> Ładowanie tego występuje nawet wtedy, gdy wywołanie z wczesnym wiązaniem `T1.M()` została wprowadzona w treści <xref:System.Reflection.Emit.DynamicMethod>, lub w innym kodzie dynamicznie generowanym.</xref:System.Reflection.Emit.DynamicMethod> Jeśli bieżąca domena jest domeną domyślną, zestawu `C` nie może być zwolnione, do czasu zakończenia procesu. Jeśli bieżąca domena później próbuje załadować zestawu `C`, obciążenie może zakończyć się niepowodzeniem."
  example:
  - >-
    [!code-cpp[ADDyno#1](~/add/codesnippet/cpp/ec186439-6d54-4090-82e0-_1.cpp)]
     [!code-cs[ADDyno#1](~/add/codesnippet/csharp/ec186439-6d54-4090-82e0-_1.cs)]
     [!code-vb[ADDyno#1](~/add/codesnippet/visualbasic/ec186439-6d54-4090-82e0-_1.vb)]
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Nazwa wyświetlana zestawu. Zobacz &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; właściwości."
    - id: activationAttributes
      type: System.Object[]
      description: "Tablica jeden lub więcej atrybutów, które mogą uczestniczyć w aktywacji. Zazwyczaj tablicę, która zawiera jedną <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.       Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest starsze technologia, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation."
    return:
      type: System.Object
      description: "Wystąpienie obiektu określonego przez <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Brak pasującego konstruktora publicznego został znaleziony."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>Nie znaleziono w <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>Nie znaleziono."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Obiekt wywołujący nie ma uprawnienia do wywoływania tego konstruktora."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>nie jest prawidłowym zestawem.       - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <code>assemblyName</code> został skompilowany przy użyciu nowszej wersji."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Tworzy nowe wystąpienie określonego typu zdefiniowane w określonym zestawie, określania, czy jest ignorowana w przypadku nazwy typu. atrybuty wiązania i integratorów, które służą do wybierania typu, który ma zostać utworzony; Argumenty konstruktora; Kultura; i atrybuty aktywacji."
  remarks: "Jest to metoda wygody, łączącą <xref:System.AppDomain.CreateInstance%2A>i <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A>       Zobacz <xref:System.Reflection.AssemblyName>dla formatu `assemblyName`.</xref:System.Reflection.AssemblyName> Zobacz <xref:System.Type.FullName%2A?displayProperty=fullName>Właściwość format `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Aby wywołania z wczesnym wiązaniem do metody `M` obiektu typu `T1` zwrócony przez <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, i metoda zgłasza wywołania z wczesnym wiązaniem metod typu obiektu `T2` w zestawie `C` niż bieżący zestaw lub zestawu zawierającego `T1`, zestawu `C` jest ładowany do bieżącej domeny aplikacji.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> Ładowanie tego występuje nawet wtedy, gdy wywołanie z wczesnym wiązaniem `T1.M()` została wprowadzona w treści <xref:System.Reflection.Emit.DynamicMethod>, lub w innym kodzie dynamicznie generowanym.</xref:System.Reflection.Emit.DynamicMethod> Jeśli bieżąca domena jest domeną domyślną, zestawu `C` nie może być zwolnione, do czasu zakończenia procesu. Jeśli bieżąca domena później próbuje załadować zestawu `C`, obciążenie może zakończyć się niepowodzeniem."
  example:
  - "The following sample demonstrates the use of the `ignoreCase` parameter.  \n  \n [!code-cs[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/csharp/7b1dcc86-9680-463d-b78c-_1.cs)]\n [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/cpp/7b1dcc86-9680-463d-b78c-_1.cpp)]\n [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/visualbasic/7b1dcc86-9680-463d-b78c-_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Nazwa wyświetlana zestawu. Zobacz &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; właściwości."
    - id: ignoreCase
      type: System.Boolean
      description: "Wartość logiczna określająca, czy można wykonać wyszukiwanie z uwzględnieniem wielkości liter, czy nie."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Kombinacja zero lub więcej flag bitowych, które mają wpływ na wyszukiwanie `typeName` konstruktora. Jeśli `bindingAttr` jest zero, wyszukiwanie jest przeprowadzane konstruktorów publicznych."
    - id: binder
      type: System.Reflection.Binder
      description: "Obiekt, który umożliwia powiązanie koercja argumentu typy wywołania elementów członkowskich i pobieranie <xref:System.Reflection.MemberInfo>obiektów za pomocą odbicia.</xref:System.Reflection.MemberInfo> Jeśli `binder` jest wartość null, jest używany domyślny integrator."
    - id: args
      type: System.Object[]
      description: "Argumenty do przekazania do konstruktora. Ta tablica argumentów musi zgodne w polu numer zamówienia i wpisz parametry konstruktora do wywołania. Jeśli domyślny konstruktor jest preferowana, `args` musi być pustą tablicą ani mieć wartości null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Używane do sterowania koercja typu obiektu specyficzne dla kultury. Jeśli `culture` jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;> </xref> dla bieżącego wątku."
    - id: activationAttributes
      type: System.Object[]
      description: "Tablica jeden lub więcej atrybutów, które mogą uczestniczyć w aktywacji. Zazwyczaj tablicę, która zawiera jedną <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> obiektu. który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.       Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation."
    return:
      type: System.Object
      description: "Wystąpienie obiektu określonego przez <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nie odnaleziono pasującego konstruktora został."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>Nie znaleziono w <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>Nie znaleziono."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Obiekt wywołujący nie ma uprawnienia do wywoływania tego konstruktora."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>nie jest prawidłowym zestawem.       - lub - <code>assemblyName</code> został skompilowany przy użyciu nowszej wersji środowiska CLR niż wersja, który jest aktualnie załadowany."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Tworzy nowe wystąpienie określonego typu. Parametry, określ nazwę typu i jak jest znaleziono i utworzyć."
  remarks: "Jest to metoda wygody, łączącą <xref:System.AppDomain.CreateInstance%2A>i <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstance%2A>       Zobacz <xref:System.Reflection.AssemblyName>dla formatu `assemblyName`.</xref:System.Reflection.AssemblyName> Zobacz <xref:System.Type.FullName%2A?displayProperty=fullName>Właściwość format `typeName`.</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > Aby wywołania z wczesnym wiązaniem do metody `M` obiektu typu `T1` zwrócony przez <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, i metoda zgłasza wywołania z wczesnym wiązaniem metod typu obiektu `T2` w zestawie `C` niż bieżący zestaw lub zestawu zawierającego `T1`, zestawu `C` jest ładowany do bieżącej domeny aplikacji.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> Ładowanie tego występuje nawet wtedy, gdy wywołanie z wczesnym wiązaniem `T1.M()` została wprowadzona w treści <xref:System.Reflection.Emit.DynamicMethod>, lub w innym kodzie dynamicznie generowanym.</xref:System.Reflection.Emit.DynamicMethod> Jeśli bieżąca domena jest domeną domyślną, zestawu `C` nie może być zwolnione, do czasu zakończenia procesu. Jeśli bieżąca domena później próbuje załadować zestawu `C`, obciążenie może zakończyć się niepowodzeniem."
  example:
  - "The following sample demonstrates the use of the `ignoreCase` parameter.  \n  \n [!code-cs[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/csharp/8e0d44ad-3def-4658-8d9d-_1.cs)]\n [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/cpp/8e0d44ad-3def-4658-8d9d-_1.cpp)]\n [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/visualbasic/8e0d44ad-3def-4658-8d9d-_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Nazwa wyświetlana zestawu. Zobacz &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: typeName
      type: System.String
      description: "W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; właściwości."
    - id: ignoreCase
      type: System.Boolean
      description: "Wartość logiczna określająca, czy można wykonać wyszukiwanie z uwzględnieniem wielkości liter, czy nie."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Kombinacja zero lub więcej flag bitowych, które mają wpływ na wyszukiwanie `typeName` konstruktora. Jeśli `bindingAttr` jest zero, wyszukiwanie jest przeprowadzane konstruktorów publicznych."
    - id: binder
      type: System.Reflection.Binder
      description: "Obiekt, który umożliwia powiązanie koercja argumentu typy wywołania elementów członkowskich i pobieranie <xref:System.Reflection.MemberInfo>obiektów za pomocą odbicia.</xref:System.Reflection.MemberInfo> Jeśli `binder` jest wartość null, jest używany domyślny integrator."
    - id: args
      type: System.Object[]
      description: "Argumenty do przekazania do konstruktora. Ta tablica argumentów musi zgodne w polu numer zamówienia i wpisz parametry konstruktora do wywołania. Jeśli domyślny konstruktor jest preferowana, `args` musi być pustą tablicą ani mieć wartości null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Używane do sterowania koercja typu obiektu specyficzne dla kultury. Jeśli `culture` jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;> </xref> dla bieżącego wątku."
    - id: activationAttributes
      type: System.Object[]
      description: "Tablica jeden lub więcej atrybutów, które mogą uczestniczyć w aktywacji. Zazwyczaj tablicę, która zawiera jedną <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.       Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Informacje używane do tworzenia autoryzacji `typeName`."
    return:
      type: System.Object
      description: "Wystąpienie obiektu określonego przez <code> typeName </code>."
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Nie odnaleziono pasującego konstruktora został."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>Nie znaleziono w <code>assemblyName</code>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>Nie znaleziono."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Obiekt wywołujący nie ma uprawnienia do wywoływania tego konstruktora."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>nie jest prawidłowym zestawem.       - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <code>assemblyName</code> został skompilowany przy użyciu nowszej wersji."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String)
  id: CreateInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String)
  nameWithType: AppDomain.CreateInstanceFrom(String,String)
  fullName: System.AppDomain.CreateInstanceFrom(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Tworzy nowe wystąpienie określonego typu zdefiniowane w pliku określonego zestawu."
  remarks: "Domyślny konstruktor `typeName` jest wywoływana.       Aby uzyskać więcej informacji, zobacz <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metody.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       Metoda CreateInstanceFrom służy do tworzenia wystąpienia w domenie aplikacji docelowej, inne niż domena aplikacji, z którego następuje wywołanie, zestaw jest ładowany w docelowej domenie aplikacji. Jednak w przypadku wystąpienia bez otoki w domenie aplikacji wywołującej, przy użyciu wystąpienia bez otoki w określony sposób może spowodować zestawu do załadowania do wywoływania domeny aplikacji. Na przykład gdy wystąpienie jest bez otoki, może można żądać informacji o typie, celu wywołania metody późnym wiązaniem. Jeśli zestaw jest ładowany do wywoływania domeny aplikacji, może wystąpić wyjątki.      — Jeśli inna wersja tego samego zestawu zostało wcześniej załadowane do wywoływania domeny aplikacji lub jeśli takie jak ścieżka obciążenia wywoływania domeny aplikacji to innym niż docelowa domena aplikacji, wyjątki <xref:System.MissingMethodException>może wystąpić.</xref:System.MissingMethodException>      — Jeśli wywołanie domeny aplikacji sprawia, że wywołania z wczesnym wiązaniem na typ wystąpienia <xref:System.InvalidCastException>może zostać wygenerowany, gdy podejmowana jest próba można rzutować wystąpienia.</xref:System.InvalidCastException>"
  example:
  - "The following example shows how to use the CreateInstanceFrom method overload to create an instance of an object in a target application domain and call its methods.  \n  \n The example defines the `MarshallableExample` class, which can be marshaled across application domain boundaries. The example builds a path to the currently executing assembly, creates a target application domain, and uses the CreateInstanceFrom method overload to load the example assembly into the target application domain and create an instance of `MarshallableExample`.  \n  \n> [!NOTE]\n>  The path is absolute in this example, but a relative path would also work because the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=fullName> method is used to load the assembly.  \n  \n After unwrapping the object handle, the example demonstrates three ways to use an object in a target application domain:  \n  \n-   Invoking a method with late binding, using reflection. This requires type information, which causes the assembly to be loaded into the application domain of the caller. (In this example, it is already loaded.)  \n  \n-   Casting the object to an interface known to both the caller and the callee. If the interface is defined in the calling assembly or in a third assembly referenced by both the caller and the callee, the called assembly is not loaded into the application domain of the caller.  \n  \n-   Using the object directly when its type is known to the caller. The assembly must be loaded into the application domain of the caller.  \n  \n Another way to avoid loading the called assembly into the application domain of the caller is for the caller to derive from the <xref:System.MarshalByRefObject> class and to define a method that can be run in the target application domain. That method can use reflection to examine a target assembly, because the target assembly is already loaded into the target application domain. See the example for the <xref:System.AppDomain.DynamicDirectory%2A> property.  \n  \n [!code-cs[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/csharp/m-system.appdomain.creat_3_1.cs)]\n [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/cpp/m-system.appdomain.creat_3_1.cpp)]\n [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_3_1.vb)]"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Nazwa, łącznie ze ścieżką pliku, który zawiera zestaw, który definiuje żądanego typu. Zestaw jest ładowany przy użyciu <xref:System.Reflection.Assembly.LoadFrom*>metody.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; właściwości."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Obiekt będący otoki dla nowego wystąpienia lub <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Jeśli <code> typeName </code> nie można odnaleźć. Wartość zwracana musi odkodowania dostępu do rzeczywistego obiektu."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>Nie znaleziono."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>Nie znaleziono w <code>assemblyFile</code>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Znaleziono nie publicznego konstruktora bez parametrów."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Obiekt wywołujący nie ma wystarczających uprawnień do wywoływania tego konstruktora."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>nie jest prawidłowym zestawem.       - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <code>assemblyFile</code> został skompilowany przy użyciu nowszej wersji."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "To wystąpienie jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  id: CreateInstanceFrom(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Tworzy nowe wystąpienie określonego typu zdefiniowane w pliku określonego zestawu."
  remarks: "Domyślny konstruktor `typeName` jest wywoływana.       Aby uzyskać więcej informacji na temat tej metody, zobacz <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metody.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       Gdy <xref:System.AppDomain.CreateInstanceFrom%2A>Metoda jest używana do utworzenia wystąpienia w domenie aplikacji docelowej, inne niż domena aplikacji, w którym jest nawiązane połączenie, zestaw jest ładowany w docelowej domenie aplikacji.</xref:System.AppDomain.CreateInstanceFrom%2A> Jednak w przypadku wystąpienia bez otoki w domenie aplikacji wywołującej, przy użyciu wystąpienia bez otoki w określony sposób może spowodować zestawu do załadowania do wywoływania domeny aplikacji. Na przykład gdy wystąpienie jest bez otoki, może można żądać informacji o typie, celu wywołania metody późnym wiązaniem. Jeśli zestaw jest ładowany do wywoływania domeny aplikacji, może wystąpić wyjątki.      — Jeśli inna wersja tego samego zestawu zostało wcześniej załadowane do wywoływania domeny aplikacji lub jeśli takie jak ścieżka obciążenia wywoływania domeny aplikacji to innym niż docelowa domena aplikacji, wyjątki <xref:System.MissingMethodException>może wystąpić.</xref:System.MissingMethodException>      — Jeśli wywołanie domeny aplikacji sprawia, że wywołania z wczesnym wiązaniem na typ wystąpienia <xref:System.InvalidCastException>może zostać wygenerowany, gdy podejmowana jest próba można rzutować wystąpienia.</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Nazwa, łącznie ze ścieżką pliku, który zawiera zestaw, który definiuje żądanego typu. Zestaw jest ładowany przy użyciu <xref:System.Reflection.Assembly.LoadFrom*>metody.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; właściwości."
    - id: activationAttributes
      type: System.Object[]
      description: "Tablica jeden lub więcej atrybutów, które mogą uczestniczyć w aktywacji. Zazwyczaj tablicę, która zawiera jedną <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.       Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest starsze technologia, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Obiekt będący otoki dla nowego wystąpienia lub <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Jeśli <code> typeName </code> nie można odnaleźć. Wartość zwracana musi odkodowania dostępu do rzeczywistego obiektu."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>Nie znaleziono."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>Nie znaleziono w <code>assemblyFile</code>."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Obiekt wywołujący nie ma wystarczających uprawnień do wywoływania tego konstruktora."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Brak pasującego konstruktora publicznego został znaleziony."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>nie jest prawidłowym zestawem.       - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <code>assemblyFile</code> został skompilowany przy użyciu nowszej wersji."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "To wystąpienie jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Tworzy nowe wystąpienie określonego typu zdefiniowane w pliku określonego zestawu."
  remarks: "Aby uzyskać więcej informacji, zobacz <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metody.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       Gdy <xref:System.AppDomain.CreateInstanceFrom%2A>Metoda jest używana do utworzenia wystąpienia w domenie aplikacji docelowej, inne niż domena aplikacji, w którym jest nawiązane połączenie, zestaw jest ładowany w docelowej domenie aplikacji.</xref:System.AppDomain.CreateInstanceFrom%2A> Jednak w przypadku wystąpienia bez otoki w domenie aplikacji wywołującej, przy użyciu wystąpienia bez otoki w określony sposób może spowodować zestawu do załadowania do wywoływania domeny aplikacji. Na przykład gdy wystąpienie jest bez otoki, może można żądać informacji o typie, celu wywołania metody późnym wiązaniem. Jeśli zestaw jest ładowany do wywoływania domeny aplikacji, może wystąpić wyjątki.      — Jeśli inna wersja tego samego zestawu zostało wcześniej załadowane do wywoływania domeny aplikacji lub jeśli takie jak ścieżka obciążenia wywoływania domeny aplikacji to innym niż docelowa domena aplikacji, wyjątki <xref:System.MissingMethodException>może wystąpić.</xref:System.MissingMethodException>      — Jeśli wywołanie domeny aplikacji sprawia, że wywołania z wczesnym wiązaniem na typ wystąpienia <xref:System.InvalidCastException>może zostać wygenerowany, gdy podejmowana jest próba można rzutować wystąpienia.</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Nazwa, łącznie ze ścieżką pliku, który zawiera zestaw, który definiuje żądanego typu. Zestaw jest ładowany przy użyciu <xref:System.Reflection.Assembly.LoadFrom*>metody.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; właściwości."
    - id: ignoreCase
      type: System.Boolean
      description: "Wartość logiczna określająca, czy można wykonać wyszukiwanie z uwzględnieniem wielkości liter, czy nie."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Kombinacja zero lub więcej flag bitowych, które mają wpływ na wyszukiwanie `typeName` konstruktora. Jeśli `bindingAttr` jest zero, wyszukiwanie jest przeprowadzane konstruktorów publicznych."
    - id: binder
      type: System.Reflection.Binder
      description: "Obiekt, który umożliwia powiązanie koercja argumentu typy, wywołania elementów członkowskich i pobieranie <xref:System.Reflection.MemberInfo>obiektów przez odbicie.</xref:System.Reflection.MemberInfo> Jeśli `binder` jest wartość null, jest używany domyślny integrator."
    - id: args
      type: System.Object[]
      description: "Argumenty do przekazania do konstruktora. Ta tablica argumentów musi zgodne w polu numer zamówienia i wpisz parametry konstruktora do wywołania. Jeśli domyślny konstruktor jest preferowana, `args` musi być pustą tablicą ani mieć wartości null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Informacje specyficzne dla kultury, które kontroluje koercja z `args` typom posiadanie zadeklarowanym dla `typeName` konstruktora. Jeśli `culture` jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref:System.Globalization.CultureInfo>służy bieżącego wątku.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Tablica jeden lub więcej atrybutów, które mogą uczestniczyć w aktywacji. Zazwyczaj tablicę, która zawiera jedną <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.       Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Obiekt będący otoki dla nowego wystąpienia lub <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Jeśli <code> typeName </code> nie można odnaleźć. Wartość zwracana musi odkodowania dostępu do rzeczywistego obiektu."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>Nie znaleziono."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>Nie znaleziono w <code>assemblyFile</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Brak pasującego konstruktora publicznego został znaleziony."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Obiekt wywołujący nie ma wystarczających uprawnień do wywoływania tego konstruktora."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>nie jest prawidłowym zestawem.       - lub - <code>assemblyFile</code> został skompilowany przy użyciu nowszej wersji środowiska CLR niż wersja, który jest aktualnie załadowany."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "To wystąpienie jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Tworzy nowe wystąpienie określonego typu zdefiniowane w pliku określonego zestawu."
  remarks: "Aby uzyskać więcej informacji na temat tej metody, zobacz <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metody.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       Gdy <xref:System.AppDomain.CreateInstanceFrom%2A>Metoda jest używana do utworzenia wystąpienia w domenie aplikacji docelowej, inne niż domena aplikacji, w którym jest nawiązane połączenie, zestaw jest ładowany w docelowej domenie aplikacji.</xref:System.AppDomain.CreateInstanceFrom%2A> Jednak w przypadku wystąpienia bez otoki w domenie aplikacji wywołującej, przy użyciu wystąpienia bez otoki w określony sposób może spowodować zestawu do załadowania do wywoływania domeny aplikacji. Na przykład gdy wystąpienie jest bez otoki, może można żądać informacji o typie, celu wywołania metody późnym wiązaniem. Jeśli zestaw jest ładowany do wywoływania domeny aplikacji, może wystąpić wyjątki.      — Jeśli inna wersja tego samego zestawu zostało wcześniej załadowane do wywoływania domeny aplikacji lub jeśli takie jak ścieżka obciążenia wywoływania domeny aplikacji to innym niż docelowa domena aplikacji, wyjątki <xref:System.MissingMethodException>może wystąpić.</xref:System.MissingMethodException>      — Jeśli wywołanie domeny aplikacji sprawia, że wywołania z wczesnym wiązaniem na typ wystąpienia <xref:System.InvalidCastException>może zostać wygenerowany, gdy podejmowana jest próba można rzutować wystąpienia.</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Nazwa, łącznie ze ścieżką pliku, który zawiera zestaw, który definiuje żądanego typu. Zestaw jest ładowany przy użyciu <xref:System.Reflection.Assembly.LoadFrom*>metody.</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; właściwości."
    - id: ignoreCase
      type: System.Boolean
      description: "Wartość logiczna określająca, czy można wykonać wyszukiwanie z uwzględnieniem wielkości liter, czy nie."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Kombinacja zero lub więcej flag bitowych, które mają wpływ na wyszukiwanie `typeName` konstruktora. Jeśli `bindingAttr` jest zero, wyszukiwanie jest przeprowadzane konstruktorów publicznych."
    - id: binder
      type: System.Reflection.Binder
      description: "Obiekt, który umożliwia powiązanie koercja argumentu typy, wywołania elementów członkowskich i pobieranie <xref:System.Reflection.MemberInfo>obiektów przez odbicie.</xref:System.Reflection.MemberInfo> Jeśli `binder` jest wartość null, jest używany domyślny integrator."
    - id: args
      type: System.Object[]
      description: "Argumenty do przekazania do konstruktora. Ta tablica argumentów musi zgodne w polu numer zamówienia i wpisz parametry konstruktora do wywołania. Jeśli domyślny konstruktor jest preferowana, `args` musi być pustą tablicą ani mieć wartości null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Informacje specyficzne dla kultury, które kontroluje koercja z `args` typom posiadanie zadeklarowanym dla `typeName` konstruktora. Jeśli `culture` jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref:System.Globalization.CultureInfo>służy bieżącego wątku.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Tablica jeden lub więcej atrybutów, które mogą uczestniczyć w aktywacji. Zazwyczaj tablicę, która zawiera jedną <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.       Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Informacje używane do tworzenia autoryzacji `typeName`."
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "Obiekt będący otoki dla nowego wystąpienia lub <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Jeśli <code> typeName </code> nie można odnaleźć. Wartość zwracana musi odkodowania dostępu do rzeczywistego obiektu."
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <xref href=&quot;System.MarshalByRefObject&quot;> </xref>.       -or-       <code>securityAttributes</code> is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Gdy starszą zasadę nie jest włączone, <code> securityAttributes </code> powinien być <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>Nie znaleziono."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>Nie znaleziono w <code>assemblyFile</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Brak pasującego konstruktora publicznego został znaleziony."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Obiekt wywołujący nie ma wystarczających uprawnień do wywoływania tego konstruktora."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>nie jest prawidłowym zestawem.       - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <code>assemblyFile</code> został skompilowany przy użyciu nowszej wersji."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "To wystąpienie jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  id: CreateInstanceFromAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Tworzy nowe wystąpienie określonego typu zdefiniowane w pliku określonego zestawu."
  remarks: "Jest to metoda wygody, łączącą <xref:System.AppDomain.CreateInstanceFrom%2A>i <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A> Ta metoda wywołuje konstruktor domyślny `typeName`.       Aby uzyskać więcej informacji, zobacz <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metody.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Nazwa pliku i ścieżka zestawu, który definiuje żądanego typu."
    - id: typeName
      type: System.String
      description: "W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; właściwości."
    return:
      type: System.Object
      description: "Żądany obiekt lub <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Jeśli <code> typeName </code> nie można odnaleźć."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>Nie znaleziono."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>Nie znaleziono w <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Znaleziono nie publicznego konstruktora bez parametrów."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Obiekt wywołujący nie ma wystarczających uprawnień do wywoływania tego konstruktora."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>nie jest prawidłowym zestawem.       - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <code>assemblyName</code> został skompilowany przy użyciu nowszej wersji."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Tworzy nowe wystąpienie określonego typu zdefiniowane w pliku określonego zestawu."
  remarks: "Jest to metoda wygody, łączącą <xref:System.AppDomain.CreateInstanceFrom%2A>i <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A> Ta metoda wywołuje konstruktor domyślny `typeName`.       Aby uzyskać więcej informacji na temat tej metody, zobacz <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metody.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Nazwa pliku i ścieżka zestawu, który definiuje żądanego typu."
    - id: typeName
      type: System.String
      description: "W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestawu (zobacz &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; właściwości)."
    - id: activationAttributes
      type: System.Object[]
      description: "Tablica jeden lub więcej atrybutów, które mogą uczestniczyć w aktywacji. Zazwyczaj tablicę, która zawiera jedną <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.       Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest starsze technologia, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation."
    return:
      type: System.Object
      description: "Żądany obiekt lub <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Jeśli <code> typeName </code> nie można odnaleźć."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>Nie znaleziono."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>Nie znaleziono w <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Znaleziono nie publicznego konstruktora bez parametrów."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Obiekt wywołujący nie ma wystarczających uprawnień do wywoływania tego konstruktora."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>nie jest prawidłowym zestawem.       - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <code>assemblyName</code> został skompilowany przy użyciu nowszej wersji."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Tworzy nowe wystąpienie określonego typu zdefiniowane w pliku określonego zestawu określenie, czy jest ignorowana w przypadku nazwy typu. atrybuty wiązania i integratorów, które służą do wybierania typu, który ma zostać utworzony; Argumenty konstruktora; Kultura; i atrybuty aktywacji."
  remarks: "Jest to metoda wygody, łączącą <xref:System.AppDomain.CreateInstanceFrom%2A>i <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A>       Aby uzyskać więcej informacji na temat tej metody, zobacz <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metody.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Nazwa pliku i ścieżka zestawu, który definiuje żądanego typu."
    - id: typeName
      type: System.String
      description: "W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; właściwości."
    - id: ignoreCase
      type: System.Boolean
      description: "Wartość logiczna określająca, czy można wykonać wyszukiwanie z uwzględnieniem wielkości liter, czy nie."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Kombinacja zero lub więcej flag bitowych, które mają wpływ na wyszukiwanie `typeName` konstruktora. Jeśli `bindingAttr` jest zero, wyszukiwanie jest przeprowadzane konstruktorów publicznych."
    - id: binder
      type: System.Reflection.Binder
      description: "Obiekt, który umożliwia powiązanie koercja argumentu typy, wywołania elementów członkowskich i pobieranie <xref:System.Reflection.MemberInfo>obiektów przez odbicie.</xref:System.Reflection.MemberInfo> Jeśli `binder` jest wartość null, jest używany domyślny integrator."
    - id: args
      type: System.Object[]
      description: "Argumenty do przekazania do konstruktora. Ta tablica argumentów musi zgodne w polu numer zamówienia i wpisz parametry konstruktora do wywołania. Jeśli domyślny konstruktor jest preferowana, `args` musi być pustą tablicą ani mieć wartości null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Informacje specyficzne dla kultury, które kontroluje koercja z `args` typom posiadanie zadeklarowanym dla `typeName` konstruktora. Jeśli `culture` jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref:System.Globalization.CultureInfo>służy bieżącego wątku.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Tablica jeden lub więcej atrybutów, które mogą uczestniczyć w aktywacji. Zazwyczaj tablicę, która zawiera jedną <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.       Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation."
    return:
      type: System.Object
      description: "Żądany obiekt lub <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Jeśli <code> typeName </code> nie można odnaleźć."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>Nie znaleziono."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>Nie znaleziono w <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Brak pasującego konstruktora publicznego został znaleziony."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Obiekt wywołujący nie ma wystarczających uprawnień do wywoływania tego konstruktora."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>nie jest prawidłowym zestawem.       - lub - <code>assemblyName</code> został skompilowany przy użyciu nowszej wersji środowiska CLR wersji, która jest obecnie załadowane."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Tworzy nowe wystąpienie określonego typu zdefiniowane w pliku określonego zestawu."
  remarks: "Jest to metoda wygody, łączącą <xref:System.AppDomain.CreateInstanceFrom%2A>i <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName> </xref:System.AppDomain.CreateInstanceFrom%2A>       Aby uzyskać więcej informacji na temat tej metody, zobacz <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>metody.</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Nazwa pliku i ścieżka zestawu, który definiuje żądanego typu."
    - id: typeName
      type: System.String
      description: "W pełni kwalifikowana nazwa żądanego typu, łącznie z przestrzeni nazw, ale nie zestaw zwrócony przez &lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt; właściwości."
    - id: ignoreCase
      type: System.Boolean
      description: "Wartość logiczna określająca, czy można wykonać wyszukiwanie z uwzględnieniem wielkości liter, czy nie."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Kombinacja zero lub więcej flag bitowych, które mają wpływ na wyszukiwanie `typeName` konstruktora. Jeśli `bindingAttr` jest zero, wyszukiwanie jest przeprowadzane konstruktorów publicznych."
    - id: binder
      type: System.Reflection.Binder
      description: "Obiekt, który umożliwia powiązanie koercja argumentu typy, wywołania elementów członkowskich i pobieranie <xref:System.Reflection.MemberInfo>obiektów przez odbicie.</xref:System.Reflection.MemberInfo> Jeśli `binder` jest wartość null, jest używany domyślny integrator."
    - id: args
      type: System.Object[]
      description: "Argumenty do przekazania do konstruktora. Ta tablica argumentów musi zgodne w polu numer zamówienia i wpisz parametry konstruktora do wywołania. Jeśli domyślny konstruktor jest preferowana, `args` musi być pustą tablicą ani mieć wartości null."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Informacje specyficzne dla kultury, które kontroluje koercja z `args` typom posiadanie zadeklarowanym dla `typeName` konstruktora. Jeśli `culture` jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref:System.Globalization.CultureInfo>służy bieżącego wątku.</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "Tablica jeden lub więcej atrybutów, które mogą uczestniczyć w aktywacji. Zazwyczaj tablicę, która zawiera jedną <xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;> </xref> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.       Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation."
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "Informacje używane do tworzenia autoryzacji `typeName`."
    return:
      type: System.Object
      description: "Żądany obiekt lub <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Jeśli <code> typeName </code> nie można odnaleźć."
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <xref href=&quot;System.MarshalByRefObject&quot;> </xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>Nie znaleziono."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>Nie znaleziono w <code>assemblyName</code>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Brak pasującego konstruktora publicznego został znaleziony."
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "Obiekt wywołujący nie ma wystarczających uprawnień do wywoływania tego konstruktora."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>nie jest prawidłowym zestawem.       - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <code>assemblyName</code> został skompilowany przy użyciu nowszej wersji."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  platform:
  - net462
- uid: System.AppDomain.CurrentDomain
  id: CurrentDomain
  parent: System.AppDomain
  langs:
  - csharp
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
  fullName: System.AppDomain.CurrentDomain
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera bieżącej domeny aplikacji dla bieżącego <xref href=&quot;System.Threading.Thread&quot;> </xref>."
  remarks: ''
  example:
  - "The following code example creates a new application domain. The CurrentDomain property is used to obtain an <xref:System.AppDomain> object that represents the current application domain. The <xref:System.AppDomain.FriendlyName%2A> property provides the name of the current application domain, which is then displayed at the command line.  \n  \n [!code-vb[ADApplicationBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.curre_1.vb)]\n [!code-cpp[ADApplicationBase#1](~/add/codesnippet/cpp/p-system.appdomain.curre_1.cpp)]\n [!code-cs[ADApplicationBase#1](~/add/codesnippet/csharp/p-system.appdomain.curre_1.cs)]"
  syntax:
    content: public static AppDomain CurrentDomain { get; }
    return:
      type: System.AppDomain
      description: "Bieżącej domeny aplikacji."
  overload: System.AppDomain.CurrentDomain*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definiuje dynamicznego zestawu z określonym trybem nazwy i dostępu."
  remarks: "Tej metody należy tylko zdefiniować zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>przeciążenie metody.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Podczas tworzenia kodu, który emituje zestawów dynamicznych, zaleca się używanie przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A>metodę, która określa dowód i uprawnienia, podaj dowód ma zestawie dynamicznym ma i zawierać <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>w `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> W tym <xref:System.Security.Permissions.SecurityPermissionFlag>w `refusedPermissions` parametru zapewnia, że MSIL jest weryfikowany.</xref:System.Security.Permissions.SecurityPermissionFlag> Ograniczenie tej metody jest, że powoduje także <xref:System.Security.SecurityException>zostanie wygenerowany, gdy jest używany z kodu, który wymaga pełnego zaufania.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the DefineDynamicAssembly method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/ec69fa93-4aea-4fc8-90e1-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/ec69fa93-4aea-4fc8-90e1-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/ec69fa93-4aea-4fc8-90e1-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Unikatową tożsamość zestawu dynamicznego."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "Tryb dostępu dla zestawów dynamicznych."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Dynamiczne zestawu z określonym trybem nazwy i dostępu."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - lub - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> właściwość <code> name </code> rozpoczyna się od biały znak lub zawiera ukośnik do przodu lub do tyłu."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definiuje dynamicznego zestawu o określonej nazwie, tryb dostępu oraz atrybuty niestandardowe."
  remarks: "Użyj tego przeciążenia metody, aby określić atrybuty, które nie działają prawidłowo, chyba że są one stosowane podczas tworzenia zestawu dynamicznego. Na przykład zabezpieczeń atrybuty, takie jak <xref:System.Security.SecurityTransparentAttribute>i <xref:System.Security.SecurityCriticalAttribute>nie działają prawidłowo, jeśli są one dodawane po utworzeniu zestawu dynamicznego.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       Tej metody należy użyć tylko w celu zdefiniowania zestawu dynamicznego w bieżącej domeny aplikacji. Aby uzyskać więcej informacji na temat tego ograniczenia, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>przeciążenie metody.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>       To przeciążenie metody została wprowadzona w systemie [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]."
  example:
  - "The following code sample shows how to create a dynamic assembly that has the <xref:System.Security.SecurityTransparentAttribute>. The attribute must be specified as an element of an array of <xref:System.Reflection.Emit.CustomAttributeBuilder> objects.  \n  \n The first step in creating the <xref:System.Reflection.Emit.CustomAttributeBuilder> is to obtain a constructor for the attribute. The constructor has no parameters, so the <xref:System.Type.GetConstructor%2A> method is called with an empty array of <xref:System.Type> objects to represent the types of the parameters. The second step is to pass the resulting <xref:System.Reflection.ConstructorInfo> object to the constructor for the <xref:System.Reflection.Emit.CustomAttributeBuilder> class, together with an empty array of type <xref:System.Object> to represent the arguments.  \n  \n The resulting <xref:System.Reflection.Emit.CustomAttributeBuilder> is then passed to the DefineDynamicAssembly method as the only element of an array.  \n  \n The example code defines a module and a type in the new dynamic assembly, and then displays the assembly's attributes.  \n  \n [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/cpp/02b9ff71-a699-4692-a2ae-_1.cpp)]\n [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/visualbasic/02b9ff71-a699-4692-a2ae-_1.vb)]\n [!code-cs[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/csharp/02b9ff71-a699-4692-a2ae-_1.cs)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Unikatową tożsamość zestawu dynamicznego."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "Tryb dostępu dla zestawów dynamicznych."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "Wyliczalny listę atrybutów, które ma zostać zastosowany do zestawu, lub <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Jeśli istnieją żadne atrybuty."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Dynamiczne zestawu z określoną nazwą i funkcje."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - lub - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> właściwość <code> name </code> rozpoczyna się od biały znak lub zawiera ukośnik do przodu lub do tyłu."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definiuje zestawie dynamicznym przy użyciu określonej nazwy, tryb dostępu i dokumenty."
  remarks: "Tylko w pełni zaufane obiekty wywołujące można podać ich `evidence` podczas definiowania dynamicznie <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> Środowisko uruchomieniowe przypisze <xref:System.Security.Policy.Evidence>za pomocą zasad zabezpieczeń, aby określić uprawnienia nadanego.</xref:System.Security.Policy.Evidence> Częściowo zaufane obiekty wywołujące należy podać wartość null `evidence`. Jeśli `evidence` jest `null`, środowisko uruchomieniowe kopiuje zestawy uprawnień, czyli bieżącego udzielania i odmawiania zestawów z obiektu wywołującego <xref:System.Reflection.Assembly>do dynamicznej <xref:System.Reflection.Assembly>definiowanego i oznacza zasad jako rozwiązane.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Jeśli dynamiczny <xref:System.Reflection.Assembly>jest zapisywany na dysku, kolejne obciążeń otrzyma przyznaje na podstawie zasad związane z lokalizacją gdzie <xref:System.Reflection.Assembly>został zapisany.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Tej metody należy tylko zdefiniować zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>przeciążenie metody.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Podczas tworzenia kodu, który emituje zestawów dynamicznych, zaleca się używanie przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A>metodę, która określa dowód i uprawnienia, podaj dowód ma zestawie dynamicznym ma i zawierać <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>w `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> W tym <xref:System.Security.Permissions.SecurityPermissionFlag>w `refusedPermissions` parametru zapewnia, że MSIL jest weryfikowany.</xref:System.Security.Permissions.SecurityPermissionFlag> Ograniczenie tej metody jest, że powoduje także <xref:System.Security.SecurityException>zostanie wygenerowany, gdy jest używany z kodu, który wymaga pełnego zaufania.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and the <xref:System.AppDomain.AssemblyResolve> event.  \n  \n First, the code example tries to create an instance of `MyDynamicType` by calling the <xref:System.AppDomain.CreateInstance%2A> method with an invalid assembly name, and catches the resulting exception.  \n  \n The code example then adds an event handler for the <xref:System.AppDomain.AssemblyResolve> event, and again tries to create an instance of`MyDynamicType`. During the call to <xref:System.AppDomain.CreateInstance%2A>, the <xref:System.AppDomain.AssemblyResolve> event is raised for the invalid assembly. The event handler creates a dynamic assembly that contains a type named `MyDynamicType`, gives the type a parameterless constructor, and returns the new dynamic assembly. The call to <xref:System.AppDomain.CreateInstance%2A> then finishes successfully, and the constructor for `MyDynamicType` displays a message at the console.  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/1d1d705b-aac9-4233-8756-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/1d1d705b-aac9-4233-8756-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/1d1d705b-aac9-4233-8756-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Unikatową tożsamość zestawu dynamicznego."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "Tryb, w którym będzie dostępna w zestawie dynamicznym."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Dowody dla zestawów dynamicznych. Jest używany dowód niezmieniony jako ostatecznego zestawu dowód używany do rozpoznawania zasad."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Dynamiczne zestawu z określoną nazwą i funkcje."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - lub - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> właściwość <code> name </code> rozpoczyna się od biały znak lub zawiera ukośnik do przodu lub do tyłu."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definiuje zestawie dynamicznym przy użyciu określonej nazwy, tryb dostępu i katalog magazynu."
  remarks: "Tej metody należy tylko zdefiniować zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>przeciążenie metody.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Podczas tworzenia kodu, który emituje zestawów dynamicznych, zaleca się używanie przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A>metodę, która określa dowód i uprawnienia, podaj dowód ma zestawie dynamicznym ma i zawierać <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>w `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> W tym <xref:System.Security.Permissions.SecurityPermissionFlag>w `refusedPermissions` parametru zapewnia, że MSIL jest weryfikowany.</xref:System.Security.Permissions.SecurityPermissionFlag> Ograniczenie tej metody jest, że powoduje także <xref:System.Security.SecurityException>zostanie wygenerowany, gdy jest używany z kodu, który wymaga pełnego zaufania.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/f3a30d18-28ff-4503-b1c6-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/f3a30d18-28ff-4503-b1c6-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/f3a30d18-28ff-4503-b1c6-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Unikatową tożsamość zestawu dynamicznego."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "Tryb, w którym będzie dostępna w zestawie dynamicznym."
    - id: dir
      type: System.String
      description: "Nazwa katalogu, w którym zostanie zapisany zestaw. Jeśli `dir` jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, domyślne ustawienia katalogu do bieżącego katalogu."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Dynamiczne zestawu z określoną nazwą i funkcje."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - lub - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> właściwość <code> name </code> rozpoczyna się od biały znak lub zawiera ukośnik do przodu lub do tyłu."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definiuje dynamicznego zestawu o określonej nazwie, tryb dostępu oraz atrybuty niestandardowe, a jego kontekstu zabezpieczeń przy użyciu określonego źródła."
  remarks: "Użyj tego przeciążenia metody, aby określić atrybuty, które nie działają prawidłowo, chyba że są one stosowane podczas tworzenia zestawu dynamicznego. Na przykład zabezpieczeń atrybuty, takie jak <xref:System.Security.SecurityTransparentAttribute>i <xref:System.Security.SecurityCriticalAttribute>nie działają prawidłowo, jeśli są one dodawane po utworzeniu zestawu dynamicznego.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       Tej metody należy użyć tylko w celu zdefiniowania zestawu dynamicznego w bieżącej domeny aplikacji. Aby uzyskać więcej informacji na temat tego ograniczenia, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>przeciążenie metody.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes, System.Security.SecurityContextSource securityContextSource);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Unikatową tożsamość zestawu dynamicznego."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "Tryb dostępu dla zestawów dynamicznych."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "Wyliczalny listę atrybutów, które ma zostać zastosowany do zestawu, lub <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Jeśli istnieją żadne atrybuty."
    - id: securityContextSource
      type: System.Security.SecurityContextSource
      description: "Źródło kontekstu zabezpieczeń."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Dynamiczne zestawu z określoną nazwą i funkcje."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - lub - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> właściwość <code> name </code> rozpoczyna się od biały znak lub zawiera ukośnik do przodu lub do tyłu."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Wartość <code> securityContextSource </code> nie jest jedną z wartości wyliczenia."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definiuje przy użyciu określonej nazwy, tryb dostępu, katalog magazynu i dowód zestawie dynamicznym."
  remarks: "Tylko w pełni zaufane obiekty wywołujące można podać ich `evidence` podczas definiowania dynamicznie <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> Środowisko uruchomieniowe przypisze <xref:System.Security.Policy.Evidence>za pomocą zasad zabezpieczeń, aby określić uprawnienia nadanego.</xref:System.Security.Policy.Evidence> Częściowo zaufane obiekty wywołujące należy podać wartość null `evidence`. Jeśli `evidence` jest `null`, środowisko uruchomieniowe kopiuje zestawy uprawnień, czyli bieżącego udzielania i odmawiania zestawów z obiektu wywołującego <xref:System.Reflection.Assembly>do dynamicznej <xref:System.Reflection.Assembly>definiowanego i oznacza zasad jako rozwiązane.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Jeśli dynamiczny <xref:System.Reflection.Assembly>jest zapisywany na dysku, kolejne obciążeń otrzyma przyznaje na podstawie zasad związane z lokalizacją gdzie <xref:System.Reflection.Assembly>został zapisany.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Tej metody należy tylko zdefiniować zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>przeciążenie metody.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > Podczas tworzenia kodu, który emituje zestawów dynamicznych, zaleca się używanie przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A>metodę, która określa dowód i uprawnienia, podaj dowód ma zestawie dynamicznym ma i zawierać <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>w `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> W tym <xref:System.Security.Permissions.SecurityPermissionFlag>w `refusedPermissions` parametru zapewnia, że MSIL jest weryfikowany.</xref:System.Security.Permissions.SecurityPermissionFlag> Ograniczenie tej metody jest, że powoduje także <xref:System.Security.SecurityException>zostanie wygenerowany, gdy jest używany z kodu, który wymaga pełnego zaufania.</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/2cf98986-7843-48cf-a73f-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/2cf98986-7843-48cf-a73f-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/2cf98986-7843-48cf-a73f-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Unikatową tożsamość zestawu dynamicznego."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "Tryb, w którym będzie dostępna w zestawie dynamicznym."
    - id: dir
      type: System.String
      description: "Nazwa katalogu, w którym zostanie zapisany zestaw. Jeśli `dir` jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, domyślne ustawienia katalogu do bieżącego katalogu."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Dowody dla zestawów dynamicznych. Jest używany dowód niezmieniony jako ostatecznego zestawu dowód używany do rozpoznawania zasad."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Dynamiczne zestawu z określoną nazwą i funkcje."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - lub - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> właściwość <code> name </code> rozpoczyna się od biały znak lub zawiera ukośnik do przodu lub do tyłu."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definiuje zestawie dynamicznym przy użyciu określonej nazwy, tryb dostępu i żądania uprawnień."
  remarks: "Żądania uprawnień określony dla `requiredPermissions`, `optionalPermissions`, i `refusedPermissions` nie są używane, chyba że dynamicznego zestawu został zapisany i ponownie załadowana do pamięci. Aby określić żądanych uprawnień dla zestawu przejściowego, który nie jest zapisywany na dysku, użyj przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A>metodę, która określa jako również jako żądane uprawnienia i podaj dowód <xref:System.Security.Policy.Evidence>obiektu.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.DefineDynamicAssembly%2A>      > [!NOTE] > Podczas tworzenia kodu, który emituje zestawów dynamicznych, zaleca się używanie przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A>metodę, która określa dowód i uprawnienia, podaj dowód ma zestawie dynamicznym ma i zawierać <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>w `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> W tym <xref:System.Security.Permissions.SecurityPermissionFlag>w `refusedPermissions` parametru zapewnia, że MSIL jest weryfikowany.</xref:System.Security.Permissions.SecurityPermissionFlag> Ograniczenie tej metody jest, że powoduje także <xref:System.Security.SecurityException>zostanie wygenerowany, gdy jest używany z kodu, który wymaga pełnego zaufania.</xref:System.Security.SecurityException>       Tej metody należy tylko zdefiniować zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>przeciążenie metody.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/be48f0dd-e58f-4a8c-bdad-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/be48f0dd-e58f-4a8c-bdad-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/be48f0dd-e58f-4a8c-bdad-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Unikatową tożsamość zestawu dynamicznego."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "Tryb, w którym będzie dostępna w zestawie dynamicznym."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Żądanie wymaganych uprawnień."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "Żądanie uprawnienia opcjonalne."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "Żądanie uprawnienia odrzucony."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Dynamiczne zestawu z określoną nazwą i funkcje."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - lub - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> właściwość <code> name </code> rozpoczyna się od biały znak lub zawiera ukośnik do przodu lub do tyłu."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definiuje zestawie dynamicznym przy użyciu określonej nazwy, tryb dostępu, katalog magazynu i opcji synchronizacji."
  remarks: "Użyj tego przeciążenia metody, aby określić atrybuty, które nie działają prawidłowo, chyba że są one stosowane podczas tworzenia zestawu dynamicznego. Na przykład zabezpieczeń atrybuty, takie jak <xref:System.Security.SecurityTransparentAttribute>i <xref:System.Security.SecurityCriticalAttribute>nie działają prawidłowo, jeśli są one dodawane po utworzeniu zestawu dynamicznego.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       Jeśli `isSynchronized` jest `true`, z następujących metod powstałe w ten sposób <xref:System.Reflection.Emit.AssemblyBuilder>zostaną zsynchronizowane: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>i <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> Jeśli dwa z tych metod są nazywane w różnych wątkach, blokuje ukończenie innych."
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Unikatową tożsamość zestawu dynamicznego."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "Tryb, w którym będzie dostępna w zestawie dynamicznym."
    - id: dir
      type: System.String
      description: "Nazwa katalogu, w którym zostanie zapisany w zestawie dynamicznym. Jeśli `dir` jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, bieżący katalog jest używany."
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby zsynchronizować tworzenia modułów, typy i elementy członkowskie w zestawie dynamicznym; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "Wyliczalny listę atrybutów, które ma zostać zastosowany do zestawu, lub <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Jeśli istnieją żadne atrybuty."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Dynamiczne zestawu z określoną nazwą i funkcje."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - lub - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> właściwość <code> name </code> rozpoczyna się od biały znak lub zawiera ukośnik do przodu lub do tyłu."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definiuje zestawie dynamicznym przy użyciu określonej nazwy, tryb dostępu, dowód i żądania uprawnień."
  remarks: "Żądania uprawnień określony dla `requiredPermissions`, `optionalPermissions`, i `refusedPermissions` są używane tylko wtedy, gdy `evidence` jest także dostarczany, lub jeśli w zestawie dynamicznym jest zapisany i ponownie załadowana do pamięci.      > [!NOTE] > Podczas tworzenia kodu, który emituje zestawów dynamicznych zalecane jest, że obejmuje <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>w `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> W tym <xref:System.Security.Permissions.SecurityPermissionFlag>w `refusedPermissions` parametru zapewnia, że MSIL jest weryfikowany.</xref:System.Security.Permissions.SecurityPermissionFlag> Ograniczenie tej metody jest, że powoduje także <xref:System.Security.SecurityException>zostanie wygenerowany, gdy jest używany z kodu, który wymaga pełnego zaufania.</xref:System.Security.SecurityException>       Tylko w pełni zaufane obiekty wywołujące można podać ich `evidence` podczas definiowania dynamicznie <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> Środowisko uruchomieniowe przypisze <xref:System.Security.Policy.Evidence>za pomocą zasad zabezpieczeń, aby określić uprawnienia nadanego.</xref:System.Security.Policy.Evidence> Częściowo zaufane obiekty wywołujące należy podać wartość null `evidence`. Jeśli `evidence` jest `null`, środowisko uruchomieniowe kopiuje zestawy uprawnień, czyli bieżącego udzielania i odmawiania zestawów z obiektu wywołującego <xref:System.Reflection.Assembly>do dynamicznej <xref:System.Reflection.Assembly>definiowanego i oznacza zasad jako rozwiązane.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Jeśli dynamiczny <xref:System.Reflection.Assembly>jest zapisywany na dysku, kolejne obciążeń otrzyma przyznaje na podstawie zasad związane z lokalizacją gdzie <xref:System.Reflection.Assembly>został zapisany.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Tej metody należy tylko zdefiniować zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>przeciążenie metody.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/7d7c7162-9e00-4b91-93d0-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/7d7c7162-9e00-4b91-93d0-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/7d7c7162-9e00-4b91-93d0-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Unikatową tożsamość zestawu dynamicznego."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "Tryb, w którym będzie dostępna w zestawie dynamicznym."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Dowody dla zestawów dynamicznych. Jest używany dowód niezmieniony jako ostatecznego zestawu dowód używany do rozpoznawania zasad."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Żądanie wymaganych uprawnień."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "Żądanie uprawnienia opcjonalne."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "Żądanie uprawnienia odrzucony."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Dynamiczne zestawu z określoną nazwą i funkcje."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - lub - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> właściwość <code> name </code> rozpoczyna się od biały znak lub zawiera ukośnik do przodu lub do tyłu."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definiuje zestawie dynamicznym przy użyciu określonej nazwy, tryb dostępu, katalog magazynu i żądania uprawnień."
  remarks: "Żądania uprawnień określony dla `requiredPermissions`, `optionalPermissions`, i `refusedPermissions` nie są używane, chyba że dynamicznego zestawu został zapisany i ponownie załadowana do pamięci. Aby określić żądanych uprawnień dla zestawu przejściowego, który nie jest zapisywany na dysku, użyj przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A>metodę, która określa jako również jako żądane uprawnienia i podaj dowód <xref:System.Security.Policy.Evidence>obiektu.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.DefineDynamicAssembly%2A>      > [!NOTE] > Podczas tworzenia kodu, który emituje zestawów dynamicznych, zaleca się używanie przeciążenia <xref:System.AppDomain.DefineDynamicAssembly%2A>metodę, która określa dowód i uprawnienia, podaj dowód ma zestawie dynamicznym ma i zawierać <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>w `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> W tym <xref:System.Security.Permissions.SecurityPermissionFlag>w `refusedPermissions` parametru zapewnia, że MSIL jest weryfikowany.</xref:System.Security.Permissions.SecurityPermissionFlag> Ograniczenie tej metody jest, że powoduje także <xref:System.Security.SecurityException>zostanie wygenerowany, gdy jest używany z kodu, który wymaga pełnego zaufania.</xref:System.Security.SecurityException>       Tej metody należy tylko zdefiniować zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>przeciążenie metody.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/0fc3676e-96ff-42c6-ad25-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/0fc3676e-96ff-42c6-ad25-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/0fc3676e-96ff-42c6-ad25-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Unikatową tożsamość zestawu dynamicznego."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "Tryb, w którym będzie dostępna w zestawie dynamicznym."
    - id: dir
      type: System.String
      description: "Nazwa katalogu, w którym zostanie zapisany zestaw. Jeśli `dir` jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, domyślne ustawienia katalogu do bieżącego katalogu."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Żądanie wymaganych uprawnień."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "Żądanie uprawnienia opcjonalne."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "Żądanie uprawnienia odrzucony."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Dynamiczne zestawu z określoną nazwą i funkcje."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - lub - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> właściwość <code> name </code> rozpoczyna się od biały znak lub zawiera ukośnik do przodu lub do tyłu."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definiuje zestawie dynamicznym przy użyciu określonej nazwy, tryb dostępu, katalog magazynu, dowód i żądania uprawnień."
  remarks: "Żądania uprawnień określony dla `requiredPermissions`, `optionalPermissions`, i `refusedPermissions` są używane tylko wtedy, gdy `evidence` jest także dostarczany, lub jeśli w zestawie dynamicznym jest zapisany i ponownie załadowana do pamięci.      > [!NOTE] > Podczas tworzenia kodu, który emituje zestawów dynamicznych zalecane jest, że obejmuje <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>w `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> W tym <xref:System.Security.Permissions.SecurityPermissionFlag>w `refusedPermissions` parametru zapewnia, że MSIL jest weryfikowany.</xref:System.Security.Permissions.SecurityPermissionFlag> Ograniczenie tej metody jest, że powoduje także <xref:System.Security.SecurityException>zostanie wygenerowany, gdy jest używany z kodu, który wymaga pełnego zaufania.</xref:System.Security.SecurityException>       Tylko w pełni zaufane obiekty wywołujące można podać ich `evidence` podczas definiowania dynamicznie <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> Środowisko uruchomieniowe przypisze <xref:System.Security.Policy.Evidence>za pomocą zasad zabezpieczeń, aby określić uprawnienia nadanego.</xref:System.Security.Policy.Evidence> Częściowo zaufane obiekty wywołujące należy podać wartość null `evidence`. Jeśli `evidence` jest `null`, środowisko uruchomieniowe kopiuje zestawy uprawnień, czyli bieżącego udzielania i odmawiania zestawów z obiektu wywołującego <xref:System.Reflection.Assembly>do dynamicznej <xref:System.Reflection.Assembly>definiowanego i oznacza zasad jako rozwiązane.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Jeśli dynamiczny <xref:System.Reflection.Assembly>jest zapisywany na dysku, kolejne obciążeń otrzyma przyznaje na podstawie zasad związane z lokalizacją gdzie <xref:System.Reflection.Assembly>został zapisany.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Tej metody należy tylko zdefiniować zestawu dynamicznego w bieżącej domenie aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>przeciążenie metody.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/0baa3466-02cf-4d9c-bb66-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/0baa3466-02cf-4d9c-bb66-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/0baa3466-02cf-4d9c-bb66-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Unikatową tożsamość zestawu dynamicznego."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "Tryb, w którym będzie dostępna w zestawie dynamicznym."
    - id: dir
      type: System.String
      description: "Nazwa katalogu, w którym zostanie zapisany zestaw. Jeśli `dir` jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, domyślne ustawienia katalogu do bieżącego katalogu."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Dowody dla zestawów dynamicznych. Jest używany dowód niezmieniony jako ostatecznego zestawu dowód używany do rozpoznawania zasad."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Żądanie wymaganych uprawnień."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "Żądanie uprawnienia opcjonalne."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "Żądanie uprawnienia odrzucony."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Dynamiczne zestawu z określoną nazwą i funkcje."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - lub - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> właściwość <code> name </code> rozpoczyna się od biały znak lub zawiera ukośnik do przodu lub do tyłu."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definiuje zestawie dynamicznym przy użyciu określonej nazwy, tryb dostępu, katalog magazynu dowód, żądania uprawnień i opcji synchronizacji."
  remarks: "Żądania uprawnień określony dla `requiredPermissions`, `optionalPermissions`, i `refusedPermissions` są używane tylko wtedy, gdy `evidence` jest także dostarczany, lub jeśli w zestawie dynamicznym jest zapisany i ponownie załadowana do pamięci.      > [!NOTE] > Podczas tworzenia kodu, który emituje zestawów dynamicznych zalecane jest, że obejmuje <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>w `refusedPermissions`.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> W tym <xref:System.Security.Permissions.SecurityPermissionFlag>w `refusedPermissions` parametru zapewnia, że MSIL jest weryfikowany.</xref:System.Security.Permissions.SecurityPermissionFlag> Ograniczenie tej metody jest, że powoduje także <xref:System.Security.SecurityException>zostanie wygenerowany, gdy jest używany z kodu, który wymaga pełnego zaufania.</xref:System.Security.SecurityException>       Tylko w pełni zaufane obiekty wywołujące mogą udowodnić ich podczas definiowania dynamicznie <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> Środowisko uruchomieniowe przypisze <xref:System.Security.Policy.Evidence>za pomocą zasad zabezpieczeń, aby określić uprawnienia nadanego.</xref:System.Security.Policy.Evidence> Częściowo zaufane obiekty wywołujące należy podać `null` dla `evidence` parametru. Jeśli `evidence` jest `null`, środowisko uruchomieniowe kopiuje zestawy uprawnień, czyli bieżącego udzielania i odmawiania zestawów z obiektu wywołującego <xref:System.Reflection.Assembly>do dynamicznej <xref:System.Reflection.Assembly>definiowanego i oznacza zasad jako rozwiązane.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Jeśli dynamiczny <xref:System.Reflection.Assembly>jest zapisywany na dysku, kolejne obciążeń otrzyma przyznaje na podstawie zasad związane z lokalizacją gdzie <xref:System.Reflection.Assembly>został zapisany.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       Jeśli `isSynchronized` jest `true`, z następujących metod powstałe w ten sposób <xref:System.Reflection.Emit.AssemblyBuilder>zostaną zsynchronizowane: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>i <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> Jeśli dwa z tych metod są nazywane w różnych wątkach, zablokuje innych zakończenia."
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/84dd3b17-5601-467b-b1e3-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/84dd3b17-5601-467b-b1e3-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/84dd3b17-5601-467b-b1e3-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Unikatową tożsamość zestawu dynamicznego."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "Tryb, w którym będzie dostępna w zestawie dynamicznym."
    - id: dir
      type: System.String
      description: "Nazwa katalogu, w którym zostanie zapisany w zestawie dynamicznym. Jeśli `dir` jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, domyślne ustawienia katalogu do bieżącego katalogu."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Dowody dla zestawów dynamicznych. Jest używany dowód niezmieniony jako ostatecznego zestawu dowód używany do rozpoznawania zasad."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Żądanie wymaganych uprawnień."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "Żądanie uprawnienia opcjonalne."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "Żądanie uprawnienia odrzucony."
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby zsynchronizować tworzenia modułów, typy i elementy członkowskie w zestawie dynamicznym; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Dynamiczne zestawu z określoną nazwą i funkcje."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - lub - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> właściwość <code> name </code> rozpoczyna się od biały znak lub zawiera ukośnik do przodu lub do tyłu."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Definiuje dynamicznego zestawu z określoną nazwą, tryb dostępu, katalog magazynu, dowód, żądania uprawnień, opcja synchronizacji i atrybuty niestandardowe."
  remarks: "Użyj tego przeciążenia metody, aby określić atrybuty, które nie działają prawidłowo, chyba że są one stosowane podczas tworzenia zestawu dynamicznego. Na przykład zabezpieczeń atrybuty, takie jak <xref:System.Security.SecurityTransparentAttribute>i <xref:System.Security.SecurityCriticalAttribute>nie działają prawidłowo, jeśli są one dodawane po utworzeniu zestawu dynamicznego.</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       Żądania uprawnień określony dla `requiredPermissions`, `optionalPermissions`, i `refusedPermissions` tylko wtedy, gdy są używane parametry `evidence` również podano parametr, lub jeśli w zestawie dynamicznym jest zapisany i ponownie załadowana do pamięci.      > [!NOTE] > Podczas opracowywania kod, który emituje zestawów dynamicznych, firma Microsoft zaleca możesz uwzględnić <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>oflagowane w `refusedPermissions` parametru.</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> Włączenie tej flagi zapewnia, że zostaną zweryfikowane język pośredni (MSIL) firmy Microsoft. Ta technika wykryje niezamierzone Generowanie zweryfikowanie kodu, które w przeciwnym razie jest bardzo trudne do wykrycia. Ograniczenie tej metody jest, że powoduje także <xref:System.Security.SecurityException>zostanie wygenerowany, gdy jest używany z kodem, który wymaga pełnego zaufania.</xref:System.Security.SecurityException>       Tylko w pełni zaufane obiekty wywołujące mogą udowodnić podczas definiowania dynamicznie <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> Środowisko uruchomieniowe mapuje <xref:System.Security.Policy.Evidence>za pomocą zasad zabezpieczeń, aby określić uprawnienia nadanego.</xref:System.Security.Policy.Evidence> Częściowo zaufane obiekty wywołujące należy podać `null` dla `evidence` parametru. Jeśli `evidence` jest `null`, środowisko uruchomieniowe kopiuje zestawów uprawnienia (które jest bieżącym grant i odmowy zestawy) z zestawu obiektu wywołującego do dynamicznego zestawu, który jest definiowany i oznacza zasady jako rozwiązane.       Jeśli w zestawie dynamicznym jest zapisywany na dysku, kolejne obciążenie otrzyma przyznaje na podstawie zasad, które są skojarzone z lokalizacji, w którym zapisano w zestawie dynamicznym.       Jeśli `isSynchronized` jest `true`, z następujących metod powstałe w ten sposób <xref:System.Reflection.Emit.AssemblyBuilder>zostaną zsynchronizowane: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>i <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> Jeśli dwa z tych metod są nazywane w różnych wątkach, blokuje ukończenie innych.       To przeciążenie metody została wprowadzona w systemie [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]."
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "Unikatową tożsamość zestawu dynamicznego."
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "Tryb, w którym będzie dostępna w zestawie dynamicznym."
    - id: dir
      type: System.String
      description: "Nazwa katalogu, w którym zostanie zapisany w zestawie dynamicznym. Jeśli `dir` jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, bieżący katalog jest używany."
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Dowód, że dostarczonej dla zestawu dynamicznego. Jest używany dowód niezmieniony jako ostatecznego zestawu dowód używany do rozpoznawania zasad."
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "Żądanie wymaganych uprawnień."
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "Żądanie uprawnienia opcjonalne."
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "Żądanie uprawnienia odrzucony."
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby zsynchronizować tworzenia modułów, typy i elementy członkowskie w zestawie dynamicznym; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "Wyliczalny listę atrybutów, które ma zostać zastosowany do zestawu, lub <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Jeśli istnieją żadne atrybuty."
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "Dynamiczne zestawu z określoną nazwą i funkcje."
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - lub - <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> właściwość <code> name </code> rozpoczyna się od biały znak lub zawiera ukośnik do przodu lub do tyłu."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  id: DoCallBack(System.CrossAppDomainDelegate)
  parent: System.AppDomain
  langs:
  - csharp
  name: DoCallBack(CrossAppDomainDelegate)
  nameWithType: AppDomain.DoCallBack(CrossAppDomainDelegate)
  fullName: System.AppDomain.DoCallBack(CrossAppDomainDelegate)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Wykonuje kod w innej domenie aplikacji, identyfikowany przez określonego delegata."
  remarks: '`callBackDelegate`można określić marshal za wartość, <xref:System.MarshalByRefObject>, lub <xref:System.ContextBoundObject>.</xref:System.ContextBoundObject> </xref:System.MarshalByRefObject>'
  example:
  - "The following sample demonstrates using a static DoCallBack method.  \n  \n [!code-vb[AppDomain_DoCallBack#1](~/add/codesnippet/visualbasic/m-system.appdomain.docal_1.vb)]\n [!code-cpp[AppDomain_DoCallBack#1](~/add/codesnippet/cpp/m-system.appdomain.docal_1.cpp)]\n [!code-cs[AppDomain_DoCallBack#1](~/add/codesnippet/csharp/m-system.appdomain.docal_1.cs)]  \n  \n The following sample demonstrates using the DoCallBack method by value.  \n  \n [!code-vb[AppDomain_DoCallBack#2](~/add/codesnippet/visualbasic/m-system.appdomain.docal_2.vb)]\n [!code-cs[AppDomain_DoCallBack#2](~/add/codesnippet/csharp/m-system.appdomain.docal_2.cs)]\n [!code-cpp[AppDomain_DoCallBack#2](~/add/codesnippet/cpp/m-system.appdomain.docal_2.cpp)]  \n  \n The following sample demonstrates using the DoCallBack method by reference.  \n  \n [!code-cpp[AppDomain_DoCallBack#3](~/add/codesnippet/cpp/m-system.appdomain.docal_3.cpp)]\n [!code-cs[AppDomain_DoCallBack#3](~/add/codesnippet/csharp/m-system.appdomain.docal_3.cs)]\n [!code-vb[AppDomain_DoCallBack#3](~/add/codesnippet/visualbasic/m-system.appdomain.docal_3.vb)]"
  syntax:
    content: public void DoCallBack (CrossAppDomainDelegate callBackDelegate);
    parameters:
    - id: callBackDelegate
      type: System.CrossAppDomainDelegate
      description: "Delegat, który określa metodę do wywołania."
  overload: System.AppDomain.DoCallBack*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBackDelegate</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.DomainManager
  id: DomainManager
  parent: System.AppDomain
  langs:
  - csharp
  name: DomainManager
  nameWithType: AppDomain.DomainManager
  fullName: System.AppDomain.DomainManager
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera Menedżera domeny dostarczony przez hosta podczas inicjowania domeny aplikacji."
  remarks: "Niezarządzane hosta środowisko uruchomieniowe języka wspólnego (CLR) może zapewnić Menedżer domeny. Menedżer domeny mogą uczestniczyć w Inicjowanie nowej domeny aplikacji i podaj inne menedżerów, takich jak <xref:System.Security.HostSecurityManager>, który uczestniczyć w operacji domeny aplikacji.</xref:System.Security.HostSecurityManager>"
  syntax:
    content: public AppDomainManager DomainManager { get; }
    return:
      type: System.AppDomainManager
      description: "Obiekt reprezentujący Menedżer domeny dostarczone przez hosta podczas inicjowania domeny aplikacji lub <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> , jeśli nie został podany żaden Menedżer domeny."
  overload: System.AppDomain.DomainManager*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DomainUnload
  id: DomainUnload
  parent: System.AppDomain
  langs:
  - csharp
  name: DomainUnload
  nameWithType: AppDomain.DomainUnload
  fullName: System.AppDomain.DomainUnload
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Występuje, gdy <xref href=&quot;System.AppDomain&quot;> </xref> ma zostać zwolniony."
  remarks: "<xref:System.EventHandler>Delegowanie dla to zdarzenie można wykonać żadnych działań zakończenie przed domeny aplikacji zostanie zwolniona.</xref:System.EventHandler>       Każda domena aplikacji potrzebnych do wykonania przetwarzania, gdy jest zwolniony należy zarejestrować program obsługi zdarzeń dla tego zdarzenia. Program obsługi zdarzeń udostępnionego nie powinna być używana, ponieważ <xref:System.EventHandler>delegata nie będzie rozpoznawał domeny, która jest zwalniany.</xref:System.EventHandler>      > [!NOTE] > To zdarzenie nie jest wywoływane w domyślnej domeny aplikacji.       Nie należy wprowadzać założeń, o które zdarzenie jest wywoływane w wątku. Może być zdarzenia w innym wątku niż ten, który wywołuje <xref:System.AppDomain.Unload%2A>metody.</xref:System.AppDomain.Unload%2A>       Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [zdarzenia](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event EventHandler DomainUnload;
    return:
      type: System.EventHandler
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DynamicDirectory
  id: DynamicDirectory
  parent: System.AppDomain
  langs:
  - csharp
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
  fullName: System.AppDomain.DynamicDirectory
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera katalogu, którego używa mechanizmu rozpoznawania zestawu do sondowania dla zestawów utworzony dynamicznie."
  remarks: "Aby ustawić katalogu dynamicznych, przypisz ścieżkę katalogu podstawowego do <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName>Właściwość <xref:System.AppDomainSetup>obiekt, który będzie używany do utworzenia nowej domeny aplikacji.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> Ścieżka katalogu podstawowego można przypisać do właściwości jest modyfikowany przez dodanie którego prostą nazwą jest wartością skrótu parametrów przypisywane do podkatalogu <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>Właściwości, więc jest format podstawowego katalogu *Oryginalna ścieżka*\\\\*skrótu*.</xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName> Dynamiczne katalog jest podkatalogiem katalogu podstawowego. Jego prostą nazwą jest wartością <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>Właściwości, więc jego format jest *oryginalnej ścieżce*\\\\*skrótu*\\\\*Nazwa aplikacji*.</xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>"
  example:
  - "The following example creates an application domain with a directory for dynamic assemblies, emits a dynamic assembly and stores it in the dynamic directory, and then loads the assembly into the new application domain and uses it.  \n  \n The example creates an <xref:System.AppDomainSetup> object and sets its <xref:System.AppDomainSetup.ApplicationName%2A> property to \"Example\" and its <xref:System.AppDomainSetup.DynamicBase%2A> property to \"C:\\DynamicAssemblyDir\". The example then displays the <xref:System.AppDomainSetup.DynamicBase%2A> property, to show that the hash code of the application name has been appended as a subdirectory of the path that was originally assigned.  \n  \n> [!NOTE]\n>  The base directory in this example is intended to be outside the probing path for the example application. Be sure to compile the example in a different location. Delete the base directory and all its subdirectories each time you run the example.  \n  \n The example creates a new application domain, using the <xref:System.AppDomainSetup> object. The example uses the DynamicDirectory property to retrieve the name of the directory, so it can create the directory. (The example could just as easily create the directory beforehand by concatenating the original path, the hash code of the application name, and the application name.)  \n  \n The example has a `GenerateDynamicAssembly` method that emits an assembly named `DynamicHelloWorld.dll` and stores it in the new application domain's dynamic directory. The dynamic assembly contains one type, `HelloWorld`, that has a static method (`Shared` method in Visual Basic) named `HelloFromAD`. Calling this method displays the name of the application domain.  \n  \n The `Example` class derives from <xref:System.MarshalByRefObject>, so the example can create an instance of the class in the new application domain and call its `Test` method. The `Test` method loads the dynamic assembly by its display name and calls the static `HelloFromAD` method.  \n  \n You can show that the dynamic directory is searched after the normal probing paths by writing code for an assembly named `DynamicHelloWorld.dll` and compiling it in the same directory as this example. The assembly must have a class named `HelloWorld` with a static method named `HelloFromAD`. This method does not have to have the same functionality as the one in the example; it can simply display a string to the console. The assembly must also have an <xref:System.Reflection.AssemblyVersionAttribute> attribute that sets its version to 1.0.0.0. When you run the example, the assembly you compiled in the current directory is found before the dynamic directory is searched.  \n  \n [!code-cpp[ADDynamicBase#1](~/add/codesnippet/cpp/p-system.appdomain.dynam_1.cpp)]\n [!code-cs[ADDynamicBase#1](~/add/codesnippet/csharp/p-system.appdomain.dynam_1.cs)]\n [!code-vb[ADDynamicBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.dynam_1.vb)]"
  syntax:
    content: public string DynamicDirectory { get; }
    return:
      type: System.String
      description: "Katalog używany przez mechanizm rozpoznawania zestawów do sondowania dla zestawów utworzony dynamicznie."
  overload: System.AppDomain.DynamicDirectory*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.Evidence
  id: Evidence
  parent: System.AppDomain
  langs:
  - csharp
  name: Evidence
  nameWithType: AppDomain.Evidence
  fullName: System.AppDomain.Evidence
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera <xref href=&quot;System.Security.Policy.Evidence&quot;> </xref> skojarzone z tą domeną aplikacji."
  syntax:
    content: public System.Security.Policy.Evidence Evidence { get; }
    return:
      type: System.Security.Policy.Evidence
      description: "Dowody skojarzone z tą domeną aplikacji."
  overload: System.AppDomain.Evidence*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String)
  id: ExecuteAssembly(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String)
  nameWithType: AppDomain.ExecuteAssembly(String)
  fullName: System.AppDomain.ExecuteAssembly(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Wykonuje zawarte w określonym pliku zestawu."
  remarks: "Zestaw rozpoczyna wykonywanie na punkt wejścia określony w nagłówku .NET Framework.       Ta metoda nie powoduje utworzenia nowego procesu lub domena aplikacji, a nie wykonuje metodę punktu wejścia w nowym wątku.       Ta metoda ładuje zestawów przy użyciu <xref:System.Reflection.Assembly.LoadFile%2A>metody.</xref:System.Reflection.Assembly.LoadFile%2A> Można również wykonywać zestawów przy użyciu <xref:System.AppDomain.ExecuteAssemblyByName%2A>metodę, która ładuje zestawów przy użyciu <xref:System.Reflection.Assembly.Load%2A>metody.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       Aby utworzyć <xref:System.AppDomain>do ładowania i wykonywania, użyj <xref:System.AppDomain.CreateDomain%2A>metody.</xref:System.AppDomain.CreateDomain%2A> </xref:System.AppDomain>"
  example:
  - "The following sample demonstrates using one of the overloads of ExecuteAssembly on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/m-system.appdomain.execu_0_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/m-system.appdomain.execu_0_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/m-system.appdomain.execu_0_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Nazwa pliku, który zawiera zestaw do wykonania."
    return:
      type: System.Int32
      description: "Wartość zwrócona przez punkt wejścia zestawu."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>Nie znaleziono."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>nie jest prawidłowym zestawem.       - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <code>assemblyFile</code> został skompilowany przy użyciu nowszej wersji."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Określony zestaw nie ma wpisu punktu."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Wykonuje zawarte w określonym pliku zestawu przy użyciu określonego dowód."
  remarks: "Zestaw rozpoczyna wykonywanie na punkt wejścia określony w nagłówku .NET Framework.       <xref:System.AppDomain.ExecuteAssembly%2A>Metoda nie powoduje utworzenia nowego procesu lub domeny aplikacji i nie wykonuj metoda punktu wejścia w nowym wątku.</xref:System.AppDomain.ExecuteAssembly%2A>       Ta metoda ładuje zestawów przy użyciu <xref:System.Reflection.Assembly.LoadFile%2A>metody.</xref:System.Reflection.Assembly.LoadFile%2A> Można również wykonywać zestawów przy użyciu <xref:System.AppDomain.ExecuteAssemblyByName%2A>metodę, która ładuje zestawów przy użyciu <xref:System.Reflection.Assembly.Load%2A>metody.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/8a3b95e3-eb51-4f5b-bb93-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/8a3b95e3-eb51-4f5b-bb93-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/8a3b95e3-eb51-4f5b-bb93-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Nazwa pliku, który zawiera zestaw do wykonania."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Dowód ładowania zestawu."
    return:
      type: System.Int32
      description: "Wartość zwrócona przez punkt wejścia zestawu."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>Nie znaleziono."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>nie jest prawidłowym zestawem.       - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <code>assemblyFile</code> został skompilowany przy użyciu nowszej wersji."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Określony zestaw nie ma wpisu punktu."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[])
  id: ExecuteAssembly(System.String,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Wykonuje zawarte w określonym pliku zestawu przy użyciu określonych argumentów."
  remarks: "Zestaw rozpoczyna wykonywanie na punkt wejścia określony w nagłówku .NET Framework.       Ta metoda nie powoduje utworzenia nowego procesu lub domena aplikacji, a nie wykonuje metodę punktu wejścia w nowym wątku.       Ta metoda ładuje zestawów przy użyciu <xref:System.Reflection.Assembly.LoadFile%2A>metody.</xref:System.Reflection.Assembly.LoadFile%2A> Można również wykonywać zestawów przy użyciu <xref:System.AppDomain.ExecuteAssemblyByName%2A>metodę, która ładuje zestawów przy użyciu <xref:System.Reflection.Assembly.Load%2A>metody.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/m-system.appdomain.execu_1_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/m-system.appdomain.execu_1_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/m-system.appdomain.execu_1_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, string[] args);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Nazwa pliku, który zawiera zestaw do wykonania."
    - id: args
      type: System.String[]
      description: "Argumenty do punktu wejścia zestawu."
    return:
      type: System.Int32
      description: "Wartość zwracana przez punkt wejścia zestawu."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>Nie znaleziono."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>nie jest prawidłowym zestawem.       - lub - <code>assemblyFile</code> został skompilowany przy użyciu nowszej wersji środowiska CLR niż wersja, który jest aktualnie załadowany."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Określony zestaw nie ma wpisu punktu."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Wykonuje zawarte w określonym pliku zestawu przy użyciu określonego dowodów i argumentów."
  remarks: "Zestaw rozpoczyna wykonywanie na punkt wejścia określony w nagłówku .NET Framework.       Ta metoda nie powoduje utworzenia nowego procesu lub domena aplikacji, a nie wykonuje metodę punktu wejścia w nowym wątku.       Ta metoda ładuje zestawów przy użyciu <xref:System.Reflection.Assembly.LoadFile%2A>metody.</xref:System.Reflection.Assembly.LoadFile%2A> Można również wykonywać zestawów przy użyciu <xref:System.AppDomain.ExecuteAssemblyByName%2A>metodę, która ładuje zestawów przy użyciu <xref:System.Reflection.Assembly.Load%2A>metody.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/cb15b913-548c-4cb1-bbc5-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/cb15b913-548c-4cb1-bbc5-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/cb15b913-548c-4cb1-bbc5-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Nazwa pliku, który zawiera zestaw do wykonania."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Podany dowody dla zestawu."
    - id: args
      type: System.String[]
      description: "Argumenty do punktu wejścia zestawu."
    return:
      type: System.Int32
      description: "Wartość zwrócona przez punkt wejścia zestawu."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>Nie znaleziono."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>nie jest prawidłowym zestawem.       - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <code>assemblyFile</code> został skompilowany przy użyciu nowszej wersji."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Gdy starszą zasadę nie jest włączone, <code>assemblySecurity</code> powinien być <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Określony zestaw nie ma wpisu punktu."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Wykonuje zawarte w określonym pliku zestawu przy użyciu określonych argumentów, wartość skrótu i algorytmu wyznaczania wartości skrótu."
  remarks: "Zestaw rozpoczyna wykonywanie na punkt wejścia określony w nagłówku .NET Framework.       Ta metoda nie powoduje utworzenia nowego procesu lub domena aplikacji, a nie wykonuje metodę punktu wejścia w nowym wątku.       Ta metoda ładuje zestawów przy użyciu <xref:System.Reflection.Assembly.LoadFile%2A>metody.</xref:System.Reflection.Assembly.LoadFile%2A> Można również wykonywać zestawów przy użyciu <xref:System.AppDomain.ExecuteAssemblyByName%2A>metodę, która ładuje zestawów przy użyciu <xref:System.Reflection.Assembly.Load%2A>metody.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/ccb3b356-1169-4d65-9fdd-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/ccb3b356-1169-4d65-9fdd-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/ccb3b356-1169-4d65-9fdd-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Nazwa pliku, który zawiera zestaw do wykonania."
    - id: args
      type: System.String[]
      description: "Argumenty do punktu wejścia zestawu."
    - id: hashValue
      type: System.Byte[]
      description: "Reprezentuje wartość obliczona wartość skrótu."
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "Reprezentuje siła algorytmu wyznaczania wartości skrótu używanego przez manifest zestawu."
    return:
      type: System.Int32
      description: "Wartość zwracana przez punkt wejścia zestawu."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>Nie znaleziono."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>nie jest prawidłowym zestawem.       - lub - <code>assemblyFile</code> został skompilowany przy użyciu nowszej wersji środowiska CLR niż wersja, który jest aktualnie załadowany."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Określony zestaw nie ma wpisu punktu."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Wykonuje zawarte w określonym pliku zestawu przy użyciu określonego dowód, argumenty, wartość skrótu i algorytmu wyznaczania wartości skrótu."
  remarks: "Zestaw rozpoczyna wykonywanie na punkt wejścia określony w nagłówku .NET Framework.       Ta metoda nie powoduje utworzenia nowego procesu lub domena aplikacji, a nie wykonuje metodę punktu wejścia w nowym wątku.       Ta metoda ładuje zestawów przy użyciu <xref:System.Reflection.Assembly.LoadFile%2A>metody.</xref:System.Reflection.Assembly.LoadFile%2A> Można również wykonywać zestawów przy użyciu <xref:System.AppDomain.ExecuteAssemblyByName%2A>metodę, która ładuje zestawów przy użyciu <xref:System.Reflection.Assembly.Load%2A>metody.</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "Thefollowing sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/c176353b-cef5-4b78-b4a8-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/c176353b-cef5-4b78-b4a8-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/c176353b-cef5-4b78-b4a8-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "Nazwa pliku, który zawiera zestaw do wykonania."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Podany dowody dla zestawu."
    - id: args
      type: System.String[]
      description: "Argumenty do punktu wejścia zestawu."
    - id: hashValue
      type: System.Byte[]
      description: "Reprezentuje wartość obliczona wartość skrótu."
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "Reprezentuje siła algorytmu wyznaczania wartości skrótu używanego przez manifest zestawu."
    return:
      type: System.Int32
      description: "Wartość zwrócona przez punkt wejścia zestawu."
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>Nie znaleziono."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>nie jest prawidłowym zestawem.       - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <code>assemblyFile</code> został skompilowany przy użyciu nowszej wersji."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Gdy starszą zasadę nie jest włączone, <code>assemblySecurity</code> powinien być <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Określony zestaw nie ma wpisu punktu."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String)
  id: ExecuteAssemblyByName(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String)
  nameWithType: AppDomain.ExecuteAssemblyByName(String)
  fullName: System.AppDomain.ExecuteAssemblyByName(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Wykonuje podane nazwy wyświetlanej zestawu."
  remarks: "<xref:System.AppDomain.ExecuteAssemblyByName%2A>Metoda zapewnia funkcje podobne do <xref:System.AppDomain.ExecuteAssembly%2A>metody, ale określa zestaw według nazwy wyświetlanej lub <xref:System.Reflection.AssemblyName>, a nie na podstawie lokalizacji pliku.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> W związku z tym <xref:System.AppDomain.ExecuteAssemblyByName%2A>ładuje zestawy za pomocą <xref:System.Reflection.Assembly.Load%2A>metody, a nie z <xref:System.Reflection.Assembly.LoadFile%2A>metody.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       Zestaw rozpoczyna wykonywanie na punkt wejścia określony w nagłówku .NET Framework.       Ta metoda nie powoduje utworzenia nowego procesu lub domena aplikacji, a nie wykonuje metodę punktu wejścia w nowym wątku.       Aby utworzyć <xref:System.AppDomain>do ładowania i wykonywania, użyj <xref:System.AppDomain.CreateDomain%2A>metody.</xref:System.AppDomain.CreateDomain%2A> </xref:System.AppDomain>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Nazwa wyświetlana zestawu. Zobacz &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    return:
      type: System.Int32
      description: "Wartość zwrócona przez punkt wejścia zestawu."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Określony przez zestaw <code> assemblyName </code> nie można odnaleźć."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "Określony przez zestaw <code> assemblyName </code> nie jest prawidłowym zestawem.       - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <code> assemblyName </code> został skompilowany przy użyciu nowszej wersji."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Określony przez zestaw <code> assemblyName </code> został znaleziony, ale nie można go załadować."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Określony zestaw nie ma wpisu punktu."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  id: ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(AssemblyName,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Wykonuje zestaw podane <xref:System.Reflection.AssemblyName>, przy użyciu określonych argumentów.</xref:System.Reflection.AssemblyName>"
  remarks: "<xref:System.AppDomain.ExecuteAssemblyByName%2A>Metoda zapewnia funkcje podobne do <xref:System.AppDomain.ExecuteAssembly%2A>metody, ale określa zestaw według nazwy wyświetlanej lub <xref:System.Reflection.AssemblyName>, a nie na podstawie lokalizacji pliku.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> W związku z tym <xref:System.AppDomain.ExecuteAssemblyByName%2A>ładuje zestawy za pomocą <xref:System.Reflection.Assembly.Load%2A>metody, a nie z <xref:System.Reflection.Assembly.LoadFile%2A>metody.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       Zestaw rozpoczyna wykonywanie na punkt wejścia określony w nagłówku .NET Framework.       Ta metoda nie powoduje utworzenia nowego procesu lub domena aplikacji, a nie wykonuje metodę punktu wejścia w nowym wątku."
  syntax:
    content: public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, string[] args);
    parameters:
    - id: assemblyName
      type: System.Reflection.AssemblyName
      description: "<xref:System.Reflection.AssemblyName>Obiekt reprezentujący nazwę zestawu.</xref:System.Reflection.AssemblyName>"
    - id: args
      type: System.String[]
      description: "Argumenty wiersza polecenia do przekazania podczas uruchamiania procesu."
    return:
      type: System.Int32
      description: "Wartość zwracana przez punkt wejścia zestawu."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Określony przez zestaw <code> assemblyName </code> nie można odnaleźć."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Określony przez zestaw <code> assemblyName </code> został znaleziony, ale nie można go załadować."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "Określony przez zestaw <code> assemblyName </code> nie jest prawidłowym zestawem.       - lub - <code> assemblyName </code> został skompilowany przy użyciu nowszej wersji środowiska CLR niż wersja, który jest aktualnie załadowany."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Określony zestaw nie ma wpisu punktu."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  id: ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,Evidence)
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence)
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Wykonuje zestawu podanej nazwy wyświetlanej za pomocą określonego dowód."
  remarks: "<xref:System.AppDomain.ExecuteAssemblyByName%2A>Metoda zapewnia funkcje podobne do <xref:System.AppDomain.ExecuteAssembly%2A>metody, ale określa zestaw według nazwy wyświetlanej lub <xref:System.Reflection.AssemblyName>, a nie na podstawie lokalizacji pliku.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> W związku z tym <xref:System.AppDomain.ExecuteAssemblyByName%2A>ładuje zestawy za pomocą <xref:System.Reflection.Assembly.Load%2A>metody, a nie z <xref:System.Reflection.Assembly.LoadFile%2A>metody.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       Zestaw rozpoczyna wykonywanie na punkt wejścia określony w nagłówku .NET Framework.       <xref:System.AppDomain.ExecuteAssemblyByName%2A>Metoda nie powoduje utworzenia nowego procesu lub domeny aplikacji i nie wykonuj metoda punktu wejścia w nowym wątku.</xref:System.AppDomain.ExecuteAssemblyByName%2A>      > [!NOTE] > Korzystając <xref:System.AppDomain.ExecuteAssemblyByName%2A>metody z <xref:System.Security.Policy.Evidence>parametru części dowód są scalane.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Elementy dowody dostarczone jako argument <xref:System.AppDomain.ExecuteAssemblyByName%2A>metody zastępują elementy dowody dostarczone przez moduł ładujący.</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Nazwa wyświetlana zestawu. Zobacz &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Dowód ładowania zestawu."
    return:
      type: System.Int32
      description: "Wartość zwrócona przez punkt wejścia zestawu."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Określony przez zestaw <code> assemblyName </code> nie można odnaleźć."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Określony przez zestaw <code> assemblyName </code> został znaleziony, ale nie można go załadować."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "Określony przez zestaw <code> assemblyName </code> nie jest prawidłowym zestawem.       - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <code> assemblyName </code> został skompilowany przy użyciu nowszej wersji."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Określony zestaw nie ma wpisu punktu."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  id: ExecuteAssemblyByName(System.String,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Wykonuje podane nazwy wyświetlanej zestawu przy użyciu określonych argumentów."
  remarks: "<xref:System.AppDomain.ExecuteAssemblyByName%2A>Metoda zapewnia funkcje podobne do <xref:System.AppDomain.ExecuteAssembly%2A>metody, ale określa zestaw według nazwy wyświetlanej lub <xref:System.Reflection.AssemblyName>, a nie na podstawie lokalizacji pliku.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> W związku z tym <xref:System.AppDomain.ExecuteAssemblyByName%2A>ładuje zestawy za pomocą <xref:System.Reflection.Assembly.Load%2A>metody, a nie z <xref:System.Reflection.Assembly.LoadFile%2A>metody.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       Zestaw rozpoczyna wykonywanie na punkt wejścia określony w nagłówku .NET Framework.       Ta metoda nie powoduje utworzenia nowego procesu lub domena aplikacji, a nie wykonuje metodę punktu wejścia w nowym wątku."
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, string[] args);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Nazwa wyświetlana zestawu. Zobacz &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: args
      type: System.String[]
      description: "Argumenty wiersza polecenia do przekazania podczas uruchamiania procesu."
    return:
      type: System.Int32
      description: "Wartość zwracana przez punkt wejścia zestawu."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Określony przez zestaw <code> assemblyName </code> nie można odnaleźć."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Określony przez zestaw <code> assemblyName </code> został znaleziony, ale nie można go załadować."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "Określony przez zestaw <code> assemblyName </code> nie jest prawidłowym zestawem.       - lub - <code> assemblyName </code> został skompilowany przy użyciu nowszej wersji środowiska CLR niż wersja, który jest aktualnie załadowany."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Określony zestaw nie ma wpisu punktu."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Wykonuje zestaw podane <xref:System.Reflection.AssemblyName>, przy użyciu określonego dowodów i argumentów.</xref:System.Reflection.AssemblyName>"
  remarks: "<xref:System.AppDomain.ExecuteAssemblyByName%2A>Metoda zapewnia funkcje podobne do <xref:System.AppDomain.ExecuteAssembly%2A>metody, ale określa zestaw według nazwy wyświetlanej lub <xref:System.Reflection.AssemblyName>, a nie na podstawie lokalizacji pliku.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> W związku z tym <xref:System.AppDomain.ExecuteAssemblyByName%2A>ładuje zestawy za pomocą <xref:System.Reflection.Assembly.Load%2A>metody, a nie z <xref:System.Reflection.Assembly.LoadFile%2A>metody.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       Zestaw rozpoczyna wykonywanie na punkt wejścia określony w nagłówku .NET Framework.       Ta metoda nie powoduje utworzenia nowego procesu lub domena aplikacji, a nie wykonuje metodę punktu wejścia w nowym wątku.      > [!NOTE] > Korzystając <xref:System.AppDomain.ExecuteAssemblyByName%2A>metody z <xref:System.Security.Policy.Evidence>parametru części dowód są scalane.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Elementy dowody dostarczone jako argument <xref:System.AppDomain.ExecuteAssemblyByName%2A>metody zastępują elementy dowody dostarczone przez moduł ładujący.</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyName
      type: System.Reflection.AssemblyName
      description: "<xref:System.Reflection.AssemblyName>Obiekt reprezentujący nazwę zestawu.</xref:System.Reflection.AssemblyName>"
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Dowód ładowania zestawu."
    - id: args
      type: System.String[]
      description: "Argumenty wiersza polecenia do przekazania podczas uruchamiania procesu."
    return:
      type: System.Int32
      description: "Wartość zwrócona przez punkt wejścia zestawu."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Określony przez zestaw <code> assemblyName </code> nie można odnaleźć."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Określony przez zestaw <code> assemblyName </code> został znaleziony, ale nie można go załadować."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "Określony przez zestaw <code> assemblyName </code> nie jest prawidłowym zestawem.       - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <code> assemblyName </code> został skompilowany przy użyciu nowszej wersji."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Gdy starszą zasadę nie jest włączone, <code>assemblySecurity</code> powinien być <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Określony zestaw nie ma wpisu punktu."
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Wykonuje podane nazwy wyświetlanej zestawu przy użyciu określonego dowodów i argumentów."
  remarks: "<xref:System.AppDomain.ExecuteAssemblyByName%2A>Metoda zapewnia funkcje podobne do <xref:System.AppDomain.ExecuteAssembly%2A>metody, ale określa zestaw według nazwy wyświetlanej lub <xref:System.Reflection.AssemblyName>, a nie na podstawie lokalizacji pliku.</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> W związku z tym <xref:System.AppDomain.ExecuteAssemblyByName%2A>ładuje zestawy za pomocą <xref:System.Reflection.Assembly.Load%2A>metody, a nie z <xref:System.Reflection.Assembly.LoadFile%2A>metody.</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       Zestaw rozpoczyna wykonywanie na punkt wejścia określony w nagłówku .NET Framework.       Ta metoda nie powoduje utworzenia nowego procesu lub domena aplikacji, a nie wykonuje metodę punktu wejścia w nowym wątku.      > [!NOTE] > Korzystając <xref:System.AppDomain.ExecuteAssemblyByName%2A>metody z <xref:System.Security.Policy.Evidence>parametru części dowód są scalane.</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> Elementy dowody dostarczone jako argument <xref:System.AppDomain.ExecuteAssemblyByName%2A>metody zastępują elementy dowody dostarczone przez moduł ładujący.</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyName
      type: System.String
      description: "Nazwa wyświetlana zestawu. Zobacz &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Dowód ładowania zestawu."
    - id: args
      type: System.String[]
      description: "Argumenty wiersza polecenia do przekazania podczas uruchamiania procesu."
    return:
      type: System.Int32
      description: "Wartość zwrócona przez punkt wejścia zestawu."
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Określony przez zestaw <code> assemblyName </code> nie można odnaleźć."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Określony przez zestaw <code> assemblyName </code> został znaleziony, ale nie można go załadować."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "Określony przez zestaw <code> assemblyName </code> nie jest prawidłowym zestawem.       - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <code> assemblyName </code> został skompilowany przy użyciu nowszej wersji."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Gdy starszą zasadę nie jest włączone, <code>assemblySecurity</code> powinien być <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "Określony zestaw nie ma wpisu punktu."
  platform:
  - net462
- uid: System.AppDomain.FirstChanceException
  id: FirstChanceException
  parent: System.AppDomain
  langs:
  - csharp
  name: FirstChanceException
  nameWithType: AppDomain.FirstChanceException
  fullName: System.AppDomain.FirstChanceException
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Występuje, gdy jest zwracany wyjątek w kodzie zarządzanym przed środowiska uruchomieniowego wyszukuje stos wywołań dla obsługi wyjątków w domenie aplikacji."
  remarks: "To zdarzenie jest tylko powiadomienie. Obsługa tego zdarzenia obsłużyć wyjątek lub nie mają wpływ na kolejne obsługi wyjątków w dowolny sposób. Po zdarzeniu został zgłoszony i procedury obsługi zdarzeń został wywołany, środowisko uruchomieniowe języka wspólnego (CLR) rozpoczyna się do wyszukiwania program obsługi wyjątku. FirstChanceException zapewnia domeny aplikacji z pierwszej szansy zbadanie zarządzanych wyjątku.       Zdarzenia mogą być obsługiwane w każdej domenie aplikacji. Jeśli wątek przechodzi przez wielu domen aplikacji podczas wykonywania wywołania, zdarzenie jest wywoływane w każdej domenie aplikacji, który został zarejestrowany program obsługi zdarzeń, przed rozpoczęciem CLR wyszukiwanie zgodnych obsługi wyjątków w tej domenie aplikacji. Po zdarzeniu został obsłużony, wyszukiwanie jest przeprowadzane dla zgodnych obsługi wyjątków w tej domenie aplikacji. W przypadku nieodnalezienia, zdarzenie jest wywoływane w następnej domeny aplikacji.       Musi obsługiwać wszystkie wyjątki, które występują w przypadku obsługi dla zdarzenia FirstChanceException. W przeciwnym razie FirstChanceException jest zgłoszono rekursywnie. Może to spowodować przepełnienie stosu i kończenie działania aplikacji. Zaleca się wdrożenie obsługi zdarzeń dla tego zdarzenia jako ograniczone regiony wykonania (CERs), aby uniknąć związanych z infrastrukturą wyjątki, takie jak braku pamięci lub stos przepełnienie wpływających na maszynie wirtualnej, podczas przetwarzania powiadomienia wyjątek.       To zdarzenie nie jest wywoływane dla wyjątków, które wskazują uszkodzenie stan procesu, np. naruszenia zasad dostępu, jeśli program obsługi zdarzeń jest krytyczny dla zabezpieczeń i ma <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>atrybutu.</xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>       Środowisko uruchomieniowe języka wspólnego wstrzymuje przerwań wątku podczas obsługi zdarzenia z powiadomieniem."
  example:
  - "The following example creates a series of application domains named `AD0` through `AD3`, with a `Worker` object in each application domain. Each `Worker` object has a reference to the `Worker` object in the next application domain, except for the `Worker` in the last application domain. The FirstChanceException event is handled in all application domains except `AD1`.  \n  \n> [!NOTE]\n>  In addition to this example, which demonstrates first-chance exception notifications in multiple application domains, you can find simple use cases in [How to: Receive First-Chance Exception Notifications](~/add/includes/ajax-current-ext-md.md).  \n  \n When the application domains have been created, the default application domain calls the `TestException` method for the first application domain. Each `Worker` object calls the `TestException` method for the next application domain, until the last `Worker` throws an exception that is either handled or unhandled. Thus, the current thread passes through all the application domains, and `TestException` is added to the stack in each application domain.  \n  \n When the last `Worker` object handles the exception, the FirstChanceException event is raised only in the last application domain. The other application domains never get a chance to handle the exception, so the event is not raised.  \n  \n When the last `Worker` object does not handle the exception, the FirstChanceException event is raised in each application domain that has an event handler. After each event handler has finished, the stack continues to unwind until the exception is caught by the default application domain.  \n  \n> [!NOTE]\n>  To see how the stack display grows as the event is raised closer and closer to the default application domain, change `e.Exception.Message` to `e.Exception` in the `FirstChanceHandler` event handlers. Notice that when `TestException` is called across application domain boundaries, it appears twice: once for the proxy and once for the stub.  \n  \n [!code-vb[System.AppDomain.FirstChanceException#1](~/add/codesnippet/visualbasic/e-system.appdomain.first_1.vb)]\n [!code-cs[System.AppDomain.FirstChanceException#1](~/add/codesnippet/csharp/e-system.appdomain.first_1.cs)]"
  syntax:
    content: public event EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs> FirstChanceException;
    return:
      type: System.EventHandler{System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs}
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.FriendlyName
  id: FriendlyName
  parent: System.AppDomain
  langs:
  - csharp
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
  fullName: System.AppDomain.FriendlyName
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera przyjazną nazwę tej domeny aplikacji."
  remarks: "Przyjazna nazwa domyślnej domeny aplikacji jest nazwą pliku wykonywalnego procesu. Na przykład, jeśli plik wykonywalny używane do uruchamiania procesu jest `&quot;c:\\MyAppDirectory\\MyAssembly.exe&quot;`, przyjazną nazwę domyślnej domeny aplikacji jest `&quot;MyAssembly.exe&quot;`."
  example:
  - "The following code example uses the FriendlyName property to get the friendly name of the current application domain. For the default application domain, the friendly name is the name of the application's executable file. The code example also displays additional information about the application domain.  \n  \n [!code-vb[ADApplicationBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.frien_1.vb)]\n [!code-cpp[ADApplicationBase#1](~/add/codesnippet/cpp/p-system.appdomain.frien_1.cpp)]\n [!code-cs[ADApplicationBase#1](~/add/codesnippet/csharp/p-system.appdomain.frien_1.cs)]"
  syntax:
    content: public string FriendlyName { get; }
    return:
      type: System.String
      description: "Przyjazna nazwa tej domeny aplikacji."
  overload: System.AppDomain.FriendlyName*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.GetAssemblies
  id: GetAssemblies
  parent: System.AppDomain
  langs:
  - csharp
  name: GetAssemblies()
  nameWithType: AppDomain.GetAssemblies()
  fullName: System.AppDomain.GetAssemblies()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera zestawy, które zostały załadowane do kontekstu wykonywania tej domeny aplikacji."
  remarks: ''
  example:
  - "The following code example uses the GetAssemblies method to get a list of all assemblies that have been loaded into the application domain. The assemblies are then displayed to the console.  \n  \n To run this code example, you need to create an assembly named `CustomLibrary.dll`, or change the assembly name that is passed to the GetAssemblies method.  \n  \n [!code-cpp[ADGetAssemblies#1](~/add/codesnippet/cpp/m-system.appdomain.getas_1.cpp)]\n [!code-cs[ADGetAssemblies#1](~/add/codesnippet/csharp/m-system.appdomain.getas_1.cs)]\n [!code-vb[ADGetAssemblies#1](~/add/codesnippet/visualbasic/m-system.appdomain.getas_1.vb)]"
  syntax:
    content: public System.Reflection.Assembly[] GetAssemblies ();
    parameters: []
    return:
      type: System.Reflection.Assembly[]
      description: "Tablica zestawów w tej domenie aplikacji."
  overload: System.AppDomain.GetAssemblies*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.GetCurrentThreadId
  id: GetCurrentThreadId
  parent: System.AppDomain
  langs:
  - csharp
  name: GetCurrentThreadId()
  nameWithType: AppDomain.GetCurrentThreadId()
  fullName: System.AppDomain.GetCurrentThreadId()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera bieżący identyfikator wątku."
  remarks: "Użyj <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=fullName>właściwość, która jest stabilna nawet wtedy, gdy programu .NET Framework jest obsługiwana w środowisku obsługującym włókien (wątki lekkie).</xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=fullName>"
  syntax:
    content: public static int GetCurrentThreadId ();
    parameters: []
    return:
      type: System.Int32
      description: "32-bitowe liczby całkowite ze znakiem to identyfikator bieżącego wątku."
  overload: System.AppDomain.GetCurrentThreadId*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.GetData(System.String)
  id: GetData(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: GetData(String)
  nameWithType: AppDomain.GetData(String)
  fullName: System.AppDomain.GetData(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera wartość przechowywana w bieżącej domenie aplikacji dla podanej nazwy."
  remarks: "Ta metoda służy do pobierania wartości do wpisu w wewnętrznej pamięci podręcznej par nazwa danych opisujących właściwości tego wystąpienia <xref:System.AppDomain>.</xref:System.AppDomain> Należy pamiętać, że porównanie `name` o nazwie pary klucz wartość jest rozróżniana wielkość liter.       Pamięć podręczna zawiera automatycznie wpisy wstępnie zdefiniowanych systemu, które są wstawiane podczas tworzenia domeny aplikacji. Możesz sprawdzić ich wartości, przy użyciu metody GetData lub jego odpowiednik <xref:System.AppDomainSetup>Właściwości.</xref:System.AppDomainSetup>       Możesz wstawić lub zmodyfikować własne par nazwa danych zdefiniowanych przez użytkownika z <xref:System.AppDomain.SetData%2A>— Metoda i sprawdzić ich wartości przy użyciu metody GetData.</xref:System.AppDomain.SetData%2A>       W poniższej tabeli opisano `name` każdego wstępnie zdefiniowane wpisu systemu i odpowiednie <xref:System.AppDomainSetup>Właściwości.</xref:System.AppDomainSetup>      | Wartość &quot;name&quot; | Właściwość |   |---------------------|--------------|   |&quot; APPBASE &quot;| <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>|   |&quot; APP_CONFIG_FILE &quot;| <xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=fullName>|   |&quot; APP_LAUNCH_URL &quot;| (nie właściwości)</xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=fullName> </xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName><br /><br /> &quot;APP_LAUNCH_URL&quot; odpowiada adresowi URL pierwotnie żądanej przez użytkownika, przed przekierowania. Jest dostępna tylko wtedy, gdy aplikacja została uruchomiona przy użyciu przeglądarki, takich jak program Internet Explorer. Nie wszystkie przeglądarki zawierają tę wartość. |   |&quot; NAZWA_APLIKACJI &quot;| <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>|   |&quot; BINPATH_PROBE_ONLY &quot;| <xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=fullName>|   |&quot; CACHE_BASE &quot;| <xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>|   |&quot; CODE_DOWNLOAD_DISABLED &quot;| <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName>|   |&quot; DEV_PATH &quot;| (nie właściwości) |   |&quot; DISALLOW_APP &quot;| <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=fullName>|   |&quot; DISALLOW_APP_BASE_PROBING &quot;| <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=fullName>|   |&quot; DISALLOW_APP_REDIRECTS &quot;| <xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=fullName>|   |&quot; DYNAMIC_BASE &quot;| <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName>|   |&quot; FORCE_CACHE_INSTALL &quot;| <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>|   |&quot; LICENSE_FILE&quot;lub ciąg specyficzne dla aplikacji | <xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=fullName>|   |&quot; LOADER_OPTIMIZATION &quot;| <xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=fullName>|   |&quot; LOCATION_URI &quot;| (nie właściwości) |   |&quot; PRIVATE_BINPATH &quot;| <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>|   |&quot; REGEX_DEFAULT_MATCH_TIMEOUT &quot;| <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=fullName></xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=fullName></xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName></xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=fullName></xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=fullName></xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName></xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName></xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName></xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=fullName></xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName><br /><br /> &quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot; nie jest wpisem systemu i jej wartość można ustawić przez wywołanie metody <xref:System.AppDomain.SetData%2A>. |   |&quot; SHADOW_COPY_DIRS &quot;| <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>|</xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName></xref:System.AppDomain.SetData%2A>"
  example:
  - "The following example creates a new application domain, sets a system-provided value for the domain, and adds a new value pair for the domain. The example then demonstrates how to use the GetData method to retrieve the data from these value pairs and display them to the console.  \n  \n [!code-cpp[ADGetData#1](~/add/codesnippet/cpp/m-system.appdomain.getda_1.cpp)]\n [!code-vb[ADGetData#1](~/add/codesnippet/visualbasic/m-system.appdomain.getda_1.vb)]\n [!code-cs[ADGetData#1](~/add/codesnippet/csharp/m-system.appdomain.getda_1.cs)]"
  syntax:
    content: public object GetData (string name);
    parameters:
    - id: name
      type: System.String
      description: "Nazwa właściwości domeny aplikacji wstępnie zdefiniowanych lub nazwa właściwości domeny aplikacji zdefiniowano."
    return:
      type: System.Object
      description: "Wartość <code> name </code> właściwości, lub <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Jeśli właściwość nie istnieje."
  overload: System.AppDomain.GetData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.GetType
  id: GetType
  parent: System.AppDomain
  langs:
  - csharp
  name: GetType()
  nameWithType: AppDomain.GetType()
  fullName: System.AppDomain.GetType()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera typ bieżącego wystąpienia."
  syntax:
    content: public Type GetType ();
    parameters: []
    return:
      type: System.Type
      description: "Typ bieżącego wystąpienia."
  overload: System.AppDomain.GetType*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Id
  id: Id
  parent: System.AppDomain
  langs:
  - csharp
  name: Id
  nameWithType: AppDomain.Id
  fullName: System.AppDomain.Id
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera całkowitą, który unikatowo identyfikuje domeny aplikacji w ramach procesu."
  remarks: ''
  example:
  - "The following code example creates a second application domain and displays information about the default domain and the new domain.  \n  \n [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/visualbasic/p-system.appdomain.id_1.vb)]\n [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/cpp/p-system.appdomain.id_1.cpp)]\n [!code-cs[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/csharp/p-system.appdomain.id_1.cs)]"
  syntax:
    content: public int Id { get; }
    return:
      type: System.Int32
      description: "Liczba całkowita, która identyfikuje domeny aplikacji."
  overload: System.AppDomain.Id*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.InitializeLifetimeService
  id: InitializeLifetimeService
  parent: System.AppDomain
  langs:
  - csharp
  name: InitializeLifetimeService()
  nameWithType: AppDomain.InitializeLifetimeService()
  fullName: System.AppDomain.InitializeLifetimeService()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Zapewnia <xref href=&quot;System.AppDomain&quot;> </xref> przez cały okres istnienia, zapobiegając tworzona dzierżawy."
  syntax:
    content: public override object InitializeLifetimeService ();
    parameters: []
    return:
      type: System.Object
      description: "Always <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  overload: System.AppDomain.InitializeLifetimeService*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.IsCompatibilitySwitchSet(System.String)
  id: IsCompatibilitySwitchSet(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: IsCompatibilitySwitchSet(String)
  nameWithType: AppDomain.IsCompatibilitySwitchSet(String)
  fullName: System.AppDomain.IsCompatibilitySwitchSet(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera wartości NULL wartość logiczna, która wskazuje, czy ustawiono żadnych przełączników zgodności i jeśli tak, czy ustawiono zgodności określonego przełącznika."
  remarks: "This method tests whether the specified compatibility switch has been set for the current application domain. Compatibility switches typically restore a behavior (such as the way strings are sorted) that was changed between versions of the .NET Framework.  They are set by calling the <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=fullName> method before creating an application domain.  \n  \n The following table provides examples of compatibility switches that can be set to restore the behavior of earlier versions of the .NET Framework.  \n  \n|Switch|Meaning|  \n|------------|-------------|  \n|\"NetFx40_LegacySecurityPolicy\"|Code access security (CAS) for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] is enabled in this application domain. See [\\&lt;NetFx40_LegacySecurityPolicy\\&gt; Element](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md).|  \n|\"NetFx40_Legacy20SortingBehavior\"|String sorting defaults for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] are enabled in this application domain. Its success requires sort00001000.dll to be installed. See [\\&lt;CompatSortNLSVersion\\&gt; Element](../Topic/%3CCompatSortNLSVersion%3E%20Element.md).|  \n|\"NetFx40_Legacy40SortingBehavior\"|String sorting defaults for the [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]and Unicode 5.0 are enabled in this application domain. Its success requires sort00060101.dll to be installed.|  \n|\"NetFx40_TimeSpanLegacyFormatMode\"|<xref:System.TimeSpan> formatting behavior for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] is enabled in this application domain.  See [\\&lt;TimeSpan_LegacyFormatMode\\&gt; Element](../Topic/%3CTimeSpan_LegacyFormatMode%3E%20Element.md) and the \"Restoring Legacy TimeSpan Formatting\" section of the <xref:System.TimeSpan> topic.|  \n|\"UseRandomizedStringHashAlgorithm\"|The runtime calculates hash codes for strings on a per application domain basis instead of using a single hashing algorithm that produces a consistent hash code across application domains. See [\\&lt;UseRandomizedStringHashAlgorithm\\&gt; Element](../Topic/%3CUseRandomizedStringHashAlgorithm%3E%20Element.md).|"
  syntax:
    content: public Nullable<bool> IsCompatibilitySwitchSet (string value);
    parameters:
    - id: value
      type: System.String
      description: "Przełącz zgodności, aby przetestować."
    return:
      type: System.Nullable{System.Boolean}
      description: "Odwołanie o wartości null (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref> w języku Visual Basic) Jeśli zostały zdefiniowane żadne przełączniki zgodności; w przeciwnym razie wartość logiczna wskazująca czy zgodność przełącznik jest określona przez <code> value </code> jest ustawiona."
  overload: System.AppDomain.IsCompatibilitySwitchSet*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsDefaultAppDomain
  id: IsDefaultAppDomain
  parent: System.AppDomain
  langs:
  - csharp
  name: IsDefaultAppDomain()
  nameWithType: AppDomain.IsDefaultAppDomain()
  fullName: System.AppDomain.IsDefaultAppDomain()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Zwraca wartość wskazującą, czy domena aplikacji jest domeną domyślną aplikację dla procesu."
  remarks: "Każdy proces zarządzanych ma domyślnej domeny aplikacji. Rozpoczyna wykonywanie w domenie domyślnej."
  example:
  - "The following code example creates a second application domain and displays information about the default domain and the new domain.  \n  \n [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/visualbasic/m-system.appdomain.isdef_1.vb)]\n [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/cpp/m-system.appdomain.isdef_1.cpp)]\n [!code-cs[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/csharp/m-system.appdomain.isdef_1.cs)]"
  syntax:
    content: public bool IsDefaultAppDomain ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli bieżący <xref href=&quot;System.AppDomain&quot;> </xref> obiekt reprezentuje domyślnej domeny aplikacji dla procesu; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsDefaultAppDomain*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsFinalizingForUnload
  id: IsFinalizingForUnload
  parent: System.AppDomain
  langs:
  - csharp
  name: IsFinalizingForUnload()
  nameWithType: AppDomain.IsFinalizingForUnload()
  fullName: System.AppDomain.IsFinalizingForUnload()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Wskazuje, czy ta domena aplikacji jest zwolnienie i obiektami, które zawiera są zatwierdzony przez środowisko uruchomieniowe języka wspólnego."
  remarks: "Metoda finalizacji obiektu zapewnia możliwość wykonania wszystkich operacji cleanup konieczne przed bezużytecznych jest obiekt. Po zakończeniu obiekt jest dostępny, ale w nieprawidłowym stanie i w związku z tym korzystanie z niej. Po pewnym czasie wyrzucanie elementów bezużytecznych kończy i zwraca obiekt.       Wywoływana jest metoda finalizacji obiektu w jednym z następujących sytuacji: podczas wyrzucania elementów bezużytecznych, gdy trwa zamykanie środowiska CLR lub gdy domena aplikacji, która zawiera obiekt jest usunięty z pamięci. Zwraca metodę IsFinalizingForUnload `true` tylko w przypadku ostatniego; nie zwraca `true` Jeśli finalizacji wyniki z rutynowych wyrzucanie elementów bezużytecznych lub zamykania środowiska CLR.      > [!NOTE] > Aby określić, czy finalizacji z powodu wyłączenia CLR, użyj <xref:System.Environment.HasShutdownStarted%2A?displayProperty=fullName>Właściwości.</xref:System.Environment.HasShutdownStarted%2A?displayProperty=fullName> Zwraca `true` w przypadku finalizacji z powodu Zwalnianie domeny aplikacji lub do zamykania środowiska CLR.       Podczas wykonywania w metodę finalizacji podczas wyładowywania domeny, można uzyskać dostępu do innego obiektu, który odwołuje się do niego pola statycznego i ma metodę finalizacji. Jednak nie można niezawodnie tym ponieważ dostęp do obiektu mogą już mieć sfinalizowany.      > [!NOTE] > Wyjątek od tej reguły jest <xref:System.Console>klasy, która zawiera pól statycznych, które odwołują się obiekty strumienia, ale jest zaimplementowana specjalnie, aby zawsze można pisać do konsoli systemu, nawet podczas zamykania domeny zwalnianie lub systemu.</xref:System.Console>       Użyj tej metody w metodzie finalizacji obiektu, aby ustalić, czy domena aplikacji, która zawiera obiekt wyładowywania. Jeśli tak jest, nie można niezawodnie dostęp każdy obiekt, który ma metodę finalizacji i odwołuje się do niego pola statycznego."
  syntax:
    content: public bool IsFinalizingForUnload ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Czy ta domena aplikacji jest zwalnianie i środowisko uruchomieniowe języka wspólnego rozpoczęło się wywoływania finalizatory; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsFinalizingForUnload*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsFullyTrusted
  id: IsFullyTrusted
  parent: System.AppDomain
  langs:
  - csharp
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
  fullName: System.AppDomain.IsFullyTrusted
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera wartość wskazującą, czy zestawy, które są ładowane do bieżącej domeny aplikacji wykonywanie z pełnym zaufaniem."
  remarks: "Ta metoda zawsze zwraca `true` dla domyślnej domeny aplikacji aplikację, która działa na pulpicie. Zwraca `false` dla domeny aplikacji w trybie piaskownicy, który został utworzony przy użyciu [AppDomain.CreateDomain (ciąg, dowód, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) — metoda przeciążenia, chyba że uprawnienia, które są przypisywane do domeny aplikacji są równoważne pełnego zaufania."
  example:
  - "The following example demonstrates the IsFullyTrusted property and the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> property with fully trusted and partially trusted application domains. The fully trusted application domain is the default application domain for the application. The partially trusted application domain is created by using the [AppDomain.CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) method overload.  \n  \n The example uses a `Worker` class that derives from <xref:System.MarshalByRefObject>, so it can be marshaled across application domain boundaries. The example creates a `Worker` object in the default application domain. It then calls the `TestIsFullyTrusted` method to display the property value for the application domain and for two assemblies that are loaded into the application domain: mscorlib, which is part of the .NET Framework, and the example assembly. The application domain is fully trusted, so both assemblies are fully trusted.  \n  \n The example creates another `Worker` object in a sandboxed application domain and again calls the `TestIsFullyTrusted` method. Mscorlib is always trusted, even in a partially trusted application domain, but the example assembly is partially trusted.  \n  \n [!code-vb[System.AppDomain.IsFullyTrusted#1](~/add/codesnippet/visualbasic/p-system.appdomain.isful_1.vb)]\n [!code-cs[System.AppDomain.IsFullyTrusted#1](~/add/codesnippet/csharp/p-system.appdomain.isful_1.cs)]"
  syntax:
    content: public bool IsFullyTrusted { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli zostanie wykonane przy pełnym zaufaniu; zestawy, które są ładowane do bieżącej domeny aplikacji w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsFullyTrusted*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsHomogenous
  id: IsHomogenous
  parent: System.AppDomain
  langs:
  - csharp
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
  fullName: System.AppDomain.IsHomogenous
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera wartość wskazującą, czy bieżącej domeny aplikacji zawiera zestaw uprawnień, który został udzielony do wszystkich zestawów załadowanych do domeny aplikacji."
  remarks: "This property returns `true` for sandboxed application domains that were created by using the [AppDomain.CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) method overload. Sandboxed application domains have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain. A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.  \n  \n Fully trusted code can use the <xref:System.AppDomain.PermissionSet%2A> property to determine the homogenous grant set of a sandboxed application domain.  \n  \n This property also returns `true` for the default application domain of a desktop application, because that application domain grants full trust to all assemblies."
  syntax:
    content: public bool IsHomogenous { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli bieżąca domena aplikacji ma jednorodnego zestawu uprawnień; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.IsHomogenous*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[])
  id: Load(System.Byte[])
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[])
  nameWithType: AppDomain.Load(Byte[])
  fullName: System.AppDomain.Load(Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ładuje <xref:System.Reflection.Assembly>z obrazem formatu (COFF) na podstawie wspólnej pliku obiektu zawierającego emitowany <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>"
  remarks: "Począwszy od [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], poziom zaufania zestawu, który jest ładowany za pomocą tej metody jest taki sam jak poziom zaufania domeny aplikacji.       Tej metody należy użyć tylko w celu załadowania zestawu do bieżącej domeny aplikacji. Ta metoda jest przewidziane jako udogodnienie wywołań współdziałania, którzy nie można wywołać statycznych <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metody.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Ładowanie zestawów do innych domen aplikacji, należy użyć metody takie jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Aby uzyskać informacje, które są wspólne dla wszystkich przeciążenie tej metody, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>przeciążenie metody.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_1_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/m-system.appdomain.load-_1_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/m-system.appdomain.load-_1_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "Tablica typu <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> czyli COFF obrazu zawierający emitowany zestawu."
    return:
      type: System.Reflection.Assembly
      description: "Załadowanego zestawu."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>nie jest prawidłowym zestawem.       - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <code>rawAssembly</code> został skompilowany przy użyciu nowszej wersji."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Reflection.AssemblyName)
  id: Load(System.Reflection.AssemblyName)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(AssemblyName)
  nameWithType: AppDomain.Load(AssemblyName)
  fullName: System.AppDomain.Load(AssemblyName)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ładuje <xref:System.Reflection.Assembly>podane jego <xref:System.Reflection.AssemblyName>.</xref:System.Reflection.AssemblyName> </xref:System.Reflection.Assembly>"
  remarks: "Tej metody należy użyć tylko w celu załadowania zestawu do bieżącej domeny aplikacji. Ta metoda jest przewidziane jako udogodnienie wywołań współdziałania, którzy nie można wywołać statycznych <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metody.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Ładowanie zestawów do innych domen aplikacji, należy użyć metody takie jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Jeśli wersja żądany zestaw został już załadowany, ta metoda zwraca załadowanego zestawu, nawet jeśli wymagana jest inna wersja.       Podanie nazwy zestawu z częściowa dla `assemblyRef` nie jest zalecane. (Część nazwy pomija co najmniej jeden kultury, wersji lub token klucza publicznego. Dla przeciążeń, które przyjmują ciąg zamiast <xref:System.Reflection.AssemblyName>obiektu, &quot;MyAssembly, wersja =&1;.0.0.0&quot; przykładem część nazwy i &quot;MyAssembly, wersja&1;.0.0.0, Culture = neutral, PublicKeyToken = =&18;ab3442da84b47&quot; jest pełna nazwa.)</xref:System.Reflection.AssemblyName> Korzystanie z częściowa nazw ma negatywny wpływ na wydajność. Ponadto nazwy zestawu z częściowa można załadować zestawu z globalnej pamięci podręcznej zestawów tylko wtedy, gdy dokładną kopię zestawu w katalogu podstawowego aplikacji (<xref:System.AppDomain.BaseDirectory%2A> lub <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>).</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName> </xref:System.AppDomain.BaseDirectory%2A>       Jeśli bieżący <xref:System.AppDomain>obiekt reprezentuje domeny aplikacji `A`i <xref:System.AppDomain.Load%2A>Metoda jest wywoływana z domeny aplikacji `B`, zestaw jest ładowany do obu domen aplikacji.</xref:System.AppDomain.Load%2A> </xref:System.AppDomain> Na przykład poniższy kod obciążeń `MyAssembly` do nowej domeny aplikacji `ChildDomain` , a także do domeny aplikacji, w którym kod wykonywany: [!code-vb [System.AppDomain.Load#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_2_1.vb)][!code-cpp[System.AppDomain.Load#1](~/add/codesnippet/cpp/m-system.appdomain.load-_2_1.cpp)][!code-cs[System.AppDomain.Load#1](~/add/codesnippet/csharp/m-system.appdomain.load-_2_1.cs) ] zestaw jest ładowany do obie domeny, ponieważ <xref:System.Reflection.Assembly>nie pochodzi od <xref:System.MarshalByRefObject>i dlatego wartość zwracana <xref:System.AppDomain.Load%2A>metody nie mogą być przekazywane.</xref:System.AppDomain.Load%2A> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly>     Zamiast tego środowisko uruchomieniowe języka wspólnego próbuje załadować zestawu do wywoływania domeny aplikacji. Zestawy, które są ładowane do domeny dwóch aplikacji mogą się różnić, jeśli ustawienia ścieżki dla domeny dwóch aplikacji są różne.      > [!NOTE] > Jeśli obie <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=fullName>Właściwości i <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=fullName>Właściwości są ustawione, pierwsza próba załadowania zestawu, użyta zostanie nazwa wyświetlana (łącznie z wersji, kultury i tak dalej zwrócony przez <xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName>Właściwości).</xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName> </xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=fullName> </xref:System.Reflection.AssemblyName.Name%2A?displayProperty=fullName> Jeśli plik nie zostanie znaleziony, <xref:System.Reflection.AssemblyName.CodeBase%2A>właściwość jest używana do wyszukiwania zestawu.</xref:System.Reflection.AssemblyName.CodeBase%2A> Jeśli zestaw znajduje się za pomocą <xref:System.Reflection.AssemblyName.CodeBase%2A>, nazwa wyświetlana jest dopasowywana do zestawu.</xref:System.Reflection.AssemblyName.CodeBase%2A> W przypadku niepowodzenia dopasowania <xref:System.IO.FileLoadException>jest generowany.</xref:System.IO.FileLoadException>"
  syntax:
    content: public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);
    parameters:
    - id: assemblyRef
      type: System.Reflection.AssemblyName
      description: "Obiekt zestawu do załadowania."
    return:
      type: System.Reflection.Assembly
      description: "Załadowanego zestawu."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyRef</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyRef</code>Nie znaleziono."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyRef</code>nie jest prawidłowym zestawem.       - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <code>assemblyRef</code> został skompilowany przy użyciu nowszej wersji."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  platform:
  - net462
- uid: System.AppDomain.Load(System.String)
  id: Load(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(String)
  nameWithType: AppDomain.Load(String)
  fullName: System.AppDomain.Load(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ładunki <xref:System.Reflection.Assembly>podanej nazwy wyświetlanej.</xref:System.Reflection.Assembly>"
  remarks: "Tej metody należy użyć tylko w celu załadowania zestawu do bieżącej domeny aplikacji. Ta metoda jest przewidziane jako udogodnienie wywołań współdziałania, którzy nie można wywołać statycznych <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metody.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Ładowanie zestawów do innych domen aplikacji, należy użyć metody takie jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Aby uzyskać informacje, które są wspólne dla wszystkich przeciążenie tej metody, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>przeciążenie metody.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (string assemblyString);
    parameters:
    - id: assemblyString
      type: System.String
      description: "Nazwa wyświetlana zestawu. Zobacz &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    return:
      type: System.Reflection.Assembly
      description: "Załadowanego zestawu."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyString</code>jest<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyString</code>Nie znaleziono."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyString</code>nie jest prawidłowym zestawem.       - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <code>assemblyString</code> został skompilowany przy użyciu nowszej wersji."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[],System.Byte[])
  id: Load(System.Byte[],System.Byte[])
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[],Byte[])
  nameWithType: AppDomain.Load(Byte[],Byte[])
  fullName: System.AppDomain.Load(Byte[],Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ładuje <xref:System.Reflection.Assembly>z obrazem formatu (COFF) na podstawie wspólnej pliku obiektu zawierającego emitowany <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly> Nieprzetworzona bajtów reprezentujący symboli dla <xref:System.Reflection.Assembly>również zostały załadowane.</xref:System.Reflection.Assembly>"
  remarks: "Począwszy od [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], poziom zaufania zestawu, który jest ładowany za pomocą tej metody jest taki sam jak poziom zaufania domeny aplikacji.       Tej metody należy użyć tylko w celu załadowania zestawu do bieżącej domeny aplikacji. Ta metoda jest przewidziane jako udogodnienie wywołań współdziałania, którzy nie można wywołać statycznych <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metody.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Ładowanie zestawów do innych domen aplikacji, należy użyć metody takie jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Aby uzyskać informacje, które są wspólne dla wszystkich przeciążenie tej metody, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>przeciążenie metody.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_0_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/m-system.appdomain.load-_0_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/m-system.appdomain.load-_0_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "Tablica typu <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> czyli COFF obrazu zawierający emitowany zestawu."
    - id: rawSymbolStore
      type: System.Byte[]
      description: "Tablica typu <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> zawierające nieprzetworzone bajtów reprezentujący symboli dla zestawu."
    return:
      type: System.Reflection.Assembly
      description: "Załadowanego zestawu."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>nie jest prawidłowym zestawem.       - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <code>rawAssembly</code> został skompilowany przy użyciu nowszej wersji."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  id: Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(AssemblyName,Evidence)
  nameWithType: AppDomain.Load(AssemblyName,Evidence)
  fullName: System.AppDomain.Load(AssemblyName,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ładuje <xref:System.Reflection.Assembly>podane jego <xref:System.Reflection.AssemblyName>.</xref:System.Reflection.AssemblyName> </xref:System.Reflection.Assembly>"
  remarks: "Tej metody należy użyć tylko w celu załadowania zestawu do bieżącej domeny aplikacji. Ta metoda jest przewidziane jako udogodnienie wywołań współdziałania, którzy nie można wywołać statycznych <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metody.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Ładowanie zestawów do innych domen aplikacji, należy użyć metody takie jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Aby uzyskać informacje, które są wspólne dla wszystkich przeciążenie tej metody, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>przeciążenie metody.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyRef
      type: System.Reflection.AssemblyName
      description: "Obiekt zestawu do załadowania."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Dowód ładowania zestawu."
    return:
      type: System.Reflection.Assembly
      description: "Załadowanego zestawu."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyRef</code>jest<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyRef</code>Nie znaleziono."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyRef</code>nie jest prawidłowym zestawem.       - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <code>assemblyRef</code> został skompilowany przy użyciu nowszej wersji."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  platform:
  - net462
- uid: System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  id: Load(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(String,Evidence)
  nameWithType: AppDomain.Load(String,Evidence)
  fullName: System.AppDomain.Load(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ładunki <xref:System.Reflection.Assembly>podanej nazwy wyświetlanej.</xref:System.Reflection.Assembly>"
  remarks: "Tej metody należy użyć tylko w celu załadowania zestawu do bieżącej domeny aplikacji. Ta metoda jest przewidziane jako udogodnienie wywołań współdziałania, którzy nie można wywołać statycznych <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metody.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Ładowanie zestawów do innych domen aplikacji, należy użyć metody takie jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Aby uzyskać informacje, które są wspólne dla wszystkich przeciążenie tej metody, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>przeciążenie metody.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyString
      type: System.String
      description: "Nazwa wyświetlana zestawu. Zobacz &lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;."
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "Dowód ładowania zestawu."
    return:
      type: System.Reflection.Assembly
      description: "Załadowanego zestawu."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyString</code>jest<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyString</code>Nie znaleziono."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyString</code>nie jest prawidłowym zestawem.       - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <code>assemblyString</code> został skompilowany przy użyciu nowszej wersji."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  id: Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[],Byte[],Evidence)
  nameWithType: AppDomain.Load(Byte[],Byte[],Evidence)
  fullName: System.AppDomain.Load(Byte[],Byte[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ładuje <xref:System.Reflection.Assembly>z obrazem formatu (COFF) na podstawie wspólnej pliku obiektu zawierającego emitowany <xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly> Nieprzetworzona bajtów reprezentujący symboli dla <xref:System.Reflection.Assembly>również zostały załadowane.</xref:System.Reflection.Assembly>"
  remarks: "Począwszy od [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], poziom zaufania zestawu, który jest ładowany za pomocą tej metody jest taki sam jak poziom zaufania domeny aplikacji.       Tej metody należy użyć tylko w celu załadowania zestawu do bieżącej domeny aplikacji. Ta metoda jest przewidziane jako udogodnienie wywołań współdziałania, którzy nie można wywołać statycznych <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>metody.</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> Ładowanie zestawów do innych domen aplikacji, należy użyć metody takie jak <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>       Aby uzyskać informacje, które są wspólne dla wszystkich przeciążenie tej metody, zobacz <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>przeciążenie metody.</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/1e204365-b0ec-4650-8d52-_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/1e204365-b0ec-4650-8d52-_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/1e204365-b0ec-4650-8d52-_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "Tablica typu <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> czyli COFF obrazu zawierający emitowany zestawu."
    - id: rawSymbolStore
      type: System.Byte[]
      description: "Tablica typu <xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;> </xref> zawierające nieprzetworzone bajtów reprezentujący symboli dla zestawu."
    - id: securityEvidence
      type: System.Security.Policy.Evidence
      description: "Dowód ładowania zestawu."
    return:
      type: System.Reflection.Assembly
      description: "Załadowanego zestawu."
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>nie jest prawidłowym zestawem.       - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i <code>rawAssembly</code> został skompilowany przy użyciu nowszej wersji."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "Zestaw lub moduł został załadowany z dwóch różnych też dowody."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>securityEvidence</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. Gdy starszą zasadę nie jest włączone, <code>securityEvidence</code> powinien być <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.MonitoringIsEnabled
  id: MonitoringIsEnabled
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
  fullName: System.AppDomain.MonitoringIsEnabled
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera lub ustawia wartość wskazującą, czy procesora CPU i pamięci monitorowania domeny aplikacji jest włączone dla bieżącego procesu. Gdy monitorowanie jest włączone dla procesu, nie można wyłączyć."
  remarks: "To `static` właściwości (`Shared` właściwość w języku Visual Basic) steruje procesora CPU i pamięci monitorowania wszystkich domen aplikacji w procesie.       Jeśli spróbujesz ustawić tę właściwość na `false`, <xref:System.ArgumentException>wyjątek jest zgłaszany, nawet jeśli bieżąca wartość właściwości jest `false`.</xref:System.ArgumentException>       Gdy jest włączone monitorowanie, możesz użyć <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, i <xref:System.AppDomain.MonitoringTotalProcessorTime%2A>wystąpienia właściwości do monitorowania użycia procesora CPU i pamięci domen aplikacji.</xref:System.AppDomain.MonitoringTotalProcessorTime%2A> </xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A> </xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A> </xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>"
  syntax:
    content: public static bool MonitoringIsEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli jest włączone monitorowanie; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.MonitoringIsEnabled*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Bieżący proces Próbowano przypisać wartość <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> do tej właściwości."
  platform:
  - net462
- uid: System.AppDomain.MonitoringSurvivedMemorySize
  id: MonitoringSurvivedMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
  fullName: System.AppDomain.MonitoringSurvivedMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera liczbę bajtów, który udało się przetrwać ostatniego zebrania i które są znane odwoływać się do bieżącej domeny aplikacji."
  remarks: "Statystyki są aktualizowane przy każdym wyrzucanie elementów bezużytecznych. Jednak gwarancji one być dokładne tylko po pełnej, blokowanie kolekcji; występuje, oznacza to, kolekcję zawierającą wszystkie generacje i zatrzymuje się podczas pobierania aplikacji. Na przykład <xref:System.GC.Collect?displayProperty=fullName>przeciążenie metody wykonuje pełne, blokowanie kolekcji.</xref:System.GC.Collect?displayProperty=fullName> (Kolekcji współbieżnych przebiega w tle i nie są blokowane w aplikacji)."
  syntax:
    content: public long MonitoringSurvivedMemorySize { get; }
    return:
      type: System.Int64
      description: "Liczba bajtów zachowane."
  overload: System.AppDomain.MonitoringSurvivedMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> w języku Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled*>właściwość jest ustawiona na <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize
  id: MonitoringSurvivedProcessMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
  fullName: System.AppDomain.MonitoringSurvivedProcessMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera całkowitą liczbę bajtów, które udało przetrwać od ostatniego zebrania dla wszystkich domen aplikacji w procesie."
  remarks: "Po pobraniu pełne, blokowania to liczba reprezentuje liczbę bajtów aktualnie przechowywany na żywo w zarządzanych stertach. Powinien być bliski liczba zgłoszonych przez <xref:System.GC.GetTotalMemory%2A>metody.</xref:System.GC.GetTotalMemory%2A> Po pobraniu tymczasowych ta liczba reprezentuje liczbę bajtów posiadanych na żywo w generacje tymczasowych."
  syntax:
    content: public static long MonitoringSurvivedProcessMemorySize { get; }
    return:
      type: System.Int64
      description: "Całkowita liczba bajtów sprawny dla procesu."
  overload: System.AppDomain.MonitoringSurvivedProcessMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> w języku Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled*>właściwość jest ustawiona na <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize
  id: MonitoringTotalAllocatedMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
  fullName: System.AppDomain.MonitoringTotalAllocatedMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera całkowity rozmiar w bajtach, wszystkie alokacji pamięci, które zostały wprowadzone przez domenę aplikacji od czasu utworzenia, bez odjęcie ilości pamięci, które zostały zebrane."
  syntax:
    content: public long MonitoringTotalAllocatedMemorySize { get; }
    return:
      type: System.Int64
      description: "Całkowity rozmiar wszystkich alokacji pamięci."
  overload: System.AppDomain.MonitoringTotalAllocatedMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> w języku Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled*>właściwość jest ustawiona na <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringTotalProcessorTime
  id: MonitoringTotalProcessorTime
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
  fullName: System.AppDomain.MonitoringTotalProcessorTime
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera całkowitego czasu procesora użytą przez wszystkie wątki podczas wykonywania w bieżącej domenie aplikacji, od momentu uruchomienia procesu."
  remarks: "Całkowity czas, który jest zgłaszany, dla domeny aplikacji obejmuje czas każdy wątek w procesie wykonywania w tej domenie aplikacji.       Wątek, który odwołuje się do kodu niezarządzanego jest nadal skojarzone z domeny aplikacji, a czas procesora poświęcony na wykonywanie kodu niezarządzanego jest raportowane dla domeny aplikacji, w którym wykonano wywołanie.       Gdy wątek jest zablokowany lub uśpiony, go nie zużywa czas procesora."
  syntax:
    content: public TimeSpan MonitoringTotalProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "Łączny czas procesora dla bieżącej domeny aplikacji."
  overload: System.AppDomain.MonitoringTotalProcessorTime*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref> w języku Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled*>właściwość jest ustawiona na <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.PermissionSet
  id: PermissionSet
  parent: System.AppDomain
  langs:
  - csharp
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
  fullName: System.AppDomain.PermissionSet
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera zestaw uprawnień w domenie aplikacji piaskownicy."
  remarks: "Domeny aplikacji w trybie piaskownicy, które zostały utworzone przy użyciu [AppDomain.CreateDomain (ciąg, dowód, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) przeciążenie metody ma jednorodnego zestawu uprawnień; oznacza to, uzyskuje ten sam zestaw uprawnień do wszystkich zestawów częściowo zaufany, które są ładowane do domeny aplikacji. Domeny aplikacji w trybie piaskownicy opcjonalnie zawiera listę zestawów o silnych nazwach, które są wykluczone z tego uprawnienia ustawiona, a zamiast tego Uruchom przy pełnym zaufaniu."
  syntax:
    content: public System.Security.PermissionSet PermissionSet { get; }
    return:
      type: System.Security.PermissionSet
      description: "Zestaw uprawnień w domenie aplikacji piaskownicy."
  overload: System.AppDomain.PermissionSet*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ProcessExit
  id: ProcessExit
  parent: System.AppDomain
  langs:
  - csharp
  name: ProcessExit
  nameWithType: AppDomain.ProcessExit
  fullName: System.AppDomain.ProcessExit
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Występuje, gdy kończy proces nadrzędny domyślnej domeny aplikacji."
  remarks: "<xref:System.EventHandler>Dla to zdarzenie można wykonać zakończenia działania, takie jak zamykanie plików, zwalniając magazynu i tak dalej przed zakończeniem procesu.</xref:System.EventHandler>       Począwszy od programu .NET Framework w wersji 2.0, to zdarzenie jest zgłaszane w każdej domenie aplikacji, która rejestruje program obsługi zdarzeń.      > [!NOTE] > Łączny czas wykonywania wszystkich programów obsługi zdarzeń ProcessExit jest ograniczona, tak samo, jak całkowity czas wykonywania wszystkich finalizatory jest ograniczona w Zamykanie procesu. Wartość domyślna to dwie sekundy. Niezarządzane hosta można zmienić czasu wykonania przez wywołanie metody [ICLRPolicyManager::SetTimeout](~/add/includes/ajax-current-ext-md.md) metody z [OPR_ProcessExit](~/add/includes/ajax-current-ext-md.md) wartości wyliczenia.       W wersji systemu .NET Framework 1.0 i 1.1 to zdarzenie jest wywoływane tylko w domyślnej domeny aplikacji i tylko wtedy, gdy program obsługi zdarzeń jest zarejestrowany w domyślnej domeny aplikacji.       Aby zarejestrować program obsługi zdarzeń dla tego zdarzenia, musi mieć wymagane uprawnienia lub <xref:System.Security.SecurityException>jest generowany.</xref:System.Security.SecurityException>       Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [zdarzenia](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event EventHandler ProcessExit;
    return:
      type: System.EventHandler
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ReflectionOnlyAssemblyResolve
  id: ReflectionOnlyAssemblyResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: ReflectionOnlyAssemblyResolve
  nameWithType: AppDomain.ReflectionOnlyAssemblyResolve
  fullName: System.AppDomain.ReflectionOnlyAssemblyResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Występuje, gdy rozpoznawania zestawu nie powiodło się w kontekstu reflection-only."
  remarks: "W kontekście tylko odbicie zależności nie są rozpoznawane automatycznie. Muszą być wstępnie ładowane lub zwrócone przez procedurę obsługi dla tego zdarzenia. To zdarzenie jest wywoływane, gdy ma zależność, która nie jest już załadowana do kontekstu reflection-only. Brakująca zależność jest określona przez <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>Właściwości.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName> <xref:System.ResolveEventHandler>Dla tego zdarzenia musi zwracać zestawu, który spełnia zależność.</xref:System.ResolveEventHandler> Zestaw, który jest zwracany muszą być załadowane do kontekstu reflection-only.      > [!IMPORTANT] > To zdarzenie jest wywoływane tylko w przypadku brakujące zależności zestawu, który jest ładowany do kontekstu reflection-only (na przykład za pomocą <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=fullName>metody).</xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=fullName> Nie jest wywoływane, jeśli nie można znaleźć zestawu, które są ładowane.       Począwszy od [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>właściwość zwraca żądane ładowanie zestawu, którego nie można rozpoznać zestawu.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> Znajomość tożsamości żądającego zestawu może być przydatne do określenia poprawnej wersji zależności, jeśli jest dostępna więcej niż jedna wersja. Aby uzyskać więcej informacji zobacz <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>       Dla tego zdarzenia <xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>właściwość zwraca nazwę zestawu, przed zastosowaniem zasad.</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>       Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [zdarzenia](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event ResolveEventHandler ReflectionOnlyAssemblyResolve;
    return:
      type: System.ResolveEventHandler
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ReflectionOnlyGetAssemblies
  id: ReflectionOnlyGetAssemblies
  parent: System.AppDomain
  langs:
  - csharp
  name: ReflectionOnlyGetAssemblies()
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies()
  fullName: System.AppDomain.ReflectionOnlyGetAssemblies()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Zwraca zestawy, które zostały załadowane do kontekstu reflection-only domeny aplikacji."
  remarks: "Ta metoda zwraca zestawy, które zostały załadowane do kontekstu reflection-only. Aby uzyskać zestawy, które zostały załadowane do wykonania, należy użyć <xref:System.AppDomain.GetAssemblies%2A>metody.</xref:System.AppDomain.GetAssemblies%2A>"
  example:
  - "The following code example loads the System.dll assembly into the execution context and then into the reflection-only context. The <xref:System.AppDomain.GetAssemblies%2A> and ReflectionOnlyGetAssemblies methods are used to display the assemblies loaded into each context.  \n  \n [!code-cs[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/csharp/m-system.appdomain.refle_1.cs)]\n [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/cpp/m-system.appdomain.refle_1.cpp)]\n [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/visualbasic/m-system.appdomain.refle_1.vb)]"
  syntax:
    content: public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();
    parameters: []
    return:
      type: System.Reflection.Assembly[]
      description: "Tablica <xref:System.Reflection.Assembly>obiektów, które reprezentują zestawy ładowane do kontekstu reflection-only domeny aplikacji.</xref:System.Reflection.Assembly>"
  overload: System.AppDomain.ReflectionOnlyGetAssemblies*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "W domenie aplikacji zwolniony nastąpi próba wykonania operacji."
  platform:
  - net462
- uid: System.AppDomain.RelativeSearchPath
  id: RelativeSearchPath
  parent: System.AppDomain
  langs:
  - csharp
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
  fullName: System.AppDomain.RelativeSearchPath
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera ścieżkę katalogu podstawowego gdzie powinien sondowania mechanizm rozpoznawania zestawów dla zestawy prywatne."
  remarks: "Zestawy prywatne są wdrażane w tej samej struktury katalogów, co aplikacja. Jeśli ścieżka określona przez właściwość RelativeSearchPath nie jest w obszarze <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>, zostanie zignorowany.</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>       Ta właściwość zwraca wartość ustawiona przy użyciu <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>.</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>"
  syntax:
    content: public string RelativeSearchPath { get; }
    return:
      type: System.String
      description: "Ścieżka katalogu podstawowego gdzie mechanizm rozpoznawania zestawów powinny sondować zestawy prywatne."
  overload: System.AppDomain.RelativeSearchPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.ResourceResolve
  id: ResourceResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: ResourceResolve
  nameWithType: AppDomain.ResourceResolve
  fullName: System.AppDomain.ResourceResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Występuje, gdy rozwiązanie zasobu nie powiedzie się, ponieważ zasób nie jest prawidłowy zasób połączony lub osadzony w zestawie."
  remarks: "<xref:System.ResolveEventHandler>Dla tego zdarzenia może podjąć próbę zlokalizować zestawu zawierającego zasobów i zwraca go.</xref:System.ResolveEventHandler>      > [!IMPORTANT] > To zdarzenie nie jest wywoływane, jeśli rozpoznawania nie powiedzie się, ponieważ nie można odnaleźć pliku dla prawidłowego połączonego zasobu. Jest on uruchamiany, jeśli nie można znaleźć strumienia zasobu manifestu, ale nie jest wywoływane, jeśli nie można odnaleźć klucza pojedynczego zasobu.       Począwszy od [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>właściwość zawiera zestaw żądanego zasobu.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> Aby uzyskać więcej informacji zobacz <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>       Aby zarejestrować program obsługi zdarzeń dla tego zdarzenia, musi mieć wymagane uprawnienia lub <xref:System.Security.SecurityException>jest generowany.</xref:System.Security.SecurityException>       Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [zdarzenia](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public event ResolveEventHandler ResourceResolve;
    return:
      type: System.ResolveEventHandler
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  id: SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetAppDomainPolicy(PolicyLevel)
  nameWithType: AppDomain.SetAppDomainPolicy(PolicyLevel)
  fullName: System.AppDomain.SetAppDomainPolicy(PolicyLevel)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ustanawia poziomu zasad zabezpieczeń dla tej domeny aplikacji."
  remarks: "Ta metoda jest wywoływana przed zestaw jest ładowany do <xref:System.AppDomain>w kolejności obowiązują zasady zabezpieczeń.</xref:System.AppDomain>"
  example:
  - "The following example demonstrates how to use the SetAppDomainPolicymethod to set the security policy level of an application domain.  \n  \n [!code-cs[ADSetAppDomainPolicy#1](~/add/codesnippet/csharp/m-system.appdomain.setap_1.cs)]\n [!code-cpp[ADSetAppDomainPolicy#1](~/add/codesnippet/cpp/m-system.appdomain.setap_1.cpp)]\n [!code-vb[ADSetAppDomainPolicy#1](~/add/codesnippet/visualbasic/m-system.appdomain.setap_1.vb)]"
  syntax:
    content: public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);
    parameters:
    - id: domainPolicy
      type: System.Security.Policy.PolicyLevel
      description: "Poziomu zasad zabezpieczeń."
  overload: System.AppDomain.SetAppDomainPolicy*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>domainPolicy</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.Policy.PolicyException
    commentId: T:System.Security.Policy.PolicyException
    description: "Poziom zabezpieczeń zasad została już ustawiona."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.SetCachePath(System.String)
  id: SetCachePath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetCachePath(String)
  nameWithType: AppDomain.SetCachePath(String)
  fullName: System.AppDomain.SetCachePath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Określa ścieżkę katalogu określonego jako lokalizacji, w którym zestawy są kopie w tle."
  remarks: "Ścieżka pamięci podręcznej jest ignorowana, jeśli <xref:System.AppDomainSetup.ApplicationName%2A>nie ustawiono właściwości.</xref:System.AppDomainSetup.ApplicationName%2A> Zobacz <xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>Właściwości.</xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>       Aby uzyskać więcej informacji na temat Kopiowanie w tle Zobacz [Kopiowanie zestawów w tle](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void SetCachePath (string path);
    parameters:
    - id: path
      type: System.String
      description: "Pełna ścieżka do lokalizacji kopiowania w tle."
  overload: System.AppDomain.SetCachePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.SetData(System.String,System.Object)
  id: SetData(System.String,System.Object)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetData(String,Object)
  nameWithType: AppDomain.SetData(String,Object)
  fullName: System.AppDomain.SetData(String,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Przypisuje określona wartość właściwości określonej aplikacji."
  remarks: "Użyj tej metody, aby wstawić wpis lub zmodyfikuj wartość wpisu w wewnętrznej pamięci podręcznej par nazwa danych opisujących właściwości tego wystąpienia <xref:System.AppDomain>.</xref:System.AppDomain>       Pamięć podręczna zawiera automatycznie wpisy wstępnie zdefiniowanych systemu, które są wstawiane podczas tworzenia domeny aplikacji. Nie można wstawić lub zmodyfikować wpisy systemu za pomocą tej metody. Wywołanie metody, która próbuje zmodyfikować wpis systemu nie obowiązuje; Metoda nie zgłasza wyjątek. Możesz sprawdzić wartości system wpisów z <xref:System.AppDomain.GetData%2A>metody, lub równoważne <xref:System.AppDomainSetup>właściwości opisane w <xref:System.AppDomain.GetData%2A>.</xref:System.AppDomain.GetData%2A> </xref:System.AppDomainSetup> </xref:System.AppDomain.GetData%2A>       Można wywołać tej metody można ustawić wartości domyślny limit czasu dla obliczenia wyrażenia regularnego wzorce przez dostaw &quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot; jako wartości `name` argumentu i <xref:System.TimeSpan>wartość, która reprezentuje jako wartość interwał limitu czasu `data` argument.</xref:System.TimeSpan> Możesz również wstawić lub zmodyfikować własne par nazwa danych zdefiniowanych przez użytkownika za pomocą tej metody i sprawdzać ich wartości z <xref:System.AppDomain.GetData%2A>metody.</xref:System.AppDomain.GetData%2A>"
  example:
  - "The following example demonstrates how to use the SetData method to create a new value pair. The example then uses the <xref:System.AppDomain.GetData%2A> method to retrieve the value, and displays it to the console.  \n  \n [!code-cpp[ADGetData#1](~/add/codesnippet/cpp/m-system.appdomain.setda_1.cpp)]\n [!code-vb[ADGetData#1](~/add/codesnippet/visualbasic/m-system.appdomain.setda_1.vb)]\n [!code-cs[ADGetData#1](~/add/codesnippet/csharp/m-system.appdomain.setda_1.cs)]"
  syntax:
    content: public void SetData (string name, object data);
    parameters:
    - id: name
      type: System.String
      description: "Nazwa właściwości domeny użytkownika aplikacji do tworzenia lub zmiany."
    - id: data
      type: System.Object
      description: "Wartość właściwości."
  overload: System.AppDomain.SetData*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  id: SetData(System.String,System.Object,System.Security.IPermission)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetData(String,Object,IPermission)
  nameWithType: AppDomain.SetData(String,Object,IPermission)
  fullName: System.AppDomain.SetData(String,Object,IPermission)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Przypisuje określona dla właściwości domeny określonej aplikacji z określonego uprawnienia, aby żądanie obiektu wywołującego, gdy właściwość zostanie pobrana."
  remarks: "Użyj tej metody można wstawić ani modyfikować własnych wpisów zdefiniowane przez użytkownika w wewnętrznej pamięci podręcznej par nazwa/danych, które opisują właściwości domeny aplikacji. Po wstawieniu wpis, można określić żądanie uprawnień, aby wymusić po pobraniu wpis. Ponadto można wywołać tej metody można ustawić wartości domyślny limit czasu dla obliczenia wyrażenia regularnego wzorce przez dostaw &quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot; jako wartości `name` argumentu i <xref:System.TimeSpan>wartość, która reprezentuje jako wartość interwał limitu czasu `data` argument.</xref:System.TimeSpan>       Nie można użyć tej metody można przypisać żądania zabezpieczeń do ciągu właściwości zdefiniowane przez system.       Pamięć podręczna zawiera automatycznie wpisy wstępnie zdefiniowanych systemu, które są wstawiane podczas tworzenia domeny aplikacji. Nie można wstawić lub zmodyfikować wpisy systemu za pomocą tej metody. Wywołanie metody, która próbuje zmodyfikować wpis systemu nie obowiązuje; Metoda nie zgłasza wyjątek. Możesz sprawdzić wartości system wpisów z <xref:System.AppDomain.GetData%2A>metody lub jego odpowiednik <xref:System.AppDomainSetup>właściwości opisane w sekcji uwag dla <xref:System.AppDomain.GetData%2A>— Metoda.</xref:System.AppDomain.GetData%2A> </xref:System.AppDomainSetup> </xref:System.AppDomain.GetData%2A>"
  syntax:
    content: public void SetData (string name, object data, System.Security.IPermission permission);
    parameters:
    - id: name
      type: System.String
      description: "Nazwa właściwości domeny użytkownika aplikacji do tworzenia lub zmiany."
    - id: data
      type: System.Object
      description: "Wartość właściwości."
    - id: permission
      type: System.Security.IPermission
      description: "Uprawnienie do żądanie obiektu wywołującego, gdy właściwość zostanie pobrana."
  overload: System.AppDomain.SetData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>name</code>Określa ciąg właściwości zdefiniowane przez system i <code>permission</code> nie jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.AppDomain.SetDynamicBase(System.String)
  id: SetDynamicBase(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetDynamicBase(String)
  nameWithType: AppDomain.SetDynamicBase(String)
  fullName: System.AppDomain.SetDynamicBase(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Określa ścieżkę katalogu określonego jako podstawowego katalogu do podkatalogów, gdzie przechowywane dynamicznie generowanym plików i dostępne."
  remarks: "Ta metoda ustawia <xref:System.AppDomainSetup.DynamicBase%2A>Właściwości wewnętrznego <xref:System.AppDomainSetup>skojarzony z tym wystąpieniem.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.DynamicBase%2A>"
  example:
  - "This method is now obsolete, and should not be used for new development. The following example shows how to use the non-obsolete alternative, the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> property. For an explanation of this example, see the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> property or the <xref:System.AppDomain.DynamicDirectory%2A> property.  \n  \n [!code-cpp[ADDynamicBase#1](~/add/codesnippet/cpp/m-system.appdomain.setdy_1.cpp)]\n [!code-cs[ADDynamicBase#1](~/add/codesnippet/csharp/m-system.appdomain.setdy_1.cs)]\n [!code-vb[ADDynamicBase#1](~/add/codesnippet/visualbasic/m-system.appdomain.setdy_1.vb)]"
  syntax:
    content: public void SetDynamicBase (string path);
    parameters:
    - id: path
      type: System.String
      description: "Pełni kwalifikowana ścieżka jest katalogiem podstawowej podkatalogi przechowywania zestawów dynamicznych."
  overload: System.AppDomain.SetDynamicBase*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  id: SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetPrincipalPolicy(PrincipalPolicy)
  nameWithType: AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  fullName: System.AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Określa, jak obiekty Principal role i tożsamość musi być podłączona do wątku wątek próba powiązania do podmiotu zabezpieczeń podczas wykonywania w tej domenie aplikacji."
  remarks: "Ustawienie wartości tylko zostaną zastosowane, jeśli zostanie ustawiona przed użyciem <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>Właściwości.</xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> Na przykład jeśli ustawisz <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>do danego podmiotu zabezpieczeń (na przykład ogólny podmiot zabezpieczeń), a następnie użycie metody SetPrincipalPolicy, aby ustawić <xref:System.Security.Principal.PrincipalPolicy>do <xref:System.Security.Principal.PrincipalPolicy>, bieżący podmiot zabezpieczeń pozostanie ogólnego podmiot zabezpieczeń.</xref:System.Security.Principal.PrincipalPolicy> </xref:System.Security.Principal.PrincipalPolicy> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>"
  example:
  - "The following example shows the effect on threads of using the SetPrincipalPolicy method to change the principal policy of the application domain. It also shows the effect of using the <xref:System.AppDomain.SetThreadPrincipal%2A> method to change the principal that is available for attaching to threads in the application domain.  \n  \n [!code-cpp[ADPrincipal#1](~/add/codesnippet/cpp/m-system.appdomain.setpr_1.cpp)]\n [!code-vb[ADPrincipal#1](~/add/codesnippet/visualbasic/m-system.appdomain.setpr_1.vb)]\n [!code-cs[ADPrincipal#1](~/add/codesnippet/csharp/m-system.appdomain.setpr_1.cs)]"
  syntax:
    content: public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);
    parameters:
    - id: policy
      type: System.Security.Principal.PrincipalPolicy
      description: "Jeden z <xref href=&quot;System.Security.Principal.PrincipalPolicy&quot;> </xref> wartości, które określają typ obiektu głównej można dołączyć do wątków."
  overload: System.AppDomain.SetPrincipalPolicy*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.SetShadowCopyFiles
  id: SetShadowCopyFiles
  parent: System.AppDomain
  langs:
  - csharp
  name: SetShadowCopyFiles()
  nameWithType: AppDomain.SetShadowCopyFiles()
  fullName: System.AppDomain.SetShadowCopyFiles()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Włącza kopiowanie w tle."
  remarks: "Aby uzyskać więcej informacji na temat kopiowania w tle, zobacz [Kopiowanie zestawów w tle](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[adproperties#1](~/add/codesnippet/cpp/m-system.appdomain.setsh_0_1.cpp)]\n [!code-vb[adproperties#1](~/add/codesnippet/visualbasic/m-system.appdomain.setsh_0_1.vb)]\n [!code-cs[adproperties#1](~/add/codesnippet/csharp/m-system.appdomain.setsh_0_1.cs)]"
  syntax:
    content: public void SetShadowCopyFiles ();
    parameters: []
  overload: System.AppDomain.SetShadowCopyFiles*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.SetShadowCopyPath(System.String)
  id: SetShadowCopyPath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetShadowCopyPath(String)
  nameWithType: AppDomain.SetShadowCopyPath(String)
  fullName: System.AppDomain.SetShadowCopyPath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Określa ścieżkę katalogu określonego jako lokalizacji zestawów się kopie w tle."
  remarks: "Domyślnie kopia w tle obejmuje wszystkie zestawy znaleziono przez sondowanie. Metoda SetShadowCopyPath ogranicza kopii w tle do zestawów w określonym przez `path`.       Metoda SetShadowCopyPath nie określa dodatkowe katalogi wyszukiwania zestawów. Zestawy należy skopiować w tle musi znajdować się już w ścieżce wyszukiwania, na przykład w obszarze <xref:System.AppDomain.BaseDirectory%2A>.</xref:System.AppDomain.BaseDirectory%2A> Metoda SetShadowCopyPath określa ścieżki wyszukiwania, które kwalifikują się na tle skopiowane.       Ta metoda ustawia <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>Właściwości wewnętrznego <xref:System.AppDomainSetup>skojarzony z tym wystąpieniem.</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.ShadowCopyDirectories%2A>       Aby uzyskać więcej informacji na temat kopiowania w tle, zobacz [Kopiowanie zestawów w tle](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[ADShadowCopy#1](~/add/codesnippet/cpp/m-system.appdomain.setsh_1_1.cpp)]\n [!code-vb[ADShadowCopy#1](~/add/codesnippet/visualbasic/m-system.appdomain.setsh_1_1.vb)]\n [!code-cs[ADShadowCopy#1](~/add/codesnippet/csharp/m-system.appdomain.setsh_1_1.cs)]"
  syntax:
    content: public void SetShadowCopyPath (string path);
    parameters:
    - id: path
      type: System.String
      description: "Lista nazw katalogów, których nazwy oddzielone średnikami."
  overload: System.AppDomain.SetShadowCopyPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  id: SetThreadPrincipal(System.Security.Principal.IPrincipal)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetThreadPrincipal(IPrincipal)
  nameWithType: AppDomain.SetThreadPrincipal(IPrincipal)
  fullName: System.AppDomain.SetThreadPrincipal(IPrincipal)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Ustawia domyślnego obiektu głównego jest dołączony do wątków, jeśli ich próba powiązania do podmiotu zabezpieczeń podczas wykonywania w tej domenie aplikacji."
  remarks: ''
  example:
  - "The following example shows the effect of using the SetThreadPrincipal method to change the principal that is available for attaching to threads that are executing in the application domain. It also shows the effect on threads of using the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to change the principal policy of the application domain.  \n  \n [!code-cpp[ADPrincipal#1](~/add/codesnippet/cpp/m-system.appdomain.setth_1.cpp)]\n [!code-vb[ADPrincipal#1](~/add/codesnippet/visualbasic/m-system.appdomain.setth_1.vb)]\n [!code-cs[ADPrincipal#1](~/add/codesnippet/csharp/m-system.appdomain.setth_1.cs)]"
  syntax:
    content: public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);
    parameters:
    - id: principal
      type: System.Security.Principal.IPrincipal
      description: "Obiekt główny, aby dołączyć do wątków."
  overload: System.AppDomain.SetThreadPrincipal*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>principal</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.Policy.PolicyException
    commentId: T:System.Security.Policy.PolicyException
    description: "Główny wątek został już ustawiony."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.SetupInformation
  id: SetupInformation
  parent: System.AppDomain
  langs:
  - csharp
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
  fullName: System.AppDomain.SetupInformation
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera informacje o konfiguracji domeny aplikacji dla tego wystąpienia."
  syntax:
    content: public AppDomainSetup SetupInformation { get; }
    return:
      type: System.AppDomainSetup
      description: "Informacje o inicjowania domeny aplikacji."
  overload: System.AppDomain.SetupInformation*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.ShadowCopyFiles
  id: ShadowCopyFiles
  parent: System.AppDomain
  langs:
  - csharp
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
  fullName: System.AppDomain.ShadowCopyFiles
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera wskazuje, czy domena aplikacji jest skonfigurowana do plików kopii w tle."
  remarks: "Aby uzyskać więcej informacji, zobacz <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>i [Kopiowanie zestawów w tle](~/add/includes/ajax-current-ext-md.md).</xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>"
  syntax:
    content: public bool ShadowCopyFiles { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli domena aplikacji jest skonfigurowana do pliki kopii w tle; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.AppDomain.ShadowCopyFiles*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Próba operacji zostanie podjęta na domeny aplikacji zwolniony."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  id: System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Zestaw nazw jest mapowany na odpowiedni zestaw identyfikatorów wysyłania."
  remarks: "Ta metoda jest dostęp do zarządzanych klas z kodem niezarządzanym i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetIDsOfNames`, zobacz bibliotece MSDN."
  syntax:
    content: void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
    parameters:
    - id: riid
      type: System.Guid
      description: "Zarezerwowane do użytku w przyszłości. Musi być ma wartości IID_NULL."
    - id: rgszNames
      type: System.IntPtr
      description: "Tablica przekazany nazw można mapować."
    - id: cNames
      type: System.UInt32
      description: "Liczba nazw można mapować."
    - id: lcid
      type: System.UInt32
      description: "Kontekst ustawień regionalnych, w którym zinterpretować nazwy."
    - id: rgDispId
      type: System.IntPtr
      description: "Tablica przydzielone przez obiekt wywołujący, który odbiera identyfikatory, odpowiadających nazwy."
  overload: System.AppDomain.System#_AppDomain#GetIDsOfNames*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Dostęp z późnym wiązaniem za pomocą modelu COM `IDispatch` interfejs nie jest obsługiwany."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  id: System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera informacje o typie dla obiekt, który można pobrać informacji o typie dla interfejsu."
  remarks: "Ta metoda jest dostęp do zarządzanych klas z kodem niezarządzanym i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfo`, zobacz bibliotece MSDN."
  syntax:
    content: void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);
    parameters:
    - id: iTInfo
      type: System.UInt32
      description: "Informacje o typie do zwrócenia."
    - id: lcid
      type: System.UInt32
      description: "Identyfikator ustawień regionalnych dla informacji o typie."
    - id: ppTInfo
      type: System.IntPtr
      description: "Uzyskuje wskaźnik do obiektu informacji żądanego typu."
  overload: System.AppDomain.System#_AppDomain#GetTypeInfo*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Dostęp z późnym wiązaniem za pomocą modelu COM `IDispatch` interfejs nie jest obsługiwany."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  id: System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetTypeInfoCount(UInt32)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Pobiera numer typu informacji interfejsów, że obiekt zawiera (0 lub 1)."
  remarks: "Ta metoda jest dostęp do zarządzanych klas z kodem niezarządzanym i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfoCount`, zobacz bibliotece MSDN."
  syntax:
    content: void _AppDomain.GetTypeInfoCount (out uint pcTInfo);
    parameters:
    - id: pcTInfo
      type: System.UInt32
      description: "Wskazuje lokalizację, która odbiera liczba interfejsów informacji typu dostarczanych przez obiekt."
  overload: System.AppDomain.System#_AppDomain#GetTypeInfoCount*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Dostęp z późnym wiązaniem za pomocą modelu COM `IDispatch` interfejs nie jest obsługiwany."
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  id: System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Zapewnia dostęp do właściwości i metody ujawnione przez obiekt."
  remarks: "Ta metoda jest dostęp do zarządzanych klas z kodem niezarządzanym i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::Invoke`, zobacz bibliotece MSDN."
  syntax:
    content: void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    parameters:
    - id: dispIdMember
      type: System.UInt32
      description: "Identyfikuje element członkowski."
    - id: riid
      type: System.Guid
      description: "Zarezerwowane do użytku w przyszłości. Musi być ma wartości IID_NULL."
    - id: lcid
      type: System.UInt32
      description: "Kontekst ustawień regionalnych, w którym interpretować argumentów."
    - id: wFlags
      type: System.Int16
      description: "Flagi opisujące kontekstu wywołania."
    - id: pDispParams
      type: System.IntPtr
      description: "Wskaźnik do struktury zawierający tablicę argumentów tablicy argumentu identyfikator DISPID dla argumentów nazwanych i liczbie liczba elementów w tablicach."
    - id: pVarResult
      type: System.IntPtr
      description: "Wskaźnik do lokalizacji, w którym ma być przechowywany wynik."
    - id: pExcepInfo
      type: System.IntPtr
      description: "Wskaźnik do struktury, która zawiera informacje o wyjątku."
    - id: puArgErr
      type: System.IntPtr
      description: "Indeks pierwszego argumentu, który zawiera błąd."
  overload: System.AppDomain.System#_AppDomain#Invoke*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Dostęp z późnym wiązaniem za pomocą modelu COM `IDispatch` interfejs nie jest obsługiwany."
  platform:
  - net462
- uid: System.AppDomain.ToString
  id: ToString
  parent: System.AppDomain
  langs:
  - csharp
  name: ToString()
  nameWithType: AppDomain.ToString()
  fullName: System.AppDomain.ToString()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Uzyskuje reprezentacji w postaci ciągu zawiera przyjazną nazwę domeny aplikacji i wszelkich zasad kontekstu."
  remarks: ''
  example:
  - "The following code example displays the return value of the ToString method.  \n  \n [!code-cpp[ADToString#1](~/add/codesnippet/cpp/m-system.appdomain.tostr_1.cpp)]\n [!code-cs[ADToString#1](~/add/codesnippet/csharp/m-system.appdomain.tostr_1.cs)]\n [!code-vb[ADToString#1](~/add/codesnippet/visualbasic/m-system.appdomain.tostr_1.vb)]"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "Ciąg utworzony łączenie literału &quot;Nazwa:&quot;, przyjazną nazwę domeny aplikacji i reprezentacji ciągu zasad kontekstu albo ciąg &quot;nie ma żadnych kontekstu zasad.&quot;"
  overload: System.AppDomain.ToString*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "Domeny aplikacji reprezentowany przez bieżący <xref href=&quot;System.AppDomain&quot;> </xref> został usunięty z pamięci."
  platform:
  - net462
- uid: System.AppDomain.TypeResolve
  id: TypeResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: TypeResolve
  nameWithType: AppDomain.TypeResolve
  fullName: System.AppDomain.TypeResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Występuje, gdy rozwiązanie typu kończy się niepowodzeniem."
  remarks: "Zdarzenie TypeResolve występuje, gdy środowisko uruchomieniowe języka wspólnego nie mógł określić zestaw, który można utworzyć żądanego typu. Może to wystąpić, jeśli typ jest zdefiniowany w zestawie dynamicznym, lub typ nie jest zdefiniowany w zestawie dynamicznym, ale środowisko uruchomieniowe nie ma zestawu, którego typ jest zdefiniowany w. Ostatnie sytuacja może wystąpić, gdy <xref:System.Type.GetType%2A?displayProperty=fullName>jest wywoływana z nazwę typu, który nie jest kwalifikowana nazwą zestawu.</xref:System.Type.GetType%2A?displayProperty=fullName>       <xref:System.ResolveEventHandler>Dla tego zdarzenia może próbować zlokalizować i utworzenia typu.</xref:System.ResolveEventHandler>       Jednak TypeResolve zdarzenie nie występuje, jeśli środowisko uruchomieniowe wie, że nie można znaleźć typu w niektórych zestawach jest. To zdarzenie nie występuje na przykład, jeśli typ nie zostanie znaleziony w zestawie statycznych, ponieważ środowisko uruchomieniowe wie, że typów nie można dynamicznie dodawać do zestawy statyczne.       Począwszy od [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>właściwość zawiera zestaw żądanego typu.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> Aby uzyskać więcej informacji zobacz <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>       Aby zarejestrować program obsługi zdarzeń dla tego zdarzenia, musi mieć wymagane uprawnienia lub <xref:System.Security.SecurityException>jest generowany.</xref:System.Security.SecurityException>       Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [zdarzenia](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following sample demonstrates the TypeResolve event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_TypeResolve#1](~/add/codesnippet/csharp/e-system.appdomain.typer_1.cs)]\n [!code-vb[AppDomain_TypeResolve#1](~/add/codesnippet/visualbasic/e-system.appdomain.typer_1.vb)]\n [!code-cpp[AppDomain_TypeResolve#1](~/add/codesnippet/cpp/e-system.appdomain.typer_1.cpp)]"
  syntax:
    content: public event ResolveEventHandler TypeResolve;
    return:
      type: System.ResolveEventHandler
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.UnhandledException
  id: UnhandledException
  parent: System.AppDomain
  langs:
  - csharp
  name: UnhandledException
  nameWithType: AppDomain.UnhandledException
  fullName: System.AppDomain.UnhandledException
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "Występuje, gdy nie zostanie przechwycony wyjątek."
  remarks: "To zdarzenie zawiera powiadomień nieprzechwyconych wyjątków. Umożliwia aplikacji do rejestrowania informacji o wyjątku, przed domyślny program obsługi systemu zgłasza wyjątek dla użytkownika i zakończenie aplikacji. Jeśli dostępne są wystarczające dane o stanie aplikacji, innych działań — takie jak zapisywanie danych program nowsze odzyskiwania. Zalecane jest ostrożność, ponieważ mogą ulec uszkodzeniu danych programu, gdy wyjątki nie są obsługiwane.      > [!NOTE] > W wersji systemu .NET Framework 1.0 i 1.1 zakończenie aplikacji oraz opcji debugowania są zgłaszane dla użytkownika przed to zdarzenie jest zgłaszane, a nie po.       To zdarzenie można obsługiwać w dowolnej domenie aplikacji. Zdarzenie nie jest jednak niekoniecznie wywoływane w domenie aplikacji, w którym wystąpił wyjątek. Wyjątek jest obsługiwany tylko wtedy, gdy cały stos wątku został oddzielić bez znajdowanie program obsługi wyjątku dotyczy, więc pierwszego miejsca, które mogą być zdarzenia znajduje się w domenie aplikacji, którego pochodzi wątku.      > [!NOTE] > Wersji w programie .NET Framework 1.0 i 1.1, to zdarzenie występuje tylko w przypadku domyślnej domeny aplikacji jest tworzony przez system po uruchomieniu aplikacji. Jeśli aplikacja tworzy domeny dodatkowych aplikacji, określając delegowanego dla tego zdarzenia w tych domenach aplikacji nie ma znaczenia.       Jeśli zdarzenie UnhandledException jest obsługiwane w domyślnej domeny aplikacji, jest on uruchamiany dla dowolnego nieobsługiwany wyjątek w którymkolwiek wątku, niezależnie od tego, jakie domeny aplikacji wątek jest uruchomiony w. Jeśli wątek jest uruchomiony w domenie aplikacji, która ma obsługi zdarzeń dla UnhandledException, zdarzenie jest zgłaszane w tej domenie aplikacji. Jeśli ta domena aplikacji nie jest domyślnej domeny aplikacji, a także jest program obsługi zdarzeń w domyślnej domeny aplikacji, zdarzenie jest wywoływane w obu domenach aplikacji.       Na przykład załóżmy, że wątek jest uruchamiany w domeny aplikacji &quot;AD1&quot; wywołuje metodę w domenie aplikacji &quot;AD2&quot; i stamtąd wywołuje metodę w domenie aplikacji &quot;AD3&quot;, gdzie zgłasza wyjątek. Wygenerowany zdarzeń UnhandledException pierwsza domena aplikacji jest &quot;AD1&quot;. Jeśli ta domena aplikacji nie jest domyślnej domeny aplikacji, można również być zdarzenia w domyślnej domeny aplikacji.      > [!NOTE] > Środowisko uruchomieniowe języka wspólnego wstrzymuje przerwań wątku podczas obsługi zdarzeń dla zdarzenia UnhandledException są wykonywane.       Jeśli program obsługi zdarzeń ma <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>atrybutu flag odpowiednie, program obsługi zdarzeń jest traktowany jako region ograniczonego wykonania.</xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>       Począwszy od [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], to zdarzenie nie jest zgłaszane wyjątki, które doprowadzić do uszkodzenia procesu, takie jak przepełnienie stosu lub uzyskać dostępu do naruszenia, chyba że obsługi zdarzeń jest krytyczny dla zabezpieczeń i ma <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>atrybutu.</xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>       W wersji systemu .NET Framework 1.0 i 1.1 nieobsługiwany wyjątek w wątku innego niż wątku głównego aplikacji zostanie przechwycony przez środowisko uruchomieniowe i w związku z tym nie powoduje zamknięcie aplikacji. W związku z tym istnieje możliwość się bez przerywania aplikacji zdarzenia UnhandledException. W programie .NET Framework w wersji 2.0, to backstop dla nieobsługiwanych wyjątków w wątkach podrzędnych został usunięty, ponieważ skrócenie takie błędy dyskretnej uwzględnione spadek wydajności, uszkodzone dane i zawieszaniu, które były trudne do debugowania. Aby uzyskać więcej informacji, łącznie z listą przypadków, w których środowisko uruchomieniowe nie kończy się, zobacz [wyjątki w zarządzanych wątkach](~/add/includes/ajax-current-ext-md.md).       Aby zarejestrować program obsługi zdarzeń dla tego zdarzenia, musi mieć wymagane uprawnienia lub <xref:System.Security.SecurityException>jest generowany.</xref:System.Security.SecurityException>       Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [zdarzenia](~/add/includes/ajax-current-ext-md.md).      ## Inne zdarzenia dla nieobsługiwanych wyjątków dla określonych aplikacji modele, UnhandledException zdarzeń może być wywłaszczony przez inne zdarzenia, jeśli wystąpi nieobsługiwany wyjątek w wątku głównego aplikacji.       W aplikacjach korzystających z technologii Windows Forms nieobsługiwanych wyjątków w aplikacji głównej przyczyny wątku <xref:System.Windows.Forms.Application.ThreadException?displayProperty=fullName>się zdarzenia.</xref:System.Windows.Forms.Application.ThreadException?displayProperty=fullName> Jeśli to zdarzenie jest obsługiwane, domyślne zachowanie jest nieobsługiwany wyjątek nie zakończy aplikacji, mimo że aplikacja pozostaje w nieznanym stanie. W takim przypadku zdarzenie UnhandledException nie jest wywoływane. To zachowanie można zmienić za pomocą pliku konfiguracji aplikacji lub przy użyciu <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=fullName>metody można zmienić trybu <xref:System.Windows.Forms.UnhandledExceptionMode?displayProperty=fullName>przed <xref:System.Windows.Forms.Application.ThreadException>procedura obsługi zdarzeń jest argumentów podłączono oceny.</xref:System.Windows.Forms.Application.ThreadException> </xref:System.Windows.Forms.UnhandledExceptionMode?displayProperty=fullName> </xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=fullName> Dotyczy to tylko wątku głównego aplikacji. UnhandledException zdarzenie jest wywoływane dla nieobsługiwanych wyjątków zgłoszonych w innych wątków.       Struktura aplikacji Visual Basic w programie Microsoft Visual Studio 2005, zapewnia inne zdarzenie nieobsługiwanych wyjątków w wątku głównego aplikacji. Zobacz <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=fullName>zdarzeń.</xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=fullName> To zdarzenie ma obiekt argumentów zdarzenia z taką samą nazwę jak obiekt argumenty zdarzenia używane przez UnhandledException, ale inne właściwości. W szczególności ten obiekt argumenty zdarzeń ma <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A>właściwość, która umożliwia to aplikacji kontynuować uruchamianie, ignorowanie nieobsługiwany wyjątek (i pozostawienie aplikacji w nieznanym stanie).</xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> W takim przypadku zdarzenie UnhandledException nie jest wywoływane."
  example:
  - "The followingexample demonstrates the UnhandledException event. It defines an event handler, `MyHandler`, that is invoked whenever an unhandled exception is thrown in the default application domain. It then throws two exceptions. The first is handled by a **try/catch** block. The second is unhandled and invokes the `MyHandle` routine before the application terminates.  \n  \n [!code-cs[AppDomain_UnhandledException#1](~/add/codesnippet/csharp/e-system.appdomain.unhan_1.cs)]\n [!code-vb[AppDomain_UnhandledException#1](~/add/codesnippet/visualbasic/e-system.appdomain.unhan_1.vb)]\n [!code-cpp[AppDomain_UnhandledException#1](~/add/codesnippet/cpp/e-system.appdomain.unhan_1.cpp)]"
  syntax:
    content: public event UnhandledExceptionEventHandler UnhandledException;
    return:
      type: System.UnhandledExceptionEventHandler
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Unload(System.AppDomain)
  id: Unload(System.AppDomain)
  parent: System.AppDomain
  langs:
  - csharp
  name: Unload(AppDomain)
  nameWithType: AppDomain.Unload(AppDomain)
  fullName: System.AppDomain.Unload(AppDomain)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Zwalnia domeny określonej aplikacji."
  remarks: "W programie .NET Framework w wersji 2.0 jest wątku dedykowane do zwalniania domen aplikacji. Zwiększa niezawodność, szczególnie w przypadku programu .NET Framework jest obsługiwana. Podczas wywołania wątku zwolnienie domeny docelowej jest oznaczony do zwalnianie. Dedykowanym wątku próbuje zwolnić domeny, a wszystkie wątki w domenie są przerywane. Jeśli wątek nie przerwać, na przykład ponieważ jej wykonywania kodu niezarządzanego lub jej wykonywania `finally` bloku, po upływie pewnego czasu <xref:System.CannotUnloadAppDomainException>jest zgłaszany w wątku, który pierwotnie używana Unload.</xref:System.CannotUnloadAppDomainException> Kończy się wątku, który nie można przerwać po pewnym czasie, do domeny docelowej nie jest usunięty z pamięci. W związku z tym w programie .NET Framework w wersji 2.0 `domain` nie jest gwarantowana można zwolnić, ponieważ może nie być możliwe zakończyć wykonywanie wątków.      > [!NOTE] > W niektórych przypadkach wywołanie zwolnienia powoduje natychmiastowe <xref:System.CannotUnloadAppDomainException>, na przykład jeśli jest to finalizator.</xref:System.CannotUnloadAppDomainException>       Wątki `domain` kończą się przy użyciu <xref:System.Threading.Thread.Abort%2A>metodę, która zgłasza <xref:System.Threading.ThreadAbortException>w wątku.</xref:System.Threading.ThreadAbortException> </xref:System.Threading.Thread.Abort%2A> Mimo że wątek należy zakończyć natychmiast, może kontynuować wykonywania dla nieprzewidywalne ilość czasu w `finally` klauzuli.      ## Wersja zgodności w .NET Framework w wersji 1.0, 1.1, jeśli wątek, który wywołuje zwolnienie działa w `domain`, inny wątek jest uruchomiony do wykonania tej operacji unload. Jeśli `domain` nie może być zwolnione, <xref:System.CannotUnloadAppDomainException>jest zgłaszany w tym wątku nie znajduje się w oryginalnym wątku, który wywołuje Unload.</xref:System.CannotUnloadAppDomainException> Jednak jeśli wątku wywołującym zwolnienie działa poza `domain`, że wątek otrzyma wyjątek."
  example:
  - "The following code example shows how to unload an application domain.  \n  \n [!code-cpp[ADUnload#1](~/add/codesnippet/cpp/m-system.appdomain.unloa_1.cpp)]\n [!code-vb[ADUnload#1](~/add/codesnippet/visualbasic/m-system.appdomain.unloa_1.vb)]\n [!code-cs[ADUnload#1](~/add/codesnippet/csharp/m-system.appdomain.unloa_1.cs)]"
  syntax:
    content: public static void Unload (AppDomain domain);
    parameters:
    - id: domain
      type: System.AppDomain
      description: "Aby zwolnić domeny aplikacji."
  overload: System.AppDomain.Unload*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>domain</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.CannotUnloadAppDomainException
    commentId: T:System.CannotUnloadAppDomainException
    description: "<code>domain</code>nie może zostać usunięty."
  - type: System.Exception
    commentId: T:System.Exception
    description: "Wystąpił błąd podczas zwalniania."
  platform:
  - net462
references:
- uid: System.MarshalByRefObject
  isExternal: false
  name: System.MarshalByRefObject
- uid: System.AppDomainUnloadedException
  parent: System
  isExternal: false
  name: AppDomainUnloadedException
  nameWithType: AppDomainUnloadedException
  fullName: System.AppDomainUnloadedException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.TypeLoadException
  isExternal: true
  name: System.TypeLoadException
- uid: System.MissingMethodException
  isExternal: true
  name: System.MissingMethodException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.MemberAccessException
  isExternal: true
  name: System.MemberAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.BadImageFormatException
  isExternal: true
  name: System.BadImageFormatException
- uid: System.IO.FileLoadException
  isExternal: true
  name: System.IO.FileLoadException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.MethodAccessException
  isExternal: true
  name: System.MethodAccessException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Security.Policy.PolicyException
  parent: System.Security.Policy
  isExternal: false
  name: PolicyException
  nameWithType: PolicyException
  fullName: System.Security.Policy.PolicyException
- uid: System.NotImplementedException
  isExternal: true
  name: System.NotImplementedException
- uid: System.CannotUnloadAppDomainException
  parent: System
  isExternal: false
  name: CannotUnloadAppDomainException
  nameWithType: CannotUnloadAppDomainException
  fullName: System.CannotUnloadAppDomainException
- uid: System.Exception
  isExternal: true
  name: System.Exception
- uid: System.AppDomain.ActivationContext
  parent: System.AppDomain
  isExternal: false
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
  fullName: System.AppDomain.ActivationContext
- uid: System.ActivationContext
  parent: System
  isExternal: false
  name: ActivationContext
  nameWithType: ActivationContext
  fullName: System.ActivationContext
- uid: System.AppDomain.AppendPrivatePath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: AppendPrivatePath(String)
  nameWithType: AppDomain.AppendPrivatePath(String)
  fullName: System.AppDomain.AppendPrivatePath(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.AppDomain.ApplicationIdentity
  parent: System.AppDomain
  isExternal: false
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
  fullName: System.AppDomain.ApplicationIdentity
- uid: System.ApplicationIdentity
  parent: System
  isExternal: false
  name: ApplicationIdentity
  nameWithType: ApplicationIdentity
  fullName: System.ApplicationIdentity
- uid: System.AppDomain.ApplicationTrust
  parent: System.AppDomain
  isExternal: false
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
  fullName: System.AppDomain.ApplicationTrust
- uid: System.Security.Policy.ApplicationTrust
  parent: System.Security.Policy
  isExternal: false
  name: ApplicationTrust
  nameWithType: ApplicationTrust
  fullName: System.Security.Policy.ApplicationTrust
- uid: System.AppDomain.ApplyPolicy(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ApplyPolicy(String)
  nameWithType: AppDomain.ApplyPolicy(String)
  fullName: System.AppDomain.ApplyPolicy(String)
- uid: System.AppDomain.AssemblyLoad
  parent: System.AppDomain
  isExternal: false
  name: AssemblyLoad
  nameWithType: AppDomain.AssemblyLoad
  fullName: System.AppDomain.AssemblyLoad
- uid: System.AssemblyLoadEventHandler
  parent: System
  isExternal: false
  name: AssemblyLoadEventHandler
  nameWithType: AssemblyLoadEventHandler
  fullName: System.AssemblyLoadEventHandler
- uid: System.AppDomain.AssemblyResolve
  parent: System.AppDomain
  isExternal: false
  name: AssemblyResolve
  nameWithType: AppDomain.AssemblyResolve
  fullName: System.AppDomain.AssemblyResolve
- uid: System.ResolveEventHandler
  parent: System
  isExternal: false
  name: ResolveEventHandler
  nameWithType: ResolveEventHandler
  fullName: System.ResolveEventHandler
- uid: System.AppDomain.BaseDirectory
  parent: System.AppDomain
  isExternal: false
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
  fullName: System.AppDomain.BaseDirectory
- uid: System.AppDomain.ClearPrivatePath
  parent: System.AppDomain
  isExternal: false
  name: ClearPrivatePath()
  nameWithType: AppDomain.ClearPrivatePath()
  fullName: System.AppDomain.ClearPrivatePath()
- uid: System.AppDomain.ClearShadowCopyPath
  parent: System.AppDomain
  isExternal: false
  name: ClearShadowCopyPath()
  nameWithType: AppDomain.ClearShadowCopyPath()
  fullName: System.AppDomain.ClearShadowCopyPath()
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom(String,String)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String)
- uid: System.Runtime.Remoting.ObjectHandle
  parent: System.Runtime.Remoting
  isExternal: false
  name: ObjectHandle
  nameWithType: ObjectHandle
  fullName: System.Runtime.Remoting.ObjectHandle
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Configuration.Assemblies.AssemblyHashAlgorithm
  parent: System.Configuration.Assemblies
  isExternal: false
  name: AssemblyHashAlgorithm
  nameWithType: AssemblyHashAlgorithm
  fullName: System.Configuration.Assemblies.AssemblyHashAlgorithm
- uid: System.AppDomain.CreateDomain(System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String)
  nameWithType: AppDomain.CreateDomain(String)
  fullName: System.AppDomain.CreateDomain(String)
- uid: System.AppDomain
  parent: System
  isExternal: false
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence)
  nameWithType: AppDomain.CreateDomain(String,Evidence)
  fullName: System.AppDomain.CreateDomain(String,Evidence)
- uid: System.Security.Policy.Evidence
  parent: System.Security.Policy
  isExternal: false
  name: Evidence
  nameWithType: Evidence
  fullName: System.Security.Policy.Evidence
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,AppDomainSetup)
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
- uid: System.AppDomainSetup
  parent: System
  isExternal: false
  name: AppDomainSetup
  nameWithType: AppDomainSetup
  fullName: System.AppDomainSetup
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
- uid: System.Security.PermissionSet
  parent: System.Security
  isExternal: false
  name: PermissionSet
  nameWithType: PermissionSet
  fullName: System.Security.PermissionSet
- uid: System.Security.Policy.StrongName[]
  parent: System.Security.Policy
  isExternal: false
  name: StrongName
  nameWithType: StrongName
  fullName: System.Security.Policy.StrongName[]
  spec.csharp:
  - uid: System.Security.Policy.StrongName
    name: StrongName
    nameWithType: StrongName
    fullName: StrongName[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,String,String,Boolean)
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
- uid: System.AppDomainInitializer
  parent: System
  isExternal: false
  name: AppDomainInitializer
  nameWithType: AppDomainInitializer
  fullName: System.AppDomainInitializer
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateInstance(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String)
  nameWithType: AppDomain.CreateInstance(String,String)
  fullName: System.AppDomain.CreateInstance(String,String)
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Object[])
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.Reflection.BindingFlags
  parent: System.Reflection
  isExternal: false
  name: BindingFlags
  nameWithType: BindingFlags
  fullName: System.Reflection.BindingFlags
- uid: System.Reflection.Binder
  parent: System.Reflection
  isExternal: false
  name: Binder
  nameWithType: Binder
  fullName: System.Reflection.Binder
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String)
  nameWithType: AppDomain.CreateInstanceFrom(String,String)
  fullName: System.AppDomain.CreateInstanceFrom(String,String)
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Object[])
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String)
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CurrentDomain
  parent: System.AppDomain
  isExternal: false
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
  fullName: System.AppDomain.CurrentDomain
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
- uid: System.Reflection.Emit.AssemblyBuilder
  parent: System.Reflection.Emit
  isExternal: true
  name: AssemblyBuilder
  nameWithType: AssemblyBuilder
  fullName: System.Reflection.Emit.AssemblyBuilder
- uid: System.Reflection.AssemblyName
  parent: System.Reflection
  isExternal: true
  name: AssemblyName
  nameWithType: AssemblyName
  fullName: System.Reflection.AssemblyName
- uid: System.Reflection.Emit.AssemblyBuilderAccess
  parent: System.Reflection.Emit
  isExternal: true
  name: AssemblyBuilderAccess
  nameWithType: AssemblyBuilderAccess
  fullName: System.Reflection.Emit.AssemblyBuilderAccess
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
- uid: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<CustomAttributeBuilder>
  nameWithType: IEnumerable<CustomAttributeBuilder>
  fullName: System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.Reflection.Emit.CustomAttributeBuilder>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Reflection.Emit.CustomAttributeBuilder
    name: CustomAttributeBuilder
    nameWithType: CustomAttributeBuilder
    fullName: CustomAttributeBuilder
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
- uid: System.Security.SecurityContextSource
  parent: System.Security
  isExternal: false
  name: SecurityContextSource
  nameWithType: SecurityContextSource
  fullName: System.Security.SecurityContextSource
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
- uid: System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  parent: System.AppDomain
  isExternal: false
  name: DoCallBack(CrossAppDomainDelegate)
  nameWithType: AppDomain.DoCallBack(CrossAppDomainDelegate)
  fullName: System.AppDomain.DoCallBack(CrossAppDomainDelegate)
- uid: System.CrossAppDomainDelegate
  parent: System
  isExternal: false
  name: CrossAppDomainDelegate
  nameWithType: CrossAppDomainDelegate
  fullName: System.CrossAppDomainDelegate
- uid: System.AppDomain.DomainManager
  parent: System.AppDomain
  isExternal: false
  name: DomainManager
  nameWithType: AppDomain.DomainManager
  fullName: System.AppDomain.DomainManager
- uid: System.AppDomainManager
  parent: System
  isExternal: false
  name: AppDomainManager
  nameWithType: AppDomainManager
  fullName: System.AppDomainManager
- uid: System.AppDomain.DomainUnload
  parent: System.AppDomain
  isExternal: false
  name: DomainUnload
  nameWithType: AppDomain.DomainUnload
  fullName: System.AppDomain.DomainUnload
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.AppDomain.DynamicDirectory
  parent: System.AppDomain
  isExternal: false
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
  fullName: System.AppDomain.DynamicDirectory
- uid: System.AppDomain.Evidence
  parent: System.AppDomain
  isExternal: false
  name: Evidence
  nameWithType: AppDomain.Evidence
  fullName: System.AppDomain.Evidence
- uid: System.AppDomain.ExecuteAssembly(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String)
  nameWithType: AppDomain.ExecuteAssembly(String)
  fullName: System.AppDomain.ExecuteAssembly(String)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence)
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,String[])
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[])
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
- uid: System.AppDomain.ExecuteAssemblyByName(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String)
  nameWithType: AppDomain.ExecuteAssemblyByName(String)
  fullName: System.AppDomain.ExecuteAssemblyByName(String)
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(AssemblyName,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,Evidence)
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence)
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence)
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
- uid: System.AppDomain.FirstChanceException
  parent: System.AppDomain
  isExternal: false
  name: FirstChanceException
  nameWithType: AppDomain.FirstChanceException
  fullName: System.AppDomain.FirstChanceException
- uid: System.EventHandler{System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<FirstChanceExceptionEventArgs>
  nameWithType: EventHandler<FirstChanceExceptionEventArgs>
  fullName: System.EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs
    name: FirstChanceExceptionEventArgs
    nameWithType: FirstChanceExceptionEventArgs
    fullName: FirstChanceExceptionEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.FriendlyName
  parent: System.AppDomain
  isExternal: false
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
  fullName: System.AppDomain.FriendlyName
- uid: System.AppDomain.GetAssemblies
  parent: System.AppDomain
  isExternal: false
  name: GetAssemblies()
  nameWithType: AppDomain.GetAssemblies()
  fullName: System.AppDomain.GetAssemblies()
- uid: System.Reflection.Assembly[]
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly[]
  spec.csharp:
  - uid: System.Reflection.Assembly
    name: Assembly
    nameWithType: Assembly
    fullName: Assembly[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.GetCurrentThreadId
  parent: System.AppDomain
  isExternal: false
  name: GetCurrentThreadId()
  nameWithType: AppDomain.GetCurrentThreadId()
  fullName: System.AppDomain.GetCurrentThreadId()
- uid: System.AppDomain.GetData(System.String)
  parent: System.AppDomain
  isExternal: false
  name: GetData(String)
  nameWithType: AppDomain.GetData(String)
  fullName: System.AppDomain.GetData(String)
- uid: System.AppDomain.GetType
  parent: System.AppDomain
  isExternal: false
  name: GetType()
  nameWithType: AppDomain.GetType()
  fullName: System.AppDomain.GetType()
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.AppDomain.Id
  parent: System.AppDomain
  isExternal: false
  name: Id
  nameWithType: AppDomain.Id
  fullName: System.AppDomain.Id
- uid: System.AppDomain.InitializeLifetimeService
  parent: System.AppDomain
  isExternal: false
  name: InitializeLifetimeService()
  nameWithType: AppDomain.InitializeLifetimeService()
  fullName: System.AppDomain.InitializeLifetimeService()
- uid: System.AppDomain.IsCompatibilitySwitchSet(System.String)
  parent: System.AppDomain
  isExternal: false
  name: IsCompatibilitySwitchSet(String)
  nameWithType: AppDomain.IsCompatibilitySwitchSet(String)
  fullName: System.AppDomain.IsCompatibilitySwitchSet(String)
- uid: System.Nullable{System.Boolean}
  parent: System
  isExternal: true
  name: Nullable<Boolean>
  nameWithType: Nullable<Boolean>
  fullName: System.Nullable<System.Boolean>
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    nameWithType: Nullable
    fullName: Nullable<System.Boolean>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: Boolean
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.IsDefaultAppDomain
  parent: System.AppDomain
  isExternal: false
  name: IsDefaultAppDomain()
  nameWithType: AppDomain.IsDefaultAppDomain()
  fullName: System.AppDomain.IsDefaultAppDomain()
- uid: System.AppDomain.IsFinalizingForUnload
  parent: System.AppDomain
  isExternal: false
  name: IsFinalizingForUnload()
  nameWithType: AppDomain.IsFinalizingForUnload()
  fullName: System.AppDomain.IsFinalizingForUnload()
- uid: System.AppDomain.IsFullyTrusted
  parent: System.AppDomain
  isExternal: false
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
  fullName: System.AppDomain.IsFullyTrusted
- uid: System.AppDomain.IsHomogenous
  parent: System.AppDomain
  isExternal: false
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
  fullName: System.AppDomain.IsHomogenous
- uid: System.AppDomain.Load(System.Byte[])
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[])
  nameWithType: AppDomain.Load(Byte[])
  fullName: System.AppDomain.Load(Byte[])
- uid: System.Reflection.Assembly
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly
- uid: System.AppDomain.Load(System.Reflection.AssemblyName)
  parent: System.AppDomain
  isExternal: false
  name: Load(AssemblyName)
  nameWithType: AppDomain.Load(AssemblyName)
  fullName: System.AppDomain.Load(AssemblyName)
- uid: System.AppDomain.Load(System.String)
  parent: System.AppDomain
  isExternal: false
  name: Load(String)
  nameWithType: AppDomain.Load(String)
  fullName: System.AppDomain.Load(String)
- uid: System.AppDomain.Load(System.Byte[],System.Byte[])
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[],Byte[])
  nameWithType: AppDomain.Load(Byte[],Byte[])
  fullName: System.AppDomain.Load(Byte[],Byte[])
- uid: System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(AssemblyName,Evidence)
  nameWithType: AppDomain.Load(AssemblyName,Evidence)
  fullName: System.AppDomain.Load(AssemblyName,Evidence)
- uid: System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(String,Evidence)
  nameWithType: AppDomain.Load(String,Evidence)
  fullName: System.AppDomain.Load(String,Evidence)
- uid: System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[],Byte[],Evidence)
  nameWithType: AppDomain.Load(Byte[],Byte[],Evidence)
  fullName: System.AppDomain.Load(Byte[],Byte[],Evidence)
- uid: System.AppDomain.MonitoringIsEnabled
  parent: System.AppDomain
  isExternal: false
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
  fullName: System.AppDomain.MonitoringIsEnabled
- uid: System.AppDomain.MonitoringSurvivedMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
  fullName: System.AppDomain.MonitoringSurvivedMemorySize
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
  fullName: System.AppDomain.MonitoringSurvivedProcessMemorySize
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
  fullName: System.AppDomain.MonitoringTotalAllocatedMemorySize
- uid: System.AppDomain.MonitoringTotalProcessorTime
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
  fullName: System.AppDomain.MonitoringTotalProcessorTime
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.AppDomain.PermissionSet
  parent: System.AppDomain
  isExternal: false
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
  fullName: System.AppDomain.PermissionSet
- uid: System.AppDomain.ProcessExit
  parent: System.AppDomain
  isExternal: false
  name: ProcessExit
  nameWithType: AppDomain.ProcessExit
  fullName: System.AppDomain.ProcessExit
- uid: System.AppDomain.ReflectionOnlyAssemblyResolve
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyAssemblyResolve
  nameWithType: AppDomain.ReflectionOnlyAssemblyResolve
  fullName: System.AppDomain.ReflectionOnlyAssemblyResolve
- uid: System.AppDomain.ReflectionOnlyGetAssemblies
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyGetAssemblies()
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies()
  fullName: System.AppDomain.ReflectionOnlyGetAssemblies()
- uid: System.AppDomain.RelativeSearchPath
  parent: System.AppDomain
  isExternal: false
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
  fullName: System.AppDomain.RelativeSearchPath
- uid: System.AppDomain.ResourceResolve
  parent: System.AppDomain
  isExternal: false
  name: ResourceResolve
  nameWithType: AppDomain.ResourceResolve
  fullName: System.AppDomain.ResourceResolve
- uid: System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  parent: System.AppDomain
  isExternal: false
  name: SetAppDomainPolicy(PolicyLevel)
  nameWithType: AppDomain.SetAppDomainPolicy(PolicyLevel)
  fullName: System.AppDomain.SetAppDomainPolicy(PolicyLevel)
- uid: System.Security.Policy.PolicyLevel
  parent: System.Security.Policy
  isExternal: false
  name: PolicyLevel
  nameWithType: PolicyLevel
  fullName: System.Security.Policy.PolicyLevel
- uid: System.AppDomain.SetCachePath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetCachePath(String)
  nameWithType: AppDomain.SetCachePath(String)
  fullName: System.AppDomain.SetCachePath(String)
- uid: System.AppDomain.SetData(System.String,System.Object)
  parent: System.AppDomain
  isExternal: false
  name: SetData(String,Object)
  nameWithType: AppDomain.SetData(String,Object)
  fullName: System.AppDomain.SetData(String,Object)
- uid: System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  parent: System.AppDomain
  isExternal: false
  name: SetData(String,Object,IPermission)
  nameWithType: AppDomain.SetData(String,Object,IPermission)
  fullName: System.AppDomain.SetData(String,Object,IPermission)
- uid: System.Security.IPermission
  parent: System.Security
  isExternal: false
  name: IPermission
  nameWithType: IPermission
  fullName: System.Security.IPermission
- uid: System.AppDomain.SetDynamicBase(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetDynamicBase(String)
  nameWithType: AppDomain.SetDynamicBase(String)
  fullName: System.AppDomain.SetDynamicBase(String)
- uid: System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  parent: System.AppDomain
  isExternal: false
  name: SetPrincipalPolicy(PrincipalPolicy)
  nameWithType: AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  fullName: System.AppDomain.SetPrincipalPolicy(PrincipalPolicy)
- uid: System.Security.Principal.PrincipalPolicy
  parent: System.Security.Principal
  isExternal: false
  name: PrincipalPolicy
  nameWithType: PrincipalPolicy
  fullName: System.Security.Principal.PrincipalPolicy
- uid: System.AppDomain.SetShadowCopyFiles
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyFiles()
  nameWithType: AppDomain.SetShadowCopyFiles()
  fullName: System.AppDomain.SetShadowCopyFiles()
- uid: System.AppDomain.SetShadowCopyPath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyPath(String)
  nameWithType: AppDomain.SetShadowCopyPath(String)
  fullName: System.AppDomain.SetShadowCopyPath(String)
- uid: System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  parent: System.AppDomain
  isExternal: false
  name: SetThreadPrincipal(IPrincipal)
  nameWithType: AppDomain.SetThreadPrincipal(IPrincipal)
  fullName: System.AppDomain.SetThreadPrincipal(IPrincipal)
- uid: System.Security.Principal.IPrincipal
  parent: System.Security.Principal
  isExternal: true
  name: IPrincipal
  nameWithType: IPrincipal
  fullName: System.Security.Principal.IPrincipal
- uid: System.AppDomain.SetupInformation
  parent: System.AppDomain
  isExternal: false
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
  fullName: System.AppDomain.SetupInformation
- uid: System.AppDomain.ShadowCopyFiles
  parent: System.AppDomain
  isExternal: false
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
  fullName: System.AppDomain.ShadowCopyFiles
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
- uid: System.Guid
  parent: System
  isExternal: true
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfoCount(UInt32)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
- uid: System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.AppDomain.ToString
  parent: System.AppDomain
  isExternal: false
  name: ToString()
  nameWithType: AppDomain.ToString()
  fullName: System.AppDomain.ToString()
- uid: System.AppDomain.TypeResolve
  parent: System.AppDomain
  isExternal: false
  name: TypeResolve
  nameWithType: AppDomain.TypeResolve
  fullName: System.AppDomain.TypeResolve
- uid: System.AppDomain.UnhandledException
  parent: System.AppDomain
  isExternal: false
  name: UnhandledException
  nameWithType: AppDomain.UnhandledException
  fullName: System.AppDomain.UnhandledException
- uid: System.UnhandledExceptionEventHandler
  parent: System
  isExternal: false
  name: UnhandledExceptionEventHandler
  nameWithType: UnhandledExceptionEventHandler
  fullName: System.UnhandledExceptionEventHandler
- uid: System.AppDomain.Unload(System.AppDomain)
  parent: System.AppDomain
  isExternal: false
  name: Unload(AppDomain)
  nameWithType: AppDomain.Unload(AppDomain)
  fullName: System.AppDomain.Unload(AppDomain)
- uid: System.AppDomain.ActivationContext*
  parent: System.AppDomain
  isExternal: false
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
- uid: System.AppDomain.AppendPrivatePath*
  parent: System.AppDomain
  isExternal: false
  name: AppendPrivatePath
  nameWithType: AppDomain.AppendPrivatePath
- uid: System.AppDomain.ApplicationIdentity*
  parent: System.AppDomain
  isExternal: false
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
- uid: System.AppDomain.ApplicationTrust*
  parent: System.AppDomain
  isExternal: false
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
- uid: System.AppDomain.ApplyPolicy*
  parent: System.AppDomain
  isExternal: false
  name: ApplyPolicy
  nameWithType: AppDomain.ApplyPolicy
- uid: System.AppDomain.BaseDirectory*
  parent: System.AppDomain
  isExternal: false
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
- uid: System.AppDomain.ClearPrivatePath*
  parent: System.AppDomain
  isExternal: false
  name: ClearPrivatePath
  nameWithType: AppDomain.ClearPrivatePath
- uid: System.AppDomain.ClearShadowCopyPath*
  parent: System.AppDomain
  isExternal: false
  name: ClearShadowCopyPath
  nameWithType: AppDomain.ClearShadowCopyPath
- uid: System.AppDomain.CreateComInstanceFrom*
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom
  nameWithType: AppDomain.CreateComInstanceFrom
- uid: System.AppDomain.CreateDomain*
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain
  nameWithType: AppDomain.CreateDomain
- uid: System.AppDomain.CreateInstance*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance
  nameWithType: AppDomain.CreateInstance
- uid: System.AppDomain.CreateInstanceAndUnwrap*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap
  nameWithType: AppDomain.CreateInstanceAndUnwrap
- uid: System.AppDomain.CreateInstanceFrom*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom
  nameWithType: AppDomain.CreateInstanceFrom
- uid: System.AppDomain.CreateInstanceFromAndUnwrap*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap
- uid: System.AppDomain.CurrentDomain*
  parent: System.AppDomain
  isExternal: false
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
- uid: System.AppDomain.DefineDynamicAssembly*
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly
  nameWithType: AppDomain.DefineDynamicAssembly
- uid: System.AppDomain.DoCallBack*
  parent: System.AppDomain
  isExternal: false
  name: DoCallBack
  nameWithType: AppDomain.DoCallBack
- uid: System.AppDomain.DomainManager*
  parent: System.AppDomain
  isExternal: false
  name: DomainManager
  nameWithType: AppDomain.DomainManager
- uid: System.AppDomain.DynamicDirectory*
  parent: System.AppDomain
  isExternal: false
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
- uid: System.AppDomain.Evidence*
  parent: System.AppDomain
  isExternal: false
  name: Evidence
  nameWithType: AppDomain.Evidence
- uid: System.AppDomain.ExecuteAssembly*
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly
  nameWithType: AppDomain.ExecuteAssembly
- uid: System.AppDomain.ExecuteAssemblyByName*
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName
  nameWithType: AppDomain.ExecuteAssemblyByName
- uid: System.AppDomain.FriendlyName*
  parent: System.AppDomain
  isExternal: false
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
- uid: System.AppDomain.GetAssemblies*
  parent: System.AppDomain
  isExternal: false
  name: GetAssemblies
  nameWithType: AppDomain.GetAssemblies
- uid: System.AppDomain.GetCurrentThreadId*
  parent: System.AppDomain
  isExternal: false
  name: GetCurrentThreadId
  nameWithType: AppDomain.GetCurrentThreadId
- uid: System.AppDomain.GetData*
  parent: System.AppDomain
  isExternal: false
  name: GetData
  nameWithType: AppDomain.GetData
- uid: System.AppDomain.GetType*
  parent: System.AppDomain
  isExternal: false
  name: GetType
  nameWithType: AppDomain.GetType
- uid: System.AppDomain.Id*
  parent: System.AppDomain
  isExternal: false
  name: Id
  nameWithType: AppDomain.Id
- uid: System.AppDomain.InitializeLifetimeService*
  parent: System.AppDomain
  isExternal: false
  name: InitializeLifetimeService
  nameWithType: AppDomain.InitializeLifetimeService
- uid: System.AppDomain.IsCompatibilitySwitchSet*
  parent: System.AppDomain
  isExternal: false
  name: IsCompatibilitySwitchSet
  nameWithType: AppDomain.IsCompatibilitySwitchSet
- uid: System.AppDomain.IsDefaultAppDomain*
  parent: System.AppDomain
  isExternal: false
  name: IsDefaultAppDomain
  nameWithType: AppDomain.IsDefaultAppDomain
- uid: System.AppDomain.IsFinalizingForUnload*
  parent: System.AppDomain
  isExternal: false
  name: IsFinalizingForUnload
  nameWithType: AppDomain.IsFinalizingForUnload
- uid: System.AppDomain.IsFullyTrusted*
  parent: System.AppDomain
  isExternal: false
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
- uid: System.AppDomain.IsHomogenous*
  parent: System.AppDomain
  isExternal: false
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
- uid: System.AppDomain.Load*
  parent: System.AppDomain
  isExternal: false
  name: Load
  nameWithType: AppDomain.Load
- uid: System.AppDomain.MonitoringIsEnabled*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
- uid: System.AppDomain.MonitoringSurvivedMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
- uid: System.AppDomain.MonitoringTotalProcessorTime*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
- uid: System.AppDomain.PermissionSet*
  parent: System.AppDomain
  isExternal: false
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
- uid: System.AppDomain.ReflectionOnlyGetAssemblies*
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyGetAssemblies
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies
- uid: System.AppDomain.RelativeSearchPath*
  parent: System.AppDomain
  isExternal: false
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
- uid: System.AppDomain.SetAppDomainPolicy*
  parent: System.AppDomain
  isExternal: false
  name: SetAppDomainPolicy
  nameWithType: AppDomain.SetAppDomainPolicy
- uid: System.AppDomain.SetCachePath*
  parent: System.AppDomain
  isExternal: false
  name: SetCachePath
  nameWithType: AppDomain.SetCachePath
- uid: System.AppDomain.SetData*
  parent: System.AppDomain
  isExternal: false
  name: SetData
  nameWithType: AppDomain.SetData
- uid: System.AppDomain.SetDynamicBase*
  parent: System.AppDomain
  isExternal: false
  name: SetDynamicBase
  nameWithType: AppDomain.SetDynamicBase
- uid: System.AppDomain.SetPrincipalPolicy*
  parent: System.AppDomain
  isExternal: false
  name: SetPrincipalPolicy
  nameWithType: AppDomain.SetPrincipalPolicy
- uid: System.AppDomain.SetShadowCopyFiles*
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyFiles
  nameWithType: AppDomain.SetShadowCopyFiles
- uid: System.AppDomain.SetShadowCopyPath*
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyPath
  nameWithType: AppDomain.SetShadowCopyPath
- uid: System.AppDomain.SetThreadPrincipal*
  parent: System.AppDomain
  isExternal: false
  name: SetThreadPrincipal
  nameWithType: AppDomain.SetThreadPrincipal
- uid: System.AppDomain.SetupInformation*
  parent: System.AppDomain
  isExternal: false
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
- uid: System.AppDomain.ShadowCopyFiles*
  parent: System.AppDomain
  isExternal: false
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetIDsOfNames
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfo
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfoCount
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount
- uid: System.AppDomain.System#_AppDomain#Invoke*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.Invoke
  nameWithType: AppDomain.System._AppDomain.Invoke
- uid: System.AppDomain.ToString*
  parent: System.AppDomain
  isExternal: false
  name: ToString
  nameWithType: AppDomain.ToString
- uid: System.AppDomain.Unload*
  parent: System.AppDomain
  isExternal: false
  name: Unload
  nameWithType: AppDomain.Unload
