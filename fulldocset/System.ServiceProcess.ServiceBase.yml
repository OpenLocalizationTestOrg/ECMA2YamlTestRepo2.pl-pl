### YamlMime:ManagedReference
items:
- uid: System.ServiceProcess.ServiceBase
  id: ServiceBase
  children:
  - System.ServiceProcess.ServiceBase.#ctor
  - System.ServiceProcess.ServiceBase.AutoLog
  - System.ServiceProcess.ServiceBase.CanHandlePowerEvent
  - System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent
  - System.ServiceProcess.ServiceBase.CanPauseAndContinue
  - System.ServiceProcess.ServiceBase.CanShutdown
  - System.ServiceProcess.ServiceBase.CanStop
  - System.ServiceProcess.ServiceBase.Dispose(System.Boolean)
  - System.ServiceProcess.ServiceBase.EventLog
  - System.ServiceProcess.ServiceBase.ExitCode
  - System.ServiceProcess.ServiceBase.MaxNameLength
  - System.ServiceProcess.ServiceBase.OnContinue
  - System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)
  - System.ServiceProcess.ServiceBase.OnPause
  - System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)
  - System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)
  - System.ServiceProcess.ServiceBase.OnShutdown
  - System.ServiceProcess.ServiceBase.OnStart(System.String[])
  - System.ServiceProcess.ServiceBase.OnStop
  - System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)
  - System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)
  - System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])
  - System.ServiceProcess.ServiceBase.ServiceHandle
  - System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)
  - System.ServiceProcess.ServiceBase.ServiceName
  - System.ServiceProcess.ServiceBase.Stop
  langs:
  - csharp
  name: ServiceBase
  nameWithType: ServiceBase
  fullName: System.ServiceProcess.ServiceBase
  type: Class
  summary: "Udostępnia klasę podstawową dla usługi, która będzie istnieć w ramach aplikacji usługi. Musi być pochodną elementu ServiceBase, podczas tworzenia nowej klasy usługi."
  remarks: "Derive from ServiceBase when defining your service class in a service application. Any useful service overrides the [OnStart(String\\[\\])](assetId:///M:System.ServiceProcess.ServiceBase.OnStart(System.String[])?qualifyHint=False&autoUpgrade=True) and <xref:System.ServiceProcess.ServiceBase.OnStop%2A> methods. For additional functionality, you can override <xref:System.ServiceProcess.ServiceBase.OnPause%2A> and <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> with specific behavior in response to changes in the service state.  \n  \n A service is a long-running executable that does not support a user interface, and which might not run under the logged-on user account. The service can run without any user being logged on to the computer.  \n  \n By default, services run under the System account, which is not the same as the Administrator account. You cannot change the rights of the System account. Alternatively, you can use a <xref:System.ServiceProcess.ServiceProcessInstaller> to specify a user account under which the service will run.  \n  \n An executable can contain more than one service but must contain a separate <xref:System.ServiceProcess.ServiceInstaller> for each service. The <xref:System.ServiceProcess.ServiceInstaller> instance registers the service with the system. The installer also associates each service with an event log that you can use to record service commands. The `main()` function in the executable defines which services should run. The current working directory of the service is the system directory, not the directory in which the executable is located.  \n  \n When you start a service, the system locates the executable and runs the <xref:System.ServiceProcess.ServiceBase.OnStart%2A> method for that service, contained within the executable. However, running the service is not the same as running the executable. The executable only loads the service. The service is accessed (for example, started and stopped) through the Service Control Manager.  \n  \n The executable calls the ServiceBase derived class's constructor the first time you call Start on the service. The <xref:System.ServiceProcess.ServiceBase.OnStart%2A> command-handling method is called immediately after the constructor executes. The constructor is not executed again after the first time the service has been loaded, so it is necessary to separate the processing performed by the constructor from that performed by <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Any resources that can be released by <xref:System.ServiceProcess.ServiceBase.OnStop%2A> should be created in <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Creating resources in the constructor prevents them from being created properly if the service is started again after <xref:System.ServiceProcess.ServiceBase.OnStop%2A> has released the resources.  \n  \n The Service Control Manager (SCM) provides a way to interact with the service. You can use the SCM to pass Start, Stop, Pause, Continue, or custom commands into the service. The SCM uses the values of <xref:System.ServiceProcess.ServiceBase.CanStop%2A> and <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> to determine whether the service accepts Stop, Pause, or Continue commands. Stop, Pause, and Continue are enabled in the SCM's context menus only if the corresponding property <xref:System.ServiceProcess.ServiceBase.CanStop%2A> or <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> is `true` in the service class. If enabled, the command is passed to the service, and <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, or <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> is called. If <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, or <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> is `false`, the corresponding command-handling method (such as <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) will not be processed, even if you have implemented the method.  \n  \n You can use the <xref:System.ServiceProcess.ServiceController> class to do programmatically what the SCM does using a user interface. You can automate the tasks available in the console. If <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, or <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> is `true` but you have not implemented a corresponding command-handling method (such as <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) the system throws an exception and ignores the command.  \n  \n You do not have to implement <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, or any other method in ServiceBase. However, the service's behavior is described in <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, so at minimum, this member should be overridden. The `main()` function of the executable registers the service in the executable with the Service Control Manager by calling the <xref:System.ServiceProcess.ServiceBase.Run%2A> method. The <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> property of the ServiceBase object passed to the <xref:System.ServiceProcess.ServiceBase.Run%2A> method must match the <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A> property of the service installer for that service.  \n  \n You can use `InstallUtil.exe` to install services on your system.  \n  \n> [!NOTE]\n>  You can specify a log other than the Application event log to receive notification of service calls, but neither the <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> nor the <xref:System.ServiceProcess.ServiceBase.EventLog%2A> property can write to a custom log. Set <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> to `false` if you do not want to use automatic logging."
  syntax:
    content: >-
      [System.ComponentModel.InstallerType(typeof(System.ServiceProcess.ServiceProcessInstaller))]

      public class ServiceBase : System.ComponentModel.Component
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements: []
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.#ctor
  id: '#ctor'
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: ServiceBase()
  nameWithType: ServiceBase.ServiceBase()
  fullName: System.ServiceProcess.ServiceBase.ServiceBase()
  type: Constructor
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Tworzy nowe wystąpienie klasy <xref href=&quot;System.ServiceProcess.ServiceBase&quot;> </xref> klasy."
  remarks: "Nie należy tworzyć wystąpienia <xref:System.ServiceProcess.ServiceBase>klasy.</xref:System.ServiceProcess.ServiceBase> Zamiast tego dziedziczyć <xref:System.ServiceProcess.ServiceBase>i utworzenia wystąpienia z klasy pochodnej.</xref:System.ServiceProcess.ServiceBase> Minimalna należy wdrożyć w Konstruktorze dla odziedziczone po klasie <xref:System.ServiceProcess.ServiceBase>jest skonfigurowanie <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>na składnika.</xref:System.ServiceProcess.ServiceBase.ServiceName%2A> </xref:System.ServiceProcess.ServiceBase> Nie inne przetwarzania jest wymagany w szczególności w konstruktorze. Powinna obsługiwać większość inicjowania w <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, a nie w konstruktorze.</xref:System.ServiceProcess.ServiceBase.OnStart%2A> W przeciwnym razie nie ma żadnej gwarancji, które obiekty zostanie zainicjowana ponownie po ponownym uruchomieniu usługi po została zatrzymana.       Jeśli w Konstruktorze przesłonięcia w klasie pochodnej, wywołanie konstruktora klasy podstawowej w kodzie.       <xref:System.ServiceProcess.ServiceBase>Ustawia konstruktora <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>do `true`.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A> </xref:System.ServiceProcess.ServiceBase> Jeśli nie chcesz automatycznie logować wywołań do usługi z Menedżera sterowania usługami (SCM), ustaw <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>do `false`.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A>       Jeśli pliku wykonywalnego zawiera pojedynczą usługę, system wywołuje konstruktor usługi podczas uruchamiania wybrano SCM i uruchamia destruktor, gdy Stop została wywołana.       Jeśli pliku wykonywalnego zawiera wiele usług, wywoływania rozpoczęcia w jednej usługi powoduje, że konstruktorów ma być wywoływana dla wszystkich usług w pliku wykonywalnego, ale tylko określona usługa jest uruchomiona. Destruktory dla usług są uruchamiane razem gdy wszystkie usługi została zatrzymana, nie pojedynczo po zatrzymaniu każdej usługi.      > [!NOTE] > Jeśli zastąpienie konstruktora klasy podstawowej, należy go jawnie wywołać konstruktora klasy pochodnej."
  syntax:
    content: public ServiceBase ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.AutoLog
  id: AutoLog
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: AutoLog
  nameWithType: ServiceBase.AutoLog
  fullName: System.ServiceProcess.ServiceBase.AutoLog
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Wskazuje, czy zgłaszać polecenia Start, Zatrzymaj, Wstrzymaj i Kontynuuj w dzienniku zdarzeń."
  remarks: "Ustawienie AutoLog `true` powoduje, że usługa Dziennik zdarzeń aplikacji, aby niepowodzenia polecenia raportu, a także informacje o zmianie stanu na użytek Uruchom, Zatrzymaj, Wstrzymaj i Kontynuuj zdarzeń w usłudze. Nazwa usługi jest używana jako <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName>.</xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName> dziennika       Aby przekazać informacje niestandardowe dziennika zdarzeń, a nie w dzienniku aplikacji, ustaw AutoLog `false` i pisanie instrukcji w obrębie metody obsługi polecenia <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, lub <xref:System.ServiceProcess.ServiceBase.OnStop%2A>do wysłania do odpowiedniego dziennika</xref:System.ServiceProcess.ServiceBase.OnStop%2A> </xref:System.ServiceProcess.ServiceBase.OnPause%2A> </xref:System.ServiceProcess.ServiceBase.OnContinue%2A>      > [!NOTE] > <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>Które dostaw ciąg źródłowy dla dziennika zdarzeń, należy ustawić przed usługa próbuje dokonać zapisu w dzienniku zdarzeń.</xref:System.ServiceProcess.ServiceBase.ServiceName%2A> Próby dostępu do dziennika zdarzeń, przed skonfigurowaniem nazwę źródła zgłasza wyjątek."
  syntax:
    content: public bool AutoLog { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>do informacji w raporcie w dzienniku zdarzeń; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.AutoLog*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.CanHandlePowerEvent
  id: CanHandlePowerEvent
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: CanHandlePowerEvent
  nameWithType: ServiceBase.CanHandlePowerEvent
  fullName: System.ServiceProcess.ServiceBase.CanHandlePowerEvent
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Pobiera lub ustawia wartość wskazującą, czy usługa może obsłużyć powiadomienia o zmianie stanu zasilania komputera."
  remarks: "Podczas zmiany stanu zasilania komputera, Menedżer sterowania usługami (SCM) sprawdza, czy usługa akceptuje przy użyciu wartości CanHandlePowerEvent poleceń zdarzeń zasilania.       Jeśli jest CanHandlePowerEvent `true`, polecenie jest przekazywany do usługi i <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>Metoda jest wywoływana, jeśli została zdefiniowana.</xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> Jeśli <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>nie jest zaimplementowana w klasie pochodnej SCM obsługuje zdarzenie zasilania za pośrednictwem pustą klasę podstawową <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=fullName>metody.</xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=fullName> </xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>"
  syntax:
    content: public bool CanHandlePowerEvent { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli usługa obsługuje stan zasilania komputera zmiany w oznaczone <xref href=&quot;System.ServiceProcess.PowerBroadcastStatus&quot;> </xref> klasy, w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.CanHandlePowerEvent*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Ta właściwość jest modyfikowana po usługa została uruchomiona."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent
  id: CanHandleSessionChangeEvent
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: CanHandleSessionChangeEvent
  nameWithType: ServiceBase.CanHandleSessionChangeEvent
  fullName: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Pobiera lub ustawia wartość wskazującą, czy usługa może obsłużyć zdarzenia zmiany sesji odebrane w sesji serwera terminali."
  syntax:
    content: public bool CanHandleSessionChangeEvent { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli usługa może obsłużyć zdarzenia zmiany sesji serwera terminali; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Ta właściwość jest modyfikowana po usługa została uruchomiona."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.CanPauseAndContinue
  id: CanPauseAndContinue
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: CanPauseAndContinue
  nameWithType: ServiceBase.CanPauseAndContinue
  fullName: System.ServiceProcess.ServiceBase.CanPauseAndContinue
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Pobiera lub ustawia wartość wskazującą, czy usługa może wstrzymany i ponownie uruchomiony."
  remarks: "Wartość właściwości CanPauseAndContinue w Konstruktorze dla usługi.       Gdy usługa jest wstrzymana, zatrzymuje wykonywania. Jeśli nadal (lub za pośrednictwem Menedżera sterowania usługami programowo), usługa <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>uruchamia.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A>       Wysyła żądanie wstrzymania do usługi, można zaoszczędzić zasoby systemowe. Wstrzymaj może nie zwalnia wszystkie zasoby systemowe, ale nie Stop. <xref:System.ServiceProcess.ServiceBase.OnPause%2A>i <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>są często stosowane do przetwarzania mniej niż <xref:System.ServiceProcess.ServiceBase.OnStop%2A>i <xref:System.ServiceProcess.ServiceBase.OnStart%2A>.</xref:System.ServiceProcess.ServiceBase.OnStart%2A> </xref:System.ServiceProcess.ServiceBase.OnStop%2A> </xref:System.ServiceProcess.ServiceBase.OnContinue%2A></xref:System.ServiceProcess.ServiceBase.OnPause%2A>       Gdy jest CanPauseAndContinue `true`, Zastąp <xref:System.ServiceProcess.ServiceBase.OnPause%2A>i <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>do określenia przetwarzania, który powinien wystąpić, gdy Menedżer sterowania usługami (SCM) przekazuje żądanie wstrzymania lub kontynuować z usługą.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A> </xref:System.ServiceProcess.ServiceBase.OnPause%2A> <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>powinny zostać wdrożone cofnąć przetwarzania <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.</xref:System.ServiceProcess.ServiceBase.OnPause%2A></xref:System.ServiceProcess.ServiceBase.OnContinue%2A>       Jeśli jest CanPauseAndContinue `false`SCM nie przejdą Wstrzymaj i Kontynuuj żądania do usługi, więc <xref:System.ServiceProcess.ServiceBase.OnPause%2A>i <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>metody nie zostanie wywołany, nawet jeśli są one wykonywane.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A> </xref:System.ServiceProcess.ServiceBase.OnPause%2A> W SCM `Pause` i `Continue` formanty są wyłączone, gdy jest CanPauseAndContinue `false`."
  syntax:
    content: public bool CanPauseAndContinue { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli usługa może zostać wstrzymana; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.CanPauseAndContinue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Usługa została już uruchomiona. Nie można zmienić właściwości CanPauseAndContinue, gdy usługa została uruchomiona."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.CanShutdown
  id: CanShutdown
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: CanShutdown
  nameWithType: ServiceBase.CanShutdown
  fullName: System.ServiceProcess.ServiceBase.CanShutdown
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Pobiera lub ustawia wartość wskazującą, czy Usługa powiadamiania, gdy system jest zamykany."
  remarks: "Jeśli jest CanShutdown `true`, usługa jest powiadomienie, gdy system jest zamykany. Podczas zamykania systemu, <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>Metoda jest wywoływana, jeśli został zaimplementowany w Twojej klasy pochodnej.</xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>      > [!NOTE] > Tylko system powinno powodować <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>metodę można wykonać; usługi można wywołać ją, ale nie jest to zalecane.</xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>"
  syntax:
    content: public bool CanShutdown { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli usługa powiadamiania, gdy system jest zamykany; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.  Wartość domyślna to <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.CanShutdown*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Usługa została już uruchomiona. Nie można zmienić właściwości CanShutdown, gdy usługa została uruchomiona."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.CanStop
  id: CanStop
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: CanStop
  nameWithType: ServiceBase.CanStop
  fullName: System.ServiceProcess.ServiceBase.CanStop
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Pobiera lub ustawia wartość wskazującą, czy usługa może zostać zatrzymana, gdy została ona uruchomiona."
  remarks: "Zatrzymaj wywołanego w usłudze Menedżer sterowania usługami (SCM) sprawdza, czy usługa akceptuje przy użyciu wartości CanStop polecenia Stop. W przypadku większości usług jest wartość CanStop `true`, ale niektóre usługi systemu operacyjnego, na przykład nie Zezwalaj użytkownikowi na ich zatrzymania.       Jeśli jest CanStop `true`, polecenia zatrzymania jest przekazywany do usługi i <xref:System.ServiceProcess.ServiceBase.OnStop%2A>Metoda jest wywoływana, gdy jest zdefiniowana.</xref:System.ServiceProcess.ServiceBase.OnStop%2A> Jeśli <xref:System.ServiceProcess.ServiceBase.OnStop%2A>nie jest zaimplementowana w klasie pochodnej uchwytów SCM polecenie zatrzymania za pośrednictwem pustą klasę podstawową <xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=fullName>metody.</xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=fullName> </xref:System.ServiceProcess.ServiceBase.OnStop%2A>"
  syntax:
    content: public bool CanStop { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli usługa może zostać zatrzymana i <xref:System.ServiceProcess.ServiceBase.OnStop*>metody o nazwie; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.ServiceProcess.ServiceBase.OnStop*>"
  overload: System.ServiceProcess.ServiceBase.CanStop*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Usługa została już uruchomiona. Nie można zmienić właściwości CanStop, gdy usługa została uruchomiona."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: ServiceBase.Dispose(Boolean)
  fullName: System.ServiceProcess.ServiceBase.Dispose(Boolean)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Usuwa zasoby (inne niż pamięć) używany przez <xref href=&quot;System.ServiceProcess.ServiceBase&quot;> </xref>."
  remarks: "Wywołanie metody Dispose w klasie pochodnej (oraz za jego pośrednictwem w <xref:System.ServiceProcess.ServiceBase>klasy) po zakończeniu korzystania z klasy pochodnej.</xref:System.ServiceProcess.ServiceBase> Metoda Dispose pozostawia klasy pochodnej w stanie uniemożliwiającym jego używanie. Po wywołaniu metody Dispose, konieczne jest zwolnienie wszystkich odwołań do klasy pochodnej i <xref:System.ServiceProcess.ServiceBase>, można odzyskać pamięci, zostały one zajmujące przez wyrzucanie elementów bezużytecznych.</xref:System.ServiceProcess.ServiceBase>      > [!NOTE] > Zawsze wywołanie metody Dispose przed zwolnieniem ostatniego odwołania do klasy pochodne <xref:System.ServiceProcess.ServiceBase>.</xref:System.ServiceProcess.ServiceBase> W przeciwnym razie zasoby <xref:System.ServiceProcess.ServiceBase>i korzystają z klasy pochodnej zostanie nie zwolniona dopóki wyrzucanie elementów bezużytecznych wywołuj destruktory obiektów.</xref:System.ServiceProcess.ServiceBase>       <xref:System.ServiceProcess.ServiceBase.OnStop%2A>często jest stosowane do przetwarzania kodu w <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, łączonych w wyniku wywołania metody Dispose.</xref:System.ServiceProcess.ServiceBase.OnPause%2A></xref:System.ServiceProcess.ServiceBase.OnStop%2A> Jeśli chcesz to zrobić w klasie pochodnej jest zwyczajowe do zaimplementowania <xref:System.ServiceProcess.ServiceBase.OnStart%2A>przydzielić, niezależnie od wydane Dispose.</xref:System.ServiceProcess.ServiceBase.OnStart%2A>"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby zwolnić zasoby zarządzane i niezarządzane; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> aby zwolnić tylko zasoby niezarządzane."
  overload: System.ServiceProcess.ServiceBase.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.EventLog
  id: EventLog
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: EventLog
  nameWithType: ServiceBase.EventLog
  fullName: System.ServiceProcess.ServiceBase.EventLog
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Pobiera dziennika zdarzeń, który służy do zapisania powiadomień wywołania polecenia usługi, takie jak uruchamianie i zatrzymywanie, w dzienniku zdarzeń aplikacji."
  remarks: "Konstruktor inicjuje właściwość dziennik zdarzeń do wystąpienia o <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName>i <xref:System.Diagnostics.EventLog.Log%2A?displayProperty=fullName>set właściwości.</xref:System.Diagnostics.EventLog.Log%2A?displayProperty=fullName> </xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName> Źródło jest <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>usługi, i dziennik jest dziennika aplikacji komputera</xref:System.ServiceProcess.ServiceBase.ServiceName%2A> Te wartości są ustawiane automatycznie i nie można zmienić dla automatycznego rejestrowania poleceń usługi.       Gdy <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>jest `true`, Start, Zatrzymaj, Wstrzymaj, Kontynuuj i polecenia niestandardowych są automatycznie rejestrowane w dzienniku zdarzeń aplikacji</xref:System.ServiceProcess.ServiceBase.AutoLog%2A> Właściwości dziennika zdarzeń służy do zapisu w tym dzienniku również przejrzeć dodatkowe komunikaty. Wywołania składnika <xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=fullName>przy użyciu tego elementu członkowskiego EventLog.</xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=fullName>       Aby przekazać informacje niestandardowe dziennika zdarzeń, a nie w dzienniku aplikacji, ustaw <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>do `false` i pisanie instrukcji w obrębie metody obsługi polecenia <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, lub <xref:System.ServiceProcess.ServiceBase.OnStop%2A>do wysłania do odpowiedniego dziennika</xref:System.ServiceProcess.ServiceBase.OnStop%2A> </xref:System.ServiceProcess.ServiceBase.OnPause%2A> </xref:System.ServiceProcess.ServiceBase.OnContinue%2A> </xref:System.ServiceProcess.ServiceBase.AutoLog%2A>"
  syntax:
    content: public virtual System.Diagnostics.EventLog EventLog { get; }
    return:
      type: System.Diagnostics.EventLog
      description: "<xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> Wystąpienie, którego źródłem jest zarejestrowany w dzienniku aplikacji."
  overload: System.ServiceProcess.ServiceBase.EventLog*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.ExitCode
  id: ExitCode
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: ExitCode
  nameWithType: ServiceBase.ExitCode
  fullName: System.ServiceProcess.ServiceBase.ExitCode
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Pobiera lub ustawia kod zakończenia usługi."
  remarks: "Ustaw właściwość ExitCode na wartość inną niż zero, przed zatrzymaniem usługi wystąpił błąd menedżera kontroli usług."
  syntax:
    content: public int ExitCode { get; set; }
    return:
      type: System.Int32
      description: "Kod zakończenia usługi."
  overload: System.ServiceProcess.ServiceBase.ExitCode*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.MaxNameLength
  id: MaxNameLength
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: MaxNameLength
  nameWithType: ServiceBase.MaxNameLength
  fullName: System.ServiceProcess.ServiceBase.MaxNameLength
  type: Field
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Określa maksymalny rozmiar nazwy usługi."
  remarks: "Elementy ServiceName i DisplayName mają rozmiar ograniczenia, które muszą przestrzegać podczas ustawiania właściwości w klasie usługi."
  syntax:
    content: public const int MaxNameLength = 80;
    return:
      type: System.Int32
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnContinue
  id: OnContinue
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnContinue()
  nameWithType: ServiceBase.OnContinue()
  fullName: System.ServiceProcess.ServiceBase.OnContinue()
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Po zaimplementowaniu w klasie pochodnej, OnContinue uruchamiane po polecenie Kontynuuj, jest wysyłane do usługi przez Menedżera sterowania usługami (SCM). Określa akcje w sytuacji, gdy usługa wznawia normalne działanie po wstrzymaniu."
  remarks: "Implementowanie OnContinue dublowanego odpowiedzi aplikacji <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.</xref:System.ServiceProcess.ServiceBase.OnPause%2A> Gdy kontynuować (lub za pośrednictwem konsoli usługi programowo), usługa OnContinue przetwarzania działa i usługa stanie się ponownie aktywna.       OnContinue powinien być zastąpione, gdy <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>jest właściwość `true`.</xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>       Jeśli <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>jest `false`SCM nie przejdą Wstrzymaj i Kontynuuj żądania do usługi, więc <xref:System.ServiceProcess.ServiceBase.OnPause%2A>i metody OnContinue nie zostanie wywołany, nawet jeśli są one wykonywane.</xref:System.ServiceProcess.ServiceBase.OnPause%2A> </xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> W SCM `Pause` i `Continue` formanty są wyłączone, gdy <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>jest `false`.</xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>"
  syntax:
    content: protected virtual void OnContinue ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.OnContinue*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)
  id: OnCustomCommand(System.Int32)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnCustomCommand(Int32)
  nameWithType: ServiceBase.OnCustomCommand(Int32)
  fullName: System.ServiceProcess.ServiceBase.OnCustomCommand(Int32)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Po zaimplementowaniu w klasie pochodnej, OnCustomCommand wykonuje się, gdy Menedżer sterowania usługami (SCM) przekazuje polecenia niestandardowych do usługi. Określa akcje do wykonania po wystąpieniu polecenia podana wartość parametru."
  remarks: "OnCustomCommand pozwala określić dodatkowe funkcje oprócz uruchamianie, zatrzymywanie, wstrzymywanie i kontynuowanie usługi.       Menedżer sterowania usługami nie bada niestandardowe polecenia, aby sprawdzić, czy usługa obsługuje `command` przekazany parametr. Przekazuje ono polecenia niestandardowych bezpośrednio do usługi. Jeśli usługa nie rozpoznaje `command` parametru go nie działają.       Polecenia niestandardowe są wywoływane przez <xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A>instrukcji w <xref:System.ServiceProcess.ServiceController>składnika.</xref:System.ServiceProcess.ServiceController> </xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A> Użyj instrukcji switch lub, jeśli... następnie warunek do obsługi polecenia niestandardowych, które należy zdefiniować w usłudze.       Są tylko wartości dla polecenia niestandardowych, które można zdefiniować w aplikacji lub użyć w OnCustomCommand od 128 do 255. Liczby całkowite poniżej 128 odpowiadają wartościom zarezerwowana przez system.       Jeśli <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>jest właściwość `true`, niestandardowych poleceń, takich jak wszystkie inne polecenia tworzyć wpisy w dzienniku zdarzeń do raportowania, czy wykonanie metody powodzeniem lub niepowodzeniem.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A>"
  syntax:
    content: protected virtual void OnCustomCommand (int command);
    parameters:
    - id: command
      type: System.Int32
      description: "Komunikat polecenia wysyłane do usługi."
  overload: System.ServiceProcess.ServiceBase.OnCustomCommand*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnPause
  id: OnPause
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnPause()
  nameWithType: ServiceBase.OnPause()
  fullName: System.ServiceProcess.ServiceBase.OnPause()
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Po zaimplementowaniu w klasie pochodnej, wykonuje się, gdy polecenia Wstrzymaj jest wysyłane do usługi przez Menedżera sterowania usługami (SCM). Określa akcje w sytuacji, gdy wstrzymuje usługę."
  remarks: "OnPause umożliwia określenie przetwarzania, które występuje, gdy usługa odbierze polecenie wstrzymania. OnPause powinien być zastąpione, gdy <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>jest właściwość `true`.</xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>       Jeśli będziesz kontynuować wstrzymanej usługi (lub za pośrednictwem konsoli usługi programowo), <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>przetwarzania jest uruchamiane, a usługa stanie się ponownie aktywna.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A>       Polecenie Wstrzymaj umożliwia tylko aplikację do reagowania na zdarzenia. OnPause nie działają z usługą nie definiują zrobić.       Wysyła żądanie wstrzymania do usługi można zaoszczędzić zasoby systemowe, ponieważ Wstrzymaj muszą zwalnia wszystkie zasoby systemowe. Na przykład jeśli zostały otwarte wątków w procesie, wstrzymanie usługi, a nie jej zatrzymania umożliwiają wątków pozostają otwarte, co eliminuje konieczność ich ponowne przydzielenie, gdy usługa będzie. W przypadku definiowania Wstrzymaj, aby zwolnić wszystkie zasoby systemowe, zachowuje się jak polecenia zatrzymania.       Ustaw <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>do `true`i Zastąp OnPause i <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>do określenia przetwarzania, który powinien wystąpić, gdy Menedżer sterowania usługami przekazuje żądanie wstrzymania lub kontynuować z usługą.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A> </xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>powinny zostać wdrożone do przetwarzania w OnPause cofania.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A>       Jeśli <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>jest `false`SCM nie przejdą Wstrzymaj i Kontynuuj żądania do usługi, więc OnPause i <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>metody nie zostanie wywołany, nawet jeśli zaimplementowano.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A> </xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> W SCM `Pause` i `Continue` formanty są wyłączone, gdy <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>jest `false`.</xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>"
  syntax:
    content: protected virtual void OnPause ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.OnPause*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)
  id: OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnPowerEvent(PowerBroadcastStatus)
  nameWithType: ServiceBase.OnPowerEvent(PowerBroadcastStatus)
  fullName: System.ServiceProcess.ServiceBase.OnPowerEvent(PowerBroadcastStatus)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Po zaimplementowaniu w klasie pochodnej, wykonuje po zmianie stanu zasilania komputera. Dotyczy to komputerów przenośnych gdy przejdą w tryb wstrzymania, który nie jest taka sama jak zamknięcia systemu."
  remarks: "Umożliwia określenie przetwarzania, które występuje, gdy zdarzenie systemowe OnPowerEvent <xref:System.ServiceProcess.PowerBroadcastStatus>występuje wyliczenie — na przykład gdy komputer znajduje się w trybie wstrzymania lub wskazuje zasilania niskim poziomie naładowania baterii.</xref:System.ServiceProcess.PowerBroadcastStatus>       OnPowerEvent powinien być zastąpione, gdy <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>jest właściwość `true`.</xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>"
  syntax:
    content: protected virtual bool OnPowerEvent (System.ServiceProcess.PowerBroadcastStatus powerStatus);
    parameters:
    - id: powerStatus
      type: System.ServiceProcess.PowerBroadcastStatus
      description: "A <xref href=&quot;System.ServiceProcess.PowerBroadcastStatus&quot;> </xref> wskazujące powiadomienie z systemu o jego stan zasilania."
    return:
      type: System.Boolean
      description: "Po zaimplementowaniu w klasie pochodnej, wymagań aplikacji ustalić, jakie wartości do zwrócenia. Na przykład jeśli <xref uid=&quot;langword_csharp_QuerySuspend&quot; name=&quot;QuerySuspend&quot; href=&quot;&quot;> </xref> emisji stanu jest przekazywana, może spowodować, że aplikacja do odrzucania zapytanie zwróciła <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.OnPowerEvent*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)
  id: OnSessionChange(System.ServiceProcess.SessionChangeDescription)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnSessionChange(SessionChangeDescription)
  nameWithType: ServiceBase.OnSessionChange(SessionChangeDescription)
  fullName: System.ServiceProcess.ServiceBase.OnSessionChange(SessionChangeDescription)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Wykonywana po odebraniu zdarzenia zmiany z sesji serwera terminali."
  remarks: "Należy ustawić <xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A>właściwości `true` umożliwiające wykonanie tej metody.</xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A>"
  syntax:
    content: protected virtual void OnSessionChange (System.ServiceProcess.SessionChangeDescription changeDescription);
    parameters:
    - id: changeDescription
      type: System.ServiceProcess.SessionChangeDescription
      description: "Struktura, która identyfikuje typ zmiany."
  overload: System.ServiceProcess.ServiceBase.OnSessionChange*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnShutdown
  id: OnShutdown
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnShutdown()
  nameWithType: ServiceBase.OnShutdown()
  fullName: System.ServiceProcess.ServiceBase.OnShutdown()
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Po zaimplementowaniu w klasie pochodnej, wykonuje się, gdy system jest zamykany. Określa, jakie powinny występować bezpośrednio przed zamykanie systemu."
  remarks: "Umożliwia określenie przetwarzania, które występuje, gdy system będzie zamykany OnShutdown.       To zdarzenie występuje tylko wtedy, gdy system operacyjny jest zamknięta, nie w przypadku, gdy komputer jest wyłączony.       OnShutdown powinien być zastąpione, gdy <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>jest właściwość `true`.</xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>"
  syntax:
    content: protected virtual void OnShutdown ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.OnShutdown*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnStart(System.String[])
  id: OnStart(System.String[])
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnStart(String[])
  nameWithType: ServiceBase.OnStart(String[])
  fullName: System.ServiceProcess.ServiceBase.OnStart(String[])
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Po zaimplementowaniu w klasie pochodnej, wykonuje po wysłaniu polecenia Start z usługą przez Menedżera sterowania usługami (SCM) lub podczas uruchamiania systemu operacyjnego (dla usługi, które jest uruchamiane automatycznie). Określa akcje do wykonania podczas uruchamiania usługi."
  remarks: "Use OnStart to specify the processing that occurs when the service receives a Start command. OnStart is the method in which you specify the behavior of the service. OnStart can take arguments as a way to pass data, but this usage is rare.  \n  \n> [!CAUTION]\n>  Do not use the constructor to perform processing that should be in OnStart. Use OnStart to handle all initialization of your service. The constructor is called when the application's executable runs, not when the service runs. The executable runs before OnStart. When you continue, for example, the constructor is not called again because the SCM already holds the object in memory. If <xref:System.ServiceProcess.ServiceBase.OnStop%2A> releases resources allocated in the constructor rather than in OnStart, the needed resources would not be created again the second time the service is called.  \n  \n Services can be set to start automatically when the computer reboots by setting the <xref:System.ServiceProcess.ServiceInstaller.StartType%2A> on the service's installer to <xref:System.ServiceProcess.ServiceStartMode>. In such a situation, OnStart would be called at system startup.  \n  \n OnStart is expected to be overridden in the derived class. For the service to be useful, OnStart and <xref:System.ServiceProcess.ServiceBase.OnStop%2A> should both be implemented in your service class.  \n  \n Process initialization arguments for the service in the OnStart method, not in the Main method. The arguments in the `args` parameter array can be set manually in the properties window for the service in the Services console. The arguments entered in the console are not saved; they are passed to the service on a one-time basis when the service is started from the control panel. Arguments that must be present when the service is automatically started can be placed in the ImagePath string value for the service's registry key (HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\\\*\\<service name>*). You can obtain the arguments from the registry using the <xref:System.Environment.GetCommandLineArgs%2A> method, for example:  `string[] imagePathArgs = Environment.GetCommandLineArgs();`."
  syntax:
    content: protected virtual void OnStart (string[] args);
    parameters:
    - id: args
      type: System.String[]
      description: "Dane przekazywane przez polecenia uruchomienia."
  overload: System.ServiceProcess.ServiceBase.OnStart*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnStop
  id: OnStop
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnStop()
  nameWithType: ServiceBase.OnStop()
  fullName: System.ServiceProcess.ServiceBase.OnStop()
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Po zaimplementowaniu w klasie pochodnej, wykonuje się, gdy polecenie zatrzymania jest wysyłane do usługi przez Menedżera sterowania usługami (SCM). Określa akcje do podjęcia, gdy usługa przestanie działać."
  remarks: "Umożliwia określenie przetwarzania, które występuje, gdy usługa odbierze polecenie zatrzymania OnStop.       Menedżer sterowania usługami odebrania polecenia zatrzymania używa wartości <xref:System.ServiceProcess.ServiceBase.CanStop%2A>Aby sprawdzić, czy usługa akceptuje polecenia zatrzymania.</xref:System.ServiceProcess.ServiceBase.CanStop%2A> Jeśli <xref:System.ServiceProcess.ServiceBase.CanStop%2A>jest `true`polecenia zatrzymania jest przekazywany do usługi i OnStop — metoda jest wywoływana, gdy jest on zdefiniowany.</xref:System.ServiceProcess.ServiceBase.CanStop%2A> Jeśli OnStop nie jest zaimplementowana w usłudze, SCM obsługuje polecenia zatrzymania.       Jeśli <xref:System.ServiceProcess.ServiceBase.CanStop%2A>jest `false`, SCM ignoruje polecenia zatrzymania.</xref:System.ServiceProcess.ServiceBase.CanStop%2A> Nie jest przekazywany do usługi. Polecenie zatrzymania zwraca i zgłasza wyjątek.       OnStop powinien zostać zastąpiony w klasie pochodnej. Dla usługi powinna być użyteczna, <xref:System.ServiceProcess.ServiceBase.OnStart%2A>i OnStop powinny jednocześnie być implementowane w Twojej klasie usługi.</xref:System.ServiceProcess.ServiceBase.OnStart%2A>"
  syntax:
    content: protected virtual void OnStop ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.OnStop*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)
  id: RequestAdditionalTime(System.Int32)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: RequestAdditionalTime(Int32)
  nameWithType: ServiceBase.RequestAdditionalTime(Int32)
  fullName: System.ServiceProcess.ServiceBase.RequestAdditionalTime(Int32)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Dodatkowy czas żądań oczekujących operacji."
  remarks: "Metoda RequestAdditionalTime jest przeznaczona do wywoływania przez przesłoniętych <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, lub <xref:System.ServiceProcess.ServiceBase.OnStop%2A>metod do żądania dodatkowego czasu oczekująca operacja, aby zapobiec Menedżer sterowania usługami (SCM) oznaczenie usługi, ponieważ nie odpowiada.</xref:System.ServiceProcess.ServiceBase.OnStop%2A> </xref:System.ServiceProcess.ServiceBase.OnStart%2A> </xref:System.ServiceProcess.ServiceBase.OnPause%2A> </xref:System.ServiceProcess.ServiceBase.OnContinue%2A>  Jeśli nie jest oczekująca operacja Kontynuuj, Wstrzymaj, uruchomienia lub zatrzymania, <xref:System.InvalidOperationException>jest generowany.</xref:System.InvalidOperationException>"
  syntax:
    content: public void RequestAdditionalTime (int milliseconds);
    parameters:
    - id: milliseconds
      type: System.Int32
      description: "Żądany czas w milisekundach."
  overload: System.ServiceProcess.ServiceBase.RequestAdditionalTime*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Usługa nie jest w stanie oczekiwania."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)
  id: Run(System.ServiceProcess.ServiceBase)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: Run(ServiceBase)
  nameWithType: ServiceBase.Run(ServiceBase)
  fullName: System.ServiceProcess.ServiceBase.Run(ServiceBase)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Rejestruje plik wykonywalny usługi z Menedżera sterowania usługami (SCM)."
  remarks: "Wywołać tego przeciążenia `main()` funkcja plik wykonywalny, aby zarejestrować usługę z Menedżerem sterowania usługami usługi. Po wywołaniu metody Uruchom Menedżera sterowania usługami wystawia polecenie Start, co powoduje wywołanie <xref:System.ServiceProcess.ServiceBase.OnStart%2A>metody w usłudze.</xref:System.ServiceProcess.ServiceBase.OnStart%2A> Usługa nie jest uruchomiona do momentu rozpoczęcia polecenie zostanie wykonane.       Metoda Run jest wywoływana w znacznie taki sam sposób jak <xref:System.Windows.Forms.Application.Run%2A?displayProperty=fullName>dla aplikacji Windows Forms.</xref:System.Windows.Forms.Application.Run%2A?displayProperty=fullName>       Jeśli <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>jest `true`, wpis są zapisywane w dzienniku zdarzeń, jeśli usługa określony przez `service` parametr nie zostanie uruchomiona.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A>"
  syntax:
    content: public static void Run (System.ServiceProcess.ServiceBase service);
    parameters:
    - id: service
      type: System.ServiceProcess.ServiceBase
      description: "A <xref href=&quot;System.ServiceProcess.ServiceBase&quot;> </xref> co oznacza usługi, aby rozpocząć."
  overload: System.ServiceProcess.ServiceBase.Run*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>service</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])
  id: Run(System.ServiceProcess.ServiceBase[])
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: Run(ServiceBase[])
  nameWithType: ServiceBase.Run(ServiceBase[])
  fullName: System.ServiceProcess.ServiceBase.Run(ServiceBase[])
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Rejestruje plik wykonywalny dla wielu usług z Menedżera sterowania usługami (SCM)."
  remarks: "Wywołać tego przeciążenia `main()` funkcja plik wykonywalny do rejestrowania usług z Menedżerem sterowania usługami usługi. Po wywołaniu metody Uruchom Menedżera sterowania usługami wystawia uruchamiania poleceń, które powoduje wywołań <xref:System.ServiceProcess.ServiceBase.OnStart%2A>metod w usługach.</xref:System.ServiceProcess.ServiceBase.OnStart%2A> Nie są uruchomione usługi, do momentu rozpoczęcia polecenia są wykonywane.       Metoda Run jest wywoływana w znacznie taki sam sposób jak <xref:System.Windows.Forms.Application.Run%2A?displayProperty=fullName>metodę dla aplikacji Windows Forms.</xref:System.Windows.Forms.Application.Run%2A?displayProperty=fullName>       Jeśli <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>jest `true`, wpis są zapisywane w dzienniku zdarzeń, jeśli nie można uruchomić wszystkie usługi w tablicy.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A>"
  syntax:
    content: public static void Run (System.ServiceProcess.ServiceBase[] services);
    parameters:
    - id: services
      type: System.ServiceProcess.ServiceBase[]
      description: "Tablica wystąpień elementu ServiceBase, które wskazują uruchomienie usług."
  overload: System.ServiceProcess.ServiceBase.Run*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Nie dostarczył usługi, aby rozpocząć. Tablica może być <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> lub jest pusty."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.ServiceHandle
  id: ServiceHandle
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: ServiceHandle
  nameWithType: ServiceBase.ServiceHandle
  fullName: System.ServiceProcess.ServiceBase.ServiceHandle
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Pobiera uchwyt formantu usługi dla usługi."
  remarks: "Uchwyt formantu usługi jest używany do komunikacji z Menedżera sterowania usługami (SCM).  Dojście można zaktualizować informacji o stanie menedżera kontroli usług dla wywołania usługi za pomocą niezarządzaną `SetServiceStatus` funkcji."
  syntax:
    content: protected IntPtr ServiceHandle { get; }
    return:
      type: System.IntPtr
      description: "<xref:System.IntPtr>Strukturę, która zawiera uchwyt formantu usługi dla usługi.</xref:System.IntPtr>"
  overload: System.ServiceProcess.ServiceBase.ServiceHandle*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)
  id: ServiceMainCallback(System.Int32,System.IntPtr)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: ServiceMainCallback(Int32,IntPtr)
  nameWithType: ServiceBase.ServiceMainCallback(Int32,IntPtr)
  fullName: System.ServiceProcess.ServiceBase.ServiceMainCallback(Int32,IntPtr)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Rejestruje program obsługi poleceń i uruchamia usługę."
  syntax:
    content: public void ServiceMainCallback (int argCount, IntPtr argPointer);
    parameters:
    - id: argCount
      type: System.Int32
      description: "Liczba argumentów w tablicy argumentu."
    - id: argPointer
      type: System.IntPtr
      description: "<xref:System.IntPtr>Strukturę, która odwołuje się do tablicy argumentów.</xref:System.IntPtr>"
  overload: System.ServiceProcess.ServiceBase.ServiceMainCallback*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.ServiceName
  id: ServiceName
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: ServiceName
  nameWithType: ServiceBase.ServiceName
  fullName: System.ServiceProcess.ServiceBase.ServiceName
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Pobiera lub ustawia krótką nazwę, używany do identyfikowania usługi do systemu."
  remarks: "ServiceName identyfikuje usługę menedżera kontroli usług. Wartość tej właściwości musi być taka sama jak nazwa zarejestrowane w usłudze we <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=fullName>właściwości odpowiedniej klasy Instalatora.</xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=fullName> W kodzie, ServiceName usługi jest zwykle ustawiana `main()` funkcja pliku wykonywalnego.       ServiceName również służy do określania <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName>skojarzone z <xref:System.ServiceProcess.ServiceBase.EventLog%2A>Właściwości.</xref:System.ServiceProcess.ServiceBase.EventLog%2A> </xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName> To <xref:System.ServiceProcess.ServiceBase.EventLog%2A>jest wystąpieniem, który zapisuje informacje dotyczące poleceń usługi do dziennika aplikacji.</xref:System.ServiceProcess.ServiceBase.EventLog%2A>       ServiceName, która dostarcza ciąg źródłowy dla dziennika zdarzeń, musi być ustawiona, zanim usługa zapisuje w dzienniku zdarzeń. Próby dostępu do dziennika zdarzeń, przed skonfigurowaniem nazwę źródła powoduje, że wyjątek zostanie wygenerowany."
  syntax:
    content: public string ServiceName { get; set; }
    return:
      type: System.String
      description: "Nazwa usługi."
  overload: System.ServiceProcess.ServiceBase.ServiceName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Usługa została już uruchomiona. Nie można zmienić właściwości ServiceName, gdy usługa została uruchomiona."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Podana nazwa jest ciągiem o zerowej długości lub jej długość przekracza <xref href=&quot;System.ServiceProcess.ServiceBase.MaxNameLength&quot;> </xref>, albo określona nazwa zawiera znaki, do przodu ukośnika ani ukośnika odwrotnego."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.Stop
  id: Stop
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: Stop()
  nameWithType: ServiceBase.Stop()
  fullName: System.ServiceProcess.ServiceBase.Stop()
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Zatrzymuje usługę wykonywania."
  remarks: "Metoda Stop ustawia stan usługi, aby wskazać Trwa oczekiwanie na zatrzymanie i wywołania <xref:System.ServiceProcess.ServiceBase.OnStop%2A>metody.</xref:System.ServiceProcess.ServiceBase.OnStop%2A>  Po wyłączeniu aplikacji stan usługi jest ustawiony do zatrzymania. Jeśli aplikacja jest hostowana usługa, nie jest załadowany domeny aplikacji."
  syntax:
    content: public void Stop ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.Stop*
  exceptions: []
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ServiceProcess.ServiceBase.#ctor
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceBase()
  nameWithType: ServiceBase.ServiceBase()
  fullName: System.ServiceProcess.ServiceBase.ServiceBase()
- uid: System.ServiceProcess.ServiceBase.AutoLog
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: AutoLog
  nameWithType: ServiceBase.AutoLog
  fullName: System.ServiceProcess.ServiceBase.AutoLog
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.ServiceProcess.ServiceBase.CanHandlePowerEvent
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanHandlePowerEvent
  nameWithType: ServiceBase.CanHandlePowerEvent
  fullName: System.ServiceProcess.ServiceBase.CanHandlePowerEvent
- uid: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanHandleSessionChangeEvent
  nameWithType: ServiceBase.CanHandleSessionChangeEvent
  fullName: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent
- uid: System.ServiceProcess.ServiceBase.CanPauseAndContinue
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanPauseAndContinue
  nameWithType: ServiceBase.CanPauseAndContinue
  fullName: System.ServiceProcess.ServiceBase.CanPauseAndContinue
- uid: System.ServiceProcess.ServiceBase.CanShutdown
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanShutdown
  nameWithType: ServiceBase.CanShutdown
  fullName: System.ServiceProcess.ServiceBase.CanShutdown
- uid: System.ServiceProcess.ServiceBase.CanStop
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanStop
  nameWithType: ServiceBase.CanStop
  fullName: System.ServiceProcess.ServiceBase.CanStop
- uid: System.ServiceProcess.ServiceBase.Dispose(System.Boolean)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: ServiceBase.Dispose(Boolean)
  fullName: System.ServiceProcess.ServiceBase.Dispose(Boolean)
- uid: System.ServiceProcess.ServiceBase.EventLog
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: EventLog
  nameWithType: ServiceBase.EventLog
  fullName: System.ServiceProcess.ServiceBase.EventLog
- uid: System.Diagnostics.EventLog
  parent: System.Diagnostics
  isExternal: false
  name: EventLog
  nameWithType: EventLog
  fullName: System.Diagnostics.EventLog
- uid: System.ServiceProcess.ServiceBase.ExitCode
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ExitCode
  nameWithType: ServiceBase.ExitCode
  fullName: System.ServiceProcess.ServiceBase.ExitCode
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.ServiceProcess.ServiceBase.MaxNameLength
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: MaxNameLength
  nameWithType: ServiceBase.MaxNameLength
  fullName: System.ServiceProcess.ServiceBase.MaxNameLength
- uid: System.ServiceProcess.ServiceBase.OnContinue
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnContinue()
  nameWithType: ServiceBase.OnContinue()
  fullName: System.ServiceProcess.ServiceBase.OnContinue()
- uid: System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnCustomCommand(Int32)
  nameWithType: ServiceBase.OnCustomCommand(Int32)
  fullName: System.ServiceProcess.ServiceBase.OnCustomCommand(Int32)
- uid: System.ServiceProcess.ServiceBase.OnPause
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnPause()
  nameWithType: ServiceBase.OnPause()
  fullName: System.ServiceProcess.ServiceBase.OnPause()
- uid: System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnPowerEvent(PowerBroadcastStatus)
  nameWithType: ServiceBase.OnPowerEvent(PowerBroadcastStatus)
  fullName: System.ServiceProcess.ServiceBase.OnPowerEvent(PowerBroadcastStatus)
- uid: System.ServiceProcess.PowerBroadcastStatus
  parent: System.ServiceProcess
  isExternal: false
  name: PowerBroadcastStatus
  nameWithType: PowerBroadcastStatus
  fullName: System.ServiceProcess.PowerBroadcastStatus
- uid: System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnSessionChange(SessionChangeDescription)
  nameWithType: ServiceBase.OnSessionChange(SessionChangeDescription)
  fullName: System.ServiceProcess.ServiceBase.OnSessionChange(SessionChangeDescription)
- uid: System.ServiceProcess.SessionChangeDescription
  parent: System.ServiceProcess
  isExternal: false
  name: SessionChangeDescription
  nameWithType: SessionChangeDescription
  fullName: System.ServiceProcess.SessionChangeDescription
- uid: System.ServiceProcess.ServiceBase.OnShutdown
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnShutdown()
  nameWithType: ServiceBase.OnShutdown()
  fullName: System.ServiceProcess.ServiceBase.OnShutdown()
- uid: System.ServiceProcess.ServiceBase.OnStart(System.String[])
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnStart(String[])
  nameWithType: ServiceBase.OnStart(String[])
  fullName: System.ServiceProcess.ServiceBase.OnStart(String[])
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.ServiceProcess.ServiceBase.OnStop
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnStop()
  nameWithType: ServiceBase.OnStop()
  fullName: System.ServiceProcess.ServiceBase.OnStop()
- uid: System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: RequestAdditionalTime(Int32)
  nameWithType: ServiceBase.RequestAdditionalTime(Int32)
  fullName: System.ServiceProcess.ServiceBase.RequestAdditionalTime(Int32)
- uid: System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Run(ServiceBase)
  nameWithType: ServiceBase.Run(ServiceBase)
  fullName: System.ServiceProcess.ServiceBase.Run(ServiceBase)
- uid: System.ServiceProcess.ServiceBase
  parent: System.ServiceProcess
  isExternal: false
  name: ServiceBase
  nameWithType: ServiceBase
  fullName: System.ServiceProcess.ServiceBase
- uid: System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Run(ServiceBase[])
  nameWithType: ServiceBase.Run(ServiceBase[])
  fullName: System.ServiceProcess.ServiceBase.Run(ServiceBase[])
- uid: System.ServiceProcess.ServiceBase[]
  parent: System.ServiceProcess
  isExternal: false
  name: ServiceBase
  nameWithType: ServiceBase
  fullName: System.ServiceProcess.ServiceBase[]
  spec.csharp:
  - uid: System.ServiceProcess.ServiceBase
    name: ServiceBase
    nameWithType: ServiceBase
    fullName: ServiceBase[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.ServiceProcess.ServiceBase.ServiceHandle
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceHandle
  nameWithType: ServiceBase.ServiceHandle
  fullName: System.ServiceProcess.ServiceBase.ServiceHandle
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceMainCallback(Int32,IntPtr)
  nameWithType: ServiceBase.ServiceMainCallback(Int32,IntPtr)
  fullName: System.ServiceProcess.ServiceBase.ServiceMainCallback(Int32,IntPtr)
- uid: System.ServiceProcess.ServiceBase.ServiceName
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceName
  nameWithType: ServiceBase.ServiceName
  fullName: System.ServiceProcess.ServiceBase.ServiceName
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.ServiceProcess.ServiceBase.Stop
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Stop()
  nameWithType: ServiceBase.Stop()
  fullName: System.ServiceProcess.ServiceBase.Stop()
- uid: System.ServiceProcess.ServiceBase.#ctor*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceBase
  nameWithType: ServiceBase.ServiceBase
- uid: System.ServiceProcess.ServiceBase.AutoLog*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: AutoLog
  nameWithType: ServiceBase.AutoLog
- uid: System.ServiceProcess.ServiceBase.CanHandlePowerEvent*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanHandlePowerEvent
  nameWithType: ServiceBase.CanHandlePowerEvent
- uid: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanHandleSessionChangeEvent
  nameWithType: ServiceBase.CanHandleSessionChangeEvent
- uid: System.ServiceProcess.ServiceBase.CanPauseAndContinue*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanPauseAndContinue
  nameWithType: ServiceBase.CanPauseAndContinue
- uid: System.ServiceProcess.ServiceBase.CanShutdown*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanShutdown
  nameWithType: ServiceBase.CanShutdown
- uid: System.ServiceProcess.ServiceBase.CanStop*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanStop
  nameWithType: ServiceBase.CanStop
- uid: System.ServiceProcess.ServiceBase.Dispose*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Dispose
  nameWithType: ServiceBase.Dispose
- uid: System.ServiceProcess.ServiceBase.EventLog*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: EventLog
  nameWithType: ServiceBase.EventLog
- uid: System.ServiceProcess.ServiceBase.ExitCode*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ExitCode
  nameWithType: ServiceBase.ExitCode
- uid: System.ServiceProcess.ServiceBase.OnContinue*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnContinue
  nameWithType: ServiceBase.OnContinue
- uid: System.ServiceProcess.ServiceBase.OnCustomCommand*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnCustomCommand
  nameWithType: ServiceBase.OnCustomCommand
- uid: System.ServiceProcess.ServiceBase.OnPause*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnPause
  nameWithType: ServiceBase.OnPause
- uid: System.ServiceProcess.ServiceBase.OnPowerEvent*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnPowerEvent
  nameWithType: ServiceBase.OnPowerEvent
- uid: System.ServiceProcess.ServiceBase.OnSessionChange*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnSessionChange
  nameWithType: ServiceBase.OnSessionChange
- uid: System.ServiceProcess.ServiceBase.OnShutdown*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnShutdown
  nameWithType: ServiceBase.OnShutdown
- uid: System.ServiceProcess.ServiceBase.OnStart*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnStart
  nameWithType: ServiceBase.OnStart
- uid: System.ServiceProcess.ServiceBase.OnStop*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnStop
  nameWithType: ServiceBase.OnStop
- uid: System.ServiceProcess.ServiceBase.RequestAdditionalTime*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: RequestAdditionalTime
  nameWithType: ServiceBase.RequestAdditionalTime
- uid: System.ServiceProcess.ServiceBase.Run*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Run
  nameWithType: ServiceBase.Run
- uid: System.ServiceProcess.ServiceBase.ServiceHandle*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceHandle
  nameWithType: ServiceBase.ServiceHandle
- uid: System.ServiceProcess.ServiceBase.ServiceMainCallback*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceMainCallback
  nameWithType: ServiceBase.ServiceMainCallback
- uid: System.ServiceProcess.ServiceBase.ServiceName*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceName
  nameWithType: ServiceBase.ServiceName
- uid: System.ServiceProcess.ServiceBase.Stop*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Stop
  nameWithType: ServiceBase.Stop
