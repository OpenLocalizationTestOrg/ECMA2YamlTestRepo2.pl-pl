### YamlMime:ManagedReference
items:
- uid: System.Collections.SortedList
  id: SortedList
  children:
  - System.Collections.SortedList.#ctor
  - System.Collections.SortedList.#ctor(System.Collections.IComparer)
  - System.Collections.SortedList.#ctor(System.Collections.IDictionary)
  - System.Collections.SortedList.#ctor(System.Int32)
  - System.Collections.SortedList.#ctor(System.Collections.IComparer,System.Int32)
  - System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)
  - System.Collections.SortedList.Add(System.Object,System.Object)
  - System.Collections.SortedList.Capacity
  - System.Collections.SortedList.Clear
  - System.Collections.SortedList.Clone
  - System.Collections.SortedList.Contains(System.Object)
  - System.Collections.SortedList.ContainsKey(System.Object)
  - System.Collections.SortedList.ContainsValue(System.Object)
  - System.Collections.SortedList.CopyTo(System.Array,System.Int32)
  - System.Collections.SortedList.Count
  - System.Collections.SortedList.GetByIndex(System.Int32)
  - System.Collections.SortedList.GetEnumerator
  - System.Collections.SortedList.GetKey(System.Int32)
  - System.Collections.SortedList.GetKeyList
  - System.Collections.SortedList.GetValueList
  - System.Collections.SortedList.IndexOfKey(System.Object)
  - System.Collections.SortedList.IndexOfValue(System.Object)
  - System.Collections.SortedList.IsFixedSize
  - System.Collections.SortedList.IsReadOnly
  - System.Collections.SortedList.IsSynchronized
  - System.Collections.SortedList.Item(System.Object)
  - System.Collections.SortedList.Keys
  - System.Collections.SortedList.Remove(System.Object)
  - System.Collections.SortedList.RemoveAt(System.Int32)
  - System.Collections.SortedList.SetByIndex(System.Int32,System.Object)
  - System.Collections.SortedList.Synchronized(System.Collections.SortedList)
  - System.Collections.SortedList.SyncRoot
  - System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator
  - System.Collections.SortedList.TrimToSize
  - System.Collections.SortedList.Values
  langs:
  - csharp
  name: SortedList
  nameWithType: SortedList
  fullName: System.Collections.SortedList
  type: Class
  summary: "Reprezentuje kolekcję par klucz/wartość, są sortowane według kluczy, które są dostępne za pomocą klucza i indeksu."
  remarks: "Ogólny wersję tej kolekcji zobacz <xref:System.Collections.Generic.SortedList%602?displayProperty=fullName>.</xref:System.Collections.Generic.SortedList%602?displayProperty=fullName>       Elementu SortedList jest możliwy za pomocą klucza, takich jak element w dowolnym <xref:System.Collections.IDictionary>implementacji lub jej indeks, takich jak element w dowolnym <xref:System.Collections.IList>implementacji.</xref:System.Collections.IList> </xref:System.Collections.IDictionary>       Obiekt SortedList wewnętrznie obsługuje dwie tablice do przechowywania elementów wykazu. oznacza to, co tablica kluczy i innej tablicy dla skojarzone wartości. Każdy element jest para klucza i wartości, które są dostępne <xref:System.Collections.DictionaryEntry>obiektu.</xref:System.Collections.DictionaryEntry> Klucz nie może być `null`, ale może być wartością.       Pojemność obiektu SortedList jest liczba elementów, które może przechowywać SortedList. Gdy elementy są dodawane do SortedList, pojemność jest automatycznie zwiększana co jest wymagane przez; Ponowna alokacja. Można zmniejszyć pojemność przez wywołanie metody <xref:System.Collections.SortedList.TrimToSize%2A>lub przez ustawienie <xref:System.Collections.SortedList.Capacity%2A>Właściwości jawnie.</xref:System.Collections.SortedList.Capacity%2A> </xref:System.Collections.SortedList.TrimToSize%2A>       W przypadku bardzo dużych obiektów SortedList może zwiększyć maksymalną pojemność do 2 miliardów elementów w 64-bitowym systemie ustawiając `enabled` atrybutu elementu konfiguracji, aby `true` w środowisku czasu wykonywania.       Elementy obiektu SortedList są sortowane według kluczy albo zgodnie z określonym <xref:System.Collections.IComparer>określone podczas tworzenia SortedList lub zgodnie z implementacją <xref:System.IComparable>implementacji pochodzącymi z samych kluczy.</xref:System.IComparable> </xref:System.Collections.IComparer> W obu przypadkach SortedList nie zezwala na zduplikowane klucze.       Sekwencja indeks jest oparty na kolejności sortowania. Po dodaniu elementu wstawieniu do SortedList w kolejności poprawne sortowania i indeksowanie odpowiednio można dostosować. Po usunięciu elementu indeksowanie również dostosowuje odpowiednio. W związku z tym indeks parę klucza i wartości określonych może zmieniać się jako elementy zostały dodane lub usunięte z obiektu SortedList.       Operacje na obiekcie SortedList często wykonywane wolniej niż operacje na <xref:System.Collections.Hashtable>obiektu z powodu sortowania.</xref:System.Collections.Hashtable> Jednak SortedList zapewnia większą elastyczność zezwalania na dostęp do wartości za pośrednictwem skojarzonych kluczy lub indeksy.       Elementy w tej kolekcji jest możliwy przy użyciu indeksu liczby całkowitej.  Indeksy w tej kolekcji jest liczony od zera.       `foreach` Instrukcji języka C# (`for each` w języku Visual Basic) zwraca obiekt typu elementów w kolekcji. Ponieważ każdy element obiektu SortedList parę klucz/wartość, typ elementu nie jest typu klucza lub typ wartości. Typ elementu jest raczej, <xref:System.Collections.DictionaryEntry>.</xref:System.Collections.DictionaryEntry> Na przykład: [!code-cpp [klasycznego SortedList przykład&#2;](~/add/codesnippet/cpp/t-system.collections.sor_1.cpp)][!code-cs[klasycznego SortedList przykład&#2;](~/add/codesnippet/csharp/t-system.collections.sor_1.cs)][!code-vb[klasycznego SortedList przykład&#2;](~/add/codesnippet/visualbasic/t-system.collections.sor_1.vb) ] `foreach` instrukcja jest otokę moduł wyliczający, który umożliwia odczyt tylko z bez zapisywania do kolekcji.    "
  example:
  - "The following code example shows how to create and initialize a SortedList object and how to print out its keys and values.  \n  \n [!code-cpp[Classic SortedList Example#1](~/add/codesnippet/cpp/t-system.collections.sor_2.cpp)]\n [!code-cs[Classic SortedList Example#1](~/add/codesnippet/csharp/t-system.collections.sor_2.cs)]\n [!code-vb[Classic SortedList Example#1](~/add/codesnippet/visualbasic/t-system.collections.sor_2.vb)]"
  syntax:
    content: >-
      [System.Diagnostics.DebuggerDisplay("Count = {Count}")]

      [System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.SortedList/SortedListDebugView))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public class SortedList : ICloneable, System.Collections.IDictionary
  inheritance:
  - System.Object
  implements:
  - System.Collections.IDictionary
  - System.ICloneable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Collections.SortedList.#ctor
  id: '#ctor'
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: SortedList()
  nameWithType: SortedList.SortedList()
  fullName: System.Collections.SortedList.SortedList()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Collections.SortedList&quot;> </xref> klasy, która jest pusta, ma domyślne początkowa pojemność i jest sortowana według <xref:System.IComparable>interfejsu implementowanego przez każdy klucz dodane do <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu.</xref:System.IComparable>"
  remarks: "Każdy klucz musi implementować <xref:System.IComparable>interfejsu, aby umożliwiać porównania z każdym innym kluczem w <xref:System.Collections.SortedList>obiektu.</xref:System.Collections.SortedList> </xref:System.IComparable> Elementy są sortowane według <xref:System.IComparable>implementacji każdy klucz dodane do <xref:System.Collections.SortedList>.</xref:System.Collections.SortedList> </xref:System.IComparable>       Pojemność <xref:System.Collections.SortedList>obiekt jest liczba elementów który <xref:System.Collections.SortedList>może pomieścić.</xref:System.Collections.SortedList> </xref:System.Collections.SortedList> Po dodaniu elementów do <xref:System.Collections.SortedList>, automatycznie zostaje zwiększona wydajność zgodnie z żądaniem ponowne przydzielanie tablicy wewnętrznej.</xref:System.Collections.SortedList>       Jeśli rozmiar kolekcji można oszacować, określając początkowa pojemność eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.SortedList>obiektu.</xref:System.Collections.SortedList>       Ten konstruktor jest operacją O(1)."
  example:
  - "The following code example creates collections using different <xref:System.Collections.SortedList> constructors and demonstrates the differences in the behavior of the collections.  \n  \n [!code-cs[System.Collections.SortedList_ctor#1](~/add/codesnippet/csharp/m-system.collections.sor_7_1.cs)]\n [!code-vb[System.Collections.SortedList_ctor#1](~/add/codesnippet/visualbasic/m-system.collections.sor_7_1.vb)]\n [!code-cpp[System.Collections.SortedList_ctor#1](~/add/codesnippet/cpp/m-system.collections.sor_7_1.cpp)]"
  syntax:
    content: public SortedList ();
    parameters: []
  overload: System.Collections.SortedList.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.SortedList.#ctor(System.Collections.IComparer)
  id: '#ctor(System.Collections.IComparer)'
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: SortedList(IComparer)
  nameWithType: SortedList.SortedList(IComparer)
  fullName: System.Collections.SortedList.SortedList(IComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Collections.SortedList&quot;> </xref> klasy, która jest pusta, ma domyślne początkowa pojemność i jest sortowana według określonego <xref:System.Collections.IComparer>interfejsu.</xref:System.Collections.IComparer>"
  remarks: "Elementy są sortowane według określonego <xref:System.Collections.IComparer>implementacji.</xref:System.Collections.IComparer> Jeśli `comparer` parametr jest `null`, <xref:System.IComparable>stosowania dla każdego klucza jest używany; w związku z tym każdy klucz musi implementować <xref:System.IComparable>interfejsu, aby umożliwiać porównania z każdym innym kluczem w <xref:System.Collections.SortedList>obiektu.</xref:System.Collections.SortedList> </xref:System.IComparable> </xref:System.IComparable>       Pojemność <xref:System.Collections.SortedList>obiekt jest liczba elementów który <xref:System.Collections.SortedList>może pomieścić.</xref:System.Collections.SortedList> </xref:System.Collections.SortedList> Po dodaniu elementów do <xref:System.Collections.SortedList>, automatycznie zostaje zwiększona wydajność zgodnie z żądaniem ponowne przydzielanie tablicy wewnętrznej.</xref:System.Collections.SortedList>       Jeśli rozmiar kolekcji można oszacować, określając początkowa pojemność eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.SortedList>obiektu.</xref:System.Collections.SortedList>       Ten konstruktor jest operacją O(1)."
  example:
  - "The following code example creates collections using different <xref:System.Collections.SortedList> constructors and demonstrates the differences in the behavior of the collections.  \n  \n [!code-cs[System.Collections.SortedList_ctor#1](~/add/codesnippet/csharp/m-system.collections.sor_18_1.cs)]\n [!code-vb[System.Collections.SortedList_ctor#1](~/add/codesnippet/visualbasic/m-system.collections.sor_18_1.vb)]\n [!code-cpp[System.Collections.SortedList_ctor#1](~/add/codesnippet/cpp/m-system.collections.sor_18_1.cpp)]"
  syntax:
    content: public SortedList (System.Collections.IComparer comparer);
    parameters:
    - id: comparer
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>Implementacji do używania przy porównywaniu kluczy.</xref:System.Collections.IComparer>       - lub - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> do używania <xref:System.IComparable>stosowania dla każdego klucza.</xref:System.IComparable>"
  overload: System.Collections.SortedList.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.SortedList.#ctor(System.Collections.IDictionary)
  id: '#ctor(System.Collections.IDictionary)'
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: SortedList(IDictionary)
  nameWithType: SortedList.SortedList(IDictionary)
  fullName: System.Collections.SortedList.SortedList(IDictionary)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Collections.SortedList&quot;> </xref> klasę, która zawiera elementów kopiowanych z określonego słownika ma tego samego początkowej pojemności niż liczba elementów kopiowanych i jest sortowana według <xref:System.IComparable>interfejsu implementowanego przez każdego klucza.</xref:System.IComparable>"
  remarks: "Każdy klucz musi implementować <xref:System.IComparable>interfejsu, aby umożliwiać porównania z każdym innym kluczem w <xref:System.Collections.SortedList>obiektu.</xref:System.Collections.SortedList> </xref:System.IComparable> Elementy są sortowane według <xref:System.IComparable>implementacji każdy klucz dodane do <xref:System.Collections.SortedList>.</xref:System.Collections.SortedList> </xref:System.IComparable>       A <xref:System.Collections.Hashtable>obiekt jest przykładem <xref:System.Collections.IDictionary>implementacji, które mogą zostać przekazane do tego konstruktora.</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable> Nowy <xref:System.Collections.SortedList>obiekt zawiera kopię klucze i wartości przechowywane w <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> </xref:System.Collections.SortedList>       Pojemność <xref:System.Collections.SortedList>obiekt jest liczba elementów który <xref:System.Collections.SortedList>może pomieścić.</xref:System.Collections.SortedList> </xref:System.Collections.SortedList> Po dodaniu elementów do <xref:System.Collections.SortedList>, automatycznie zostaje zwiększona wydajność zgodnie z żądaniem ponowne przydzielanie tablicy wewnętrznej.</xref:System.Collections.SortedList>       Jeśli rozmiar kolekcji można oszacować, określając początkowa pojemność eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.SortedList>obiektu.</xref:System.Collections.SortedList>       Ten konstruktor jest O (`n`) operację, której `n` jest liczba elementów w `d`."
  example:
  - "The following code example creates collections using different <xref:System.Collections.SortedList> constructors and demonstrates the differences in the behavior of the collections.  \n  \n [!code-cpp[System.Collections.SortedList_ctorDictionary#1](~/add/codesnippet/cpp/m-system.collections.sor_9_1.cpp)]\n [!code-vb[System.Collections.SortedList_ctorDictionary#1](~/add/codesnippet/visualbasic/m-system.collections.sor_9_1.vb)]\n [!code-cs[System.Collections.SortedList_ctorDictionary#1](~/add/codesnippet/csharp/m-system.collections.sor_9_1.cs)]"
  syntax:
    content: public SortedList (System.Collections.IDictionary d);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>Implementacji, aby skopiować do nowego <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu.</xref:System.Collections.IDictionary>"
  overload: System.Collections.SortedList.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "Co najmniej jeden element w <code> d </code> nie implementują <xref:System.IComparable>interfejsu.</xref:System.IComparable>"
  platform:
  - net462
- uid: System.Collections.SortedList.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: SortedList(Int32)
  nameWithType: SortedList.SortedList(Int32)
  fullName: System.Collections.SortedList.SortedList(Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Collections.SortedList&quot;> </xref> klasy, która jest pusta, ma określony początkowa pojemność i jest sortowana według <xref:System.IComparable>interfejsu implementowanego przez każdy klucz dodane do <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu.</xref:System.IComparable>"
  remarks: "Każdy klucz musi implementować <xref:System.IComparable>interfejsu, aby umożliwiać porównania z każdym innym kluczem w <xref:System.Collections.SortedList>obiektu.</xref:System.Collections.SortedList> </xref:System.IComparable> Elementy są sortowane według <xref:System.IComparable>implementacji każdy klucz dodane do <xref:System.Collections.SortedList>.</xref:System.Collections.SortedList> </xref:System.IComparable>       Pojemność <xref:System.Collections.SortedList>obiekt jest liczba elementów który <xref:System.Collections.SortedList>może pomieścić.</xref:System.Collections.SortedList> </xref:System.Collections.SortedList> Po dodaniu elementów do <xref:System.Collections.SortedList>, automatycznie zostaje zwiększona wydajność zgodnie z żądaniem ponowne przydzielanie tablicy wewnętrznej.</xref:System.Collections.SortedList>       Jeśli rozmiar kolekcji można oszacować, określając początkowa pojemność eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.SortedList>obiektu.</xref:System.Collections.SortedList>       Ten konstruktor jest O (`n`) operację, której `n` jest `initialCapacity`."
  example:
  - "The following code example creates collections using different <xref:System.Collections.SortedList> constructors and demonstrates the differences in the behavior of the collections.  \n  \n [!code-cs[System.Collections.SortedList_ctorInt#1](~/add/codesnippet/csharp/m-system.collections.sor_15_1.cs)]\n [!code-vb[System.Collections.SortedList_ctorInt#1](~/add/codesnippet/visualbasic/m-system.collections.sor_15_1.vb)]\n [!code-cpp[System.Collections.SortedList_ctorInt#1](~/add/codesnippet/cpp/m-system.collections.sor_15_1.cpp)]"
  syntax:
    content: public SortedList (int initialCapacity);
    parameters:
    - id: initialCapacity
      type: System.Int32
      description: "Początkowa liczba elementów który <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiekt może zawierać."
  overload: System.Collections.SortedList.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>initialCapacity</code>jest mniejsza od zera."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma dostatecznej ilości dostępnej pamięci, aby utworzyć <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu z określonym <code> initialCapacity </code>."
  platform:
  - net462
- uid: System.Collections.SortedList.#ctor(System.Collections.IComparer,System.Int32)
  id: '#ctor(System.Collections.IComparer,System.Int32)'
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: SortedList(IComparer,Int32)
  nameWithType: SortedList.SortedList(IComparer,Int32)
  fullName: System.Collections.SortedList.SortedList(IComparer,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Collections.SortedList&quot;> </xref> klasy, która jest pusta, ma określony początkowa pojemność i jest sortowana według określonego <xref:System.Collections.IComparer>interfejsu.</xref:System.Collections.IComparer>"
  remarks: "Elementy są sortowane według określonego <xref:System.Collections.IComparer>implementacji.</xref:System.Collections.IComparer> Jeśli `comparer` parametr jest `null`, <xref:System.IComparable>stosowania dla każdego klucza jest używany; w związku z tym każdy klucz musi implementować <xref:System.IComparable>interfejsu, aby umożliwiać porównania z każdym innym kluczem w <xref:System.Collections.SortedList>obiektu.</xref:System.Collections.SortedList> </xref:System.IComparable> </xref:System.IComparable>       Pojemność <xref:System.Collections.SortedList>obiekt jest liczba elementów który <xref:System.Collections.SortedList>może pomieścić.</xref:System.Collections.SortedList> </xref:System.Collections.SortedList> Po dodaniu elementów do <xref:System.Collections.SortedList>, automatycznie zostaje zwiększona wydajność zgodnie z żądaniem ponowne przydzielanie tablicy wewnętrznej.</xref:System.Collections.SortedList>       Jeśli rozmiar kolekcji można oszacować, określając początkowa pojemność eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.SortedList>obiektu.</xref:System.Collections.SortedList>       Ten konstruktor jest O (`n`) operację, której `n` jest `capacity`."
  example:
  - "The following code example creates collections using different <xref:System.Collections.SortedList> constructors and demonstrates the differences in the behavior of the collections.  \n  \n [!code-cs[System.Collections.SortedList_ctorInt#1](~/add/codesnippet/csharp/1806b376-56fc-45e2-aff7-_1.cs)]\n [!code-vb[System.Collections.SortedList_ctorInt#1](~/add/codesnippet/visualbasic/1806b376-56fc-45e2-aff7-_1.vb)]\n [!code-cpp[System.Collections.SortedList_ctorInt#1](~/add/codesnippet/cpp/1806b376-56fc-45e2-aff7-_1.cpp)]"
  syntax:
    content: public SortedList (System.Collections.IComparer comparer, int capacity);
    parameters:
    - id: comparer
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>Implementacji do używania przy porównywaniu kluczy.</xref:System.Collections.IComparer>       - lub - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> do używania <xref:System.IComparable>stosowania dla każdego klucza.</xref:System.IComparable>"
    - id: capacity
      type: System.Int32
      description: "Początkowa liczba elementów który <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiekt może zawierać."
  overload: System.Collections.SortedList.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>jest mniejsza od zera."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma dostatecznej ilości dostępnej pamięci, aby utworzyć <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu z określonym <code> capacity </code>."
  platform:
  - net462
- uid: System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)
  id: '#ctor(System.Collections.IDictionary,System.Collections.IComparer)'
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: SortedList(IDictionary,IComparer)
  nameWithType: SortedList.SortedList(IDictionary,IComparer)
  fullName: System.Collections.SortedList.SortedList(IDictionary,IComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Collections.SortedList&quot;> </xref> klasę, która zawiera elementów kopiowanych z określonego słownika ma tego samego początkowej pojemności niż liczba elementów kopiowanych i jest sortowana według określonego <xref:System.Collections.IComparer>interfejsu.</xref:System.Collections.IComparer>"
  remarks: "Elementy są sortowane według określonego <xref:System.Collections.IComparer>implementacji.</xref:System.Collections.IComparer> Jeśli `comparer` parametr jest `null`, <xref:System.IComparable>stosowania dla każdego klucza jest używany; w związku z tym każdy klucz musi implementować <xref:System.IComparable>interfejsu, aby umożliwiać porównania z każdym innym kluczem w <xref:System.Collections.SortedList>obiektu.</xref:System.Collections.SortedList> </xref:System.IComparable> </xref:System.IComparable>       A <xref:System.Collections.Hashtable>obiekt jest przykładem <xref:System.Collections.IDictionary>implementacji, które mogą zostać przekazane do tego konstruktora.</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable> Nowy <xref:System.Collections.SortedList>obiekt zawiera kopię klucze i wartości przechowywane w <xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> </xref:System.Collections.SortedList>       Pojemność <xref:System.Collections.SortedList>obiekt jest liczba elementów który <xref:System.Collections.SortedList>może pomieścić.</xref:System.Collections.SortedList> </xref:System.Collections.SortedList> Po dodaniu elementów do <xref:System.Collections.SortedList>, automatycznie zostaje zwiększona wydajność zgodnie z żądaniem ponowne przydzielanie tablicy wewnętrznej.</xref:System.Collections.SortedList>       Jeśli rozmiar kolekcji można oszacować, określając początkowa pojemność eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.SortedList>obiektu.</xref:System.Collections.SortedList>       Ten konstruktor jest O (`n`) operację, której `n` jest liczba elementów w `d`."
  example:
  - "The following code example creates collections using different <xref:System.Collections.SortedList> constructors and demonstrates the differences in the behavior of the collections.  \n  \n [!code-cpp[System.Collections.SortedList_ctorDictionary#1](~/add/codesnippet/cpp/653e16d8-524e-4544-8674-_1.cpp)]\n [!code-vb[System.Collections.SortedList_ctorDictionary#1](~/add/codesnippet/visualbasic/653e16d8-524e-4544-8674-_1.vb)]\n [!code-cs[System.Collections.SortedList_ctorDictionary#1](~/add/codesnippet/csharp/653e16d8-524e-4544-8674-_1.cs)]"
  syntax:
    content: public SortedList (System.Collections.IDictionary d, System.Collections.IComparer comparer);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>Implementacji, aby skopiować do nowego <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu.</xref:System.Collections.IDictionary>"
    - id: comparer
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>Implementacji do używania przy porównywaniu kluczy.</xref:System.Collections.IComparer>       - lub - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> do używania <xref:System.IComparable>stosowania dla każdego klucza.</xref:System.IComparable>"
  overload: System.Collections.SortedList.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "<code>comparer</code>jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>i co najmniej jeden element w <code>d</code> nie implementują <xref:System.IComparable> interfejsu."
  platform:
  - net462
- uid: System.Collections.SortedList.Add(System.Object,System.Object)
  id: Add(System.Object,System.Object)
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: Add(Object,Object)
  nameWithType: SortedList.Add(Object,Object)
  fullName: System.Collections.SortedList.Add(Object,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Dodaje element z określonym kluczem i wartością do <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  remarks: "Punkt wstawiania jest określana oparte na porównania zaznaczone, jawnie lub domyślnie, gdy <xref:System.Collections.SortedList>obiekt został utworzony.</xref:System.Collections.SortedList>       Jeśli <xref:System.Collections.SortedList.Count%2A>jest już równa <xref:System.Collections.SortedList.Capacity%2A>, pojemność <xref:System.Collections.SortedList>obiektu zwiększa się o automatyczne ponowne przydzielanie tablicy wewnętrznej, a istniejące elementy są kopiowane do nowej tablicy przed dodaniem nowego elementu.</xref:System.Collections.SortedList> </xref:System.Collections.SortedList.Capacity%2A> </xref:System.Collections.SortedList.Count%2A>       Można również użyć <xref:System.Collections.SortedList.Item%2A>Właściwości, aby dodać nowe elementy za pomocą ustawienia wartości klucza, który nie istnieje w <xref:System.Collections.SortedList>obiektu (na przykład `myCollection[&quot;myNonexistentKey&quot;] = myValue`).</xref:System.Collections.SortedList> </xref:System.Collections.SortedList.Item%2A> Jednak jeśli określony klucz już istnieje w <xref:System.Collections.SortedList>, ustawienie <xref:System.Collections.SortedList.Item%2A>stara wartość jest zastąpienie właściwości.</xref:System.Collections.SortedList.Item%2A> </xref:System.Collections.SortedList> Z kolei metody Add nie modyfikuje istniejące elementy.       Elementy <xref:System.Collections.SortedList>obiektu są sortowane według kluczy albo zgodnie z określonym <xref:System.Collections.IComparer>implementacji określone podczas <xref:System.Collections.SortedList>został utworzony lub zgodnie z do <xref:System.IComparable>implementacji pochodzącymi z samych kluczy.</xref:System.IComparable> </xref:System.Collections.SortedList> </xref:System.Collections.IComparer> </xref:System.Collections.SortedList>       Klucz nie może być `null`, ale może być wartością.       Ta metoda jest O (`n`) operacji nieposortowane danych, gdzie `n` <xref:System.Collections.SortedList.Count%2A>.</xref:System.Collections.SortedList.Count%2A> Jest O (dziennika `n`) operacji, jeśli nowy element zostanie dodany na końcu listy. Jeśli wstawiania powoduje, że zmiany rozmiaru, operacja jest O (`n`)."
  example:
  - "The following code example shows how to add elements to a <xref:System.Collections.SortedList> object.  \n  \n [!code-cpp[Classic SortedList.Add Example#1](~/add/codesnippet/cpp/m-system.collections.sor_4_1.cpp)]\n [!code-vb[Classic SortedList.Add Example#1](~/add/codesnippet/visualbasic/m-system.collections.sor_4_1.vb)]\n [!code-cs[Classic SortedList.Add Example#1](~/add/codesnippet/csharp/m-system.collections.sor_4_1.cs)]"
  syntax:
    content: public virtual void Add (object key, object value);
    parameters:
    - id: key
      type: System.Object
      description: "Klucz elementu do dodania."
    - id: value
      type: System.Object
      description: "Wartość elementu do dodania. Wartość może być <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.SortedList.Add*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Element z określonym <code> key </code> już istnieje w <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu.       - lub - <xref href=&quot;System.Collections.SortedList&quot;> </xref> jest skonfigurowany do używania <xref:System.IComparable>interfejsu i <code> key </code> nie implementuje <xref:System.IComparable>interfejsu.</xref:System.IComparable> </xref:System.IComparable>"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.SortedList&quot;> </xref> Jest tylko do odczytu.       - lub - <xref href=&quot;System.Collections.SortedList&quot;> </xref> ma stały rozmiar."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma dostatecznej ilości dostępnej pamięci, aby dodać element do <xref href=&quot;System.Collections.SortedList&quot;> </xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Moduł porównujący zgłasza wyjątek."
  platform:
  - net462
- uid: System.Collections.SortedList.Capacity
  id: Capacity
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: Capacity
  nameWithType: SortedList.Capacity
  fullName: System.Collections.SortedList.Capacity
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Pobiera lub ustawia pojemność <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  remarks: "Liczba elementów jest pojemność który <xref:System.Collections.SortedList>mogą być przechowywane przez obiekt.</xref:System.Collections.SortedList> <xref:System.Collections.SortedList.Count%2A>jest to liczba elementów, które są rzeczywiście <xref:System.Collections.SortedList>.</xref:System.Collections.SortedList></xref:System.Collections.SortedList.Count%2A>       Pojemność zawsze jest większa niż lub równa <xref:System.Collections.SortedList.Count%2A>.</xref:System.Collections.SortedList.Count%2A> Jeśli <xref:System.Collections.SortedList.Count%2A>przekracza pojemność podczas dodawania elementów, pojemność jest automatycznie zwiększany o ponowne przydzielanie tablicy wewnętrznej przed skopiowaniem starych elementów i dodawanie nowych elementów.</xref:System.Collections.SortedList.Count%2A>       Można zmniejszyć pojemność przez wywołanie metody <xref:System.Collections.SortedList.TrimToSize%2A>lub przez ustawienie właściwości pojemności jawnie.</xref:System.Collections.SortedList.TrimToSize%2A> Jawnie ustawionej wartości pojemności tablicy wewnętrznej jest również przydzielić, aby zmieścił się w określonej pojemności.       Pobieranie wartości tej właściwości jest operacją O(1); Ustawienie właściwości jest O (`n`) operację, której `n` jest nowego miejsca."
  syntax:
    content: public virtual int Capacity { get; set; }
    return:
      type: System.Int32
      description: "Liczba elementów który <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiekt może zawierać."
  overload: System.Collections.SortedList.Capacity*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Wartość przypisana jest mniejsza niż bieżąca liczba elementów w <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie istnieje wystarczająca ilość pamięci dostępna w systemie."
  platform:
  - net462
- uid: System.Collections.SortedList.Clear
  id: Clear
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: Clear()
  nameWithType: SortedList.Clear()
  fullName: System.Collections.SortedList.Clear()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Usuwa wszystkie elementy z <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  remarks: "<xref:System.Collections.SortedList.Count%2A>zostaje ustawiony na zero, a ponadto są również zwalniane odwołania do innych obiektów z elementów kolekcji.</xref:System.Collections.SortedList.Count%2A>       <xref:System.Collections.SortedList.Capacity%2A>pozostaje niezmieniona.</xref:System.Collections.SortedList.Capacity%2A> Aby zresetować pojemność <xref:System.Collections.SortedList>obiekt, należy wywołać <xref:System.Collections.SortedList.TrimToSize%2A>lub ustaw <xref:System.Collections.SortedList.Capacity%2A>właściwości bezpośrednio.</xref:System.Collections.SortedList.Capacity%2A> </xref:System.Collections.SortedList.TrimToSize%2A> </xref:System.Collections.SortedList> Przycinanie pustą <xref:System.Collections.SortedList>Ustawia pojemność <xref:System.Collections.SortedList>do wydajności domyślnej.</xref:System.Collections.SortedList> </xref:System.Collections.SortedList>       Ta metoda jest O (`n`) operację, której `n` <xref:System.Collections.SortedList.Count%2A>.</xref:System.Collections.SortedList.Count%2A>"
  example:
  - "The following code example shows how to trim the unused portions of a <xref:System.Collections.SortedList> object and how to clear the values of the <xref:System.Collections.SortedList>.  \n  \n [!code-cpp[Classic SortedList.Clear Example#1](~/add/codesnippet/cpp/m-system.collections.sor_14_1.cpp)]\n [!code-cs[Classic SortedList.Clear Example#1](~/add/codesnippet/csharp/m-system.collections.sor_14_1.cs)]\n [!code-vb[Classic SortedList.Clear Example#1](~/add/codesnippet/visualbasic/m-system.collections.sor_14_1.vb)]"
  syntax:
    content: public virtual void Clear ();
    parameters: []
  overload: System.Collections.SortedList.Clear*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.SortedList&quot;> </xref> Obiekt jest tylko do odczytu.       - lub - <xref href=&quot;System.Collections.SortedList&quot;> </xref> ma stały rozmiar."
  platform:
  - net462
- uid: System.Collections.SortedList.Clone
  id: Clone
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: Clone()
  nameWithType: SortedList.Clone()
  fullName: System.Collections.SortedList.Clone()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Tworzy kopię pobieżną <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  remarks: "Kopię pobieżną kolekcji kopiuje elementy kolekcji, czy są one typy odwołań lub wartość typów, ale nie kopiuje obiektów, które dotyczą odwołania. Odwołania do nowej kolekcji wskazują te same obiekty, które wskazują odwołania w oryginalnej kolekcji.       Z kolei głęboką kopię kolekcji kopiuje elementy i wszystkich bezpośrednio lub pośrednio odwołuje się elementów.       Ta metoda jest O (`n`) operację, której `n` <xref:System.Collections.SortedList.Count%2A>.</xref:System.Collections.SortedList.Count%2A>"
  syntax:
    content: public virtual object Clone ();
    parameters: []
    return:
      type: System.Object
      description: "Kopia pobieżna <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  overload: System.Collections.SortedList.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.SortedList.Contains(System.Object)
  id: Contains(System.Object)
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: Contains(Object)
  nameWithType: SortedList.Contains(Object)
  fullName: System.Collections.SortedList.Contains(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Określa, czy <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu zawiera określony klucz."
  remarks: "Elementy <xref:System.Collections.SortedList>obiektu są sortowane według kluczy albo zgodnie z określonym <xref:System.Collections.IComparer>implementacji określone podczas <xref:System.Collections.SortedList>został utworzony lub zgodnie z do <xref:System.IComparable>implementacji pochodzącymi z samych kluczy.</xref:System.IComparable> </xref:System.Collections.SortedList> </xref:System.Collections.IComparer> </xref:System.Collections.SortedList>       Zawiera implementuje <xref:System.Collections.IDictionary.Contains%2A?displayProperty=fullName>.</xref:System.Collections.IDictionary.Contains%2A?displayProperty=fullName> Zachowuje się dokładnie jako <xref:System.Collections.SortedList.ContainsKey%2A>.</xref:System.Collections.SortedList.ContainsKey%2A>       Ta metoda używa algorytmu wyszukiwania binarne; w związku z tym ta metoda jest O (dziennika `n`) operację, której `n` <xref:System.Collections.SortedList.Count%2A>.</xref:System.Collections.SortedList.Count%2A>       Począwszy od programu .NET Framework 2.0, ta metoda używa kolekcji obiektów <xref:System.Object.Equals%2A>i <xref:System.IComparable.CompareTo%2A>metody `item` ustalenie, czy element istnieje.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> We wcześniejszych wersjach programu .NET Framework, oznaczanie został utworzony przy użyciu <xref:System.Object.Equals%2A>i <xref:System.IComparable.CompareTo%2A>metody `item` parametrów dla obiektów w kolekcji.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  example:
  - "The following code example shows how to determine whether a <xref:System.Collections.SortedList> object contains a specific element.  \n  \n [!code-cs[Classic SortedList.Contains Example#1](~/add/codesnippet/csharp/m-system.collections.sor_12_1.cs)]\n [!code-cpp[Classic SortedList.Contains Example#1](~/add/codesnippet/cpp/m-system.collections.sor_12_1.cpp)]\n [!code-vb[Classic SortedList.Contains Example#1](~/add/codesnippet/visualbasic/m-system.collections.sor_12_1.vb)]"
  syntax:
    content: public virtual bool Contains (object key);
    parameters:
    - id: key
      type: System.Object
      description: "Klucz do zlokalizowania w <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli <xref href=&quot;System.Collections.SortedList&quot;> </xref> zawiera element z określonym <code> key </code>; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.SortedList.Contains*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Moduł porównujący zgłasza wyjątek."
  platform:
  - net462
- uid: System.Collections.SortedList.ContainsKey(System.Object)
  id: ContainsKey(System.Object)
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: ContainsKey(Object)
  nameWithType: SortedList.ContainsKey(Object)
  fullName: System.Collections.SortedList.ContainsKey(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Określa, czy <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu zawiera określony klucz."
  remarks: "Elementy <xref:System.Collections.SortedList>obiektu są sortowane według kluczy albo zgodnie z określonym <xref:System.Collections.IComparer>implementacji określone podczas <xref:System.Collections.SortedList>został utworzony lub zgodnie z do <xref:System.IComparable>implementacji pochodzącymi z samych kluczy.</xref:System.IComparable> </xref:System.Collections.SortedList> </xref:System.Collections.IComparer> </xref:System.Collections.SortedList>       Ta metoda działa dokładnie jako <xref:System.Collections.SortedList.Contains%2A>metody.</xref:System.Collections.SortedList.Contains%2A>       Ta metoda używa algorytmu wyszukiwania binarne; w związku z tym ta metoda jest O (dziennika `n`) operację, której `n` <xref:System.Collections.SortedList.Count%2A>.</xref:System.Collections.SortedList.Count%2A>       Począwszy od programu .NET Framework 2.0, ta metoda używa kolekcji obiektów <xref:System.Object.Equals%2A>i <xref:System.IComparable.CompareTo%2A>metody `item` ustalenie, czy element istnieje.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> We wcześniejszych wersjach programu .NET Framework, oznaczanie został utworzony przy użyciu <xref:System.Object.Equals%2A>i <xref:System.IComparable.CompareTo%2A>metody `item` parametrów dla obiektów w kolekcji.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  example:
  - "The following code example shows how to determine whether a <xref:System.Collections.SortedList> object contains a specific element.  \n  \n [!code-cs[Classic SortedList.Contains Example#1](~/add/codesnippet/csharp/m-system.collections.sor_16_1.cs)]\n [!code-cpp[Classic SortedList.Contains Example#1](~/add/codesnippet/cpp/m-system.collections.sor_16_1.cpp)]\n [!code-vb[Classic SortedList.Contains Example#1](~/add/codesnippet/visualbasic/m-system.collections.sor_16_1.vb)]"
  syntax:
    content: public virtual bool ContainsKey (object key);
    parameters:
    - id: key
      type: System.Object
      description: "Klucz do zlokalizowania w <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli <xref href=&quot;System.Collections.SortedList&quot;> </xref> zawiera element z określonym <code> key </code>; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.SortedList.ContainsKey*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Moduł porównujący zgłasza wyjątek."
  platform:
  - net462
- uid: System.Collections.SortedList.ContainsValue(System.Object)
  id: ContainsValue(System.Object)
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: ContainsValue(Object)
  nameWithType: SortedList.ContainsValue(Object)
  fullName: System.Collections.SortedList.ContainsValue(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Określa, czy <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu zawiera określoną wartość."
  remarks: "Wartości elementów <xref:System.Collections.SortedList>obiektu są porównywane przy użyciu określonej wartości <xref:System.Object.Equals%2A>metody.</xref:System.Object.Equals%2A> </xref:System.Collections.SortedList>       Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym jest proporcjonalny do <xref:System.Collections.SortedList.Count%2A>.</xref:System.Collections.SortedList.Count%2A> Średni czas wykonania Ta metoda jest O (`n`) operację, której `n` <xref:System.Collections.SortedList.Count%2A>.</xref:System.Collections.SortedList.Count%2A>       Począwszy od programu .NET Framework 2.0, ta metoda używa kolekcji obiektów <xref:System.Object.Equals%2A>i <xref:System.IComparable.CompareTo%2A>metody `item` ustalenie, czy element istnieje.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> We wcześniejszych wersjach programu .NET Framework, oznaczanie został utworzony przy użyciu <xref:System.Object.Equals%2A>i <xref:System.IComparable.CompareTo%2A>metody `item` parametrów dla obiektów w kolekcji.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  example:
  - "The following code example shows how to determine whether a <xref:System.Collections.SortedList> object contains a specific element.  \n  \n [!code-cs[Classic SortedList.Contains Example#1](~/add/codesnippet/csharp/m-system.collections.sor_0_1.cs)]\n [!code-cpp[Classic SortedList.Contains Example#1](~/add/codesnippet/cpp/m-system.collections.sor_0_1.cpp)]\n [!code-vb[Classic SortedList.Contains Example#1](~/add/codesnippet/visualbasic/m-system.collections.sor_0_1.vb)]"
  syntax:
    content: public virtual bool ContainsValue (object value);
    parameters:
    - id: value
      type: System.Object
      description: "Wartość do zlokalizowania w <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu. Wartość może być <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli <xref href=&quot;System.Collections.SortedList&quot;> </xref> zawiera element z określonym <code> value </code>; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.SortedList.ContainsValue*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.SortedList.CopyTo(System.Array,System.Int32)
  id: CopyTo(System.Array,System.Int32)
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: CopyTo(Array,Int32)
  nameWithType: SortedList.CopyTo(Array,Int32)
  fullName: System.Collections.SortedList.CopyTo(Array,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Kopie <xref href=&quot;System.Collections.SortedList&quot;> </xref> elementów na jednowymiarowe <xref:System.Array>obiektu, zaczynając od określonego indeksu tablicy.</xref:System.Array>"
  remarks: "Pary klucz wartość są kopiowane do <xref:System.Array>obiektu w tej samej kolejności, w której moduł wyliczający iteruje <xref:System.Collections.SortedList>obiektu.</xref:System.Collections.SortedList> </xref:System.Array>       Aby skopiować tylko klucze w <xref:System.Collections.SortedList>, użyj `SortedList.Keys.CopyTo`.</xref:System.Collections.SortedList>       Aby skopiować tylko wartości w <xref:System.Collections.SortedList>, użyj `SortedList.Values.CopyTo`.</xref:System.Collections.SortedList>       Ta metoda jest O (`n`) operację, której `n` <xref:System.Collections.SortedList.Count%2A>.</xref:System.Collections.SortedList.Count%2A>"
  example:
  - "The following code example shows how to copy the values in a <xref:System.Collections.SortedList> object into a one-dimensional <xref:System.Array> object.  \n  \n [!code-cs[Classic SortedList.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.sor_20_1.cs)]\n [!code-cpp[Classic SortedList.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.sor_20_1.cpp)]\n [!code-vb[Classic SortedList.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.sor_20_1.vb)]"
  syntax:
    content: public virtual void CopyTo (Array array, int arrayIndex);
    parameters:
    - id: array
      type: System.Array
      description: "Jednowymiarowa <xref:System.Array>obiekt, który jest miejscem docelowym <xref:System.Collections.DictionaryEntry>obiektów kopiowanych ze <xref href=&quot;System.Collections.SortedList&quot;> </xref>.</xref:System.Collections.DictionaryEntry> </xref:System.Array> <xref:System.Array>Musi mieć indeksowania liczony od zera.</xref:System.Array>"
    - id: arrayIndex
      type: System.Int32
      description: "Liczony od zera indeks w `array` od rozpoczyna się kopiowanie które."
  overload: System.Collections.SortedList.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>arrayIndex</code>jest mniejsza od zera."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>jest wielowymiarowy.       - lub - liczba elementów w źródle <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu jest większa niż dostępne miejsce od <code>arrayIndex</code> do końca tablicy docelowej <code>array</code>."
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "Typ źródła <xref href=&quot;System.Collections.SortedList&quot;> </xref> nie można automatycznie rzutować na typ docelowy <code> array </code>."
  platform:
  - net462
- uid: System.Collections.SortedList.Count
  id: Count
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: Count
  nameWithType: SortedList.Count
  fullName: System.Collections.SortedList.Count
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Pobiera liczbę elementów zawartych w <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  remarks: "Każdy element jest para klucza i wartości, które są dostępne <xref:System.Collections.DictionaryEntry>obiektu.</xref:System.Collections.DictionaryEntry>       <xref:System.Collections.SortedList.Capacity%2A>Liczba elementów jest który <xref:System.Collections.SortedList>obiekt może przechowywać.</xref:System.Collections.SortedList></xref:System.Collections.SortedList.Capacity%2A> Liczba jest liczba elementów, które są rzeczywiście <xref:System.Collections.SortedList>.</xref:System.Collections.SortedList>       <xref:System.Collections.SortedList.Capacity%2A>zawsze jest większa lub równa wartości Count.</xref:System.Collections.SortedList.Capacity%2A> Jeżeli liczba przekracza <xref:System.Collections.SortedList.Capacity%2A>podczas dodawania elementów, pojemność jest automatycznie zwiększany o ponowne przydzielanie tablicy wewnętrznej przed skopiowaniem starych elementów i dodawanie nowych elementów.</xref:System.Collections.SortedList.Capacity%2A>       Pobieranie wartości tej właściwości jest operacją O(1)."
  syntax:
    content: public virtual int Count { get; }
    return:
      type: System.Int32
      description: "Liczba elementów zawartych w <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  overload: System.Collections.SortedList.Count*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.SortedList.GetByIndex(System.Int32)
  id: GetByIndex(System.Int32)
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: GetByIndex(Int32)
  nameWithType: SortedList.GetByIndex(Int32)
  fullName: System.Collections.SortedList.GetByIndex(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Pobiera wartość w określonym indeksie <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  remarks: "Sekwencja indeks jest oparty na kolejności sortowania. Po dodaniu elementu wstawieniu do <xref:System.Collections.SortedList>poprawne sortowania kolejności i indeksowanie dostosowuje odpowiednio.</xref:System.Collections.SortedList> Po usunięciu elementu indeksowanie również dostosowuje odpowiednio. W związku z tym indeks parę klucza i wartości określonych może ulec zmianie, elementy są dodawane lub usuwane z <xref:System.Collections.SortedList>obiektu.</xref:System.Collections.SortedList>       Ta metoda jest operacją O(1)."
  example:
  - "The following code example shows how to get one or all the keys or values in a <xref:System.Collections.SortedList> object.  \n  \n [!code-cpp[Classic SortedList.GetByIndex Example#1](~/add/codesnippet/cpp/m-system.collections.sor_8_1.cpp)]\n [!code-cs[Classic SortedList.GetByIndex Example#1](~/add/codesnippet/csharp/m-system.collections.sor_8_1.cs)]\n [!code-vb[Classic SortedList.GetByIndex Example#1](~/add/codesnippet/visualbasic/m-system.collections.sor_8_1.vb)]"
  syntax:
    content: public virtual object GetByIndex (int index);
    parameters:
    - id: index
      type: System.Int32
      description: "Liczony od zera indeks wartości do pobrania."
    return:
      type: System.Object
      description: "Wartość w określonym indeksie <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  overload: System.Collections.SortedList.GetByIndex*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>znajduje się poza zakresem indeksów prawidłowy dla <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  platform:
  - net462
- uid: System.Collections.SortedList.GetEnumerator
  id: GetEnumerator
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: SortedList.GetEnumerator()
  fullName: System.Collections.SortedList.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Zwraca <xref:System.Collections.IDictionaryEnumerator>obiektu, który iteruje po <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu.</xref:System.Collections.IDictionaryEnumerator>"
  remarks: "`foreach` Instrukcji języka C# (`for each` w języku Visual Basic) ukrywa złożoność wyliczenia.  W związku z tym przy użyciu `foreach` jest zalecane, zamiast bezpośrednie manipulowanie modułu wyliczającego.       Moduły wyliczające może służyć do odczytywania danych w kolekcji, ale nie może służyć do modyfikowania kolekcji źródłowej.       Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A>również wprowadzono moduł wyliczający wróć do tej pozycji.</xref:System.Collections.IEnumerator.Reset%2A>  W tym miejscu <xref:System.Collections.IEnumerator.Current%2A>jest niezdefiniowany.</xref:System.Collections.IEnumerator.Current%2A> W związku z tym należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A>można poprawić modułu wyliczającego pierwszy element do kolekcji przed odczytaniem wartość <xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>zwraca ten sam obiekt do momentu <xref:System.Collections.IEnumerator.MoveNext%2A>lub <xref:System.Collections.IEnumerator.Reset%2A>jest wywoływana.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>Ustawia <xref:System.Collections.IEnumerator.Current%2A>do następnego elementu.</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A>przekazuje końcem kolekcji, moduł wyliczający jest umieszczony za ostatnim elementem w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A>zwraca `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Gdy moduł wyliczający jest w tym miejscu kolejnych wywołań <xref:System.Collections.IEnumerator.MoveNext%2A>zwracają również `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> Jeśli przez ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A>zwrócił `false`, <xref:System.Collections.IEnumerator.Current%2A>jest niezdefiniowany.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Aby ustawić <xref:System.Collections.IEnumerator.Current%2A>pierwszy element w kolekcji, należy wywołać, <xref:System.Collections.IEnumerator.Reset%2A>następuje <xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A>       Moduł wyliczający pozostaje ważny tak długo, jak kolekcji pozostaje niezmieniona. Jeśli wprowadzono zmiany w kolekcji, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający jest bezpowrotnie nieważne i jego zachowanie jest niezdefiniowana.       Moduł wyliczający nie ma wyłączny dostęp do kolekcji; w związku z tym wyliczania kolekcji leżą nie jest bezpieczne wątkowo procedurą.  W celu zagwarantowania bezpieczeństwa wątków podczas wyliczania, można zablokować kolekcję podczas całej wyliczenia.  Aby zezwolić na dostęp przez wiele wątków do odczytu i zapisu do kolekcji, musi implementować własne synchronizacji.       Ta metoda jest operacją O(1)."
  syntax:
    content: public virtual System.Collections.IDictionaryEnumerator GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IDictionaryEnumerator
      description: "<xref:System.Collections.IDictionaryEnumerator>Obiekt do <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu.</xref:System.Collections.IDictionaryEnumerator>"
  overload: System.Collections.SortedList.GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.SortedList.GetKey(System.Int32)
  id: GetKey(System.Int32)
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: GetKey(Int32)
  nameWithType: SortedList.GetKey(Int32)
  fullName: System.Collections.SortedList.GetKey(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Pobiera klucz w określonym indeksie <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  remarks: "Sekwencja indeks jest oparty na kolejności sortowania. Po dodaniu elementu wstawieniu do <xref:System.Collections.SortedList>poprawne sortowania kolejności i indeksowanie dostosowuje odpowiednio.</xref:System.Collections.SortedList> Po usunięciu elementu indeksowanie również dostosowuje odpowiednio. W związku z tym indeks parę klucza i wartości określonych może ulec zmianie, elementy są dodawane lub usuwane z <xref:System.Collections.SortedList>obiektu.</xref:System.Collections.SortedList>       Ta metoda jest operacją O(1)."
  example:
  - "The following code example shows how to get one or all the keys or values in a <xref:System.Collections.SortedList> object.  \n  \n [!code-cpp[Classic SortedList.GetByIndex Example#1](~/add/codesnippet/cpp/m-system.collections.sor_19_1.cpp)]\n [!code-cs[Classic SortedList.GetByIndex Example#1](~/add/codesnippet/csharp/m-system.collections.sor_19_1.cs)]\n [!code-vb[Classic SortedList.GetByIndex Example#1](~/add/codesnippet/visualbasic/m-system.collections.sor_19_1.vb)]"
  syntax:
    content: public virtual object GetKey (int index);
    parameters:
    - id: index
      type: System.Int32
      description: "Liczony od zera indeks klucz do uzyskania."
    return:
      type: System.Object
      description: "Klucz w określonym indeksie <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  overload: System.Collections.SortedList.GetKey*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>znajduje się poza zakresem indeksów prawidłowy dla <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  platform:
  - net462
- uid: System.Collections.SortedList.GetKeyList
  id: GetKeyList
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: GetKeyList()
  nameWithType: SortedList.GetKeyList()
  fullName: System.Collections.SortedList.GetKeyList()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Pobiera klucze w <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  remarks: "Zwrócona <xref:System.Collections.IList>obiekt jest tylko do odczytu widoku kluczy <xref:System.Collections.SortedList>obiektu.</xref:System.Collections.SortedList> </xref:System.Collections.IList> Modyfikacje podstawowych <xref:System.Collections.SortedList>zostaną natychmiast odzwierciedlone w <xref:System.Collections.IList>.</xref:System.Collections.IList> </xref:System.Collections.SortedList>       Elementy zwracane <xref:System.Collections.IList>są sortowane w takiej samej kolejności jak klucze <xref:System.Collections.SortedList>.</xref:System.Collections.SortedList> </xref:System.Collections.IList>       Ta metoda jest podobna do <xref:System.Collections.SortedList.Keys%2A>Właściwości, ale zwraca <xref:System.Collections.IList>obiekt zamiast <xref:System.Collections.ICollection>obiektu.</xref:System.Collections.ICollection> </xref:System.Collections.IList> </xref:System.Collections.SortedList.Keys%2A>       Ta metoda jest operacją O(1)."
  example:
  - "The following code example shows how to get one or all the keys or values in a <xref:System.Collections.SortedList> object.  \n  \n [!code-cpp[Classic SortedList.GetByIndex Example#1](~/add/codesnippet/cpp/m-system.collections.sor_1_1.cpp)]\n [!code-cs[Classic SortedList.GetByIndex Example#1](~/add/codesnippet/csharp/m-system.collections.sor_1_1.cs)]\n [!code-vb[Classic SortedList.GetByIndex Example#1](~/add/codesnippet/visualbasic/m-system.collections.sor_1_1.vb)]"
  syntax:
    content: public virtual System.Collections.IList GetKeyList ();
    parameters: []
    return:
      type: System.Collections.IList
      description: "<xref:System.Collections.IList>Obiekt zawierający klucze z <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu.</xref:System.Collections.IList>"
  overload: System.Collections.SortedList.GetKeyList*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.SortedList.GetValueList
  id: GetValueList
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: GetValueList()
  nameWithType: SortedList.GetValueList()
  fullName: System.Collections.SortedList.GetValueList()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Pobiera wartości <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  remarks: "Zwrócona <xref:System.Collections.IList>obiekt jest tylko do odczytu widoku wartości <xref:System.Collections.SortedList>obiektu.</xref:System.Collections.SortedList> </xref:System.Collections.IList> Modyfikacje podstawowych <xref:System.Collections.SortedList>zostaną natychmiast odzwierciedlone w <xref:System.Collections.IList>.</xref:System.Collections.IList> </xref:System.Collections.SortedList>       Elementy zwracane <xref:System.Collections.IList>są sortowane w takiej samej kolejności jak wartości <xref:System.Collections.SortedList>.</xref:System.Collections.SortedList> </xref:System.Collections.IList>       Ta metoda jest podobna do <xref:System.Collections.SortedList.Values%2A>Właściwości, ale zwraca <xref:System.Collections.IList>obiekt zamiast <xref:System.Collections.ICollection>obiektu.</xref:System.Collections.ICollection> </xref:System.Collections.IList> </xref:System.Collections.SortedList.Values%2A>       Ta metoda jest operacją O(1)."
  example:
  - "The following code example shows how to get one or all the keys or values in a <xref:System.Collections.SortedList> object.  \n  \n [!code-cpp[Classic SortedList.GetByIndex Example#1](~/add/codesnippet/cpp/m-system.collections.sor_11_1.cpp)]\n [!code-cs[Classic SortedList.GetByIndex Example#1](~/add/codesnippet/csharp/m-system.collections.sor_11_1.cs)]\n [!code-vb[Classic SortedList.GetByIndex Example#1](~/add/codesnippet/visualbasic/m-system.collections.sor_11_1.vb)]"
  syntax:
    content: public virtual System.Collections.IList GetValueList ();
    parameters: []
    return:
      type: System.Collections.IList
      description: "<xref:System.Collections.IList>Obiekt zawierający wartości w <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu.</xref:System.Collections.IList>"
  overload: System.Collections.SortedList.GetValueList*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.SortedList.IndexOfKey(System.Object)
  id: IndexOfKey(System.Object)
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: IndexOfKey(Object)
  nameWithType: SortedList.IndexOfKey(Object)
  fullName: System.Collections.SortedList.IndexOfKey(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Zwraca liczony od zera indeks z określonym kluczem w <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  remarks: "Elementy <xref:System.Collections.SortedList>obiektu są sortowane według kluczy albo zgodnie z określonym <xref:System.Collections.IComparer>implementacji określone podczas <xref:System.Collections.SortedList>został utworzony lub zgodnie z do <xref:System.IComparable>implementacji pochodzącymi z samych kluczy.</xref:System.IComparable> </xref:System.Collections.SortedList> </xref:System.Collections.IComparer> </xref:System.Collections.SortedList>       Sekwencja indeks jest oparty na kolejności sortowania. Po dodaniu elementu wstawieniu do <xref:System.Collections.SortedList>poprawne sortowania kolejności i indeksowanie dostosowuje odpowiednio.</xref:System.Collections.SortedList> Po usunięciu elementu indeksowanie również dostosowuje odpowiednio. W związku z tym indeks parę klucza i wartości określonych może ulec zmianie, elementy są dodawane lub usuwane z <xref:System.Collections.SortedList>.</xref:System.Collections.SortedList>       Ta metoda używa algorytmu wyszukiwania binarne; w związku z tym ta metoda jest O (dziennika `n`) operację, której `n` <xref:System.Collections.SortedList.Count%2A>.</xref:System.Collections.SortedList.Count%2A>       Począwszy od programu .NET Framework 2.0, ta metoda używa kolekcji obiektów <xref:System.Object.Equals%2A>i <xref:System.IComparable.CompareTo%2A>metody `item` ustalenie, czy element istnieje.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> We wcześniejszych wersjach programu .NET Framework, oznaczanie został utworzony przy użyciu <xref:System.Object.Equals%2A>i <xref:System.IComparable.CompareTo%2A>metody `item` parametrów dla obiektów w kolekcji.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  example:
  - "The following code example shows how to determine the index of a key or a value in a <xref:System.Collections.SortedList> object.  \n  \n [!code-cpp[Classic SortedList.IndexOfKey Example#1](~/add/codesnippet/cpp/m-system.collections.sor_2_1.cpp)]\n [!code-vb[Classic SortedList.IndexOfKey Example#1](~/add/codesnippet/visualbasic/m-system.collections.sor_2_1.vb)]\n [!code-cs[Classic SortedList.IndexOfKey Example#1](~/add/codesnippet/csharp/m-system.collections.sor_2_1.cs)]"
  syntax:
    content: public virtual int IndexOfKey (object key);
    parameters:
    - id: key
      type: System.Object
      description: "Klucz do zlokalizowania w <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
    return:
      type: System.Int32
      description: "Liczony od zera indeks <code> key </code> parametru, jeśli <code> key </code> znajduje się w <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu; w przeciwnym razie wartość -1."
  overload: System.Collections.SortedList.IndexOfKey*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Moduł porównujący zgłasza wyjątek."
  platform:
  - net462
- uid: System.Collections.SortedList.IndexOfValue(System.Object)
  id: IndexOfValue(System.Object)
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: IndexOfValue(Object)
  nameWithType: SortedList.IndexOfValue(Object)
  fullName: System.Collections.SortedList.IndexOfValue(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Zwraca liczony od zera indeks pierwszego wystąpienia określoną wartość <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  remarks: "Sekwencja indeks jest oparty na kolejności sortowania. Po dodaniu elementu wstawieniu do <xref:System.Collections.SortedList>poprawne sortowania kolejności i indeksowanie dostosowuje odpowiednio.</xref:System.Collections.SortedList> Po usunięciu elementu indeksowanie również dostosowuje odpowiednio. W związku z tym indeks parę klucza i wartości określonych może ulec zmianie, elementy są dodawane lub usuwane z <xref:System.Collections.SortedList>obiektu.</xref:System.Collections.SortedList>       Wartości elementów <xref:System.Collections.SortedList>są porównywane przy użyciu określonej wartości <xref:System.Object.Equals%2A>metody.</xref:System.Object.Equals%2A> </xref:System.Collections.SortedList>       Ta metoda używa wyszukiwanie liniowe; w związku z tym ta metoda jest O (`n`) operację, której `n` <xref:System.Collections.SortedList.Count%2A>.</xref:System.Collections.SortedList.Count%2A>       Począwszy od programu .NET Framework 2.0, ta metoda używa kolekcji obiektów <xref:System.Object.Equals%2A>i <xref:System.IComparable.CompareTo%2A>metody `item` ustalenie, czy element istnieje.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> We wcześniejszych wersjach programu .NET Framework, oznaczanie został utworzony przy użyciu <xref:System.Object.Equals%2A>i <xref:System.IComparable.CompareTo%2A>metody `item` parametrów dla obiektów w kolekcji.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  example:
  - "The following code example shows how to determine the index of a key or a value in a <xref:System.Collections.SortedList> object.  \n  \n [!code-cpp[Classic SortedList.IndexOfKey Example#1](~/add/codesnippet/cpp/m-system.collections.sor_5_1.cpp)]\n [!code-vb[Classic SortedList.IndexOfKey Example#1](~/add/codesnippet/visualbasic/m-system.collections.sor_5_1.vb)]\n [!code-cs[Classic SortedList.IndexOfKey Example#1](~/add/codesnippet/csharp/m-system.collections.sor_5_1.cs)]"
  syntax:
    content: public virtual int IndexOfValue (object value);
    parameters:
    - id: value
      type: System.Object
      description: "Wartość do zlokalizowania w <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu. Wartość może być <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Int32
      description: "Liczony od zera indeks pierwszego wystąpienia <code> value </code> parametru, jeśli <code> value </code> znajduje się w <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu; w przeciwnym razie wartość -1."
  overload: System.Collections.SortedList.IndexOfValue*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.SortedList.IsFixedSize
  id: IsFixedSize
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: IsFixedSize
  nameWithType: SortedList.IsFixedSize
  fullName: System.Collections.SortedList.IsFixedSize
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Pobiera wartość wskazującą czy <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiekt ma stały rozmiar."
  remarks: "Kolekcja o stałym rozmiarze nie zezwala dodawania lub usuwania elementów po kolekcji zostało utworzone, ale zezwalaj na modyfikowanie istniejących elementów.       Kolekcja o stałym rozmiarze jest po prostu kolekcji z otoką, który uniemożliwia Dodawanie i usuwanie elementów; w związku z tym zmian w źródłowej kolekcji, włączając Dodawanie lub usuwanie elementów z kolekcji o stałym rozmiarze odzwierciedla te zmiany.       Pobieranie wartości tej właściwości jest operacją O(1)."
  syntax:
    content: public virtual bool IsFixedSize { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiekt ma ustalony rozmiar; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Wartość domyślna to <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.SortedList.IsFixedSize*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.SortedList.IsReadOnly
  id: IsReadOnly
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: IsReadOnly
  nameWithType: SortedList.IsReadOnly
  fullName: System.Collections.SortedList.IsReadOnly
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Pobiera wartość wskazującą czy <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiekt jest tylko do odczytu."
  remarks: "Kolekcja, która jest tylko do odczytu uniemożliwia dodawania, usuwania lub modyfikowania elementów po utworzeniu kolekcji.       Kolekcja, która jest tylko do odczytu jest po prostu kolekcji z otoką, co uniemożliwia ich modyfikowania kolekcji; w związku z tym jeśli wprowadzono zmiany w źródłowej kolekcji, kolekcji tylko do odczytu odzwierciedla te zmiany.       Pobieranie wartości tej właściwości jest operacją O(1)."
  syntax:
    content: public virtual bool IsReadOnly { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiekt jest tylko do odczytu; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Wartość domyślna to <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.SortedList.IsReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.SortedList.IsSynchronized
  id: IsSynchronized
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: IsSynchronized
  nameWithType: SortedList.IsSynchronized
  fullName: System.Collections.SortedList.IsSynchronized
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Pobiera wartość wskazującą czy uzyskują dostęp do <xref href=&quot;System.Collections.SortedList&quot;> </xref> jest synchronizowany obiekt (wielowątkowość)."
  remarks: "W celu zagwarantowania bezpieczeństwa wątków <xref:System.Collections.SortedList>obiektów, wszystkie operacje muszą być wykonywane przez otoki zwrócony przez <xref:System.Collections.SortedList.Synchronized%2A>metody.</xref:System.Collections.SortedList.Synchronized%2A> </xref:System.Collections.SortedList>       Wyliczanie za pomocą kolekcji leżą nie jest procedurą wątkowo. Nawet jeśli kolekcja jest synchronizowane, inne wątki mogą modyfikować kolekcji, co powoduje, że moduł wyliczający, który ma zostać zgłoszony wyjątek. W celu zagwarantowania bezpieczeństwa wątków podczas wyliczania, możesz zablokować kolekcji podczas wyliczania całego lub przechwytują wyjątki wynikające ze zmian wprowadzonych przez inne wątki."
  example:
  - "The following code example shows how to lock a collection using the <xref:System.Collections.SortedList.SyncRoot%2A> property during the entire enumeration.  \n  \n [!code-cpp[Classic SortedList.IsSynchronized Example#2](~/add/codesnippet/cpp/p-system.collections.sor_1_1.cpp)]\n [!code-cs[Classic SortedList.IsSynchronized Example#2](~/add/codesnippet/csharp/p-system.collections.sor_1_1.cs)]\n [!code-vb[Classic SortedList.IsSynchronized Example#2](~/add/codesnippet/visualbasic/p-system.collections.sor_1_1.vb)]  \n  \n Retrieving the value of this property is an O(1) operation.  \n  \n The following code example shows how to synchronize a <xref:System.Collections.SortedList> object, determine whether a <xref:System.Collections.SortedList> is synchronized, and use a synchronized <xref:System.Collections.SortedList>.  \n  \n [!code-cpp[Classic SortedList.IsSynchronized Example#1](~/add/codesnippet/cpp/p-system.collections.sor_1_2.cpp)]\n [!code-cs[Classic SortedList.IsSynchronized Example#1](~/add/codesnippet/csharp/p-system.collections.sor_1_2.cs)]\n [!code-vb[Classic SortedList.IsSynchronized Example#1](~/add/codesnippet/visualbasic/p-system.collections.sor_1_2.vb)]"
  syntax:
    content: public virtual bool IsSynchronized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli dostęp do <xref href=&quot;System.Collections.SortedList&quot;> </xref> jest synchronizowany obiekt (wielowątkowość); w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Wartość domyślna to <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.SortedList.IsSynchronized*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.SortedList.Item(System.Object)
  id: Item(System.Object)
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: Item(Object)
  nameWithType: SortedList.Item(Object)
  fullName: System.Collections.SortedList.Item(Object)
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Pobiera i ustawia wartość skojarzoną z określonym kluczem w <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  remarks: "Właściwość elementu umożliwia dostęp do określonego elementu w kolekcji, określając następującej składni: `myCollection[key]`.       Umożliwia także tej właściwości można dodawać nowe elementy za pomocą ustawienia wartości klucza, który nie istnieje w <xref:System.Collections.SortedList>obiektu (na przykład `myCollection[&quot;myNonexistentKey&quot;] = myValue)`.</xref:System.Collections.SortedList> Jednak jeśli określony klucz już istnieje w <xref:System.Collections.SortedList>, ustawienie właściwości elementu zastępuje stara wartość.</xref:System.Collections.SortedList> Z kolei <xref:System.Collections.SortedList.Add%2A>— Metoda nie modyfikuje istniejące elementy.</xref:System.Collections.SortedList.Add%2A>       Klucz nie może być `null`, ale może być wartością. Aby odróżnić `null` który jest zwracany, ponieważ nie odnaleziono określonego klucza i `null` który jest zwracany, ponieważ wartość określony klucz jest `null`, użyj <xref:System.Collections.SortedList.Contains%2A>— Metoda lub <xref:System.Collections.SortedList.ContainsKey%2A>metodę, aby określić, czy klucz znajduje się na liście.</xref:System.Collections.SortedList.ContainsKey%2A> </xref:System.Collections.SortedList.Contains%2A>       Elementy <xref:System.Collections.SortedList>są sortowane według kluczy albo zgodnie z określonym <xref:System.Collections.IComparer>implementacji określone podczas <xref:System.Collections.SortedList>został utworzony lub zgodnie z do <xref:System.IComparable>implementacji pochodzącymi z samych kluczy.</xref:System.IComparable> </xref:System.Collections.SortedList> </xref:System.Collections.IComparer> </xref:System.Collections.SortedList>       Używa języka C# do definiowania indeksatory zamiast implementacja słowa kluczowego <xref:System.Collections.SortedList.Keys%2A>Właściwości.</xref:System.Collections.SortedList.Keys%2A> Visual Basic implementuje element jako domyślna właściwość, która zapewnia te same funkcje indeksowania.       Pobieranie wartości tej właściwości jest O (dziennika `n`) operację, której `n` <xref:System.Collections.SortedList.Count%2A>.</xref:System.Collections.SortedList.Count%2A> Ustawienie właściwości jest O (dziennika `n`) operacji, jeśli klucz jest już <xref:System.Collections.SortedList>.</xref:System.Collections.SortedList> Jeśli klucz nie jest na liście, ustawienie właściwości jest O (`n`) operacji nieposortowane danych lub O (dziennika `n`) Jeśli nowy element zostanie dodany na końcu listy. Jeśli wstawiania powoduje, że zmiany rozmiaru, operacja jest O (`n`)."
  syntax:
    content: public virtual object this[object key] { get; set; }
    parameters:
    - id: key
      type: System.Object
      description: "Klucz skojarzony z wartości do pobrania lub ustawienia."
    return:
      type: System.Object
      description: "Wartość skojarzoną z <code> key </code> parametru w <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu, jeśli <code> key </code> zostanie odnaleziony; w przeciwnym razie <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.SortedList.Item*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Właściwość jest ustawiona i <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiekt jest tylko do odczytu.       - lub - właściwość jest ustawiona, <code> key </code> nie istnieje w kolekcji i <xref href=&quot;System.Collections.SortedList&quot;> </xref> ma stały rozmiar."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma dostatecznej ilości dostępnej pamięci, aby dodać element do <xref href=&quot;System.Collections.SortedList&quot;> </xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Moduł porównujący zgłasza wyjątek."
  platform:
  - net462
- uid: System.Collections.SortedList.Keys
  id: Keys
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: Keys
  nameWithType: SortedList.Keys
  fullName: System.Collections.SortedList.Keys
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Pobiera klucze w <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  remarks: "<xref:System.Collections.ICollection>Obiekt jest tylko do odczytu widoku kluczy <xref:System.Collections.SortedList>obiektu.</xref:System.Collections.SortedList> </xref:System.Collections.ICollection> Modyfikacje podstawowych <xref:System.Collections.SortedList>zostaną natychmiast odzwierciedlone w <xref:System.Collections.ICollection>.</xref:System.Collections.ICollection> </xref:System.Collections.SortedList>       Elementy <xref:System.Collections.ICollection>są sortowane w takiej samej kolejności jak klucze <xref:System.Collections.SortedList>.</xref:System.Collections.SortedList> </xref:System.Collections.ICollection>       Ta właściwość jest podobny do <xref:System.Collections.SortedList.GetKeyList%2A>metody, ale zwraca <xref:System.Collections.ICollection>obiekt zamiast <xref:System.Collections.IList>obiektu.</xref:System.Collections.IList> </xref:System.Collections.ICollection> </xref:System.Collections.SortedList.GetKeyList%2A>       Ta metoda jest operacją O(1)."
  syntax:
    content: public virtual System.Collections.ICollection Keys { get; }
    return:
      type: System.Collections.ICollection
      description: "<xref:System.Collections.ICollection>Obiekt zawierający klucze z <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu.</xref:System.Collections.ICollection>"
  overload: System.Collections.SortedList.Keys*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.SortedList.Remove(System.Object)
  id: Remove(System.Object)
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: Remove(Object)
  nameWithType: SortedList.Remove(Object)
  fullName: System.Collections.SortedList.Remove(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Usuwa element z określonym kluczem z <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  remarks: "Jeśli <xref:System.Collections.SortedList>obiekt nie zawiera element z określonym kluczem <xref:System.Collections.SortedList>pozostaje niezmieniona.</xref:System.Collections.SortedList> </xref:System.Collections.SortedList> Nie wyjątek.       W kolekcji sąsiadujących elementów, takich jak listy elementy, które należy wykonać usunięty element Przenieś w górę zajmować vacated miejscu. Jeśli kolekcja jest indeksowana, również są aktualizowane indeksów elementów, które są przenoszone. To zachowanie nie ma zastosowania do kolekcji, której elementy koncepcyjnie są zgrupowane w pakiety, takich jak tablicy skrótów.       Ta metoda jest O (`n`) operację, której `n` <xref:System.Collections.SortedList.Count%2A>.</xref:System.Collections.SortedList.Count%2A>"
  example:
  - "The following code example shows how to remove elements from a <xref:System.Collections.SortedList> object.  \n  \n [!code-cs[Classic SortedList.RemoveAt Example#1](~/add/codesnippet/csharp/m-system.collections.sor_6_1.cs)]\n [!code-cpp[Classic SortedList.RemoveAt Example#1](~/add/codesnippet/cpp/m-system.collections.sor_6_1.cpp)]\n [!code-vb[Classic SortedList.RemoveAt Example#1](~/add/codesnippet/visualbasic/m-system.collections.sor_6_1.vb)]"
  syntax:
    content: public virtual void Remove (object key);
    parameters:
    - id: key
      type: System.Object
      description: "Klucz elementu do usunięcia."
  overload: System.Collections.SortedList.Remove*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.SortedList&quot;> </xref> Obiekt jest tylko do odczytu.       - lub - <xref href=&quot;System.Collections.SortedList&quot;> </xref> ma stały rozmiar."
  platform:
  - net462
- uid: System.Collections.SortedList.RemoveAt(System.Int32)
  id: RemoveAt(System.Int32)
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: RemoveAt(Int32)
  nameWithType: SortedList.RemoveAt(Int32)
  fullName: System.Collections.SortedList.RemoveAt(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Usuwa element o określonym indeksie <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  remarks: "Sekwencja indeks jest oparty na kolejności sortowania. Po dodaniu elementu wstawieniu do <xref:System.Collections.SortedList>poprawne sortowania kolejności i indeksowanie dostosowuje odpowiednio.</xref:System.Collections.SortedList> Po usunięciu elementu indeksowanie również dostosowuje odpowiednio. W związku z tym indeks parę klucza i wartości określonych może ulec zmianie, elementy są dodawane lub usuwane z <xref:System.Collections.SortedList>obiektu.</xref:System.Collections.SortedList>       W kolekcji sąsiadujących elementów, takich jak listy elementy, które należy wykonać usunięty element Przenieś w górę zajmować vacated miejscu. Jeśli kolekcja jest indeksowana, również są aktualizowane indeksów elementów, które są przenoszone. To zachowanie nie ma zastosowania do kolekcji, której elementy koncepcyjnie są zgrupowane w pakiety, takich jak tablicy skrótów.       Ta metoda jest O (`n`) operację, której `n` <xref:System.Collections.SortedList.Count%2A>.</xref:System.Collections.SortedList.Count%2A>"
  example:
  - "The following code example shows how to remove elements from a <xref:System.Collections.SortedList> object.  \n  \n [!code-cs[Classic SortedList.RemoveAt Example#1](~/add/codesnippet/csharp/m-system.collections.sor_17_1.cs)]\n [!code-cpp[Classic SortedList.RemoveAt Example#1](~/add/codesnippet/cpp/m-system.collections.sor_17_1.cpp)]\n [!code-vb[Classic SortedList.RemoveAt Example#1](~/add/codesnippet/visualbasic/m-system.collections.sor_17_1.vb)]"
  syntax:
    content: public virtual void RemoveAt (int index);
    parameters:
    - id: index
      type: System.Int32
      description: "Liczony od zera indeks elementu do usunięcia."
  overload: System.Collections.SortedList.RemoveAt*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>znajduje się poza zakresem indeksów prawidłowy dla <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.SortedList&quot;> </xref> Jest tylko do odczytu.       - lub - <xref href=&quot;System.Collections.SortedList&quot;> </xref> ma stały rozmiar."
  platform:
  - net462
- uid: System.Collections.SortedList.SetByIndex(System.Int32,System.Object)
  id: SetByIndex(System.Int32,System.Object)
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: SetByIndex(Int32,Object)
  nameWithType: SortedList.SetByIndex(Int32,Object)
  fullName: System.Collections.SortedList.SetByIndex(Int32,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Zamienia wartości w określonym indeksie w <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  remarks: "Sekwencja indeks jest oparty na kolejności sortowania. Po dodaniu elementu wstawieniu do <xref:System.Collections.SortedList>poprawne sortowania kolejności i indeksowanie dostosowuje odpowiednio.</xref:System.Collections.SortedList> Po usunięciu elementu indeksowanie również dostosowuje odpowiednio. W związku z tym indeks parę klucza i wartości określonych może ulec zmianie, elementy są dodawane lub usuwane z <xref:System.Collections.SortedList>obiektu.</xref:System.Collections.SortedList>       Ta metoda jest operacją O(1)."
  example:
  - "The following code example shows how to replace the value of an existing element in a <xref:System.Collections.SortedList> object.  \n  \n [!code-vb[Classic SortedList.SetByIndex Example#1](~/add/codesnippet/visualbasic/m-system.collections.sor_13_1.vb)]\n [!code-cs[Classic SortedList.SetByIndex Example#1](~/add/codesnippet/csharp/m-system.collections.sor_13_1.cs)]\n [!code-cpp[Classic SortedList.SetByIndex Example#1](~/add/codesnippet/cpp/m-system.collections.sor_13_1.cpp)]"
  syntax:
    content: public virtual void SetByIndex (int index, object value);
    parameters:
    - id: index
      type: System.Int32
      description: "Liczony od zera indeks, w którym chcesz zapisać `value`."
    - id: value
      type: System.Object
      description: "<xref:System.Object>Można zapisać do <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu.</xref:System.Object> Wartość może być <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.SortedList.SetByIndex*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>znajduje się poza zakresem indeksów prawidłowy dla <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  platform:
  - net462
- uid: System.Collections.SortedList.Synchronized(System.Collections.SortedList)
  id: Synchronized(System.Collections.SortedList)
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: Synchronized(SortedList)
  nameWithType: SortedList.Synchronized(SortedList)
  fullName: System.Collections.SortedList.Synchronized(SortedList)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Zwraca zsynchronizowane otoki (wątkowo) dla <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  remarks: "W celu zagwarantowania bezpieczeństwa wątków <xref:System.Collections.SortedList>obiektów, wszystkie operacje musi odbywać się za pomocą tylko tej otoki.</xref:System.Collections.SortedList>       Wyliczanie za pomocą kolekcji leżą nie jest procedurą wątkowo. Nawet jeśli kolekcja jest synchronizowane, inne wątki mogą modyfikować kolekcji, co powoduje, że moduł wyliczający, który ma zostać zgłoszony wyjątek. W celu zagwarantowania bezpieczeństwa wątków podczas wyliczania, możesz zablokować kolekcji podczas wyliczania całego lub przechwytują wyjątki wynikające ze zmian wprowadzonych przez inne wątki."
  example:
  - "The following code example shows how to lock the collection using the <xref:System.Collections.SortedList.SyncRoot%2A> property during the entire enumeration.  \n  \n [!code-cpp[Classic SortedList.IsSynchronized Example#2](~/add/codesnippet/cpp/m-system.collections.sor_10_1.cpp)]\n [!code-cs[Classic SortedList.IsSynchronized Example#2](~/add/codesnippet/csharp/m-system.collections.sor_10_1.cs)]\n [!code-vb[Classic SortedList.IsSynchronized Example#2](~/add/codesnippet/visualbasic/m-system.collections.sor_10_1.vb)]  \n  \n This method is an O(1) operation.  \n  \n The following code example shows how to synchronize a <xref:System.Collections.SortedList> object, determine whether a <xref:System.Collections.SortedList> is synchronized, and use a synchronized <xref:System.Collections.SortedList>.  \n  \n [!code-cpp[Classic SortedList.IsSynchronized Example#1](~/add/codesnippet/cpp/m-system.collections.sor_10_2.cpp)]\n [!code-cs[Classic SortedList.IsSynchronized Example#1](~/add/codesnippet/csharp/m-system.collections.sor_10_2.cs)]\n [!code-vb[Classic SortedList.IsSynchronized Example#1](~/add/codesnippet/visualbasic/m-system.collections.sor_10_2.vb)]"
  syntax:
    content: public static System.Collections.SortedList Synchronized (System.Collections.SortedList list);
    parameters:
    - id: list
      type: System.Collections.SortedList
      description: "<xref href=&quot;System.Collections.SortedList&quot;> </xref> Obiektu do synchronizacji."
    return:
      type: System.Collections.SortedList
      description: "A zsynchronizowane (wątkowo) otoki dla <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  overload: System.Collections.SortedList.Synchronized*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>list</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.SortedList.SyncRoot
  id: SyncRoot
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: SyncRoot
  nameWithType: SortedList.SyncRoot
  fullName: System.Collections.SortedList.SyncRoot
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Pobiera obiekt, który może służyć do synchronizujący dostęp do <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  remarks: "Aby utworzyć zsynchronizowaną wersję <xref:System.Collections.SortedList>obiektów, użyj <xref:System.Collections.SortedList.Synchronized%2A>metody.</xref:System.Collections.SortedList.Synchronized%2A> </xref:System.Collections.SortedList> Jednak klasy pochodne zapewniają własne zsynchronizowanej wersji <xref:System.Collections.SortedList>za pomocą właściwości SyncRoot.</xref:System.Collections.SortedList> Synchronizowanie kodu musi wykonywać operacje na SyncRoot z <xref:System.Collections.SortedList>, bezpośrednio na <xref:System.Collections.SortedList>.</xref:System.Collections.SortedList> </xref:System.Collections.SortedList> Zapewnia to poprawne działanie kolekcje, które pochodzą od innych obiektów. W szczególności przechowuje prawidłowego synchronizacji z innych wątków, które mogą być jednocześnie modyfikowanie <xref:System.Collections.SortedList>obiektu.</xref:System.Collections.SortedList>       Wyliczanie za pomocą kolekcji leżą nie jest procedurą wątkowo. Nawet jeśli kolekcja jest synchronizowane, inne wątki mogą modyfikować kolekcji, co powoduje, że moduł wyliczający, który ma zostać zgłoszony wyjątek. W celu zagwarantowania bezpieczeństwa wątków podczas wyliczania, możesz zablokować kolekcji podczas wyliczania całego lub przechwytują wyjątki wynikające ze zmian wprowadzonych przez inne wątki."
  example:
  - "The following code example shows how to lock the collection using the SyncRoot property during the entire enumeration.  \n  \n [!code-cpp[Classic SortedList.IsSynchronized Example#2](~/add/codesnippet/cpp/p-system.collections.sor_0_1.cpp)]\n [!code-cs[Classic SortedList.IsSynchronized Example#2](~/add/codesnippet/csharp/p-system.collections.sor_0_1.cs)]\n [!code-vb[Classic SortedList.IsSynchronized Example#2](~/add/codesnippet/visualbasic/p-system.collections.sor_0_1.vb)]  \n  \n Retrieving the value of this property is an O(1) operation."
  syntax:
    content: public virtual object SyncRoot { get; }
    return:
      type: System.Object
      description: "Obiekt, który może służyć do synchronizujący dostęp do <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  overload: System.Collections.SortedList.SyncRoot*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator
  id: System#Collections#IEnumerable#GetEnumerator
  isEii: true
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: System.Collections.IEnumerable.GetEnumerator()
  nameWithType: SortedList.System.Collections.IEnumerable.GetEnumerator()
  fullName: System.Collections.SortedList.System.Collections.IEnumerable.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Zwraca <xref:System.Collections.IEnumerator>który iteruje <xref href=&quot;System.Collections.SortedList&quot;> </xref>.</xref:System.Collections.IEnumerator>"
  remarks: "[Visual Basic, C#]       `foreach` Instrukcji języka C# (`for each` w języku Visual Basic) ukrywa złożoność wyliczenia.  W związku z tym przy użyciu `foreach` jest zalecane, zamiast bezpośrednie manipulowanie modułu wyliczającego.       Moduły wyliczające może służyć do odczytywania danych w kolekcji, ale nie może służyć do modyfikowania kolekcji źródłowej.       Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A>również wprowadzono moduł wyliczający wróć do tej pozycji.</xref:System.Collections.IEnumerator.Reset%2A> At to pozycja, wywoływania <xref:System.Collections.IEnumerator.Current%2A>zgłasza wyjątek.</xref:System.Collections.IEnumerator.Current%2A> W związku z tym należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A>można poprawić modułu wyliczającego pierwszy element do kolekcji przed odczytaniem wartość <xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>zwraca ten sam obiekt do momentu <xref:System.Collections.IEnumerator.MoveNext%2A>lub <xref:System.Collections.IEnumerator.Reset%2A>jest wywoływana.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>Ustawia <xref:System.Collections.IEnumerator.Current%2A>do następnego elementu.</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A>przekazuje końcem kolekcji, moduł wyliczający jest umieszczony za ostatnim elementem w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A>zwraca `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Gdy moduł wyliczający jest w tym miejscu kolejnych wywołań <xref:System.Collections.IEnumerator.MoveNext%2A>zwracają również `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> Jeśli przez ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A>zwrócił `false`, wywoływania <xref:System.Collections.IEnumerator.Current%2A>zgłasza wyjątek.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Aby ustawić <xref:System.Collections.IEnumerator.Current%2A>pierwszy element w kolekcji, należy wywołać, <xref:System.Collections.IEnumerator.Reset%2A>następuje <xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A>       Moduł wyliczający pozostaje ważny tak długo, jak kolekcji pozostaje niezmieniona. Jeśli wprowadzono zmiany w kolekcji, takich jak dodawanie, modyfikowanie lub usuwanie elementów, spowoduje nieodwracalne unieważnienie modułu wyliczającego i następnego wywołania lub <xref:System.Collections.IEnumerator.MoveNext%2A> <xref:System.Collections.IEnumerator.Reset%2A>zgłasza <xref:System.InvalidOperationException>.</xref:System.InvalidOperationException> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Jeśli kolekcja jest zmodyfikowany między <xref:System.Collections.IEnumerator.MoveNext%2A>i <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A>zwraca element, który ma ustawioną, nawet wtedy, gdy moduł wyliczający jest już unieważnione.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A>       Moduł wyliczający nie ma wyłączny dostęp do kolekcji; w związku z tym wyliczania kolekcji leżą nie jest bezpieczne wątkowo procedurą. Nawet jeśli kolekcja jest synchronizowane, inne wątki mogą modyfikować kolekcji, co powoduje, że moduł wyliczający, który ma zostać zgłoszony wyjątek. W celu zagwarantowania bezpieczeństwa wątków podczas wyliczania, możesz zablokować kolekcji podczas wyliczania całego lub przechwytują wyjątki wynikające ze zmian wprowadzonych przez inne wątki.       Ta metoda jest operacją O(1)."
  syntax:
    content: System.Collections.IEnumerator IEnumerable.GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "An <xref:System.Collections.IEnumerator> for the <xref href=&quot;System.Collections.SortedList&quot;></xref>.</xref:System.Collections.IEnumerator>"
  overload: System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.SortedList.TrimToSize
  id: TrimToSize
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: TrimToSize()
  nameWithType: SortedList.TrimToSize()
  fullName: System.Collections.SortedList.TrimToSize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Ustawia pojemność na rzeczywistą liczbę elementów w <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  remarks: "Ta metoda może służyć do narzut zminimalizować pamięci kolekcji, jeśli żadne nowe elementy, które zostaną dodane do kolekcji.       Aby zresetować <xref:System.Collections.SortedList>obiektu do stanu początkowego wywołania <xref:System.Collections.SortedList.Clear%2A>Metoda przed wywołaniem TrimToSize.</xref:System.Collections.SortedList.Clear%2A> </xref:System.Collections.SortedList> Przycinanie pustą <xref:System.Collections.SortedList>Ustawia pojemność <xref:System.Collections.SortedList>do wydajności domyślnej.</xref:System.Collections.SortedList> </xref:System.Collections.SortedList>       Ta metoda jest O (`n`) operację, której `n` <xref:System.Collections.SortedList.Count%2A>.</xref:System.Collections.SortedList.Count%2A>"
  example:
  - "The following code example shows how to trim the unused portions of a <xref:System.Collections.SortedList> object and how to clear its values.  \n  \n [!code-cpp[Classic SortedList.Clear Example#1](~/add/codesnippet/cpp/m-system.collections.sor_3_1.cpp)]\n [!code-cs[Classic SortedList.Clear Example#1](~/add/codesnippet/csharp/m-system.collections.sor_3_1.cs)]\n [!code-vb[Classic SortedList.Clear Example#1](~/add/codesnippet/visualbasic/m-system.collections.sor_3_1.vb)]"
  syntax:
    content: public virtual void TrimToSize ();
    parameters: []
  overload: System.Collections.SortedList.TrimToSize*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.SortedList&quot;> </xref> Obiekt jest tylko do odczytu.       - lub - <xref href=&quot;System.Collections.SortedList&quot;> </xref> ma stały rozmiar."
  platform:
  - net462
- uid: System.Collections.SortedList.Values
  id: Values
  parent: System.Collections.SortedList
  langs:
  - csharp
  name: Values
  nameWithType: SortedList.Values
  fullName: System.Collections.SortedList.Values
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Pobiera wartości <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu."
  remarks: "<xref:System.Collections.ICollection>Obiekt jest tylko do odczytu widoku wartości <xref:System.Collections.SortedList>obiektu.</xref:System.Collections.SortedList> </xref:System.Collections.ICollection> Modyfikacje podstawowych <xref:System.Collections.SortedList>zostaną natychmiast odzwierciedlone w <xref:System.Collections.ICollection>.</xref:System.Collections.ICollection> </xref:System.Collections.SortedList>       Elementy <xref:System.Collections.ICollection>są sortowane w takiej samej kolejności jak wartości <xref:System.Collections.SortedList>.</xref:System.Collections.SortedList> </xref:System.Collections.ICollection>       Ta właściwość jest podobny do <xref:System.Collections.SortedList.GetValueList%2A>metody, ale zwraca <xref:System.Collections.ICollection>obiekt zamiast <xref:System.Collections.IList>obiektu.</xref:System.Collections.IList> </xref:System.Collections.ICollection> </xref:System.Collections.SortedList.GetValueList%2A>       Ta metoda jest operacją O(1)."
  syntax:
    content: public virtual System.Collections.ICollection Values { get; }
    return:
      type: System.Collections.ICollection
      description: "<xref:System.Collections.ICollection>Obiekt zawierający wartości w <xref href=&quot;System.Collections.SortedList&quot;> </xref> obiektu.</xref:System.Collections.ICollection>"
  overload: System.Collections.SortedList.Values*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.InvalidCastException
  isExternal: true
  name: System.InvalidCastException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Collections.SortedList.#ctor
  parent: System.Collections.SortedList
  isExternal: false
  name: SortedList()
  nameWithType: SortedList.SortedList()
  fullName: System.Collections.SortedList.SortedList()
- uid: System.Collections.SortedList.#ctor(System.Collections.IComparer)
  parent: System.Collections.SortedList
  isExternal: false
  name: SortedList(IComparer)
  nameWithType: SortedList.SortedList(IComparer)
  fullName: System.Collections.SortedList.SortedList(IComparer)
- uid: System.Collections.IComparer
  parent: System.Collections
  isExternal: true
  name: IComparer
  nameWithType: IComparer
  fullName: System.Collections.IComparer
- uid: System.Collections.SortedList.#ctor(System.Collections.IDictionary)
  parent: System.Collections.SortedList
  isExternal: false
  name: SortedList(IDictionary)
  nameWithType: SortedList.SortedList(IDictionary)
  fullName: System.Collections.SortedList.SortedList(IDictionary)
- uid: System.Collections.IDictionary
  parent: System.Collections
  isExternal: true
  name: IDictionary
  nameWithType: IDictionary
  fullName: System.Collections.IDictionary
- uid: System.Collections.SortedList.#ctor(System.Int32)
  parent: System.Collections.SortedList
  isExternal: false
  name: SortedList(Int32)
  nameWithType: SortedList.SortedList(Int32)
  fullName: System.Collections.SortedList.SortedList(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Collections.SortedList.#ctor(System.Collections.IComparer,System.Int32)
  parent: System.Collections.SortedList
  isExternal: false
  name: SortedList(IComparer,Int32)
  nameWithType: SortedList.SortedList(IComparer,Int32)
  fullName: System.Collections.SortedList.SortedList(IComparer,Int32)
- uid: System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)
  parent: System.Collections.SortedList
  isExternal: false
  name: SortedList(IDictionary,IComparer)
  nameWithType: SortedList.SortedList(IDictionary,IComparer)
  fullName: System.Collections.SortedList.SortedList(IDictionary,IComparer)
- uid: System.Collections.SortedList.Add(System.Object,System.Object)
  parent: System.Collections.SortedList
  isExternal: false
  name: Add(Object,Object)
  nameWithType: SortedList.Add(Object,Object)
  fullName: System.Collections.SortedList.Add(Object,Object)
- uid: System.Collections.SortedList.Capacity
  parent: System.Collections.SortedList
  isExternal: false
  name: Capacity
  nameWithType: SortedList.Capacity
  fullName: System.Collections.SortedList.Capacity
- uid: System.Collections.SortedList.Clear
  parent: System.Collections.SortedList
  isExternal: false
  name: Clear()
  nameWithType: SortedList.Clear()
  fullName: System.Collections.SortedList.Clear()
- uid: System.Collections.SortedList.Clone
  parent: System.Collections.SortedList
  isExternal: false
  name: Clone()
  nameWithType: SortedList.Clone()
  fullName: System.Collections.SortedList.Clone()
- uid: System.Collections.SortedList.Contains(System.Object)
  parent: System.Collections.SortedList
  isExternal: false
  name: Contains(Object)
  nameWithType: SortedList.Contains(Object)
  fullName: System.Collections.SortedList.Contains(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Collections.SortedList.ContainsKey(System.Object)
  parent: System.Collections.SortedList
  isExternal: false
  name: ContainsKey(Object)
  nameWithType: SortedList.ContainsKey(Object)
  fullName: System.Collections.SortedList.ContainsKey(Object)
- uid: System.Collections.SortedList.ContainsValue(System.Object)
  parent: System.Collections.SortedList
  isExternal: false
  name: ContainsValue(Object)
  nameWithType: SortedList.ContainsValue(Object)
  fullName: System.Collections.SortedList.ContainsValue(Object)
- uid: System.Collections.SortedList.CopyTo(System.Array,System.Int32)
  parent: System.Collections.SortedList
  isExternal: false
  name: CopyTo(Array,Int32)
  nameWithType: SortedList.CopyTo(Array,Int32)
  fullName: System.Collections.SortedList.CopyTo(Array,Int32)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: System.Collections.SortedList.Count
  parent: System.Collections.SortedList
  isExternal: false
  name: Count
  nameWithType: SortedList.Count
  fullName: System.Collections.SortedList.Count
- uid: System.Collections.SortedList.GetByIndex(System.Int32)
  parent: System.Collections.SortedList
  isExternal: false
  name: GetByIndex(Int32)
  nameWithType: SortedList.GetByIndex(Int32)
  fullName: System.Collections.SortedList.GetByIndex(Int32)
- uid: System.Collections.SortedList.GetEnumerator
  parent: System.Collections.SortedList
  isExternal: false
  name: GetEnumerator()
  nameWithType: SortedList.GetEnumerator()
  fullName: System.Collections.SortedList.GetEnumerator()
- uid: System.Collections.IDictionaryEnumerator
  parent: System.Collections
  isExternal: true
  name: IDictionaryEnumerator
  nameWithType: IDictionaryEnumerator
  fullName: System.Collections.IDictionaryEnumerator
- uid: System.Collections.SortedList.GetKey(System.Int32)
  parent: System.Collections.SortedList
  isExternal: false
  name: GetKey(Int32)
  nameWithType: SortedList.GetKey(Int32)
  fullName: System.Collections.SortedList.GetKey(Int32)
- uid: System.Collections.SortedList.GetKeyList
  parent: System.Collections.SortedList
  isExternal: false
  name: GetKeyList()
  nameWithType: SortedList.GetKeyList()
  fullName: System.Collections.SortedList.GetKeyList()
- uid: System.Collections.IList
  parent: System.Collections
  isExternal: true
  name: IList
  nameWithType: IList
  fullName: System.Collections.IList
- uid: System.Collections.SortedList.GetValueList
  parent: System.Collections.SortedList
  isExternal: false
  name: GetValueList()
  nameWithType: SortedList.GetValueList()
  fullName: System.Collections.SortedList.GetValueList()
- uid: System.Collections.SortedList.IndexOfKey(System.Object)
  parent: System.Collections.SortedList
  isExternal: false
  name: IndexOfKey(Object)
  nameWithType: SortedList.IndexOfKey(Object)
  fullName: System.Collections.SortedList.IndexOfKey(Object)
- uid: System.Collections.SortedList.IndexOfValue(System.Object)
  parent: System.Collections.SortedList
  isExternal: false
  name: IndexOfValue(Object)
  nameWithType: SortedList.IndexOfValue(Object)
  fullName: System.Collections.SortedList.IndexOfValue(Object)
- uid: System.Collections.SortedList.IsFixedSize
  parent: System.Collections.SortedList
  isExternal: false
  name: IsFixedSize
  nameWithType: SortedList.IsFixedSize
  fullName: System.Collections.SortedList.IsFixedSize
- uid: System.Collections.SortedList.IsReadOnly
  parent: System.Collections.SortedList
  isExternal: false
  name: IsReadOnly
  nameWithType: SortedList.IsReadOnly
  fullName: System.Collections.SortedList.IsReadOnly
- uid: System.Collections.SortedList.IsSynchronized
  parent: System.Collections.SortedList
  isExternal: false
  name: IsSynchronized
  nameWithType: SortedList.IsSynchronized
  fullName: System.Collections.SortedList.IsSynchronized
- uid: System.Collections.SortedList.Item(System.Object)
  parent: System.Collections.SortedList
  isExternal: false
  name: Item(Object)
  nameWithType: SortedList.Item(Object)
  fullName: System.Collections.SortedList.Item(Object)
- uid: System.Collections.SortedList.Keys
  parent: System.Collections.SortedList
  isExternal: false
  name: Keys
  nameWithType: SortedList.Keys
  fullName: System.Collections.SortedList.Keys
- uid: System.Collections.ICollection
  parent: System.Collections
  isExternal: true
  name: ICollection
  nameWithType: ICollection
  fullName: System.Collections.ICollection
- uid: System.Collections.SortedList.Remove(System.Object)
  parent: System.Collections.SortedList
  isExternal: false
  name: Remove(Object)
  nameWithType: SortedList.Remove(Object)
  fullName: System.Collections.SortedList.Remove(Object)
- uid: System.Collections.SortedList.RemoveAt(System.Int32)
  parent: System.Collections.SortedList
  isExternal: false
  name: RemoveAt(Int32)
  nameWithType: SortedList.RemoveAt(Int32)
  fullName: System.Collections.SortedList.RemoveAt(Int32)
- uid: System.Collections.SortedList.SetByIndex(System.Int32,System.Object)
  parent: System.Collections.SortedList
  isExternal: false
  name: SetByIndex(Int32,Object)
  nameWithType: SortedList.SetByIndex(Int32,Object)
  fullName: System.Collections.SortedList.SetByIndex(Int32,Object)
- uid: System.Collections.SortedList.Synchronized(System.Collections.SortedList)
  parent: System.Collections.SortedList
  isExternal: false
  name: Synchronized(SortedList)
  nameWithType: SortedList.Synchronized(SortedList)
  fullName: System.Collections.SortedList.Synchronized(SortedList)
- uid: System.Collections.SortedList
  parent: System.Collections
  isExternal: false
  name: SortedList
  nameWithType: SortedList
  fullName: System.Collections.SortedList
- uid: System.Collections.SortedList.SyncRoot
  parent: System.Collections.SortedList
  isExternal: false
  name: SyncRoot
  nameWithType: SortedList.SyncRoot
  fullName: System.Collections.SortedList.SyncRoot
- uid: System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator
  parent: System.Collections.SortedList
  isExternal: false
  name: System.Collections.IEnumerable.GetEnumerator()
  nameWithType: SortedList.System.Collections.IEnumerable.GetEnumerator()
  fullName: System.Collections.SortedList.System.Collections.IEnumerable.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Collections.SortedList.TrimToSize
  parent: System.Collections.SortedList
  isExternal: false
  name: TrimToSize()
  nameWithType: SortedList.TrimToSize()
  fullName: System.Collections.SortedList.TrimToSize()
- uid: System.Collections.SortedList.Values
  parent: System.Collections.SortedList
  isExternal: false
  name: Values
  nameWithType: SortedList.Values
  fullName: System.Collections.SortedList.Values
- uid: System.Collections.SortedList.#ctor*
  parent: System.Collections.SortedList
  isExternal: false
  name: SortedList
  nameWithType: SortedList.SortedList
- uid: System.Collections.SortedList.Add*
  parent: System.Collections.SortedList
  isExternal: false
  name: Add
  nameWithType: SortedList.Add
- uid: System.Collections.SortedList.Capacity*
  parent: System.Collections.SortedList
  isExternal: false
  name: Capacity
  nameWithType: SortedList.Capacity
- uid: System.Collections.SortedList.Clear*
  parent: System.Collections.SortedList
  isExternal: false
  name: Clear
  nameWithType: SortedList.Clear
- uid: System.Collections.SortedList.Clone*
  parent: System.Collections.SortedList
  isExternal: false
  name: Clone
  nameWithType: SortedList.Clone
- uid: System.Collections.SortedList.Contains*
  parent: System.Collections.SortedList
  isExternal: false
  name: Contains
  nameWithType: SortedList.Contains
- uid: System.Collections.SortedList.ContainsKey*
  parent: System.Collections.SortedList
  isExternal: false
  name: ContainsKey
  nameWithType: SortedList.ContainsKey
- uid: System.Collections.SortedList.ContainsValue*
  parent: System.Collections.SortedList
  isExternal: false
  name: ContainsValue
  nameWithType: SortedList.ContainsValue
- uid: System.Collections.SortedList.CopyTo*
  parent: System.Collections.SortedList
  isExternal: false
  name: CopyTo
  nameWithType: SortedList.CopyTo
- uid: System.Collections.SortedList.Count*
  parent: System.Collections.SortedList
  isExternal: false
  name: Count
  nameWithType: SortedList.Count
- uid: System.Collections.SortedList.GetByIndex*
  parent: System.Collections.SortedList
  isExternal: false
  name: GetByIndex
  nameWithType: SortedList.GetByIndex
- uid: System.Collections.SortedList.GetEnumerator*
  parent: System.Collections.SortedList
  isExternal: false
  name: GetEnumerator
  nameWithType: SortedList.GetEnumerator
- uid: System.Collections.SortedList.GetKey*
  parent: System.Collections.SortedList
  isExternal: false
  name: GetKey
  nameWithType: SortedList.GetKey
- uid: System.Collections.SortedList.GetKeyList*
  parent: System.Collections.SortedList
  isExternal: false
  name: GetKeyList
  nameWithType: SortedList.GetKeyList
- uid: System.Collections.SortedList.GetValueList*
  parent: System.Collections.SortedList
  isExternal: false
  name: GetValueList
  nameWithType: SortedList.GetValueList
- uid: System.Collections.SortedList.IndexOfKey*
  parent: System.Collections.SortedList
  isExternal: false
  name: IndexOfKey
  nameWithType: SortedList.IndexOfKey
- uid: System.Collections.SortedList.IndexOfValue*
  parent: System.Collections.SortedList
  isExternal: false
  name: IndexOfValue
  nameWithType: SortedList.IndexOfValue
- uid: System.Collections.SortedList.IsFixedSize*
  parent: System.Collections.SortedList
  isExternal: false
  name: IsFixedSize
  nameWithType: SortedList.IsFixedSize
- uid: System.Collections.SortedList.IsReadOnly*
  parent: System.Collections.SortedList
  isExternal: false
  name: IsReadOnly
  nameWithType: SortedList.IsReadOnly
- uid: System.Collections.SortedList.IsSynchronized*
  parent: System.Collections.SortedList
  isExternal: false
  name: IsSynchronized
  nameWithType: SortedList.IsSynchronized
- uid: System.Collections.SortedList.Item*
  parent: System.Collections.SortedList
  isExternal: false
  name: Item
  nameWithType: SortedList.Item
- uid: System.Collections.SortedList.Keys*
  parent: System.Collections.SortedList
  isExternal: false
  name: Keys
  nameWithType: SortedList.Keys
- uid: System.Collections.SortedList.Remove*
  parent: System.Collections.SortedList
  isExternal: false
  name: Remove
  nameWithType: SortedList.Remove
- uid: System.Collections.SortedList.RemoveAt*
  parent: System.Collections.SortedList
  isExternal: false
  name: RemoveAt
  nameWithType: SortedList.RemoveAt
- uid: System.Collections.SortedList.SetByIndex*
  parent: System.Collections.SortedList
  isExternal: false
  name: SetByIndex
  nameWithType: SortedList.SetByIndex
- uid: System.Collections.SortedList.Synchronized*
  parent: System.Collections.SortedList
  isExternal: false
  name: Synchronized
  nameWithType: SortedList.Synchronized
- uid: System.Collections.SortedList.SyncRoot*
  parent: System.Collections.SortedList
  isExternal: false
  name: SyncRoot
  nameWithType: SortedList.SyncRoot
- uid: System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator*
  parent: System.Collections.SortedList
  isExternal: false
  name: System.Collections.IEnumerable.GetEnumerator
  nameWithType: SortedList.System.Collections.IEnumerable.GetEnumerator
- uid: System.Collections.SortedList.TrimToSize*
  parent: System.Collections.SortedList
  isExternal: false
  name: TrimToSize
  nameWithType: SortedList.TrimToSize
- uid: System.Collections.SortedList.Values*
  parent: System.Collections.SortedList
  isExternal: false
  name: Values
  nameWithType: SortedList.Values
