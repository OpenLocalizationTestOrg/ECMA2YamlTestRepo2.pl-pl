### YamlMime:ManagedReference
items:
- uid: System.Data.Common.DbDataAdapter
  id: DbDataAdapter
  children:
  - System.Data.Common.DbDataAdapter.#ctor
  - System.Data.Common.DbDataAdapter.#ctor(System.Data.Common.DbDataAdapter)
  - System.Data.Common.DbDataAdapter.AddToBatch(System.Data.IDbCommand)
  - System.Data.Common.DbDataAdapter.ClearBatch
  - System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)
  - System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)
  - System.Data.Common.DbDataAdapter.DefaultSourceTableName
  - System.Data.Common.DbDataAdapter.DeleteCommand
  - System.Data.Common.DbDataAdapter.Dispose(System.Boolean)
  - System.Data.Common.DbDataAdapter.ExecuteBatch
  - System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)
  - System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable)
  - System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.String)
  - System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable,System.Data.IDbCommand,System.Data.CommandBehavior)
  - System.Data.Common.DbDataAdapter.Fill(System.Int32,System.Int32,System.Data.DataTable[])
  - System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.Int32,System.Int32,System.String)
  - System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable[],System.Int32,System.Int32,System.Data.IDbCommand,System.Data.CommandBehavior)
  - System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.Int32,System.Int32,System.String,System.Data.IDbCommand,System.Data.CommandBehavior)
  - System.Data.Common.DbDataAdapter.FillCommandBehavior
  - System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)
  - System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType)
  - System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.String)
  - System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType,System.Data.IDbCommand,System.Data.CommandBehavior)
  - System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.Data.IDbCommand,System.String,System.Data.CommandBehavior)
  - System.Data.Common.DbDataAdapter.GetBatchedParameter(System.Int32,System.Int32)
  - System.Data.Common.DbDataAdapter.GetBatchedRecordsAffected(System.Int32,System.Int32@,System.Exception@)
  - System.Data.Common.DbDataAdapter.GetFillParameters
  - System.Data.Common.DbDataAdapter.InitializeBatching
  - System.Data.Common.DbDataAdapter.InsertCommand
  - System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)
  - System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)
  - System.Data.Common.DbDataAdapter.SelectCommand
  - System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#DeleteCommand
  - System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#InsertCommand
  - System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#SelectCommand
  - System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#UpdateCommand
  - System.Data.Common.DbDataAdapter.System#ICloneable#Clone
  - System.Data.Common.DbDataAdapter.TerminateBatching
  - System.Data.Common.DbDataAdapter.Update(System.Data.DataRow[])
  - System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)
  - System.Data.Common.DbDataAdapter.Update(System.Data.DataTable)
  - System.Data.Common.DbDataAdapter.Update(System.Data.DataRow[],System.Data.Common.DataTableMapping)
  - System.Data.Common.DbDataAdapter.Update(System.Data.DataSet,System.String)
  - System.Data.Common.DbDataAdapter.UpdateBatchSize
  - System.Data.Common.DbDataAdapter.UpdateCommand
  langs:
  - csharp
  name: DbDataAdapter
  nameWithType: DbDataAdapter
  fullName: System.Data.Common.DbDataAdapter
  type: Class
  summary: "Ułatwia wykonanie <xref href=&quot;System.Data.IDbDataAdapter&quot;> </xref> interfejsu. Dziedziczenia obiekt DbDataAdapter implementuje zestaw funkcji, aby zapewnić, wpisując silne, ale dziedziczą większość potrzebnych do pełnego wdrożenia funkcji **element DataAdapter**."
  remarks: "Obiekt DbDataAdapter klasa dziedziczy <xref:System.Data.Common.DataAdapter>klasy i pomaga w klasie implementacji **element DataAdapter** przeznaczony do użytku z relacyjnej bazy danych.</xref:System.Data.Common.DataAdapter>       Aplikacja nie tworzy wystąpienie interfejsu obiekt DbDataAdapter bezpośrednio, ale powoduje utworzenie wystąpienia klasy, która dziedziczy <xref:System.Data.IDbDataAdapter>i obiekt DbDataAdapter.</xref:System.Data.IDbDataAdapter>       Klasy, które dziedziczą obiekt DbDataAdapter musi implementować dziedziczone elementy członkowskie i zwykle zdefiniować dodatkowe elementy członkowskie Dodawanie funkcji specyficznych dla dostawcy. Na przykład klasa obiekt DbDataAdapter definiuje <xref:System.Data.IDbDataAdapter.SelectCommand%2A>właściwości oraz interfejs obiekt DbDataAdapter definiuje osiem przeciążeń <xref:System.Data.IDataAdapter.Fill%2A>metody.</xref:System.Data.IDataAdapter.Fill%2A> </xref:System.Data.IDbDataAdapter.SelectCommand%2A> Z kolei <xref:System.Data.OleDb.OleDbDataAdapter>klasa dziedziczy <xref:System.Data.Common.DbDataAdapter.Fill%2A>metody, a także określa dwa dodatkowe przeciążeń <xref:System.Data.OleDb.OleDbDataAdapter.Fill%2A>, które wymagają obiektu zestawu rekordów ADO jako parametr.</xref:System.Data.OleDb.OleDbDataAdapter.Fill%2A> </xref:System.Data.Common.DbDataAdapter.Fill%2A> </xref:System.Data.OleDb.OleDbDataAdapter>"
  syntax:
    content: 'public abstract class DbDataAdapter : System.Data.Common.DataAdapter, ICloneable, System.Data.IDbDataAdapter'
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  - System.Data.Common.DataAdapter
  implements:
  - System.Data.IDbDataAdapter
  - System.ICloneable
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.ComponentModel.Component.ToString
  - System.Data.Common.DataAdapter.AcceptChangesDuringFill
  - System.Data.Common.DataAdapter.AcceptChangesDuringUpdate
  - System.Data.Common.DataAdapter.CloneInternals
  - System.Data.Common.DataAdapter.ContinueUpdateOnError
  - System.Data.Common.DataAdapter.CreateTableMappings
  - System.Data.Common.DataAdapter.Fill(System.Data.DataSet,System.String,System.Data.IDataReader,System.Int32,System.Int32)
  - System.Data.Common.DataAdapter.Fill(System.Data.DataTable,System.Data.IDataReader)
  - System.Data.Common.DataAdapter.Fill(System.Data.DataTable[],System.Data.IDataReader,System.Int32,System.Int32)
  - System.Data.Common.DataAdapter.FillError
  - System.Data.Common.DataAdapter.FillLoadOption
  - System.Data.Common.DataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.String,System.Data.IDataReader)
  - System.Data.Common.DataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType,System.Data.IDataReader)
  - System.Data.Common.DataAdapter.HasTableMappings
  - System.Data.Common.DataAdapter.MissingMappingAction
  - System.Data.Common.DataAdapter.MissingSchemaAction
  - System.Data.Common.DataAdapter.OnFillError(System.Data.FillErrorEventArgs)
  - System.Data.Common.DataAdapter.ResetFillLoadOption
  - System.Data.Common.DataAdapter.ReturnProviderSpecificTypes
  - System.Data.Common.DataAdapter.ShouldSerializeAcceptChangesDuringFill
  - System.Data.Common.DataAdapter.ShouldSerializeFillLoadOption
  - System.Data.Common.DataAdapter.ShouldSerializeTableMappings
  - System.Data.Common.DataAdapter.System#Data#IDataAdapter#TableMappings
  - System.Data.Common.DataAdapter.TableMappings
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.#ctor
  id: '#ctor'
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: DbDataAdapter()
  nameWithType: DbDataAdapter.DbDataAdapter()
  fullName: System.Data.Common.DbDataAdapter.DbDataAdapter()
  type: Constructor
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Inicjuje nowe wystąpienie klasy **element DataAdapter** klasy."
  remarks: "Podczas tworzenia wystąpienia <xref:System.Data.Common.DbDataAdapter>, następujące właściwości odczytu/zapisu są ustawione na następujące wartości początkowej.</xref:System.Data.Common.DbDataAdapter>      | Właściwości | Nieprawidłowa wartość |   |----------------|-------------------|   | <xref:System.Data.IDbDataAdapter.SelectCommand%2A>| Nowe <xref:System.Data.IDbCommand>. |   | <xref:System.Data.IDbDataAdapter.InsertCommand%2A>| Nowe <xref:System.Data.IDbCommand>. |   | <xref:System.Data.IDbDataAdapter.DeleteCommand%2A>| Nowe <xref:System.Data.IDbCommand>. |   | <xref:System.Data.IDbDataAdapter.UpdateCommand%2A>| Nowe <xref:System.Data.IDbCommand>. |   | <xref:System.Data.Common.DataAdapter.MissingMappingAction%2A>| `MissingMappingAction.Passthrough`|   | <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A>| `MissingSchemaAction.Add`|       Można zmienić wartości tych właściwości, za pomocą oddzielnego wywołania do właściwości.</xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> </xref:System.Data.Common.DataAdapter.MissingMappingAction%2A> </xref:System.Data.IDbCommand> </xref:System.Data.IDbDataAdapter.UpdateCommand%2A> </xref:System.Data.IDbCommand> </xref:System.Data.IDbDataAdapter.DeleteCommand%2A> </xref:System.Data.IDbCommand> </xref:System.Data.IDbDataAdapter.InsertCommand%2A> </xref:System.Data.IDbCommand> </xref:System.Data.IDbDataAdapter.SelectCommand%2A>"
  syntax:
    content: protected DbDataAdapter ();
    parameters: []
  overload: System.Data.Common.DbDataAdapter.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.#ctor(System.Data.Common.DbDataAdapter)
  id: '#ctor(System.Data.Common.DbDataAdapter)'
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: DbDataAdapter(DbDataAdapter)
  nameWithType: DbDataAdapter.DbDataAdapter(DbDataAdapter)
  fullName: System.Data.Common.DbDataAdapter.DbDataAdapter(DbDataAdapter)
  type: Constructor
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Inicjuje nowe wystąpienie klasy <xref uid=&quot;langword_csharp_DataAdapter&quot; name=&quot;DataAdapter&quot; href=&quot;&quot;> </xref> klasy z istniejącego obiektu tego samego typu."
  remarks: "To przeciążenie metody <xref:System.Data.Common.DbDataAdapter>Konstruktor jest przeznaczony do użytku przez dostawcę danych .NET Framework podczas wykonywania konstruktora podobne do użycia w klonowania implementacji.</xref:System.Data.Common.DbDataAdapter>"
  syntax:
    content: protected DbDataAdapter (System.Data.Common.DbDataAdapter adapter);
    parameters:
    - id: adapter
      type: System.Data.Common.DbDataAdapter
      description: "A <xref uid=&quot;langword_csharp_DataAdapter&quot; name=&quot;DataAdapter&quot; href=&quot;&quot;> </xref> obiekt używany do tworzenia nowego <xref uid=&quot;langword_csharp_DataAdapter&quot; name=&quot;DataAdapter&quot; href=&quot;&quot;> </xref>."
  overload: System.Data.Common.DbDataAdapter.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.AddToBatch(System.Data.IDbCommand)
  id: AddToBatch(System.Data.IDbCommand)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: AddToBatch(IDbCommand)
  nameWithType: DbDataAdapter.AddToBatch(IDbCommand)
  fullName: System.Data.Common.DbDataAdapter.AddToBatch(IDbCommand)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Dodaje <xref href=&quot;System.Data.IDbCommand&quot;> </xref> do bieżącej partii."
  remarks: "W <xref:System.Data.Common.DbDataAdapter>, ta metoda zgłasza <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.Data.Common.DbDataAdapter> Klasy, które dziedziczą z <xref:System.Data.Common.DbDataAdapter>przesłonić tę metodę, aby zapewnić obsługę dla partii.</xref:System.Data.Common.DbDataAdapter>"
  syntax:
    content: protected virtual int AddToBatch (System.Data.IDbCommand command);
    parameters:
    - id: command
      type: System.Data.IDbCommand
      description: "<xref href=&quot;System.Data.IDbCommand&quot;> </xref> Do dodania do wykonywania zadania wsadowego."
    return:
      type: System.Int32
      description: "Liczba poleceń w partii przed dodaniem <xref href=&quot;System.Data.IDbCommand&quot;> </xref>."
  overload: System.Data.Common.DbDataAdapter.AddToBatch*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Karta nie obsługuje partie."
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.ClearBatch
  id: ClearBatch
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: ClearBatch()
  nameWithType: DbDataAdapter.ClearBatch()
  fullName: System.Data.Common.DbDataAdapter.ClearBatch()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Usuwa wszystkie <xref href=&quot;System.Data.IDbCommand&quot;> </xref> obiektów z partii."
  remarks: "W <xref:System.Data.Common.DbDataAdapter>, ta metoda zgłasza <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.Data.Common.DbDataAdapter> Klasy, które dziedziczą z <xref:System.Data.Common.DbDataAdapter>przesłonić tę metodę, aby zapewnić obsługę dla partii.</xref:System.Data.Common.DbDataAdapter>"
  syntax:
    content: protected virtual void ClearBatch ();
    parameters: []
  overload: System.Data.Common.DbDataAdapter.ClearBatch*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Karta nie obsługuje partie."
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)
  id: CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: CreateRowUpdatedEvent(DataRow,IDbCommand,StatementType,DataTableMapping)
  nameWithType: DbDataAdapter.CreateRowUpdatedEvent(DataRow,IDbCommand,StatementType,DataTableMapping)
  fullName: System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(DataRow,IDbCommand,StatementType,DataTableMapping)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Data.Common.RowUpdatedEventArgs&quot;> </xref> klasy."
  syntax:
    content: protected virtual System.Data.Common.RowUpdatedEventArgs CreateRowUpdatedEvent (System.Data.DataRow dataRow, System.Data.IDbCommand command, System.Data.StatementType statementType, System.Data.Common.DataTableMapping tableMapping);
    parameters:
    - id: dataRow
      type: System.Data.DataRow
      description: "<xref href=&quot;System.Data.DataRow&quot;> </xref> Używana do aktualizowania źródła danych."
    - id: command
      type: System.Data.IDbCommand
      description: "<xref href=&quot;System.Data.IDbCommand&quot;> </xref> Podczas <xref:System.Data.IDataAdapter.Update*>.</xref:System.Data.IDataAdapter.Update*>"
    - id: statementType
      type: System.Data.StatementType
      description: "Polecenie jest dostępna aktualizacja, wstawianie, usuwanie czy instrukcja SELECT."
    - id: tableMapping
      type: System.Data.Common.DataTableMapping
      description: "A <xref href=&quot;System.Data.Common.DataTableMapping&quot;></xref> object."
    return:
      type: System.Data.Common.RowUpdatedEventArgs
      description: "Nowe wystąpienie klasy <xref href=&quot;System.Data.Common.RowUpdatedEventArgs&quot;> </xref> klasy."
  overload: System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)
  id: CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: CreateRowUpdatingEvent(DataRow,IDbCommand,StatementType,DataTableMapping)
  nameWithType: DbDataAdapter.CreateRowUpdatingEvent(DataRow,IDbCommand,StatementType,DataTableMapping)
  fullName: System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(DataRow,IDbCommand,StatementType,DataTableMapping)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Data.Common.RowUpdatingEventArgs&quot;> </xref> klasy."
  syntax:
    content: protected virtual System.Data.Common.RowUpdatingEventArgs CreateRowUpdatingEvent (System.Data.DataRow dataRow, System.Data.IDbCommand command, System.Data.StatementType statementType, System.Data.Common.DataTableMapping tableMapping);
    parameters:
    - id: dataRow
      type: System.Data.DataRow
      description: "<xref href=&quot;System.Data.DataRow&quot;> </xref> Który aktualizacji źródła danych."
    - id: command
      type: System.Data.IDbCommand
      description: "<xref href=&quot;System.Data.IDbCommand&quot;> </xref> Do wykonania podczas <xref:System.Data.IDataAdapter.Update*>.</xref:System.Data.IDataAdapter.Update*>"
    - id: statementType
      type: System.Data.StatementType
      description: "Polecenie jest dostępna aktualizacja, wstawianie, usuwanie czy instrukcja SELECT."
    - id: tableMapping
      type: System.Data.Common.DataTableMapping
      description: "A <xref href=&quot;System.Data.Common.DataTableMapping&quot;></xref> object."
    return:
      type: System.Data.Common.RowUpdatingEventArgs
      description: "Nowe wystąpienie klasy <xref href=&quot;System.Data.Common.RowUpdatingEventArgs&quot;> </xref> klasy."
  overload: System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.DefaultSourceTableName
  id: DefaultSourceTableName
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: DefaultSourceTableName
  nameWithType: DbDataAdapter.DefaultSourceTableName
  fullName: System.Data.Common.DbDataAdapter.DefaultSourceTableName
  type: Field
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Domyślna nazwa używana przez <xref href=&quot;System.Data.Common.DataAdapter&quot;> </xref> obiektu mapowań tabeli."
  remarks: "&quot;Tabela&quot; jest domyślna nazwa używana przez <xref:System.Data.Common.DataAdapter>obiektu dla tabeli mapowania.</xref:System.Data.Common.DataAdapter>       Jest DefaultSourceTableName, gdy aplikacja dodaje mapowania tabeli, ma być używany z <xref:System.Data.Common.DbDataAdapter.Fill%2A>, ale nie określa <xref:System.Data.DataTable>nazwy.</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter.Fill%2A>"
  syntax:
    content: public const string DefaultSourceTableName;
    return:
      type: System.String
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.DeleteCommand
  id: DeleteCommand
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: DeleteCommand
  nameWithType: DbDataAdapter.DeleteCommand
  fullName: System.Data.Common.DbDataAdapter.DeleteCommand
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Pobiera lub ustawia polecenia usuwania rekordów z zestawu danych."
  remarks: "Podczas <xref:System.Data.Common.DbDataAdapter.Update%2A>, jeśli ta właściwość nie jest ustawiona i informacje o kluczu podstawowym znajduje się w <xref:System.Data.DataSet>, <xref:System.Data.IDbDataAdapter.DeleteCommand%2A>jest generowana automatycznie.</xref:System.Data.IDbDataAdapter.DeleteCommand%2A> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Update%2A>"
  example:
  - "The following example creates the derived class <xref:System.Data.OleDb.OleDbDataAdapter> and sets some of its properties.  \n  \n [!code-cs[Classic WebData DbDataAdapter.DeleteCommand Example#1](~/add/codesnippet/csharp/p-system.data.common.dbd_3_1.cs)]\n [!code-vb[Classic WebData DbDataAdapter.DeleteCommand Example#1](~/add/codesnippet/visualbasic/p-system.data.common.dbd_3_1.vb)]"
  syntax:
    content: public System.Data.Common.DbCommand DeleteCommand { get; set; }
    return:
      type: System.Data.Common.DbCommand
      description: "<xref href=&quot;System.Data.IDbCommand&quot;> </xref> Używane podczas <xref:System.Data.IDataAdapter.Update*>usunąć rekordy w źródle danych dla usuniętych wierszy w zestawie danych.</xref:System.Data.IDataAdapter.Update*>"
  overload: System.Data.Common.DbDataAdapter.DeleteCommand*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: DbDataAdapter.Dispose(Boolean)
  fullName: System.Data.Common.DbDataAdapter.Dispose(Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Zwalnia zasoby niezarządzane używane przez <xref href=&quot;System.Data.Common.DbDataAdapter&quot;> </xref> i opcjonalnie zwalnia zasoby zarządzane."
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby zwolnić zasoby zarządzane i niezarządzane; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> aby zwolnić tylko zasoby niezarządzane."
  overload: System.Data.Common.DbDataAdapter.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.ExecuteBatch
  id: ExecuteBatch
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: ExecuteBatch()
  nameWithType: DbDataAdapter.ExecuteBatch()
  fullName: System.Data.Common.DbDataAdapter.ExecuteBatch()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Wykonuje bieżącej partii."
  remarks: "W <xref:System.Data.Common.DbDataAdapter>, ta metoda zgłasza <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.Data.Common.DbDataAdapter> Klasy, które dziedziczą z <xref:System.Data.Common.DbDataAdapter>przesłonić tę metodę, aby zapewnić obsługę dla partii.</xref:System.Data.Common.DbDataAdapter>"
  syntax:
    content: protected virtual int ExecuteBatch ();
    parameters: []
    return:
      type: System.Int32
      description: "Wartość zwrócona przez ostatnie polecenie w partii."
  overload: System.Data.Common.DbDataAdapter.ExecuteBatch*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)
  id: Fill(System.Data.DataSet)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Fill(DataSet)
  nameWithType: DbDataAdapter.Fill(DataSet)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataSet)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Dodaje lub odświeża wierszy w <xref href=&quot;System.Data.DataSet&quot;> </xref>."
  remarks: "Fill — metoda pobiera dane ze źródła danych przy użyciu instrukcji SELECT. <xref:System.Data.IDbConnection>Obiekt skojarzony z polecenie select musi być prawidłowy, ale nie musi być otwarty.</xref:System.Data.IDbConnection> Jeśli <xref:System.Data.IDbConnection>jest zamknięty przed wywołaniem Fill, jest otwarty do pobierania danych i zamykane.</xref:System.Data.IDbConnection> Jeśli połączenie jest otwarte przed wywołaniem Fill, pozostaje otwarty.       Jeśli napotka błąd lub wystąpił wyjątek podczas wypełniania tabel danych, w tabelach danych nadal będą wierszy dodawanych przed wystąpieniem błędu. W pozostałej części operacja została przerwana.       Jeśli polecenie nie zwróci żadnych wierszy, tabele nie są dodawane do <xref:System.Data.DataSet>, i nie jest zgłaszany wyjątek nie.</xref:System.Data.DataSet>       Jeśli <xref:System.Data.Common.DbDataAdapter>obiektu wykryje zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje nazwy kolumn kolejnych przy użyciu wzorca &quot;*columnname*1&quot;, &quot;*columnname*2&quot;,&quot;*columnname*3&quot; i tak dalej.</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter> Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet>zgodnie ze wzorcem &quot;Kolumna1&quot;, &quot;Column2&quot; i tak dalej.</xref:System.Data.DataSet>       Zapytanie określone zwrócona wiele wyników zestawu wyników dla każdego wiersza zwracanie kwerendy znajduje się w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych na wartości do nazwy określonej tabeli (na przykład &quot;Tabela&quot;, &quot;Tabela1&quot;, &quot;Tabela2&quot; i tak dalej). Ponieważ tabela nie jest tworzony dla zapytania, które niezwracanie wierszy, jeśli przetwarzania zapytania insert następuje zapytania select, tabela utworzona do wykonywania zapytania select nosi &quot;Tabela&quot;, ponieważ jest pierwsza utworzona tabela. Aplikacji przy użyciu nazwy kolumn i tabel powinien upewnić się, że nie występują konflikty z tych wzorców nazewnictwa.       Jeśli instrukcja SELECT służące do wypełniania <xref:System.Data.DataSet>zwraca wiele wyników, takich jak partii instrukcji SQL, jeśli jeden z wyników zawiera błąd, wszystkie kolejne wyniki są pomijane i nie są dodawane do <xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataSet>       Podczas wypełnienia przy użyciu kolejnych wywołań, aby odświeżyć zawartość <xref:System.Data.DataSet>, muszą zostać spełnione dwa warunki: 1.</xref:System.Data.DataSet>  Instrukcja SQL powinna być zgodna początkowo używaną do wypełniania <xref:System.Data.DataSet>.</xref:System.Data.DataSet>      2.  **Klucza** informacji o kolumnie musi być obecny.       Jeśli informacje o kluczu podstawowym jest obecny, wszystkie zduplikowane wiersze są uzgadniane i są wyświetlane tylko raz w <xref:System.Data.DataTable>odpowiadającej <xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataTable> Informacje o kluczu podstawowym można konfigurować za pośrednictwem <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, określając <xref:System.Data.DataTable.PrimaryKey%2A>Właściwość <xref:System.Data.DataTable>, albo ustawiając <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A>właściwości `AddWithKey`.</xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.PrimaryKey%2A> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A>       Jeśli `SelectCommand` zwraca wyniki OUTER JOIN `DataAdapter` nie ustawia <xref:System.Data.DataTable.PrimaryKey%2A>wartości wynikowej <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.DataTable.PrimaryKey%2A> Zdefiniuj jawnie klucz podstawowy, aby upewnić się, że zduplikowane wiersze są rozpoznawane poprawnie. Aby uzyskać więcej informacji, zobacz [Definiowanie kluczy podstawowych](~/add/includes/ajax-current-ext-md.md).      > [!NOTE] > Podczas przetwarzania wsadowego instrukcji SQL, które zwracają wiele wartości, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>dla .NET Framework Data Provider for OLE DB pobiera informacje o schemacie dla pierwszego wyniku.</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Aby pobrać informacji o schemacie dla wielu wyników, należy użyć wypełnienia z <xref:System.Data.MissingSchemaAction>ustawioną `AddWithKey`.</xref:System.Data.MissingSchemaAction>"
  syntax:
    content: public override int Fill (System.Data.DataSet dataSet);
    parameters:
    - id: dataSet
      type: System.Data.DataSet
      description: "A <xref href=&quot;System.Data.DataSet&quot;> </xref> umożliwia wypełnienie rekordów i w razie potrzeby schematu."
    return:
      type: System.Int32
      description: "Liczba wierszy pomyślnie dodane do lub odświeżenia w <xref href=&quot;System.Data.DataSet&quot;> </xref>. Nie zawiera wierszy objętych instrukcji, które niezwracanie wierszy."
  overload: System.Data.Common.DbDataAdapter.Fill*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable)
  id: Fill(System.Data.DataTable)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Fill(DataTable)
  nameWithType: DbDataAdapter.Fill(DataTable)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataTable)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Dodaje lub odświeża wierszy w określonym zakresie w <xref href=&quot;System.Data.DataSet&quot;> </xref> do odpowiadają źródła danych przy użyciu <xref href=&quot;System.Data.DataTable&quot;> </xref> nazwy."
  remarks: "<xref:System.Data.Common.DbDataAdapter.Fill%2A>Metoda pobiera wierszy ze źródła danych przy użyciu instrukcji SELECT określonego przez skojarzony <xref:System.Data.IDbDataAdapter.SelectCommand%2A>Właściwości.</xref:System.Data.IDbDataAdapter.SelectCommand%2A> </xref:System.Data.Common.DbDataAdapter.Fill%2A> Obiekt połączenia skojarzony z instrukcją SELECT musi być prawidłowy, ale nie musi być otwarty. Jeśli połączenie jest zamknięte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A>jest wywoływana, jest otwarta do pobierania danych, następnie zamknięte.</xref:System.Data.Common.DbDataAdapter.Fill%2A> Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A>jest wywoływana, pozostaje otwarty.</xref:System.Data.Common.DbDataAdapter.Fill%2A>       <xref:System.Data.Common.DbDataAdapter.Fill%2A>Operacji następnie dodaje wiersze do miejsca docelowego <xref:System.Data.DataTable>obiekty w <xref:System.Data.DataSet>, tworzenie <xref:System.Data.DataTable>obiekty, jeśli nie już istnieją.</xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter.Fill%2A> Podczas tworzenia <xref:System.Data.DataTable>obiektów, <xref:System.Data.Common.DbDataAdapter.Fill%2A>operacji zwykle tworzy tylko metadane nazwy kolumny.</xref:System.Data.Common.DbDataAdapter.Fill%2A> </xref:System.Data.DataTable> Jednak jeśli <xref:System.Data.IDataAdapter.MissingSchemaAction%2A>właściwość jest ustawiona na `AddWithKey`, również są tworzone odpowiednie klucze podstawowe i ograniczeń.</xref:System.Data.IDataAdapter.MissingSchemaAction%2A>       Jeśli <xref:System.Data.Common.DbDataAdapter>napotka zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje nazwy dla kolejnych kolumn, używania wzorca &quot;*columnname*1&quot;, &quot;*columnname*2&quot;,&quot;*columnname*3&quot; i tak dalej.</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter> Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet>zgodnie ze wzorcem &quot;Kolumna1&quot;, &quot;Column2&quot; i tak dalej.</xref:System.Data.DataSet> Jeśli wiele zestawów wyników są dodawane do <xref:System.Data.DataSet>Każdy zestaw wyników znajduje się w osobnej tabeli.</xref:System.Data.DataSet>       Przeciążenia <xref:System.Data.Common.DbDataAdapter.Fill%2A>pobierającej `DataTable` jako parametr tylko uzyskuje pierwszego wyniku.</xref:System.Data.Common.DbDataAdapter.Fill%2A> Użyj przeciążenia <xref:System.Data.Common.DbDataAdapter.Fill%2A>pobierającej `DataSet` jako parametr uzyskanie wiele wyników.</xref:System.Data.Common.DbDataAdapter.Fill%2A>       <xref:System.Data.Common.DbDataAdapter.Fill%2A>Metoda obsługuje scenariusze gdzie <xref:System.Data.DataSet>zawiera wiele <xref:System.Data.DataTable>obiektów, których nazwy różnią się tylko wielkością liter.</xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Fill%2A> W takich sytuacjach <xref:System.Data.Common.DbDataAdapter.Fill%2A>przeprowadza porównanie uwzględniające wielkość liter można znaleźć odpowiedniej tabeli, a następnie tworzy nową tabelę, jeśli istnieje dokładnego dopasowania.</xref:System.Data.Common.DbDataAdapter.Fill%2A> Poniższy kod C# ilustruje to zachowanie.      ```   DataSet dataset = new DataSet();    dataset.Tables.Add(&quot;aaa&quot;);    dataset.Tables.Add(&quot;AAA&quot;);    adapter.Fill(dataset, &quot;aaa&quot;); // Fills &quot;aaa&quot;, which already exists in the DataSet.       adapter.Fill(dataset, &quot;Aaa&quot;); // Adds a new table called &quot;Aaa&quot;.   ```Jeśli <xref:System.Data.Common.DbDataAdapter.Fill%2A>nosi nazwę i <xref:System.Data.DataSet>zawiera tylko jeden <xref:System.Data.DataTable>o nazwie różni się tylko wielkością liter, która <xref:System.Data.DataTable>jest aktualizowany.</xref:System.Data.DataTable> </xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Fill%2A> W tym scenariuszu wynik porównania ma bez uwzględniania wielkości liter. Poniższy kod C# ilustruje to zachowanie.      ```   DataSet dataset = new DataSet();    dataset.Tables.Add(&quot;aaa&quot;);       adapter.Fill(dataset, &quot;AAA&quot;); // Fills table &quot;aaa&quot; because only one similarly named table is in the DataSet.   ```Można użyć <xref:System.Data.Common.DbDataAdapter.Fill%2A>metody wiele razy w tym samym <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter.Fill%2A> Jeśli klucz podstawowy istnieje, przychodzących wierszy są scalane z pasujących wierszy, które już istnieją. Jeśli klucz podstawowy istnieje, przychodzących wierszy są dołączane do <xref:System.Data.DataTable>.</xref:System.Data.DataTable>       Jeśli `SelectCommand` zwraca wyniki OUTER JOIN `DataAdapter` nie ustawia <xref:System.Data.DataTable.PrimaryKey%2A>wartości wynikowej <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.DataTable.PrimaryKey%2A> Zdefiniuj jawnie klucz podstawowy, aby upewnić się, że zduplikowane wiersze są rozpoznawane poprawnie. Aby uzyskać więcej informacji, zobacz [Definiowanie kluczy podstawowych](~/add/includes/ajax-current-ext-md.md).      > [!NOTE] > Podczas przetwarzania wsadowego instrukcji SQL, które zwracają wiele wartości, wykonania <xref:System.Data.Common.DbDataAdapter.Fill%2A>i <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>dostawcy danych .NET Framework pobiera informacje o schemacie dla pierwszego wyniku.</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> </xref:System.Data.Common.DbDataAdapter.Fill%2A>"
  syntax:
    content: public int Fill (System.Data.DataTable dataTable);
    parameters:
    - id: dataTable
      type: System.Data.DataTable
      description: "Nazwa <xref href=&quot;System.Data.DataTable&quot;> </xref> do użycia na potrzeby mapowania tabeli."
    return:
      type: System.Int32
      description: "Liczba wierszy pomyślnie dodane do lub odświeżenia w <xref href=&quot;System.Data.DataSet&quot;> </xref>. Nie zawiera wierszy objętych instrukcji, które niezwracanie wierszy."
  overload: System.Data.Common.DbDataAdapter.Fill*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Tabela źródłowa jest nieprawidłowa."
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.String)
  id: Fill(System.Data.DataSet,System.String)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Fill(DataSet,String)
  nameWithType: DbDataAdapter.Fill(DataSet,String)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataSet,String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Dodaje lub odświeża wierszy w <xref href=&quot;System.Data.DataSet&quot;> </xref> do odpowiadają źródła danych przy użyciu <xref href=&quot;System.Data.DataSet&quot;> </xref> i <xref href=&quot;System.Data.DataTable&quot;> </xref> nazwy."
  remarks: "<xref:System.Data.Common.DbDataAdapter.Fill%2A>Metoda pobiera dane ze źródła danych przy użyciu instrukcji SELECT.</xref:System.Data.Common.DbDataAdapter.Fill%2A> <xref:System.Data.IDbConnection>Obiekt skojarzony z polecenie select musi być prawidłowy, ale nie musi być otwarty.</xref:System.Data.IDbConnection> Jeśli <xref:System.Data.IDbConnection>jest zamknięty przed <xref:System.Data.Common.DbDataAdapter.Fill%2A>jest wywoływana, jest otwarta do pobierania danych, następnie zamknięte.</xref:System.Data.Common.DbDataAdapter.Fill%2A> </xref:System.Data.IDbConnection> Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A>jest wywoływana, pozostaje otwarty.</xref:System.Data.Common.DbDataAdapter.Fill%2A>       Jeśli polecenie nie zwróci żadnych wierszy, tabele nie są dodawane do <xref:System.Data.DataSet>, i nie jest zgłaszany wyjątek nie.</xref:System.Data.DataSet>       Jeśli <xref:System.Data.Common.DbDataAdapter>obiektu wykryje zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, spowoduje wygenerowanie nazw dla kolejnych kolumn, za pomocą wzorca &quot;nazwakolumny1&quot;, &quot;nazwakolumny2&quot;, &quot;columnname3&quot; i tak dalej.</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter> Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet>zgodnie ze wzorcem &quot;Kolumna1&quot;, &quot;Column2&quot; i tak dalej.</xref:System.Data.DataSet>       Zapytanie określone zwraca wiele wyników, każdy zestaw wyników jest umieszczany w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych na wartości do nazwy określonej tabeli (na przykład &quot;Tabela&quot;, &quot;Tabela1&quot;, &quot;Tabela2&quot; i tak dalej). Ponieważ nie tabela została utworzona dla zapytania, która nie zwraca wiersze, jeśli zostały do przetworzenia zapytania insert następuje zapytania select, tabela utworzona do wykonywania zapytania select będą miały postać &quot;Tabela&quot;, ponieważ jest pierwsza utworzona tabela. Aplikacji przy użyciu nazwy kolumn i tabel powinien upewnić się, że nie występują konflikty z tych wzorców nazewnictwa.       <xref:System.Data.Common.DbDataAdapter.Fill%2A>Metoda obsługuje scenariusze gdzie <xref:System.Data.DataSet>zawiera wiele <xref:System.Data.DataTable>obiektów, których nazwy różnią się tylko wielkością liter.</xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Fill%2A> W takich sytuacjach <xref:System.Data.Common.DbDataAdapter.Fill%2A>przeprowadza porównanie uwzględniające wielkość liter można znaleźć odpowiedniej tabeli, a następnie tworzy nową tabelę, jeśli istnieje dokładnego dopasowania.</xref:System.Data.Common.DbDataAdapter.Fill%2A> Poniższy kod C# ilustruje to zachowanie.      ```   DataSet dataset = new DataSet();   dataset.Tables.Add(&quot;aaa&quot;);   dataset.Tables.Add(&quot;AAA&quot;);   adapter.Fill(dataset, &quot;aaa&quot;); // Fills &quot;aaa&quot;, which already exists in the DataSet.   adapter.Fill(dataset, &quot;Aaa&quot;); // Adds a new table called &quot;Aaa&quot;.   ```Jeśli <xref:System.Data.Common.DbDataAdapter.Fill%2A>nosi nazwę i <xref:System.Data.DataSet>zawiera tylko jeden <xref:System.Data.DataTable>o nazwie różni się tylko wielkością liter, która <xref:System.Data.DataTable>jest aktualizowany.</xref:System.Data.DataTable> </xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Fill%2A> W tym scenariuszu wynik porównania ma bez uwzględniania wielkości liter. Poniższy kod C# ilustruje to zachowanie.      ```   DataSet dataset = new DataSet();   dataset.Tables.Add(&quot;aaa&quot;);   adapter.Fill(dataset, &quot;AAA&quot;); // Fills table &quot;aaa&quot; because only one similarly named table is in the DataSet.   ```Jeśli napotka błąd lub wystąpił wyjątek podczas wypełniania tabel danych, w tabelach danych nadal będą wierszy dodawanych przed wystąpieniem błędu. W pozostałej części operacja została przerwana.       Jeśli instrukcja SELECT służące do wypełniania <xref:System.Data.DataSet>zwraca wiele wyników, takie jak partii instrukcji SQL, należy pamiętać o następujących:-Jeśli jeden z wyników zawiera błąd, wszystkie kolejne wyniki są pominięty i nie zostały dodane do <xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataSet>       Korzystając z kolejnych <xref:System.Data.Common.DbDataAdapter.Fill%2A>wywołań, aby odświeżyć zawartość <xref:System.Data.DataSet>, muszą zostać spełnione dwa warunki: 1.</xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Fill%2A>  Instrukcja SQL powinna być zgodna początkowo używaną do wypełniania <xref:System.Data.DataSet>.</xref:System.Data.DataSet>      2.  **Klucza** informacji o kolumnie musi być obecny. Jeśli informacje o kluczu podstawowym jest obecny, wszystkie zduplikowane wiersze są uzgadniane i są wyświetlane tylko raz w <xref:System.Data.DataTable>odpowiadającej <xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataTable> Informacje o kluczu podstawowym można konfigurować za pośrednictwem <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, określając <xref:System.Data.DataTable.PrimaryKey%2A>Właściwość <xref:System.Data.DataTable>, albo ustawiając <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A>właściwości `AddWithKey`.</xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.PrimaryKey%2A> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A>       Jeśli `SelectCommand` zwraca wyniki OUTER JOIN `DataAdapter` nie ustawia <xref:System.Data.DataTable.PrimaryKey%2A>wartości wynikowej <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.DataTable.PrimaryKey%2A> Zdefiniuj jawnie klucz podstawowy, aby upewnić się, że zduplikowane wiersze są rozpoznawane poprawnie. Aby uzyskać więcej informacji, zobacz[Definiowanie kluczy podstawowych](~/add/includes/ajax-current-ext-md.md).      > [!NOTE] > Podczas przetwarzania wsadowego instrukcji SQL, które zwracają wiele wartości, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>dla .NET Framework Data Provider for OLE DB pobiera informacje o schemacie dla pierwszego wyniku.</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A>z <xref:System.Data.MissingSchemaAction>ustawioną `AddWithKey`.</xref:System.Data.MissingSchemaAction> </xref:System.Data.Common.DbDataAdapter.Fill%2A>"
  example:
  - "The following example uses the derived class, <xref:System.Data.OleDb.OleDbDataAdapter>, to fill a <xref:System.Data.DataSet> with rows from the categories table. This example assumes that you have created an <xref:System.Data.OleDb.OleDbDataAdapter> and a <xref:System.Data.DataSet>.  \n  \n [!code-vb[Classic WebData DbDataAdapter.Fill2 Example#1](~/add/codesnippet/visualbasic/m-system.data.common.dbd_3_1.vb)]\n [!code-cs[Classic WebData DbDataAdapter.Fill2 Example#1](~/add/codesnippet/csharp/m-system.data.common.dbd_3_1.cs)]"
  syntax:
    content: public int Fill (System.Data.DataSet dataSet, string srcTable);
    parameters:
    - id: dataSet
      type: System.Data.DataSet
      description: "A <xref href=&quot;System.Data.DataSet&quot;> </xref> umożliwia wypełnienie rekordów i w razie potrzeby schematu."
    - id: srcTable
      type: System.String
      description: "Nazwa tabeli źródłowej na potrzeby mapowania tabeli."
    return:
      type: System.Int32
      description: "Liczba wierszy pomyślnie dodane do lub odświeżenia w <xref href=&quot;System.Data.DataSet&quot;> </xref>. Nie zawiera wierszy objętych instrukcji, które niezwracanie wierszy."
  overload: System.Data.Common.DbDataAdapter.Fill*
  exceptions:
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Tabela źródłowa jest nieprawidłowa."
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable,System.Data.IDbCommand,System.Data.CommandBehavior)
  id: Fill(System.Data.DataTable,System.Data.IDbCommand,System.Data.CommandBehavior)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Fill(DataTable,IDbCommand,CommandBehavior)
  nameWithType: DbDataAdapter.Fill(DataTable,IDbCommand,CommandBehavior)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataTable,IDbCommand,CommandBehavior)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Dodaje lub odświeża wierszy w <xref href=&quot;System.Data.DataTable&quot;> </xref> zgodnie z regułami w źródle danych przy użyciu określonego <xref href=&quot;System.Data.DataTable&quot;> </xref>, <xref href=&quot;System.Data.IDbCommand&quot;> </xref> i <xref href=&quot;System.Data.CommandBehavior&quot;> </xref>."
  remarks: "<xref:System.Data.Common.DbDataAdapter.Fill%2A>Metoda pobiera wierszy ze źródła danych przy użyciu instrukcji SELECT określonego przez skojarzony <xref:System.Data.IDbDataAdapter.SelectCommand%2A>Właściwości.</xref:System.Data.IDbDataAdapter.SelectCommand%2A> </xref:System.Data.Common.DbDataAdapter.Fill%2A> Obiekt połączenia skojarzony z instrukcją SELECT musi być prawidłowy, ale nie musi być otwarty. Jeśli połączenie jest zamknięte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A>jest wywoływana, jest otwarty do pobierania danych i zamykane.</xref:System.Data.Common.DbDataAdapter.Fill%2A> Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A>jest wywoływana, pozostaje otwarty.</xref:System.Data.Common.DbDataAdapter.Fill%2A>       <xref:System.Data.Common.DbDataAdapter.Fill%2A>Operacji następnie dodaje wiersze do określonej lokalizacji docelowej <xref:System.Data.DataTable>obiektu w <xref:System.Data.DataSet>, tworzenie <xref:System.Data.DataTable>obiektu, jeśli go jeszcze nie istnieje.</xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter.Fill%2A> Podczas tworzenia <xref:System.Data.DataTable>obiektu <xref:System.Data.Common.DbDataAdapter.Fill%2A>operacji zwykle tworzy tylko metadane nazwy kolumny.</xref:System.Data.Common.DbDataAdapter.Fill%2A> </xref:System.Data.DataTable> Jednak jeśli <xref:System.Data.IDataAdapter.MissingSchemaAction%2A>właściwość jest ustawiona na `AddWithKey`, również są tworzone odpowiednie klucze podstawowe i ograniczeń.</xref:System.Data.IDataAdapter.MissingSchemaAction%2A>       Jeśli <xref:System.Data.Common.DbDataAdapter>obiektu wykryje zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, spowoduje wygenerowanie nazw dla kolejnych kolumn, używania wzorca &quot;*columnname*1&quot;, &quot;*columnname*2&quot;,&quot;*columnname*3&quot; i tak dalej.</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter> Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet>zgodnie ze wzorcem &quot;Kolumna1&quot;, &quot;Column2&quot; i tak dalej.</xref:System.Data.DataSet>       Przeciążenia <xref:System.Data.Common.DbDataAdapter.Fill%2A>pobierającej `DataTable` jako parametr tylko uzyskuje pierwszego wyniku.</xref:System.Data.Common.DbDataAdapter.Fill%2A> Użyj przeciążenia <xref:System.Data.Common.DbDataAdapter.Fill%2A>pobierającej `DataSet` jako parametr uzyskanie wiele wyników.</xref:System.Data.Common.DbDataAdapter.Fill%2A>       Można użyć <xref:System.Data.Common.DbDataAdapter.Fill%2A>metody wiele razy w tym samym <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter.Fill%2A> Jeśli klucz podstawowy istnieje, przychodzących wierszy są scalane z pasujących wierszy, które już istnieją. Jeśli klucz podstawowy istnieje, przychodzących wierszy są dołączane do <xref:System.Data.DataTable>.</xref:System.Data.DataTable>       Jeśli `SelectCommand` zwraca wyniki OUTER JOIN `DataAdapter` nie ustawia <xref:System.Data.DataTable.PrimaryKey%2A>wartości wynikowej <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.DataTable.PrimaryKey%2A> Zdefiniuj jawnie klucz podstawowy, aby upewnić się, że zduplikowane wiersze są rozpoznawane poprawnie. Aby uzyskać więcej informacji, zobacz [Definiowanie kluczy podstawowych](~/add/includes/ajax-current-ext-md.md).      > [!NOTE] > Podczas przetwarzania wsadowego instrukcji SQL, które zwracają wiele wartości, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>dla .NET Framework Data Provider for OLE DB pobiera informacje o schemacie dla pierwszego wyniku.</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A>z <xref:System.Data.MissingSchemaAction>ustawioną `AddWithKey`.</xref:System.Data.MissingSchemaAction> </xref:System.Data.Common.DbDataAdapter.Fill%2A>"
  syntax:
    content: protected virtual int Fill (System.Data.DataTable dataTable, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);
    parameters:
    - id: dataTable
      type: System.Data.DataTable
      description: "A <xref href=&quot;System.Data.DataTable&quot;> </xref> umożliwia wypełnienie rekordów i w razie potrzeby schematu."
    - id: command
      type: System.Data.IDbCommand
      description: "W instrukcji SQL SELECT używane do pobierania wierszy ze źródła danych."
    - id: behavior
      type: System.Data.CommandBehavior
      description: "Jeden z <xref href=&quot;System.Data.CommandBehavior&quot;> </xref> wartości."
    return:
      type: System.Int32
      description: "Liczba wierszy pomyślnie dodane do lub odświeżenia w <xref href=&quot;System.Data.DataTable&quot;> </xref>. Nie zawiera wierszy objętych instrukcji, które niezwracanie wierszy."
  overload: System.Data.Common.DbDataAdapter.Fill*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Fill(System.Int32,System.Int32,System.Data.DataTable[])
  id: Fill(System.Int32,System.Int32,System.Data.DataTable[])
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Fill(Int32,Int32,DataTable[])
  nameWithType: DbDataAdapter.Fill(Int32,Int32,DataTable[])
  fullName: System.Data.Common.DbDataAdapter.Fill(Int32,Int32,DataTable[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Dodaje lub odświeża wierszy w <xref href=&quot;System.Data.DataTable&quot;> </xref> zgodnie z regułami w źródle danych, zaczynając od określonego rekordu i pobierania maksymalnie określoną maksymalną liczbę rekordów."
  remarks: "<xref:System.Data.Common.DataAdapter.Fill%2A>Metoda pobiera wierszy ze źródła danych przy użyciu instrukcji SELECT określonego przez skojarzony <xref:System.Data.IDbDataAdapter.SelectCommand%2A>Właściwości.</xref:System.Data.IDbDataAdapter.SelectCommand%2A> </xref:System.Data.Common.DataAdapter.Fill%2A> Obiekt połączenia skojarzony z instrukcją SELECT musi być prawidłowy, ale nie musi być otwarty. Jeśli połączenie jest zamknięte przed <xref:System.Data.Common.DataAdapter.Fill%2A>jest wywoływana, jest otwarty do pobierania danych, a następnie jest ono zamknięte.</xref:System.Data.Common.DataAdapter.Fill%2A> Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DataAdapter.Fill%2A>jest wywoływana, pozostaje otwarty.</xref:System.Data.Common.DataAdapter.Fill%2A>       <xref:System.Data.Common.DataAdapter.Fill%2A>Operacji następnie dodaje wiersze do miejsca docelowego <xref:System.Data.DataTable>obiekty w <xref:System.Data.DataSet>, tworzenie <xref:System.Data.DataTable>obiekty, jeśli nie już istnieją.</xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.DataTable> </xref:System.Data.Common.DataAdapter.Fill%2A> Podczas tworzenia <xref:System.Data.DataTable>obiektów, <xref:System.Data.Common.DataAdapter.Fill%2A>operacji zwykle tworzy tylko metadane nazwy kolumny.</xref:System.Data.Common.DataAdapter.Fill%2A> </xref:System.Data.DataTable> Jednak jeśli <xref:System.Data.IDataAdapter.MissingSchemaAction%2A>właściwość jest ustawiona na `AddWithKey`, również są tworzone odpowiednie klucze podstawowe i ograniczeń.</xref:System.Data.IDataAdapter.MissingSchemaAction%2A>       Jeśli `SelectCommand` zwraca wyniki OUTER JOIN `DataAdapter` nie ustawia <xref:System.Data.DataTable.PrimaryKey%2A>wartości wynikowej <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.DataTable.PrimaryKey%2A> Zdefiniuj jawnie klucz podstawowy, aby upewnić się, że zduplikowane wiersze są rozpoznawane poprawnie. Aby uzyskać więcej informacji, zobacz [Definiowanie kluczy podstawowych](~/add/includes/ajax-current-ext-md.md).       Jeśli adapter danych napotka zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje nazw dla kolejnych kolumn, za pomocą wzorca &quot;nazwakolumny1&quot;, &quot;nazwakolumny2&quot;, &quot;columnname3&quot; i tak dalej.</xref:System.Data.DataTable> Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet>zgodnie ze wzorcem &quot;Kolumna1&quot;, &quot;Column2&quot; i tak dalej.</xref:System.Data.DataSet> Jeśli wiele zestawów wyników są dodawane do <xref:System.Data.DataSet>, każdy zestaw wyników znajduje się w osobnej tabeli.</xref:System.Data.DataSet> Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych na wartości do nazwy określonej tabeli (na przykład &quot;Tabela&quot;, &quot;Tabela1&quot;, &quot;Tabela2&quot; i tak dalej). Aplikacji przy użyciu nazwy kolumn i tabel powinien upewnić się, że nie występują konflikty z tych wzorców nazewnictwa.       Jeśli instrukcja SELECT służące do wypełniania <xref:System.Data.DataSet>zwraca wiele wyników, takich jak partii instrukcji SQL, jeśli jeden z wyników zawiera błąd, wszystkie kolejne wyniki są pominięty i nie zostały dodane do <xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataSet>       Można użyć <xref:System.Data.Common.DataAdapter.Fill%2A>metody wiele razy w tym samym <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.Common.DataAdapter.Fill%2A> Jeśli klucz podstawowy istnieje, przychodzących wierszy są scalane z pasujących wierszy, które już istnieją. Jeśli klucz podstawowy istnieje, przychodzących wierszy są dołączane do <xref:System.Data.DataTable>.</xref:System.Data.DataTable>      > [!NOTE] > Podczas przetwarzania wsadowego instrukcji SQL, które zwracają wiele wartości, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>dla .NET Framework Data Provider for OLE DB pobiera informacje o schemacie dla pierwszego wyniku.</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A>z <xref:System.Data.MissingSchemaAction>ustawioną `AddWithKey`.</xref:System.Data.MissingSchemaAction> </xref:System.Data.Common.DbDataAdapter.Fill%2A>"
  syntax:
    content: public int Fill (int startRecord, int maxRecords, System.Data.DataTable[] dataTables);
    parameters:
    - id: startRecord
      type: System.Int32
      description: "Liczony od zera numer rekordu zaczynać."
    - id: maxRecords
      type: System.Int32
      description: "Maksymalna liczba rekordów do pobrania."
    - id: dataTables
      type: System.Data.DataTable[]
      description: "<xref href=&quot;System.Data.DataTable&quot;> </xref> Obiektów, aby wypełnić ze źródła danych."
    return:
      type: System.Int32
      description: "Liczba wierszy pomyślnie dodane do lub odświeżenia w <xref href=&quot;System.Data.DataTable&quot;> </xref>. Ta wartość nie zawiera wierszy objętych instrukcji, które niezwracanie wierszy."
  overload: System.Data.Common.DbDataAdapter.Fill*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.Int32,System.Int32,System.String)
  id: Fill(System.Data.DataSet,System.Int32,System.Int32,System.String)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Fill(DataSet,Int32,Int32,String)
  nameWithType: DbDataAdapter.Fill(DataSet,Int32,Int32,String)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataSet,Int32,Int32,String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Dodaje lub odświeża wierszy w określonym zakresie w <xref href=&quot;System.Data.DataSet&quot;> </xref> do odpowiadają źródła danych przy użyciu <xref href=&quot;System.Data.DataSet&quot;> </xref> i <xref href=&quot;System.Data.DataTable&quot;> </xref> nazwy."
  remarks: "A `maxRecords` wszystkie rekordy po rekord początkowy pobiera wartość 0. Jeśli `maxRecords` jest większa niż liczba pozostałych wierszy tylko pozostałe wiersze są zwracane, a błąd nie jest wystawiany.       Jeśli odpowiednie polecenie select jest zwracania wyników wiele instrukcji <xref:System.Data.Common.DbDataAdapter.Fill%2A>dotyczy tylko `maxRecords` do pierwszego wyniku.</xref:System.Data.Common.DbDataAdapter.Fill%2A>       <xref:System.Data.Common.DbDataAdapter.Fill%2A>Metoda pobiera dane ze źródła danych przy użyciu instrukcji SELECT.</xref:System.Data.Common.DbDataAdapter.Fill%2A> <xref:System.Data.IDbConnection>Obiekt skojarzony z instrukcją SELECT musi być prawidłowy, ale nie musi być otwarty.</xref:System.Data.IDbConnection> Jeśli <xref:System.Data.IDbConnection>jest zamknięty przed <xref:System.Data.Common.DbDataAdapter.Fill%2A>jest wywoływana, jest otwarty do pobierania danych i zamykane.</xref:System.Data.Common.DbDataAdapter.Fill%2A> </xref:System.Data.IDbConnection> Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A>jest wywoływana, pozostaje otwarty.</xref:System.Data.Common.DbDataAdapter.Fill%2A>       Jeśli polecenie nie zwróci żadnych wierszy, tabele nie są dodawane do <xref:System.Data.DataSet>, ale nie wystąpił wyjątek.</xref:System.Data.DataSet>       Jeśli <xref:System.Data.Common.DbDataAdapter>obiektu wykryje zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, spowoduje wygenerowanie nazw dla kolejnych kolumn, używania wzorca &quot;*columnname*1&quot;, &quot;*columnname*2&quot;,&quot;*columnname*3&quot; i tak dalej.</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter> Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet>zgodnie ze wzorcem &quot;Kolumna1&quot;, &quot;Column2&quot; i tak dalej.</xref:System.Data.DataSet>       Zapytanie określone zwraca wiele wyników, każdy zestaw wyników jest umieszczany w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych na wartości do nazwy określonej tabeli (na przykład &quot;Tabela&quot;, &quot;Tabela1&quot;, &quot;Tabela2&quot; i tak dalej). Ponieważ tabela nie jest tworzony dla zapytania, które niezwracanie wierszy, jeśli przetwarzania zapytania insert następuje zapytania select, tabela utworzona do wykonywania zapytania select jest o nazwie &quot;Tabela&quot;, ponieważ jest pierwsza utworzona tabela. Aplikacji przy użyciu nazwy kolumn i tabel powinien upewnić się, że nie występują konflikty z tych wzorców nazewnictwa.       <xref:System.Data.Common.DbDataAdapter.Fill%2A>Metoda obsługuje scenariusze gdzie <xref:System.Data.DataSet>zawiera wiele <xref:System.Data.DataTable>obiektów, których nazwy różnią się tylko wielkością liter.</xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Fill%2A> W takich sytuacjach <xref:System.Data.Common.DbDataAdapter.Fill%2A>przeprowadza porównanie uwzględniające wielkość liter można znaleźć odpowiedniej tabeli, a następnie tworzy nową tabelę, jeśli istnieje dokładnego dopasowania.</xref:System.Data.Common.DbDataAdapter.Fill%2A> Poniższy kod C# ilustruje to zachowanie.      ```   DataSet dataset = new DataSet();   dataset.Tables.Add(&quot;aaa&quot;);   dataset.Tables.Add(&quot;AAA&quot;);   adapter.Fill(dataset, &quot;aaa&quot;); // Fills &quot;aaa&quot;, which already exists in the DataSet.   adapter.Fill(dataset, &quot;Aaa&quot;); // Adds a new table called &quot;Aaa&quot;.   ```Jeśli <xref:System.Data.Common.DbDataAdapter.Fill%2A>nosi nazwę i <xref:System.Data.DataSet>zawiera tylko jeden <xref:System.Data.DataTable>o nazwie różni się tylko wielkością liter, która <xref:System.Data.DataTable>jest aktualizowany.</xref:System.Data.DataTable> </xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Fill%2A> W tym scenariuszu wynik porównania ma bez uwzględniania wielkości liter. Poniższy kod C# ilustruje to zachowanie.      ```   DataSet dataset = new DataSet();   dataset.Tables.Add(&quot;aaa&quot;);   adapter.Fill(dataset, &quot;AAA&quot;); // Fills table &quot;aaa&quot; because only one similarly named table is in the DataSet.   ```Jeśli napotka błąd lub wystąpił wyjątek podczas wypełniania tabel danych, w tabelach danych nadal będą wierszy dodawanych przed wystąpieniem błędu. W pozostałej części operacja została przerwana.       Jeśli instrukcja SELECT służące do wypełniania <xref:System.Data.DataSet>zwraca wiele wyników, takich jak partii instrukcji SQL, należy pamiętać o następujących: - podczas przetwarzania wiele wyników z partii instrukcji SQL `maxRecords` ma zastosowanie tylko do pierwszego wyniku.</xref:System.Data.DataSet> To samo dotyczy wierszy zawierających podzielony na rozdziały wyniki (.NET Framework Data Provider for OLE DB tylko). Wynik najwyższego poziomu jest ograniczona przez `maxRecords`, ale są dodawane wszystkie wiersze podrzędne.      — Jeśli jeden z wyników zawiera błąd, wszystkie kolejne wyniki są pominięty i nie zostały dodane do <xref:System.Data.DataSet>.</xref:System.Data.DataSet>       Korzystając z kolejnych <xref:System.Data.Common.DbDataAdapter.Fill%2A>wywołań, aby odświeżyć zawartość <xref:System.Data.DataSet>, muszą zostać spełnione dwa warunki: 1.</xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Fill%2A>  Instrukcja SQL powinna być zgodna początkowo używaną do wypełniania <xref:System.Data.DataSet>.</xref:System.Data.DataSet>      2.  **Klucza** informacji o kolumnie musi być obecny.       Jeśli informacje o kluczu podstawowym jest obecny, zduplikowanych wierszy zostanie uzgodniony i są wyświetlane tylko raz w <xref:System.Data.DataTable>odpowiadającej <xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataTable> Informacje o kluczu podstawowym można konfigurować za pośrednictwem <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, określając <xref:System.Data.DataTable.PrimaryKey%2A>Właściwość <xref:System.Data.DataTable>, albo ustawiając <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A>właściwości `AddWithKey`.</xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.PrimaryKey%2A> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A>       Jeśli `SelectCommand` zwraca wyniki OUTER JOIN `DataAdapter` nie ustawia <xref:System.Data.DataTable.PrimaryKey%2A>wartości wynikowej <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.DataTable.PrimaryKey%2A> Zdefiniuj jawnie klucz podstawowy, aby upewnić się, że zduplikowane wiersze są rozpoznawane poprawnie. Aby uzyskać więcej informacji, zobacz [Definiowanie kluczy podstawowych](~/add/includes/ajax-current-ext-md.md).      > [!NOTE] > Podczas przetwarzania wsadowego instrukcji SQL, które zwracają wiele wartości, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>dla .NET Framework Data Provider for OLE DB pobiera informacje o schemacie dla pierwszego wyniku.</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A>z <xref:System.Data.MissingSchemaAction>ustawioną `AddWithKey`.</xref:System.Data.MissingSchemaAction> </xref:System.Data.Common.DbDataAdapter.Fill%2A>      > [!NOTE] > `DataSet` Nie będzie zawierać więcej niż liczba rekordów wskazywanym przez `maxRecords`. Jednak cały zestaw wyników generowanych przez zapytanie jest nadal zwrócone z serwera."
  example:
  - "The following example uses the derived class, <xref:System.Data.OleDb.OleDbDataAdapter>, to fill a <xref:System.Data.DataSet> with 15 rows, beginning at row 10, from the **Categories** table. This example assumes that you have created an <xref:System.Data.OleDb.OleDbDataAdapter> and a <xref:System.Data.DataSet>.  \n  \n [!code-vb[Classic WebData DbDataAdapter.Fill3 Example#1](~/add/codesnippet/visualbasic/db016a7d-8591-46f9-abcc-_1.vb)]\n [!code-cs[Classic WebData DbDataAdapter.Fill3 Example#1](~/add/codesnippet/csharp/db016a7d-8591-46f9-abcc-_1.cs)]"
  syntax:
    content: public int Fill (System.Data.DataSet dataSet, int startRecord, int maxRecords, string srcTable);
    parameters:
    - id: dataSet
      type: System.Data.DataSet
      description: "A <xref href=&quot;System.Data.DataSet&quot;> </xref> umożliwia wypełnienie rekordów i w razie potrzeby schematu."
    - id: startRecord
      type: System.Int32
      description: "Liczony od zera numer rekordu zaczynać."
    - id: maxRecords
      type: System.Int32
      description: "Maksymalna liczba rekordów do pobrania."
    - id: srcTable
      type: System.String
      description: "Nazwa tabeli źródłowej na potrzeby mapowania tabeli."
    return:
      type: System.Int32
      description: "Liczba wierszy pomyślnie dodane do lub odświeżenia w <xref href=&quot;System.Data.DataSet&quot;> </xref>. Nie zawiera wierszy objętych instrukcji, które niezwracanie wierszy."
  overload: System.Data.Common.DbDataAdapter.Fill*
  exceptions:
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "<xref href=&quot;System.Data.DataSet&quot;> </xref> Jest nieprawidłowy."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Tabela źródłowa jest nieprawidłowa.       - lub - połączenia jest nieprawidłowy."
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "Nie można odnaleźć połączenia."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> startRecord </code> Parametru jest mniejszy niż 0.       - lub - <code> maxRecords </code> parametru jest mniejszy niż 0."
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable[],System.Int32,System.Int32,System.Data.IDbCommand,System.Data.CommandBehavior)
  id: Fill(System.Data.DataTable[],System.Int32,System.Int32,System.Data.IDbCommand,System.Data.CommandBehavior)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Fill(DataTable[],Int32,Int32,IDbCommand,CommandBehavior)
  nameWithType: DbDataAdapter.Fill(DataTable[],Int32,Int32,IDbCommand,CommandBehavior)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataTable[],Int32,Int32,IDbCommand,CommandBehavior)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Dodaje lub odświeża wierszy w określonym zakresie w <xref href=&quot;System.Data.DataSet&quot;> </xref> do odpowiadają źródła danych przy użyciu <xref href=&quot;System.Data.DataSet&quot;> </xref> i <xref href=&quot;System.Data.DataTable&quot;> </xref> nazwy."
  remarks: "A `maxRecords` wszystkie rekordy po rekord początkowy pobiera wartość 0. Jeśli `maxRecords` jest większa niż liczba pozostałych wierszy tylko pozostałe wiersze są zwracane, a błąd nie jest wystawiany.       Fill — metoda pobiera dane ze źródła danych przy użyciu instrukcji SELECT. <xref:System.Data.IDbConnection>Obiekt skojarzony z instrukcją SELECT musi być prawidłowy, ale nie musi być otwarty.</xref:System.Data.IDbConnection> Jeśli <xref:System.Data.IDbConnection>jest zamknięty przed <xref:System.Data.Common.DbDataAdapter.Fill%2A>jest wywoływana, jest otwarta do pobierania danych, następnie zamknięte.</xref:System.Data.Common.DbDataAdapter.Fill%2A> </xref:System.Data.IDbConnection> Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A>jest wywoływana, pozostaje otwarty.</xref:System.Data.Common.DbDataAdapter.Fill%2A>       Jeśli polecenie nie zwróci żadnych wierszy, tabele nie są dodawane do <xref:System.Data.DataSet>, ale nie wystąpił wyjątek.</xref:System.Data.DataSet>       Jeśli <xref:System.Data.Common.DbDataAdapter>obiektu wykryje zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, spowoduje wygenerowanie nazw dla kolejnych kolumn, używania wzorca &quot;*columnname*1&quot;, &quot;*columnname*2&quot;,&quot;*columnname*3&quot; i tak dalej.</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter> Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet>zgodnie ze wzorcem &quot;Kolumna1&quot;, &quot;Column2&quot; i tak dalej.</xref:System.Data.DataSet>       Zapytanie określone zwraca wiele wyników, każdy zestaw wyników jest umieszczany w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych na wartości do nazwy określonej tabeli (na przykład &quot;Tabela&quot;, &quot;Tabela1&quot;, &quot;Tabela2&quot; i tak dalej). Ponieważ nie tabela została utworzona dla zapytania, która nie zwraca wiersze, jeśli zostały do przetworzenia zapytania insert następuje zapytania select, tabela utworzona do wykonywania zapytania select będą miały postać &quot;Tabela&quot;, ponieważ jest pierwsza utworzona tabela. Aplikacji przy użyciu nazwy kolumn i tabel powinien upewnić się, że nie występują konflikty z tych wzorców nazewnictwa.       Fill — metoda obsługuje scenariusze gdzie <xref:System.Data.DataSet>zawiera wiele <xref:System.Data.DataTable>obiektów, których nazwy różnią się tylko wielkością liter.</xref:System.Data.DataTable> </xref:System.Data.DataSet> W takich sytuacjach <xref:System.Data.Common.DbDataAdapter.Fill%2A>przeprowadza porównanie uwzględniające wielkość liter można znaleźć odpowiedniej tabeli, a następnie tworzy nową tabelę, jeśli istnieje dokładnego dopasowania.</xref:System.Data.Common.DbDataAdapter.Fill%2A> Poniższy kod C# ilustruje to zachowanie.      ```   DataSet dataset = new DataSet();   dataset.Tables.Add(&quot;aaa&quot;);   dataset.Tables.Add(&quot;AAA&quot;);   adapter.Fill(dataset, &quot;aaa&quot;); // Fills &quot;aaa&quot;, which already exists in the DataSet.   adapter.Fill(dataset, &quot;Aaa&quot;); // Adds a new table called &quot;Aaa&quot;.   ```Jeśli <xref:System.Data.Common.DbDataAdapter.Fill%2A>nosi nazwę i <xref:System.Data.DataSet>zawiera tylko jeden <xref:System.Data.DataTable>o nazwie różni się tylko wielkością liter, która <xref:System.Data.DataTable>jest aktualizowany.</xref:System.Data.DataTable> </xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Fill%2A> W tym scenariuszu wynik porównania ma bez uwzględniania wielkości liter. Poniższy kod C# ilustruje to zachowanie.      ```   DataSet dataset = new DataSet();   dataset.Tables.Add(&quot;aaa&quot;);   adapter.Fill(dataset, &quot;AAA&quot;); // Fills table &quot;aaa&quot; because only one similarly named table is in the DataSet.   ```Jeśli napotka błąd lub wystąpił wyjątek podczas wypełniania tabel danych, w tabelach danych nadal będą wierszy dodawanych przed wystąpieniem błędu. W pozostałej części operacja została przerwana.       Jeśli instrukcja SELECT służące do wypełniania <xref:System.Data.DataTable>obiektów zwraca wiele wyników, takie jak partii instrukcji SQL, należy pamiętać o następujących: - podczas przetwarzania wiele wyników z partii instrukcji SQL `maxRecords` ma zastosowanie tylko do pierwszego wyniku.</xref:System.Data.DataTable> To samo dotyczy wierszy zawierających podzielony na rozdziały wyniki (.NET Framework Data Provider for OLE DB tylko). Wynik najwyższego poziomu jest ograniczona przez `maxRecords`, ale są dodawane wszystkie wiersze podrzędne.      — Jeśli jeden z wyników zawiera błąd, wszystkie kolejne wyniki są pomijane.      > [!NOTE] > `DataSet` Nie będzie zawierać więcej niż liczba rekordów wskazywanym przez `maxRecords`. Jednak cały zestaw wyników generowanych przez zapytanie jest nadal zwrócone z serwera."
  syntax:
    content: protected virtual int Fill (System.Data.DataTable[] dataTables, int startRecord, int maxRecords, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);
    parameters:
    - id: dataTables
      type: System.Data.DataTable[]
      description: "<xref href=&quot;System.Data.DataTable&quot;> </xref> Obiektów, aby wypełnić ze źródła danych."
    - id: startRecord
      type: System.Int32
      description: "Liczony od zera numer rekordu zaczynać."
    - id: maxRecords
      type: System.Int32
      description: "Maksymalna liczba rekordów do pobrania."
    - id: command
      type: System.Data.IDbCommand
      description: "<xref href=&quot;System.Data.IDbCommand&quot;> </xref> Wykonywany w celu wypełnienia <xref href=&quot;System.Data.DataTable&quot;> </xref> obiektów."
    - id: behavior
      type: System.Data.CommandBehavior
      description: "Jeden z <xref href=&quot;System.Data.CommandBehavior&quot;> </xref> wartości."
    return:
      type: System.Int32
      description: "Liczba wierszy, dodać lub odświeżane w tabelach danych."
  overload: System.Data.Common.DbDataAdapter.Fill*
  exceptions:
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "<xref href=&quot;System.Data.DataSet&quot;> </xref> Jest nieprawidłowy."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Tabela źródłowa jest nieprawidłowa.       - lub - połączenia jest nieprawidłowy."
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "Nie można odnaleźć połączenia."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> startRecord </code> Parametru jest mniejszy niż 0.       - lub - <code> maxRecords </code> parametru jest mniejszy niż 0."
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.Int32,System.Int32,System.String,System.Data.IDbCommand,System.Data.CommandBehavior)
  id: Fill(System.Data.DataSet,System.Int32,System.Int32,System.String,System.Data.IDbCommand,System.Data.CommandBehavior)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Fill(DataSet,Int32,Int32,String,IDbCommand,CommandBehavior)
  nameWithType: DbDataAdapter.Fill(DataSet,Int32,Int32,String,IDbCommand,CommandBehavior)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataSet,Int32,Int32,String,IDbCommand,CommandBehavior)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Dodaje lub odświeża wierszy w określonym zakresie w <xref href=&quot;System.Data.DataSet&quot;> </xref> do odpowiadają źródła danych przy użyciu <xref href=&quot;System.Data.DataSet&quot;> </xref> i źródłowej nazw tabel, ciąg polecenia i zachowanie polecenia."
  remarks: "<xref:System.Data.Common.DbDataAdapter.Fill%2A>Metoda pobiera wierszy ze źródła danych przy użyciu instrukcji SELECT określonego przez skojarzony <xref:System.Data.IDbDataAdapter.SelectCommand%2A>Właściwości.</xref:System.Data.IDbDataAdapter.SelectCommand%2A> </xref:System.Data.Common.DbDataAdapter.Fill%2A> Obiekt połączenia skojarzony z instrukcją SELECT musi być prawidłowy, ale nie musi być otwarty. Jeśli połączenie jest zamknięte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A>jest wywoływana, jest otwarta do pobierania danych, następnie zamknięte.</xref:System.Data.Common.DbDataAdapter.Fill%2A> Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.Fill%2A>jest wywoływana, pozostaje otwarty.</xref:System.Data.Common.DbDataAdapter.Fill%2A>       <xref:System.Data.Common.DbDataAdapter.Fill%2A>Operacji następnie dodaje wiersze do miejsca docelowego <xref:System.Data.DataTable>obiekty w <xref:System.Data.DataSet>, tworzenie <xref:System.Data.DataTable>obiekty, jeśli nie już istnieją.</xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter.Fill%2A> Podczas tworzenia <xref:System.Data.DataTable>obiektów, <xref:System.Data.Common.DbDataAdapter.Fill%2A>operacji zwykle tworzy tylko metadane nazwy kolumny.</xref:System.Data.Common.DbDataAdapter.Fill%2A> </xref:System.Data.DataTable> Jednak jeśli <xref:System.Data.IDataAdapter.MissingSchemaAction%2A>właściwość jest ustawiona na `AddWithKey`, również są tworzone odpowiednie klucze podstawowe i ograniczeń.</xref:System.Data.IDataAdapter.MissingSchemaAction%2A>       Jeśli <xref:System.Data.Common.DbDataAdapter>napotka zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje nazwy dla kolejnych kolumn, używania wzorca &quot;*columnname*1&quot;, &quot;*columnname*2&quot;,&quot;*columnname*3&quot; i tak dalej.</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter> Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet>zgodnie ze wzorcem &quot;Kolumna1&quot;, &quot;Column2&quot; i tak dalej.</xref:System.Data.DataSet> Jeśli wiele zestawów wyników są dodawane do <xref:System.Data.DataSet>Każdy zestaw wyników znajduje się w osobnej tabeli.</xref:System.Data.DataSet> Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych na wartości do nazwy określonej tabeli (na przykład &quot;Tabela&quot;, &quot;Tabela1&quot;, &quot;Tabela2&quot; i tak dalej). Aplikacji przy użyciu nazwy kolumn i tabel powinien upewnić się, że nie występują konflikty z tych wzorców nazewnictwa.       <xref:System.Data.Common.DbDataAdapter.Fill%2A>Metoda obsługuje scenariusze gdzie <xref:System.Data.DataSet>zawiera wiele <xref:System.Data.DataTable>obiektów, których nazwy różnią się tylko wielkością liter.</xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Fill%2A> W takich sytuacjach <xref:System.Data.Common.DbDataAdapter.Fill%2A>przeprowadza porównanie uwzględniające wielkość liter można znaleźć odpowiedniej tabeli, a następnie tworzy nową tabelę, jeśli istnieje dokładnego dopasowania.</xref:System.Data.Common.DbDataAdapter.Fill%2A> Poniższy kod C# ilustruje to zachowanie.      ```   DataSet dataset = new DataSet();   dataset.Tables.Add(&quot;aaa&quot;);   dataset.Tables.Add(&quot;AAA&quot;);   adapter.Fill(dataset, &quot;aaa&quot;); // Fills &quot;aaa&quot;, which already exists in the DataSet.   adapter.Fill(dataset, &quot;Aaa&quot;); // Adds a new table called &quot;Aaa&quot;.   ```Jeśli <xref:System.Data.Common.DbDataAdapter.Fill%2A>nosi nazwę i <xref:System.Data.DataSet>zawiera tylko jeden <xref:System.Data.DataTable>o nazwie różni się tylko wielkością liter, która <xref:System.Data.DataTable>jest aktualizowany.</xref:System.Data.DataTable> </xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Fill%2A> W tym scenariuszu wynik porównania ma bez uwzględniania wielkości liter. Poniższy kod C# ilustruje to zachowanie.      ```   DataSet dataset = new DataSet();   dataset.Tables.Add(&quot;aaa&quot;);   adapter.Fill(dataset, &quot;AAA&quot;); // Fills table &quot;aaa&quot; because only one similarly named table is in the DataSet.   ```Można użyć <xref:System.Data.Common.DbDataAdapter.Fill%2A>metody wiele razy w tym samym <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter.Fill%2A> Jeśli klucz podstawowy istnieje, przychodzących wierszy są scalane z pasujących wierszy, które już istnieją. Jeśli klucz podstawowy istnieje, przychodzących wierszy są dołączane do <xref:System.Data.DataTable>.</xref:System.Data.DataTable>       Jeśli `SelectCommand` zwraca wyniki OUTER JOIN `DataAdapter` nie ustawia <xref:System.Data.DataTable.PrimaryKey%2A>wartości wynikowej <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.DataTable.PrimaryKey%2A> Zdefiniuj jawnie klucz podstawowy, aby upewnić się, że zduplikowane wiersze są rozpoznawane poprawnie. Aby uzyskać więcej informacji, zobacz[Definiowanie kluczy podstawowych](~/add/includes/ajax-current-ext-md.md).      > [!NOTE] > Podczas przetwarzania wsadowego instrukcji SQL, które zwracają wiele wartości, wykonania <xref:System.Data.Common.DbDataAdapter.Fill%2A>i <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>dostawcy danych .NET Framework pobiera informacje o schemacie dla pierwszego wyniku.</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> </xref:System.Data.Common.DbDataAdapter.Fill%2A>"
  syntax:
    content: protected virtual int Fill (System.Data.DataSet dataSet, int startRecord, int maxRecords, string srcTable, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);
    parameters:
    - id: dataSet
      type: System.Data.DataSet
      description: "A <xref href=&quot;System.Data.DataSet&quot;> </xref> umożliwia wypełnienie rekordów i w razie potrzeby schematu."
    - id: startRecord
      type: System.Int32
      description: "Liczony od zera numer rekordu zaczynać."
    - id: maxRecords
      type: System.Int32
      description: "Maksymalna liczba rekordów do pobrania."
    - id: srcTable
      type: System.String
      description: "Nazwa tabeli źródłowej na potrzeby mapowania tabeli."
    - id: command
      type: System.Data.IDbCommand
      description: "W instrukcji SQL SELECT używane do pobierania wierszy ze źródła danych."
    - id: behavior
      type: System.Data.CommandBehavior
      description: "Jeden z <xref href=&quot;System.Data.CommandBehavior&quot;> </xref> wartości."
    return:
      type: System.Int32
      description: "Liczba wierszy pomyślnie dodane do lub odświeżenia w <xref href=&quot;System.Data.DataSet&quot;> </xref>. Nie zawiera wierszy objętych instrukcji, które niezwracanie wierszy."
  overload: System.Data.Common.DbDataAdapter.Fill*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Tabela źródłowa jest nieprawidłowa."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> startRecord </code> Parametru jest mniejszy niż 0.       - lub - <code> maxRecords </code> parametru jest mniejszy niż 0."
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.FillCommandBehavior
  id: FillCommandBehavior
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: FillCommandBehavior
  nameWithType: DbDataAdapter.FillCommandBehavior
  fullName: System.Data.Common.DbDataAdapter.FillCommandBehavior
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Pobiera lub ustawia zachowanie polecenia używany do wypełniania adapter danych."
  syntax:
    content: protected System.Data.CommandBehavior FillCommandBehavior { get; set; }
    return:
      type: System.Data.CommandBehavior
      description: "<xref href=&quot;System.Data.CommandBehavior&quot;> </xref> Polecenia używany do wypełniania adapter danych."
  overload: System.Data.Common.DbDataAdapter.FillCommandBehavior*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)
  id: FillSchema(System.Data.DataSet,System.Data.SchemaType)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: FillSchema(DataSet,SchemaType)
  nameWithType: DbDataAdapter.FillSchema(DataSet,SchemaType)
  fullName: System.Data.Common.DbDataAdapter.FillSchema(DataSet,SchemaType)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Dodaje <xref href=&quot;System.Data.DataTable&quot;> </xref> o nazwie &quot;Tabela&quot; do określonego <xref href=&quot;System.Data.DataSet&quot;> </xref> i konfiguruje schemat do dopasowania w źródle danych, na podstawie której określony <xref href=&quot;System.Data.SchemaType&quot;> </xref>."
  remarks: "Ta metoda pobiera informacje o schemacie ze źródła danych przy użyciu <xref:System.Data.IDbDataAdapter.SelectCommand%2A>.</xref:System.Data.IDbDataAdapter.SelectCommand%2A>       <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>Operacja dodaje <xref:System.Data.DataTable>do miejsca docelowego <xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Następnie dodaje kolumny <xref:System.Data.DataColumnCollection>z <xref:System.Data.DataTable>oraz konfiguruje następujące opcje <xref:System.Data.DataColumn>Właściwości, jeśli istnieją w źródle danych:- <xref:System.Data.DataColumn.AllowDBNull%2A>- <xref:System.Data.DataColumn.AutoIncrement%2A>.</xref:System.Data.DataColumn.AutoIncrement%2A> </xref:System.Data.DataColumn.AllowDBNull%2A> </xref:System.Data.DataColumn> </xref:System.Data.DataTable> </xref:System.Data.DataColumnCollection> Należy ustawić <xref:System.Data.DataColumn.AutoIncrementStep%2A>i <xref:System.Data.DataColumn.AutoIncrementSeed%2A>oddzielnie.</xref:System.Data.DataColumn.AutoIncrementSeed%2A> </xref:System.Data.DataColumn.AutoIncrementStep%2A>      - <xref:System.Data.DataColumn.MaxLength%2A>- <xref:System.Data.DataColumn.ReadOnly%2A>- <xref:System.Data.DataColumn.Unique%2A><xref:System.Data.Common.DbDataAdapter.FillSchema%2A>konfiguruje również <xref:System.Data.DataTable.PrimaryKey%2A>i <xref:System.Data.DataTable.Constraints%2A>Właściwości zgodnie z następującymi zasadami: - Jeśli jeden lub więcej kolumn klucza podstawowego są zwracane przez <xref:System.Data.IDbDataAdapter.SelectCommand%2A>są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.IDbDataAdapter.SelectCommand%2A> </xref:System.Data.DataTable.Constraints%2A> </xref:System.Data.DataTable.PrimaryKey%2A> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A>       </xref:System.Data.DataColumn.Unique%2A> </xref:System.Data.DataColumn.ReadOnly%2A> </xref:System.Data.DataColumn.MaxLength%2A>      — Jeśli nie kolumn klucza podstawowego są zwracane, ale są unikatowe kolumny, unikatowe kolumny są używane jako klucz podstawowy w przypadku i tylko wtedy, gdy wszystkie unikatowe kolumny jest zaszyfrowana. Jeśli dowolnej kolumny dopuszczają wartości null, <xref:System.Data.UniqueConstraint>jest dodawany do <xref:System.Data.ConstraintCollection>, ale <xref:System.Data.DataTable.PrimaryKey%2A>nie ustawiono właściwości.</xref:System.Data.DataTable.PrimaryKey%2A> </xref:System.Data.ConstraintCollection> </xref:System.Data.UniqueConstraint>      — Jeśli zarówno kolumn klucza podstawowego, jak i unikatowe kolumny są zwracane, kolumny klucza podstawowego są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.</xref:System.Data.DataTable>       Należy pamiętać, że klucze podstawowe i ograniczenia unique są dodawane do <xref:System.Data.ConstraintCollection>zgodnie z powyższych reguł, ale także inne ograniczenia typów nie są dodawane.</xref:System.Data.ConstraintCollection>       Jeśli klastrowany unikatowy indeks jest zdefiniowany w kolumnie lub kolumny w tabeli programu SQL Server i ograniczenia klucza podstawowego została zdefiniowana osobny zestaw kolumn, będzie zwracana nazwy kolumn w indeksu klastrowanego. Aby zwrócić nazwę lub nazwy kolumn klucza podstawowego, należy użyć wskazówki zapytania z instrukcji SELECT, która określa nazwę indeksu klucza podstawowego. Aby uzyskać więcej informacji na temat określania wskazówki zapytania, zobacz [wskazówki zapytania (Transact-SQL)](http://msdn.microsoft.com/library/ms181714.aspx).       Informacje o kluczu podstawowym jest używany podczas <xref:System.Data.Common.DbDataAdapter.Fill%2A>do znajdowania i zamieniania wszystkie wiersze, w których kolumny klucza pasują do siebie.</xref:System.Data.Common.DbDataAdapter.Fill%2A> Jeśli nie jest zamierzone zachowanie, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A>bez żąda informacji o schemacie.</xref:System.Data.Common.DbDataAdapter.Fill%2A>       Jeśli <xref:System.Data.IDataAdapter>napotka zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje nazwy dla kolejnych kolumn, używania wzorca &quot;*columnname*1&quot;, &quot;*columnname*2&quot;,&quot;*columnname*3&quot; i tak dalej.</xref:System.Data.DataTable> </xref:System.Data.IDataAdapter> Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet>zgodnie ze wzorcem &quot;Kolumna1&quot;, &quot;Column2&quot; i tak dalej.</xref:System.Data.DataSet> Jeśli wiele zestawów wyników są dodawane do <xref:System.Data.DataSet>Każdy zestaw wyników znajduje się w osobnej tabeli.</xref:System.Data.DataSet> Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych na wartości do nazwy określonej tabeli (na przykład &quot;Table&quot;, &quot;Tabela1&quot;, &quot;Tabela2&quot; itd.). Aplikacji przy użyciu nazwy kolumn i tabel powinien upewnić się, że nie występują konflikty z tych wzorców nazewnictwa.       <xref:System.Data.IDbConnection>Obiekt skojarzony z polecenie select musi być prawidłowy, ale nie trzeba otworzyć.</xref:System.Data.IDbConnection> Jeśli <xref:System.Data.IDbConnection>jest zamknięty przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>jest wywoływana, jest otwarta do pobierania danych, następnie zamknięte.</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> </xref:System.Data.IDbConnection> Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>jest wywoływana, jest pozostawiany bez Otwórz.</xref:System.Data.Common.DbDataAdapter.FillSchema%2A>      > [!NOTE] > Podczas przetwarzania wsadowego instrukcji SQL, które zwracają wiele wartości, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>dla .NET Framework Data Provider for OLE DB pobiera informacje o schemacie dla pierwszego wyniku.</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A>z <xref:System.Data.MissingSchemaAction>ustawioną `AddWithKey`.</xref:System.Data.MissingSchemaAction> </xref:System.Data.Common.DbDataAdapter.Fill%2A>       Korzystając z <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, .NET Framework Data Provider for SQL Server dołącza klauzulę FOR BROWSE do instrukcji, które było wykonywane.</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Użytkownik należy zwrócić uwagę potencjalnych efekty uboczne, takie jak zakłócenia przy użyciu instrukcji FMTONLY wartość ON. Aby uzyskać więcej informacji zobacz dokumentację SQL Server — książki Online."
  example:
  - "The following example uses the derived class, <xref:System.Data.SqlClient.SqlDataAdapter>, to fill a <xref:System.Data.DataSet> with the schema, and returns a <xref:System.Data.DataSet>.  \n  \n [!code-vb[Classic WebData DbDataAdapter.FillSchema1 Example#1](~/add/codesnippet/visualbasic/5283d285-2680-48b0-856a-_1.vb)]\n [!code-cs[Classic WebData DbDataAdapter.FillSchema1 Example#1](~/add/codesnippet/csharp/5283d285-2680-48b0-856a-_1.cs)]"
  syntax:
    content: public override System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType);
    parameters:
    - id: dataSet
      type: System.Data.DataSet
      description: "A <xref href=&quot;System.Data.DataSet&quot;> </xref> do wstawienia schematu w."
    - id: schemaType
      type: System.Data.SchemaType
      description: "Jeden z <xref href=&quot;System.Data.SchemaType&quot;> </xref> wartości, które określają sposób wstawiania schematu."
    return:
      type: System.Data.DataTable[]
      description: "Odwołanie do kolekcji <xref href=&quot;System.Data.DataTable&quot;> </xref> obiektów, które zostały dodane do <xref href=&quot;System.Data.DataSet&quot;> </xref>."
  overload: System.Data.Common.DbDataAdapter.FillSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType)
  id: FillSchema(System.Data.DataTable,System.Data.SchemaType)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: FillSchema(DataTable,SchemaType)
  nameWithType: DbDataAdapter.FillSchema(DataTable,SchemaType)
  fullName: System.Data.Common.DbDataAdapter.FillSchema(DataTable,SchemaType)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Konfiguruje schemat określonego <xref href=&quot;System.Data.DataTable&quot;> </xref> oparte na określony <xref href=&quot;System.Data.SchemaType&quot;> </xref>."
  remarks: "Metoda FillSchema pobiera schemat ze źródła danych przy użyciu <xref:System.Data.IDbDataAdapter.SelectCommand%2A>.</xref:System.Data.IDbDataAdapter.SelectCommand%2A> Obiekt połączenia skojarzony z <xref:System.Data.IDbDataAdapter.SelectCommand%2A>musi być prawidłowy, ale nie musi być otwarty.</xref:System.Data.IDbDataAdapter.SelectCommand%2A> Jeśli połączenie jest zamknięte przed wywołaniem FillSchema, jest otwarta do pobierania danych, następnie zamknięte. Jeśli połączenie jest otwarte przed wywołaniem FillSchema, pozostaje otwarty.       Operacja FillSchema zwraca <xref:System.Data.DataTable>.</xref:System.Data.DataTable> Następnie dodaje kolumny <xref:System.Data.DataColumnCollection>z <xref:System.Data.DataTable>oraz konfiguruje następujące opcje <xref:System.Data.DataColumn>Właściwości, jeśli istnieją w źródle danych:- <xref:System.Data.DataColumn.AllowDBNull%2A>- <xref:System.Data.DataColumn.AutoIncrement%2A>.</xref:System.Data.DataColumn.AutoIncrement%2A> </xref:System.Data.DataColumn.AllowDBNull%2A> </xref:System.Data.DataColumn> </xref:System.Data.DataTable> </xref:System.Data.DataColumnCollection> Należy ustawić <xref:System.Data.DataColumn.AutoIncrementStep%2A>i <xref:System.Data.DataColumn.AutoIncrementSeed%2A>oddzielnie.</xref:System.Data.DataColumn.AutoIncrementSeed%2A> </xref:System.Data.DataColumn.AutoIncrementStep%2A>      - <xref:System.Data.DataColumn.MaxLength%2A>- <xref:System.Data.DataColumn.ReadOnly%2A>- <xref:System.Data.DataColumn.Unique%2A>Konfiguruje również FillSchema <xref:System.Data.DataTable.PrimaryKey%2A>i <xref:System.Data.DataTable.Constraints%2A>Właściwości zgodnie z następującymi zasadami: — Jeśli <xref:System.Data.DataTable.PrimaryKey%2A>został już zdefiniowany dla `DataTable`, lub `DataTable` zawiera dane, `PrimaryKey` właściwość nie zostanie ustawiona.</xref:System.Data.DataTable.PrimaryKey%2A> </xref:System.Data.DataTable.Constraints%2A> </xref:System.Data.DataTable.PrimaryKey%2A> </xref:System.Data.DataColumn.Unique%2A> </xref:System.Data.DataColumn.ReadOnly%2A> </xref:System.Data.DataColumn.MaxLength%2A>      — Jeśli jeden lub więcej kolumn klucza podstawowego są zwracane przez <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, są używane jako kolumny klucza podstawowego dla `DataTable`.</xref:System.Data.IDbDataAdapter.SelectCommand%2A>      — Jeśli nie kolumn klucza podstawowego są zwracane, ale są unikatowe kolumny, unikatowe kolumny są używane jako klucz podstawowy w przypadku i tylko wtedy, gdy wszystkie unikatowe kolumny jest zaszyfrowana. Jeśli dowolnej kolumny dopuszczają wartości null, <xref:System.Data.UniqueConstraint>jest dodawany do <xref:System.Data.ConstraintCollection>, ale `PrimaryKey` nie ustawiono właściwości.</xref:System.Data.ConstraintCollection> </xref:System.Data.UniqueConstraint>      — Jeśli zarówno kolumn klucza podstawowego, jak i unikatowe kolumny są zwracane, kolumny klucza podstawowego są używane jako kolumny klucza podstawowego dla `DataTable`.       Należy pamiętać, że klucze podstawowe i ograniczenia unique są dodawane do <xref:System.Data.ConstraintCollection>zgodnie z powyższych reguł, ale także inne ograniczenia typów nie są dodawane.</xref:System.Data.ConstraintCollection> Proces ten może potrwać kilka przesyłania danych do serwera.       Jeśli klastrowany unikatowy indeks jest zdefiniowany w kolumnie lub kolumny w tabeli programu SQL Server i ograniczenia klucza podstawowego została zdefiniowana osobny zestaw kolumn, będzie zwracana nazwy kolumn w indeksu klastrowanego. Aby zwrócić nazwę lub nazwy kolumn klucza podstawowego, należy użyć wskazówki zapytania z instrukcji SELECT, która określa nazwę indeksu klucza podstawowego. Aby uzyskać więcej informacji na temat określania wskazówki zapytania, zobacz [wskazówki zapytania (Transact-SQL)](http://msdn.microsoft.com/library/ms181714.aspx).       Jeśli <xref:System.Data.Common.DbDataAdapter>napotka zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje nazwy dla kolejnych kolumn, używania wzorca &quot;*columnname*1&quot;, &quot;*columnname*2&quot;,&quot;*columnname*3&quot; i tak dalej.</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter> Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet>zgodnie ze wzorcem &quot;Kolumna1&quot;, &quot;Column2&quot; i tak dalej.</xref:System.Data.DataSet> Jeśli wiele zestawów wyników są dodawane do <xref:System.Data.DataSet>Każdy zestaw wyników znajduje się w osobnej tabeli.</xref:System.Data.DataSet> Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych na wartości do nazwy określonej tabeli (na przykład &quot;Table&quot;, &quot;Tabela1&quot;, &quot;Tabela2&quot; itd.). Aplikacji przy użyciu nazwy kolumn i tabel powinien upewnić się, że nie występują konflikty z tych wzorców nazewnictwa.       Operacja FillSchema nie zwróciła żadnych wierszy. Użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A>metody dodawania wierszy do <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter.Fill%2A>      > [!NOTE] > Podczas przetwarzania wsadowego instrukcji SQL, które zwracają wiele wartości, implementacja FillSchema dla dostawcy danych programu .NET Framework dla OLE DB pobiera informacje o schemacie dla pierwszego wyniku. Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A>z <xref:System.Data.MissingSchemaAction>ustawioną `AddWithKey`.</xref:System.Data.MissingSchemaAction> </xref:System.Data.Common.DbDataAdapter.Fill%2A>       Używając FillSchema dostawcy danych programu .NET Framework dla programu SQL Server dołącza klauzulę FOR BROWSE do instrukcji, które było wykonywane. Użytkownik należy zwrócić uwagę potencjalnych efekty uboczne, takie jak zakłócenia przy użyciu instrukcji FMTONLY wartość ON. Aby uzyskać więcej informacji zobacz dokumentację SQL Server — książki Online."
  example:
  - "The following example uses the derived class, <xref:System.Data.SqlClient.SqlDataAdapter>, to fill a <xref:System.Data.DataSet> with the schema, and returns a <xref:System.Data.DataTable>.  \n  \n [!code-vb[Classic WebData DbDataAdapter.FillSchema3#1](~/add/codesnippet/visualbasic/658ac10a-3a87-4693-8b37-_1.vb)]\n [!code-cs[Classic WebData DbDataAdapter.FillSchema3#1](~/add/codesnippet/csharp/658ac10a-3a87-4693-8b37-_1.cs)]"
  syntax:
    content: public System.Data.DataTable FillSchema (System.Data.DataTable dataTable, System.Data.SchemaType schemaType);
    parameters:
    - id: dataTable
      type: System.Data.DataTable
      description: "<xref href=&quot;System.Data.DataTable&quot;> </xref> Do wypełnienia ze schematem ze źródła danych."
    - id: schemaType
      type: System.Data.SchemaType
      description: "Jeden z <xref href=&quot;System.Data.SchemaType&quot;> </xref> wartości."
    return:
      type: System.Data.DataTable
      description: "A <xref href=&quot;System.Data.DataTable&quot;> </xref> zawierający informacje o schemacie zwracane ze źródła danych."
  overload: System.Data.Common.DbDataAdapter.FillSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.String)
  id: FillSchema(System.Data.DataSet,System.Data.SchemaType,System.String)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: FillSchema(DataSet,SchemaType,String)
  nameWithType: DbDataAdapter.FillSchema(DataSet,SchemaType,String)
  fullName: System.Data.Common.DbDataAdapter.FillSchema(DataSet,SchemaType,String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Dodaje <xref href=&quot;System.Data.DataTable&quot;> </xref> do określonego <xref href=&quot;System.Data.DataSet&quot;> </xref> i konfiguruje schemat do dopasowania, który ustalane na podstawie określonego w źródle danych <xref href=&quot;System.Data.SchemaType&quot;> </xref> i <xref href=&quot;System.Data.DataTable&quot;> </xref>."
  remarks: "Ta metoda pobiera informacje o schemacie ze źródła danych przy użyciu <xref:System.Data.IDbDataAdapter.SelectCommand%2A>.</xref:System.Data.IDbDataAdapter.SelectCommand%2A>       <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>Operacja dodaje <xref:System.Data.DataTable>do miejsca docelowego <xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Następnie dodaje kolumny <xref:System.Data.DataColumnCollection>z <xref:System.Data.DataTable>oraz konfiguruje następujące opcje <xref:System.Data.DataColumn>Właściwości, jeśli istnieją w źródle danych:- <xref:System.Data.DataColumn.AllowDBNull%2A>- <xref:System.Data.DataColumn.AutoIncrement%2A>.</xref:System.Data.DataColumn.AutoIncrement%2A> </xref:System.Data.DataColumn.AllowDBNull%2A> </xref:System.Data.DataColumn> </xref:System.Data.DataTable> </xref:System.Data.DataColumnCollection> Należy ustawić <xref:System.Data.DataColumn.AutoIncrementStep%2A>i <xref:System.Data.DataColumn.AutoIncrementSeed%2A>oddzielnie.</xref:System.Data.DataColumn.AutoIncrementSeed%2A> </xref:System.Data.DataColumn.AutoIncrementStep%2A>      - <xref:System.Data.DataColumn.MaxLength%2A>- <xref:System.Data.DataColumn.ReadOnly%2A>- <xref:System.Data.DataColumn.Unique%2A><xref:System.Data.Common.DbDataAdapter.FillSchema%2A>konfiguruje również <xref:System.Data.DataTable.PrimaryKey%2A>i <xref:System.Data.DataTable.Constraints%2A>Właściwości zgodnie z następującymi zasadami: - Jeśli jeden lub więcej kolumn klucza podstawowego są zwracane przez <xref:System.Data.IDbDataAdapter.SelectCommand%2A>są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.IDbDataAdapter.SelectCommand%2A> </xref:System.Data.DataTable.Constraints%2A> </xref:System.Data.DataTable.PrimaryKey%2A> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A>       </xref:System.Data.DataColumn.Unique%2A> </xref:System.Data.DataColumn.ReadOnly%2A> </xref:System.Data.DataColumn.MaxLength%2A>      — Jeśli nie kolumn klucza podstawowego są zwracane, ale są unikatowe kolumny, unikatowe kolumny są używane jako klucz podstawowy w przypadku i tylko wtedy, gdy wszystkie unikatowe kolumny jest zaszyfrowana. Jeśli dowolnej kolumny dopuszczają wartości null, <xref:System.Data.UniqueConstraint>jest dodawany do <xref:System.Data.ConstraintCollection>, ale <xref:System.Data.DataTable.PrimaryKey%2A>nie ustawiono właściwości.</xref:System.Data.DataTable.PrimaryKey%2A> </xref:System.Data.ConstraintCollection> </xref:System.Data.UniqueConstraint>      — Jeśli zarówno kolumn klucza podstawowego, jak i unikatowe kolumny są zwracane, kolumny klucza podstawowego są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.</xref:System.Data.DataTable>       Należy pamiętać, że klucze podstawowe i ograniczenia unique są dodawane do <xref:System.Data.ConstraintCollection>zgodnie z powyższych reguł, ale także inne ograniczenia typów nie są dodawane.</xref:System.Data.ConstraintCollection>       Jeśli klastrowany unikatowy indeks jest zdefiniowany w kolumnie lub kolumny w tabeli programu SQL Server i ograniczenia klucza podstawowego została zdefiniowana osobny zestaw kolumn, będzie zwracana nazwy kolumn w indeksu klastrowanego. Aby zwrócić nazwę lub nazwy kolumn klucza podstawowego, należy użyć wskazówki zapytania z instrukcji SELECT, która określa nazwę indeksu klucza podstawowego. Aby uzyskać więcej informacji na temat określania wskazówki zapytania, zobacz [wskazówki zapytania (Transact-SQL)](http://msdn.microsoft.com/library/ms181714.aspx).       Informacje o kluczu podstawowym jest używany podczas <xref:System.Data.Common.DbDataAdapter.Fill%2A>do znajdowania i zamieniania wszystkie wiersze, w których kolumny klucza pasują do siebie.</xref:System.Data.Common.DbDataAdapter.Fill%2A> Jeśli nie jest zamierzone zachowanie, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A>bez żąda informacji o schemacie.</xref:System.Data.Common.DbDataAdapter.Fill%2A>       Jeśli <xref:System.Data.Common.DbDataAdapter>napotka zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje nazwy dla kolejnych kolumn, używania wzorca &quot;*columnname*1&quot;, &quot;*columnname*2&quot;,&quot;*columnname*3&quot; i tak dalej.</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter> Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet>zgodnie ze wzorcem &quot;Kolumna1&quot;, &quot;Column2&quot; i tak dalej.</xref:System.Data.DataSet> Jeśli wiele zestawów wyników są dodawane do <xref:System.Data.DataSet>Każdy zestaw wyników znajduje się w osobnej tabeli.</xref:System.Data.DataSet> Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych na wartości do nazwy określonej tabeli (na przykład &quot;Table&quot;, &quot;Tabela1&quot;, &quot;Tabela2&quot; itd.). Aplikacji przy użyciu nazwy kolumn i tabel powinien upewnić się, że nie występują konflikty z tych wzorców nazewnictwa.       <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>Metoda obsługuje scenariusze gdzie <xref:System.Data.DataSet>zawiera wiele <xref:System.Data.DataTable>obiektów, których nazwy różnią się tylko wielkością liter.</xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A> W takich sytuacjach <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>przeprowadza porównanie uwzględniające wielkość liter można znaleźć odpowiedniej tabeli, a następnie tworzy nową tabelę, jeśli istnieje dokładnego dopasowania.</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Poniższy kod C# ilustruje to zachowanie.      ```   DataSet dataset = new DataSet();   dataset.Tables.Add(&quot;aaa&quot;);   dataset.Tables.Add(&quot;AAA&quot;);   adapter.FillSchema(dataset, &quot;aaa&quot;); // Fills the schema of &quot;aaa&quot;, which already exists in the DataSet.   adapter.FillSchema(dataset, &quot;Aaa&quot;); // Adds a new table called &quot;Aaa&quot;.   ```Jeśli <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>nosi nazwę i <xref:System.Data.DataSet>zawiera tylko jeden <xref:System.Data.DataTable>o nazwie różni się tylko wielkością liter, która <xref:System.Data.DataTable>jest aktualizowany.</xref:System.Data.DataTable> </xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A> W tym scenariuszu wynik porównania ma bez uwzględniania wielkości liter. Poniższy kod C# ilustruje to zachowanie.      ```   DataSet dataset = new DataSet();   dataset.Tables.Add(&quot;aaa&quot;);   adapter.FillSchema(dataset, &quot;AAA&quot;); // Fills the schema of table &quot;aaa&quot; because only one similarly named table is in the DataSet.   ```<xref:System.Data.IDbConnection>Obiekt skojarzony z polecenie select musi być prawidłowy, ale nie trzeba otworzyć.</xref:System.Data.IDbConnection> Jeśli <xref:System.Data.IDbConnection>jest zamknięty przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>jest wywoływana, jest otwarta do pobierania danych, następnie zamknięte.</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> </xref:System.Data.IDbConnection> Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>jest wywoływana, jest pozostawiany bez Otwórz.</xref:System.Data.Common.DbDataAdapter.FillSchema%2A>      > [!NOTE] > Podczas przetwarzania wsadowego instrukcji SQL, które zwracają wiele wartości, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>dla .NET Framework Data Provider for OLE DB pobiera informacje o schemacie dla pierwszego wyniku.</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A>z <xref:System.Data.MissingSchemaAction>ustawioną `AddWithKey`.</xref:System.Data.MissingSchemaAction> </xref:System.Data.Common.DbDataAdapter.Fill%2A>       Korzystając z <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, .NET Framework Data Provider for SQL Server dołącza klauzulę FOR BROWSE do instrukcji, które było wykonywane.</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Użytkownik należy zwrócić uwagę potencjalnych efekty uboczne, takie jak zakłócenia przy użyciu instrukcji FMTONLY wartość ON. Aby uzyskać więcej informacji zobacz dokumentację SQL Server — książki Online."
  example:
  - "The following example uses the derived class, <xref:System.Data.SqlClient.SqlDataAdapter>, to fill a <xref:System.Data.DataSet> with the schema, and returns a <xref:System.Data.DataSet>.  \n  \n [!code-vb[Classic WebData DbDataAdapter.FillSchema2 Example#1](~/add/codesnippet/visualbasic/c7e2b899-0a44-4d9d-9e8d-_1.vb)]\n [!code-cs[Classic WebData DbDataAdapter.FillSchema2 Example#1](~/add/codesnippet/csharp/c7e2b899-0a44-4d9d-9e8d-_1.cs)]"
  syntax:
    content: public System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType, string srcTable);
    parameters:
    - id: dataSet
      type: System.Data.DataSet
      description: "A <xref href=&quot;System.Data.DataSet&quot;> </xref> do wstawienia schematu w."
    - id: schemaType
      type: System.Data.SchemaType
      description: "Jeden z <xref href=&quot;System.Data.SchemaType&quot;> </xref> wartości, które określają sposób wstawiania schematu."
    - id: srcTable
      type: System.String
      description: "Nazwa tabeli źródłowej na potrzeby mapowania tabeli."
    return:
      type: System.Data.DataTable[]
      description: "Odwołanie do kolekcji <xref href=&quot;System.Data.DataTable&quot;> </xref> obiektów, które zostały dodane do <xref href=&quot;System.Data.DataSet&quot;> </xref>."
  overload: System.Data.Common.DbDataAdapter.FillSchema*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Nie można odnaleźć tabeli źródłowej, z którego można pobrać schematu."
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType,System.Data.IDbCommand,System.Data.CommandBehavior)
  id: FillSchema(System.Data.DataTable,System.Data.SchemaType,System.Data.IDbCommand,System.Data.CommandBehavior)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: FillSchema(DataTable,SchemaType,IDbCommand,CommandBehavior)
  nameWithType: DbDataAdapter.FillSchema(DataTable,SchemaType,IDbCommand,CommandBehavior)
  fullName: System.Data.Common.DbDataAdapter.FillSchema(DataTable,SchemaType,IDbCommand,CommandBehavior)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Konfiguruje schemat określonego <xref href=&quot;System.Data.DataTable&quot;> </xref> oparte na określony <xref href=&quot;System.Data.SchemaType&quot;> </xref>, ciąg, polecenia i <xref href=&quot;System.Data.CommandBehavior&quot;> </xref> wartości."
  remarks: "<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>Metoda pobiera schematu ze źródłem danych, używając <xref:System.Data.IDbDataAdapter.SelectCommand%2A>.</xref:System.Data.IDbDataAdapter.SelectCommand%2A> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Obiekt połączenia skojarzony z <xref:System.Data.IDbDataAdapter.SelectCommand%2A>musi być prawidłowy, ale nie musi być otwarty.</xref:System.Data.IDbDataAdapter.SelectCommand%2A> Jeśli połączenie jest zamknięte przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>jest wywoływana, jest otwarta do pobierania danych, następnie zamknięte.</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>jest wywoływana, pozostaje otwarty.</xref:System.Data.Common.DbDataAdapter.FillSchema%2A>       <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>Operacja dodaje <xref:System.Data.DataTable>do miejsca docelowego <xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Następnie dodaje kolumny <xref:System.Data.DataColumnCollection>z <xref:System.Data.DataTable>oraz konfiguruje następujące opcje <xref:System.Data.DataColumn>Właściwości, jeśli istnieją w źródle danych:- <xref:System.Data.DataColumn.AllowDBNull%2A>- <xref:System.Data.DataColumn.AutoIncrement%2A>.</xref:System.Data.DataColumn.AutoIncrement%2A> </xref:System.Data.DataColumn.AllowDBNull%2A> </xref:System.Data.DataColumn> </xref:System.Data.DataTable> </xref:System.Data.DataColumnCollection> Należy ustawić <xref:System.Data.DataColumn.AutoIncrementStep%2A>i <xref:System.Data.DataColumn.AutoIncrementSeed%2A>oddzielnie.</xref:System.Data.DataColumn.AutoIncrementSeed%2A> </xref:System.Data.DataColumn.AutoIncrementStep%2A>      - <xref:System.Data.DataColumn.MaxLength%2A>- <xref:System.Data.DataColumn.ReadOnly%2A>- <xref:System.Data.DataColumn.Unique%2A><xref:System.Data.Common.DbDataAdapter.FillSchema%2A>konfiguruje również <xref:System.Data.DataTable.PrimaryKey%2A>i <xref:System.Data.DataTable.Constraints%2A>Właściwości zgodnie z następującymi zasadami: - Jeśli jeden lub więcej kolumn klucza podstawowego są zwracane przez <xref:System.Data.IDbDataAdapter.SelectCommand%2A>są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.IDbDataAdapter.SelectCommand%2A> </xref:System.Data.DataTable.Constraints%2A> </xref:System.Data.DataTable.PrimaryKey%2A> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A>       </xref:System.Data.DataColumn.Unique%2A> </xref:System.Data.DataColumn.ReadOnly%2A> </xref:System.Data.DataColumn.MaxLength%2A>      — Jeśli nie kolumn klucza podstawowego są zwracane, ale są unikatowe kolumny, unikatowe kolumny są używane jako klucz podstawowy w przypadku i tylko wtedy, gdy wszystkie unikatowe kolumny jest zaszyfrowana. Jeśli dowolnej kolumny dopuszczają wartości null, <xref:System.Data.UniqueConstraint>jest dodawany do <xref:System.Data.ConstraintCollection>, ale <xref:System.Data.DataTable.PrimaryKey%2A>nie ustawiono właściwości.</xref:System.Data.DataTable.PrimaryKey%2A> </xref:System.Data.ConstraintCollection> </xref:System.Data.UniqueConstraint>      — Jeśli zarówno kolumn klucza podstawowego, jak i unikatowe kolumny są zwracane, kolumny klucza podstawowego są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.</xref:System.Data.DataTable>       Należy pamiętać, że klucze podstawowe i ograniczenia unique są dodawane do <xref:System.Data.ConstraintCollection>zgodnie z powyższych reguł, ale także inne ograniczenia typów nie są dodawane.</xref:System.Data.ConstraintCollection>       Jeśli klastrowany unikatowy indeks jest zdefiniowany w kolumnie lub kolumny w tabeli programu SQL Server i ograniczenia klucza podstawowego została zdefiniowana osobny zestaw kolumn, będzie zwracana nazwy kolumn w indeksu klastrowanego. Aby zwrócić nazwę lub nazwy kolumn klucza podstawowego, należy użyć wskazówki zapytania z instrukcji SELECT, która określa nazwę indeksu klucza podstawowego. Aby uzyskać więcej informacji na temat określania wskazówki zapytania, zobacz [wskazówki zapytania (Transact-SQL)](http://msdn.microsoft.com/library/ms181714.aspx).       Jeśli <xref:System.Data.IDataAdapter>napotka zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje nazwy dla kolejnych kolumn, używania wzorca &quot;*columnname*1&quot;, &quot;*columnname*2&quot;,&quot;*columnname*3&quot; i tak dalej.</xref:System.Data.DataTable> </xref:System.Data.IDataAdapter> Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet>zgodnie ze wzorcem &quot;Kolumna1&quot;, &quot;Column2&quot; i tak dalej.</xref:System.Data.DataSet> Jeśli wiele zestawów wyników są dodawane do <xref:System.Data.DataSet>Każdy zestaw wyników znajduje się w osobnej tabeli.</xref:System.Data.DataSet> Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych na wartości do nazwy określonej tabeli (na przykład &quot;Table&quot;, &quot;Tabela1&quot;, &quot;Tabela2&quot; itd.). Aplikacji przy użyciu nazwy kolumn i tabel powinien upewnić się, że nie występują konflikty z tych wzorców nazewnictwa.       <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>Zwraca wszystkie wiersze.</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A>metody dodawania wierszy do <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter.Fill%2A>      > [!NOTE] > Podczas przetwarzania wsadowego instrukcji SQL, które zwracają wiele wartości, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>dla .NET Framework Data Provider for OLE DB pobiera informacje o schemacie dla pierwszego wyniku.</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A>z <xref:System.Data.MissingSchemaAction>ustawioną `AddWithKey`.</xref:System.Data.MissingSchemaAction> </xref:System.Data.Common.DbDataAdapter.Fill%2A>       Korzystając z <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, .NET Framework Data Provider for SQL Server dołącza klauzulę FOR BROWSE do instrukcji, które było wykonywane.</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Użytkownik należy zwrócić uwagę potencjalnych efekty uboczne, takie jak zakłócenia przy użyciu instrukcji FMTONLY wartość ON. Aby uzyskać więcej informacji zobacz dokumentację SQL Server — książki Online."
  syntax:
    content: protected virtual System.Data.DataTable FillSchema (System.Data.DataTable dataTable, System.Data.SchemaType schemaType, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);
    parameters:
    - id: dataTable
      type: System.Data.DataTable
      description: "<xref href=&quot;System.Data.DataTable&quot;> </xref> Do wypełnienia ze schematem ze źródła danych."
    - id: schemaType
      type: System.Data.SchemaType
      description: "Jeden z <xref href=&quot;System.Data.SchemaType&quot;> </xref> wartości."
    - id: command
      type: System.Data.IDbCommand
      description: "W instrukcji SQL SELECT używane do pobierania wierszy ze źródła danych."
    - id: behavior
      type: System.Data.CommandBehavior
      description: "Jeden z <xref href=&quot;System.Data.CommandBehavior&quot;> </xref> wartości."
    return:
      type: System.Data.DataTable
      description: "A <xref href=&quot;System.Data.DataTable&quot;> </xref> zwrócony obiekt, który zawiera informacje o schemacie ze źródła danych."
  overload: System.Data.Common.DbDataAdapter.FillSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.Data.IDbCommand,System.String,System.Data.CommandBehavior)
  id: FillSchema(System.Data.DataSet,System.Data.SchemaType,System.Data.IDbCommand,System.String,System.Data.CommandBehavior)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: FillSchema(DataSet,SchemaType,IDbCommand,String,CommandBehavior)
  nameWithType: DbDataAdapter.FillSchema(DataSet,SchemaType,IDbCommand,String,CommandBehavior)
  fullName: System.Data.Common.DbDataAdapter.FillSchema(DataSet,SchemaType,IDbCommand,String,CommandBehavior)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Dodaje <xref href=&quot;System.Data.DataTable&quot;> </xref> do określonego <xref href=&quot;System.Data.DataSet&quot;> </xref> i konfiguruje schemat do dopasowania w źródle danych, na podstawie której określony <xref href=&quot;System.Data.SchemaType&quot;> </xref>."
  remarks: "<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>Metoda pobiera schematu ze źródłem danych, używając <xref:System.Data.IDbDataAdapter.SelectCommand%2A>.</xref:System.Data.IDbDataAdapter.SelectCommand%2A> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Obiekt połączenia skojarzony z <xref:System.Data.IDbDataAdapter.SelectCommand%2A>musi być prawidłowy, ale nie musi być otwarty.</xref:System.Data.IDbDataAdapter.SelectCommand%2A> Jeśli połączenie jest zamknięte przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>jest wywoływana, jest otwarta do pobierania danych, następnie zamknięte.</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Jeśli połączenie jest otwarte przed <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>jest wywoływana, pozostaje otwarty.</xref:System.Data.Common.DbDataAdapter.FillSchema%2A>       <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>Operacja dodaje <xref:System.Data.DataTable>do miejsca docelowego <xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Następnie dodaje kolumny <xref:System.Data.DataColumnCollection>z <xref:System.Data.DataTable>oraz konfiguruje następujące opcje <xref:System.Data.DataColumn>Właściwości, jeśli istnieją w źródle danych:- <xref:System.Data.DataColumn.AllowDBNull%2A>- <xref:System.Data.DataColumn.AutoIncrement%2A>.</xref:System.Data.DataColumn.AutoIncrement%2A> </xref:System.Data.DataColumn.AllowDBNull%2A> </xref:System.Data.DataColumn> </xref:System.Data.DataTable> </xref:System.Data.DataColumnCollection> Należy ustawić <xref:System.Data.DataColumn.AutoIncrementStep%2A>i <xref:System.Data.DataColumn.AutoIncrementSeed%2A>oddzielnie.</xref:System.Data.DataColumn.AutoIncrementSeed%2A> </xref:System.Data.DataColumn.AutoIncrementStep%2A>      - <xref:System.Data.DataColumn.MaxLength%2A>- <xref:System.Data.DataColumn.ReadOnly%2A>- <xref:System.Data.DataColumn.Unique%2A><xref:System.Data.Common.DbDataAdapter.FillSchema%2A>konfiguruje również <xref:System.Data.DataTable.PrimaryKey%2A>i <xref:System.Data.DataTable.Constraints%2A>Właściwości zgodnie z następującymi zasadami: - Jeśli jeden lub więcej kolumn klucza podstawowego są zwracane przez <xref:System.Data.IDbDataAdapter.SelectCommand%2A>są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.IDbDataAdapter.SelectCommand%2A> </xref:System.Data.DataTable.Constraints%2A> </xref:System.Data.DataTable.PrimaryKey%2A> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A>       </xref:System.Data.DataColumn.Unique%2A> </xref:System.Data.DataColumn.ReadOnly%2A> </xref:System.Data.DataColumn.MaxLength%2A>      — Jeśli nie kolumn klucza podstawowego są zwracane, ale są unikatowe kolumny, unikatowe kolumny są używane jako klucz podstawowy w przypadku i tylko wtedy, gdy wszystkie unikatowe kolumny jest zaszyfrowana. Jeśli dowolnej kolumny dopuszczają wartości null, <xref:System.Data.UniqueConstraint>jest dodawany do <xref:System.Data.ConstraintCollection>, ale <xref:System.Data.DataTable.PrimaryKey%2A>nie ustawiono właściwości.</xref:System.Data.DataTable.PrimaryKey%2A> </xref:System.Data.ConstraintCollection> </xref:System.Data.UniqueConstraint>      — Jeśli zarówno kolumn klucza podstawowego, jak i unikatowe kolumny są zwracane, kolumny klucza podstawowego są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.</xref:System.Data.DataTable>       Należy pamiętać, że klucze podstawowe i ograniczenia unique są dodawane do <xref:System.Data.ConstraintCollection>zgodnie z powyższych reguł, ale także inne ograniczenia typów nie są dodawane.</xref:System.Data.ConstraintCollection>       Jeśli klastrowany unikatowy indeks jest zdefiniowany w kolumnie lub kolumny w tabeli programu SQL Server i ograniczenia klucza podstawowego została zdefiniowana osobny zestaw kolumn, będzie zwracana nazwy kolumn w indeksu klastrowanego. Aby zwrócić nazwę lub nazwy kolumn klucza podstawowego, należy użyć wskazówki zapytania z instrukcji SELECT, która określa nazwę indeksu klucza podstawowego. Aby uzyskać więcej informacji na temat określania wskazówki zapytania, zobacz [wskazówki zapytania (Transact-SQL)](http://msdn.microsoft.com/library/ms181714.aspx).       Jeśli <xref:System.Data.IDataAdapter>napotka zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje nazwy dla kolejnych kolumn, używania wzorca &quot;*columnname*1&quot;, &quot;*columnname*2&quot;,&quot;*columnname*3&quot; i tak dalej.</xref:System.Data.DataTable> </xref:System.Data.IDataAdapter> Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane w <xref:System.Data.DataSet>zgodnie ze wzorcem &quot;Kolumna1&quot;, &quot;Column2&quot; i tak dalej.</xref:System.Data.DataSet> Jeśli wiele zestawów wyników są dodawane do <xref:System.Data.DataSet>Każdy zestaw wyników znajduje się w osobnej tabeli.</xref:System.Data.DataSet> Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych na wartości do nazwy określonej tabeli (na przykład &quot;Table&quot;, &quot;Tabela1&quot;, &quot;Tabela2&quot; itd.). Aplikacji przy użyciu nazwy kolumn i tabel powinien upewnić się, że nie występują konflikty z tych wzorców nazewnictwa.       <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>Metoda obsługuje scenariusze gdzie <xref:System.Data.DataSet>zawiera wiele <xref:System.Data.DataTable>obiektów, których nazwy różnią się tylko wielkością liter.</xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A> W takich sytuacjach <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>przeprowadza porównanie uwzględniające wielkość liter można znaleźć odpowiedniej tabeli, a następnie tworzy nową tabelę, jeśli istnieje dokładnego dopasowania.</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Poniższy kod C# ilustruje to zachowanie.      ```   DataSet dataset = new DataSet();   dataset.Tables.Add(&quot;aaa&quot;);   dataset.Tables.Add(&quot;AAA&quot;);   adapter.FillSchema(dataset, &quot;aaa&quot;); // Fills the schema of &quot;aaa&quot;, which already exists in the DataSet.   adapter.FillSchema(dataset, &quot;Aaa&quot;); // Adds a new table called &quot;Aaa&quot;.   ```Jeśli <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>nosi nazwę i <xref:System.Data.DataSet>zawiera tylko jeden <xref:System.Data.DataTable>o nazwie różni się tylko wielkością liter, która <xref:System.Data.DataTable>jest aktualizowany.</xref:System.Data.DataTable> </xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A> W tym scenariuszu wynik porównania ma bez uwzględniania wielkości liter. Poniższy kod C# ilustruje to zachowanie.      ```   DataSet dataset = new DataSet();   dataset.Tables.Add(&quot;aaa&quot;);   adapter.FillSchema(dataset, &quot;AAA&quot;); // Fills the schema of table &quot;aaa&quot; because only one similarly named table is in the DataSet.   ```       <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>Zwraca wszystkie wiersze.</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A>metody dodawania wierszy do <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter.Fill%2A>      > [!NOTE] > Podczas przetwarzania wsadowego instrukcji SQL, które zwracają wiele wartości, implementacja <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>dla .NET Framework Data Provider for OLE DB pobiera informacje o schemacie dla pierwszego wyniku.</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Aby uzyskać informacje o schemacie dla wielu wyników, użyj <xref:System.Data.Common.DbDataAdapter.Fill%2A>z <xref:System.Data.MissingSchemaAction>ustawioną `AddWithKey`.</xref:System.Data.MissingSchemaAction> </xref:System.Data.Common.DbDataAdapter.Fill%2A>       Korzystając z <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, .NET Framework Data Provider for SQL Server dołącza klauzulę FOR BROWSE do instrukcji, które było wykonywane.</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> Użytkownik należy zwrócić uwagę potencjalnych efekty uboczne, takie jak zakłócenia przy użyciu instrukcji FMTONLY wartość ON. Aby uzyskać więcej informacji zobacz dokumentację SQL Server — książki Online."
  syntax:
    content: protected virtual System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType, System.Data.IDbCommand command, string srcTable, System.Data.CommandBehavior behavior);
    parameters:
    - id: dataSet
      type: System.Data.DataSet
      description: "<xref href=&quot;System.Data.DataSet&quot;> </xref> Do wypełnienia ze schematem ze źródła danych."
    - id: schemaType
      type: System.Data.SchemaType
      description: "Jeden z <xref href=&quot;System.Data.SchemaType&quot;> </xref> wartości."
    - id: command
      type: System.Data.IDbCommand
      description: "W instrukcji SQL SELECT używane do pobierania wierszy ze źródła danych."
    - id: srcTable
      type: System.String
      description: "Nazwa tabeli źródłowej na potrzeby mapowania tabeli."
    - id: behavior
      type: System.Data.CommandBehavior
      description: "Jeden z <xref href=&quot;System.Data.CommandBehavior&quot;> </xref> wartości."
    return:
      type: System.Data.DataTable[]
      description: "Tablica <xref href=&quot;System.Data.DataTable&quot;> </xref> obiektów, które zawierają informacje o schemacie zwracane ze źródła danych."
  overload: System.Data.Common.DbDataAdapter.FillSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.GetBatchedParameter(System.Int32,System.Int32)
  id: GetBatchedParameter(System.Int32,System.Int32)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: GetBatchedParameter(Int32,Int32)
  nameWithType: DbDataAdapter.GetBatchedParameter(Int32,Int32)
  fullName: System.Data.Common.DbDataAdapter.GetBatchedParameter(Int32,Int32)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Zwraca <xref href=&quot;System.Data.IDataParameter&quot;> </xref> z jednego z poleceń w bieżącej partii."
  remarks: "W <xref:System.Data.Common.DbDataAdapter>, ta metoda zgłasza <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.Data.Common.DbDataAdapter> Klasy, które dziedziczą z <xref:System.Data.Common.DbDataAdapter>przesłonić tę metodę, aby zapewnić obsługę dla partii.</xref:System.Data.Common.DbDataAdapter>"
  syntax:
    content: protected virtual System.Data.IDataParameter GetBatchedParameter (int commandIdentifier, int parameterIndex);
    parameters:
    - id: commandIdentifier
      type: System.Int32
      description: "Indeks polecenie, aby pobrać parametru z."
    - id: parameterIndex
      type: System.Int32
      description: "Indeks parametru w poleceniu."
    return:
      type: System.Data.IDataParameter
      description: "<xref href=&quot;System.Data.IDataParameter&quot;> </xref> Określony."
  overload: System.Data.Common.DbDataAdapter.GetBatchedParameter*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Karta nie obsługuje partie."
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.GetBatchedRecordsAffected(System.Int32,System.Int32@,System.Exception@)
  id: GetBatchedRecordsAffected(System.Int32,System.Int32@,System.Exception@)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: GetBatchedRecordsAffected(Int32,Int32,Exception)
  nameWithType: DbDataAdapter.GetBatchedRecordsAffected(Int32,Int32,Exception)
  fullName: System.Data.Common.DbDataAdapter.GetBatchedRecordsAffected(Int32,Int32,Exception)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Zwraca informacje o próba indywidualnej aktualizacji w większych aktualizacji wsadowych."
  remarks: "Dostawcy danych, obsługujące wsadowej logikę aktualizowania przesłonięcie szereg wirtualnej metody w <xref:System.Data.Common.DbDataAdapter>klasie.</xref:System.Data.Common.DbDataAdapter> `GetBatchedRecordsAffected`reprezentuje jedną z tych metod wirtualnych. `DbDataAdapter` Zależy od klasy `GetBatchedRecordsAffected` Aby określić powodzenie lub niepowodzenie prób indywidualnej aktualizacji w partii, dlatego można oznaczyć, każdego odpowiadającego <xref:System.Data.DataRow>odpowiednio.</xref:System.Data.DataRow>"
  syntax:
    content: protected virtual bool GetBatchedRecordsAffected (int commandIdentifier, out int recordsAffected, out Exception error);
    parameters:
    - id: commandIdentifier
      type: System.Int32
      description: "Numer kolumny od zera określonego polecenia w partii."
    - id: recordsAffected
      type: System.Int32
      description: "Liczba wierszy w magazynie danych dotyczy określonego polecenia w partii."
    - id: error
      type: System.Exception
      description: "<xref:System.Exception>Zgłoszony podczas wykonywania tego polecenia.</xref:System.Exception> Zwraca <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref> w języku Visual Basic), jeśli nie jest wyjątek."
    return:
      type: System.Boolean
      description: "Informacje o próba indywidualnej aktualizacji w większych aktualizacji wsadowych."
  overload: System.Data.Common.DbDataAdapter.GetBatchedRecordsAffected*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.GetFillParameters
  id: GetFillParameters
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: GetFillParameters()
  nameWithType: DbDataAdapter.GetFillParameters()
  fullName: System.Data.Common.DbDataAdapter.GetFillParameters()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Pobiera parametry ustawione przez użytkownika podczas wykonywania instrukcji SQL SELECT."
  syntax:
    content: public override System.Data.IDataParameter[] GetFillParameters ();
    parameters: []
    return:
      type: System.Data.IDataParameter[]
      description: "Tablica <xref href=&quot;System.Data.IDataParameter&quot;> </xref> obiektów, które zawiera parametry ustawiony przez użytkownika."
  overload: System.Data.Common.DbDataAdapter.GetFillParameters*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.InitializeBatching
  id: InitializeBatching
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: InitializeBatching()
  nameWithType: DbDataAdapter.InitializeBatching()
  fullName: System.Data.Common.DbDataAdapter.InitializeBatching()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Inicjuje przetwarzania wsadowego dla <xref href=&quot;System.Data.Common.DbDataAdapter&quot;> </xref>."
  remarks: "W <xref:System.Data.Common.DbDataAdapter>, ta metoda zgłasza <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.Data.Common.DbDataAdapter> Klasy, które dziedziczą z <xref:System.Data.Common.DbDataAdapter>przesłonić tę metodę, aby zapewnić obsługę dla partii.</xref:System.Data.Common.DbDataAdapter>"
  syntax:
    content: protected virtual void InitializeBatching ();
    parameters: []
  overload: System.Data.Common.DbDataAdapter.InitializeBatching*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Karta nie obsługuje partie."
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.InsertCommand
  id: InsertCommand
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: InsertCommand
  nameWithType: DbDataAdapter.InsertCommand
  fullName: System.Data.Common.DbDataAdapter.InsertCommand
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Pobiera lub ustawia polecenie służące do wstawianie nowych rekordów do źródła danych."
  remarks: "Podczas <xref:System.Data.Common.DbDataAdapter.Update%2A>, jeśli ta właściwość nie jest ustawiona i informacje o kluczu podstawowym znajduje się w <xref:System.Data.DataSet>, <xref:System.Data.IDbDataAdapter.InsertCommand%2A>będą automatycznie generowane.</xref:System.Data.IDbDataAdapter.InsertCommand%2A> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Update%2A>"
  example:
  - "The following example creates the derived class <xref:System.Data.OleDb.OleDbDataAdapter> and sets some of its properties.  \n  \n [!code-cs[Classic WebData DbDataAdapter.InsertCommand Example#1](~/add/codesnippet/csharp/p-system.data.common.dbd_0_1.cs)]\n [!code-vb[Classic WebData DbDataAdapter.InsertCommand Example#1](~/add/codesnippet/visualbasic/p-system.data.common.dbd_0_1.vb)]"
  syntax:
    content: public System.Data.Common.DbCommand InsertCommand { get; set; }
    return:
      type: System.Data.Common.DbCommand
      description: "A <xref href=&quot;System.Data.IDbCommand&quot;> </xref> używane podczas <xref:System.Data.IDataAdapter.Update*>do wstawiania rekordów w źródle danych dla nowych wierszy w zestawie danych.</xref:System.Data.IDataAdapter.Update*>"
  overload: System.Data.Common.DbDataAdapter.InsertCommand*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)
  id: OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: OnRowUpdated(RowUpdatedEventArgs)
  nameWithType: DbDataAdapter.OnRowUpdated(RowUpdatedEventArgs)
  fullName: System.Data.Common.DbDataAdapter.OnRowUpdated(RowUpdatedEventArgs)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Zgłasza <xref uid=&quot;langword_csharp_RowUpdated&quot; name=&quot;RowUpdated&quot; href=&quot;&quot;> </xref> zdarzenia dostawcy danych .NET Framework."
  remarks: 'Wywoływanie zdarzeń wywołuje program obsługi zdarzeń za pośrednictwem pełnomocnika. Aby uzyskać ogólne informacje, zobacz [NIB: wywoływanie zdarzeń](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).'
  syntax:
    content: protected virtual void OnRowUpdated (System.Data.Common.RowUpdatedEventArgs value);
    parameters:
    - id: value
      type: System.Data.Common.RowUpdatedEventArgs
      description: "A <xref href=&quot;System.Data.Common.RowUpdatedEventArgs&quot;> </xref> zawierający dane zdarzenia."
  overload: System.Data.Common.DbDataAdapter.OnRowUpdated*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)
  id: OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: OnRowUpdating(RowUpdatingEventArgs)
  nameWithType: DbDataAdapter.OnRowUpdating(RowUpdatingEventArgs)
  fullName: System.Data.Common.DbDataAdapter.OnRowUpdating(RowUpdatingEventArgs)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Zgłasza <xref uid=&quot;langword_csharp_RowUpdating&quot; name=&quot;RowUpdating&quot; href=&quot;&quot;> </xref> zdarzenia dostawcy danych .NET Framework."
  remarks: 'Wywoływanie zdarzeń wywołuje program obsługi zdarzeń za pośrednictwem pełnomocnika. Aby uzyskać ogólne informacje, zobacz [NIB: wywoływanie zdarzeń](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).'
  syntax:
    content: protected virtual void OnRowUpdating (System.Data.Common.RowUpdatingEventArgs value);
    parameters:
    - id: value
      type: System.Data.Common.RowUpdatingEventArgs
      description: "<xref href=&quot;System.Data.Common.RowUpdatingEventArgs&quot;> </xref> Zawierający dane zdarzenia."
  overload: System.Data.Common.DbDataAdapter.OnRowUpdating*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.SelectCommand
  id: SelectCommand
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: SelectCommand
  nameWithType: DbDataAdapter.SelectCommand
  fullName: System.Data.Common.DbDataAdapter.SelectCommand
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Pobiera lub ustawia polecenie, aby wybrać rekordy w źródle danych."
  remarks: ''
  example:
  - "The following example creates the derived class <xref:System.Data.OleDb.OleDbDataAdapter> and sets some of its properties.  \n  \n [!code-cs[Classic WebData DbDataAdapter.SelectCommand Example#1](~/add/codesnippet/csharp/p-system.data.common.dbd_1_1.cs)]\n [!code-vb[Classic WebData DbDataAdapter.SelectCommand Example#1](~/add/codesnippet/visualbasic/p-system.data.common.dbd_1_1.vb)]"
  syntax:
    content: public System.Data.Common.DbCommand SelectCommand { get; set; }
    return:
      type: System.Data.Common.DbCommand
      description: "A <xref href=&quot;System.Data.IDbCommand&quot;> </xref> używany podczas <xref:System.Data.IDataAdapter.Update*>Aby wybrać rekordy ze źródła danych do umieszczenia w zestawie danych.</xref:System.Data.IDataAdapter.Update*>"
  overload: System.Data.Common.DbDataAdapter.SelectCommand*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#DeleteCommand
  id: System#Data#IDbDataAdapter#DeleteCommand
  isEii: true
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: System.Data.IDbDataAdapter.DeleteCommand
  nameWithType: DbDataAdapter.System.Data.IDbDataAdapter.DeleteCommand
  fullName: System.Data.Common.DbDataAdapter.System.Data.IDbDataAdapter.DeleteCommand
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Pobiera lub ustawia instrukcji SQL podczas usuwania rekordów z zestawu danych."
  remarks: "Ten element jest jawną implementacją elementu interfejsu. Można go używać tylko wtedy, gdy <xref:System.Data.Common.DbDataAdapter>wystąpienia jest rzutowane na <xref:System.Data.IDbDataAdapter>interfejsu.</xref:System.Data.IDbDataAdapter> </xref:System.Data.Common.DbDataAdapter>       Aby uzyskać więcej informacji zobacz <xref:System.Data.IDbDataAdapter.DeleteCommand%2A>.</xref:System.Data.IDbDataAdapter.DeleteCommand%2A>"
  syntax:
    content: System.Data.IDbCommand System.Data.IDbDataAdapter.DeleteCommand { get; set; }
    return:
      type: System.Data.IDbCommand
      description: "<xref href=&quot;System.Data.IDbCommand&quot;> </xref> Używane podczas <xref:System.Data.Common.DbDataAdapter.Update*>usunąć rekordy w źródle danych dla usuniętych wierszy w zestawie danych.</xref:System.Data.Common.DbDataAdapter.Update*>"
  overload: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#DeleteCommand*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#InsertCommand
  id: System#Data#IDbDataAdapter#InsertCommand
  isEii: true
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: System.Data.IDbDataAdapter.InsertCommand
  nameWithType: DbDataAdapter.System.Data.IDbDataAdapter.InsertCommand
  fullName: System.Data.Common.DbDataAdapter.System.Data.IDbDataAdapter.InsertCommand
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Pobiera lub ustawia instrukcji SQL umożliwia wstawianie nowych rekordów do źródła danych."
  remarks: "Ten element jest jawną implementacją elementu interfejsu. Można go używać tylko wtedy, gdy <xref:System.Data.Common.DbDataAdapter>wystąpienia jest rzutowane na <xref:System.Data.IDbDataAdapter>interfejsu.</xref:System.Data.IDbDataAdapter> </xref:System.Data.Common.DbDataAdapter>       Aby uzyskać więcej informacji zobacz <xref:System.Data.IDbDataAdapter.InsertCommand%2A>.</xref:System.Data.IDbDataAdapter.InsertCommand%2A>"
  syntax:
    content: System.Data.IDbCommand System.Data.IDbDataAdapter.InsertCommand { get; set; }
    return:
      type: System.Data.IDbCommand
      description: "<xref href=&quot;System.Data.IDbCommand&quot;> </xref> Używane podczas <xref:System.Data.Common.DbDataAdapter.Update*>do wstawiania rekordów w źródle danych dla nowych wierszy w zestawie danych.</xref:System.Data.Common.DbDataAdapter.Update*>"
  overload: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#InsertCommand*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#SelectCommand
  id: System#Data#IDbDataAdapter#SelectCommand
  isEii: true
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: System.Data.IDbDataAdapter.SelectCommand
  nameWithType: DbDataAdapter.System.Data.IDbDataAdapter.SelectCommand
  fullName: System.Data.Common.DbDataAdapter.System.Data.IDbDataAdapter.SelectCommand
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Pobiera lub ustawia instrukcji SQL, aby wybrać rekordy w źródle danych."
  remarks: "Ten element jest jawną implementacją elementu interfejsu. Można go używać tylko wtedy, gdy <xref:System.Data.Common.DbDataAdapter>wystąpienia jest rzutowane na <xref:System.Data.IDbDataAdapter>interfejsu.</xref:System.Data.IDbDataAdapter> </xref:System.Data.Common.DbDataAdapter>       Aby uzyskać więcej informacji zobacz <xref:System.Data.IDbDataAdapter.SelectCommand%2A>.</xref:System.Data.IDbDataAdapter.SelectCommand%2A>"
  syntax:
    content: System.Data.IDbCommand System.Data.IDbDataAdapter.SelectCommand { get; set; }
    return:
      type: System.Data.IDbCommand
      description: "<xref href=&quot;System.Data.IDbCommand&quot;> </xref> Używany podczas <xref:System.Data.Common.DbDataAdapter.Update*>Aby wybrać rekordy ze źródła danych do umieszczenia w zestawie danych.</xref:System.Data.Common.DbDataAdapter.Update*>"
  overload: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#SelectCommand*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#UpdateCommand
  id: System#Data#IDbDataAdapter#UpdateCommand
  isEii: true
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: System.Data.IDbDataAdapter.UpdateCommand
  nameWithType: DbDataAdapter.System.Data.IDbDataAdapter.UpdateCommand
  fullName: System.Data.Common.DbDataAdapter.System.Data.IDbDataAdapter.UpdateCommand
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Pobiera lub ustawia instrukcji SQL używane do aktualizowania rekordów w źródle danych."
  remarks: "Ten element jest jawną implementacją elementu interfejsu. Można go używać tylko wtedy, gdy <xref:System.Data.Common.DbDataAdapter>wystąpienia jest rzutowane na <xref:System.Data.IDbDataAdapter>interfejsu.</xref:System.Data.IDbDataAdapter> </xref:System.Data.Common.DbDataAdapter>       Aby uzyskać więcej informacji zobacz <xref:System.Data.IDbDataAdapter.UpdateCommand%2A>.</xref:System.Data.IDbDataAdapter.UpdateCommand%2A>"
  syntax:
    content: System.Data.IDbCommand System.Data.IDbDataAdapter.UpdateCommand { get; set; }
    return:
      type: System.Data.IDbCommand
      description: "<xref href=&quot;System.Data.IDbCommand&quot;> </xref> Używane podczas <xref:System.Data.Common.DbDataAdapter.Update*>do aktualizowania rekordów w źródle danych dla zmodyfikowanych wierszy w zestawie danych.</xref:System.Data.Common.DbDataAdapter.Update*>"
  overload: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#UpdateCommand*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.System#ICloneable#Clone
  id: System#ICloneable#Clone
  isEii: true
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: System.ICloneable.Clone()
  nameWithType: DbDataAdapter.System.ICloneable.Clone()
  fullName: System.Data.Common.DbDataAdapter.System.ICloneable.Clone()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Tworzy nowy obiekt, który jest kopią bieżącego wystąpienia."
  remarks: "Ten element jest jawną implementacją elementu interfejsu. Można go używać tylko wtedy, gdy <xref:System.Data.Common.DbDataAdapter>wystąpienia jest rzutowane na <xref:System.ICloneable>interfejsu.</xref:System.ICloneable> </xref:System.Data.Common.DbDataAdapter>       Aby uzyskać więcej informacji zobacz <xref:System.ICloneable.Clone%2A?displayProperty=fullName>.</xref:System.ICloneable.Clone%2A?displayProperty=fullName>"
  syntax:
    content: object ICloneable.Clone ();
    parameters: []
    return:
      type: System.Object
      description: "Nowy obiekt, który jest kopią tego wystąpienia."
  overload: System.Data.Common.DbDataAdapter.System#ICloneable#Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.TerminateBatching
  id: TerminateBatching
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: TerminateBatching()
  nameWithType: DbDataAdapter.TerminateBatching()
  fullName: System.Data.Common.DbDataAdapter.TerminateBatching()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Kończy się przetwarzanie wsadowe dla <xref href=&quot;System.Data.Common.DbDataAdapter&quot;> </xref>."
  remarks: "W <xref:System.Data.Common.DbDataAdapter>, ta metoda zgłasza <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.Data.Common.DbDataAdapter> Klasy, które dziedziczą z <xref:System.Data.Common.DbDataAdapter>przesłonić tę metodę, aby zapewnić obsługę dla partii.</xref:System.Data.Common.DbDataAdapter>"
  syntax:
    content: protected virtual void TerminateBatching ();
    parameters: []
  overload: System.Data.Common.DbDataAdapter.TerminateBatching*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Karta nie obsługuje partie."
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Update(System.Data.DataRow[])
  id: Update(System.Data.DataRow[])
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Update(DataRow[])
  nameWithType: DbDataAdapter.Update(DataRow[])
  fullName: System.Data.Common.DbDataAdapter.Update(DataRow[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Aktualizuje wartości w bazie danych, wykonując odpowiednie instrukcje INSERT, UPDATE lub DELETE dla każdego wstawiania, aktualizacji lub usuwania wiersza w określonej tablicy w <xref href=&quot;System.Data.DataSet&quot;> </xref>."
  remarks: "Gdy aplikacja wywołuje <xref:System.Data.Common.DbDataAdapter.Update%2A>metody <xref:System.Data.Common.DbDataAdapter>sprawdza <xref:System.Data.DataRow.RowState%2A>Właściwości i wykonuje wymaganych instrukcji INSERT, UPDATE lub DELETE wielokrotnie powtarzane dla każdego wiersza, na podstawie kolejności indeksów skonfigurowane w <xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataRow.RowState%2A> </xref:System.Data.Common.DbDataAdapter> </xref:System.Data.Common.DbDataAdapter.Update%2A> Na przykład, <xref:System.Data.Common.DbDataAdapter.Update%2A>może wykonać instrukcji DELETE, a następnie instrukcji INSERT, a następnie inne instrukcji DELETE, ze względu na kolejność wierszy w <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter.Update%2A>       Należy zauważyć, że oświadczenia te nie są wykonywane jako przetwarzania wsadowego; Każdy wiersz jest aktualizowana pojedynczo. Aplikacja może wywołać <xref:System.Data.DataSet.GetChanges%2A>metody w sytuacjach, w którym musi sterowania sekwencją typów instrukcji (na przykład wstawia przed aktualizacji).</xref:System.Data.DataSet.GetChanges%2A> Aby uzyskać więcej informacji, zobacz [aktualizowanie źródła danych z obiektów DataAdapter](~/add/includes/ajax-current-ext-md.md).       Jeśli nie zostały określone instrukcji INSERT, UPDATE lub DELETE, <xref:System.Data.Common.DbDataAdapter.Update%2A>Metoda generuje wyjątek.</xref:System.Data.Common.DbDataAdapter.Update%2A> Można jednak utworzyć <xref:System.Data.SqlClient.SqlCommandBuilder>lub <xref:System.Data.OleDb.OleDbCommandBuilder>obiekt, aby automatycznie wygenerować instrukcji SQL aktualizacje pojedynczej tabeli, jeśli ustawisz `SelectCommand` właściwości dostawcy danych .NET Framework.</xref:System.Data.OleDb.OleDbCommandBuilder> </xref:System.Data.SqlClient.SqlCommandBuilder> Następnie żadnych dodatkowych instrukcji SQL, które nie zostały ustawione są generowane przez **CommandBuilder**. Tę logikę generowania wymaga informacji o kolumnie klucza znajdować się w <xref:System.Data.DataSet>.</xref:System.Data.DataSet> Aby uzyskać więcej informacji, zobacz [generowania poleceń CommandBuilders](~/add/includes/ajax-current-ext-md.md).       <xref:System.Data.Common.DbDataAdapter.Update%2A>Metoda pobiera wiersze z tabeli umieszczone w pierwszym mapowania przed wykonaniem operacji aktualizacji.</xref:System.Data.Common.DbDataAdapter.Update%2A> <xref:System.Data.Common.DbDataAdapter.Update%2A>Następnie odświeża wiersza przy użyciu wartości <xref:System.Data.IDbCommand.UpdatedRowSource%2A>Właściwości.</xref:System.Data.IDbCommand.UpdatedRowSource%2A> </xref:System.Data.Common.DbDataAdapter.Update%2A> Dodatkowe wiersze zwracane są ignorowane.       Po załadowaniu danych do <xref:System.Data.DataSet>, <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>zdarzenia, dzięki czemu użytkownik do sprawdzenia uzgodniony <xref:System.Data.DataSet>wiersza i wszystkie dane wyjściowe Parametry zwracane przez polecenie.</xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> </xref:System.Data.DataSet> Po wierszu aktualizacji pomyślnie, zmiany w tym wierszu są akceptowane.       Korzystając z <xref:System.Data.Common.DbDataAdapter.Update%2A>, kolejność wykonywania jest następująca: 1.</xref:System.Data.Common.DbDataAdapter.Update%2A>  Wartości w <xref:System.Data.DataRow>zostaną przeniesione do wartości parametrów.</xref:System.Data.DataRow>      2.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A>Zdarzenie jest wywoływane.</xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A>      3.  Wykonuje polecenia.      4.  Jeśli polecenie ma ustawioną wartość `FirstReturnedRecord`, pierwszy zwrócony wynik jest umieszczany w <xref:System.Data.DataRow>.</xref:System.Data.DataRow>      5.  W przypadku parametrów wyjściowych są umieszczane w <xref:System.Data.DataRow>.</xref:System.Data.DataRow>      6.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>Zdarzenie jest wywoływane.</xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>      7.  <xref:System.Data.DataRow.AcceptChanges%2A>jest wywoływana.</xref:System.Data.DataRow.AcceptChanges%2A>       Każde polecenie skojarzone z <xref:System.Data.Common.DbDataAdapter>zwykle ma kolekcję parametrów skojarzonych z nim.</xref:System.Data.Common.DbDataAdapter> Parametry są zamapowane do bieżącego wiersza za pośrednictwem `SourceColumn` i `SourceVersion` właściwości dostawcy danych .NET Framework `Parameter` klasy. `SourceColumn`odwołuje się do <xref:System.Data.DataTable>kolumny który <xref:System.Data.Common.DbDataAdapter>odwołania do uzyskania wartości parametrów dla bieżącego wiersza.</xref:System.Data.Common.DbDataAdapter> </xref:System.Data.DataTable>       `SourceColumn`odwołuje się do nazwy kolumny Niemapowane przed mapowań tabeli zostały zastosowane. Jeśli `SourceColumn` odwołuje się do nieistniejącej kolumny akcję wykonywaną zależy od jednego z następujących <xref:System.Data.MissingMappingAction>wartości.</xref:System.Data.MissingMappingAction>      | Wartość wyliczenia | Działania podjęte |   |-----------------------|------------------|   | `MissingMappingAction.Passthrough`| Korzystać z nazwy kolumny źródła i nazwy tabeli w <xref:System.Data.DataSet>nie jest obecny. |   | `MissingMappingAction.Ignore`| A <xref:System.SystemException>jest generowany.</xref:System.SystemException> </xref:System.Data.DataSet> Podczas mapowania są jawnie ustawiona, brakuje mapowania w dla parametru wejściowego jest zazwyczaj wynikiem błędu. |   | `MissingMappingAction.Error`| Generowany jest <xref:System.SystemException>. |       `SourceColumn` Właściwości są również używane do mapowania wartości dla danych wyjściowych lub parametry wejścia/wyjścia z powrotem do `DataSet`.</xref:System.SystemException> Wyjątek jest generowany, gdy odwołuje się do nieistniejącej kolumny.       `SourceVersion` Właściwości dostawcy danych .NET Framework `Parameter` klasy określa, czy użyć wersji Original, Current lub Proposed wartości kolumny. Ta funkcja jest często używane do uwzględnienia oryginalnych wartości w klauzuli WHERE instrukcji UPDATE, aby wyszukać naruszeń optymistycznej współbieżności.      > [!NOTE] > Jeśli wystąpi błąd podczas aktualizowania wiersza, jest zgłaszany wyjątek i wykonywania aktualizacji nie jest już obsługiwana. Aby kontynuować operację aktualizacji bez generowania wyjątków, gdy wystąpi błąd, ustaw <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A>właściwości `true` przed wywołaniem <xref:System.Data.Common.DbDataAdapter.Update%2A>.</xref:System.Data.Common.DbDataAdapter.Update%2A> </xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> Mogą również odpowiadać błędów na podstawie na wiersz, w ramach `RowUpdated` zdarzeń element DataAdapter. Aby kontynuować operację aktualizacji bez generowania wyjątku `RowUpdated` zdarzeń, ustaw <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A>Właściwość <xref:System.Data.Common.RowUpdatedEventArgs>do <xref:System.Data.UpdateStatus>.</xref:System.Data.UpdateStatus> </xref:System.Data.Common.RowUpdatedEventArgs> </xref:System.Data.Common.RowUpdatedEventArgs.Status%2A>"
  example:
  - "The following example uses the derived class, <xref:System.Data.OleDb.OleDbDataAdapter>, to update the data source.  \n  \n [!code-cs[Classic WebData DbDataAdapter.Update1 Example#1](~/add/codesnippet/csharp/m-system.data.common.dbd_0_1.cs)]\n [!code-vb[Classic WebData DbDataAdapter.Update1 Example#1](~/add/codesnippet/visualbasic/m-system.data.common.dbd_0_1.vb)]"
  syntax:
    content: public int Update (System.Data.DataRow[] dataRows);
    parameters:
    - id: dataRows
      type: System.Data.DataRow[]
      description: "Tablica <xref href=&quot;System.Data.DataRow&quot;> </xref> obiekty używane do aktualizowania źródła danych."
    return:
      type: System.Int32
      description: "Liczba pomyślnie zaktualizowanych z <xref href=&quot;System.Data.DataSet&quot;> </xref>."
  overload: System.Data.Common.DbDataAdapter.Update*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<xref href=&quot;System.Data.DataSet&quot;> </xref> Jest nieprawidłowy."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Tabela źródłowa jest nieprawidłowa."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Nie <xref href=&quot;System.Data.DataRow&quot;> </xref> istnieje aktualizacji.       - lub - No <xref href=&quot;System.Data.DataTable&quot;> </xref> istnieje aktualizacji.       - lub - No <xref href=&quot;System.Data.DataSet&quot;> </xref> istnieje do użycia jako źródło."
  - type: System.Data.DBConcurrencyException
    commentId: T:System.Data.DBConcurrencyException
    description: "Próba wykonania instrukcji INSERT, UPDATE lub DELETE spowodowała zero zmodyfikowanych rekordów."
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)
  id: Update(System.Data.DataSet)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Update(DataSet)
  nameWithType: DbDataAdapter.Update(DataSet)
  fullName: System.Data.Common.DbDataAdapter.Update(DataSet)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Aktualizuje wartości w bazie danych, wykonując odpowiednie instrukcje INSERT, UPDATE lub DELETE dla każdego wstawienia, aktualizacji lub usunięcia wiersza w określonej <xref href=&quot;System.Data.DataSet&quot;> </xref>."
  remarks: "Gdy aplikacja wywołuje metody aktualizacji <xref:System.Data.Common.DbDataAdapter>sprawdza <xref:System.Data.DataRow.RowState%2A>właściwości oraz wykonuje wymaganych instrukcji INSERT, UPDATE lub DELETE wielokrotnie powtarzane dla każdego wiersza, na podstawie kolejności indeksów skonfigurowane w <xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataRow.RowState%2A> </xref:System.Data.Common.DbDataAdapter> Na przykład aktualizacji może wykonać instrukcji DELETE, a następnie instrukcji INSERT, a następnie inne instrukcji DELETE, ze względu na kolejność wierszy w <xref:System.Data.DataTable>.</xref:System.Data.DataTable>       Należy zauważyć, że oświadczenia te nie są wykonywane jako przetwarzania wsadowego; Każdy wiersz jest aktualizowana pojedynczo. Aplikacja może wywołać <xref:System.Data.DataSet.GetChanges%2A>metody w sytuacjach, w którym musi sterowania sekwencją typów instrukcji (na przykład wstawia przed aktualizacji).</xref:System.Data.DataSet.GetChanges%2A> Aby uzyskać więcej informacji, zobacz [aktualizowanie źródła danych z obiektów DataAdapter](~/add/includes/ajax-current-ext-md.md).       Jeśli instrukcji INSERT, UPDATE lub DELETE nie zostały określone, metoda aktualizacji generuje wyjątek. Można jednak utworzyć <xref:System.Data.SqlClient.SqlCommandBuilder>lub <xref:System.Data.OleDb.OleDbCommandBuilder>obiekt, aby automatycznie wygenerować instrukcji SQL aktualizacje pojedynczej tabeli, jeśli ustawisz `SelectCommand` właściwości dostawcy danych .NET Framework.</xref:System.Data.OleDb.OleDbCommandBuilder> </xref:System.Data.SqlClient.SqlCommandBuilder> Następnie żadnych dodatkowych instrukcji SQL, które nie zostały ustawione są generowane przez **CommandBuilder**. Tę logikę generowania wymaga informacji o kolumnie klucza znajdować się w <xref:System.Data.DataSet>.</xref:System.Data.DataSet> Aby uzyskać więcej informacji, zobacz [generowania poleceń CommandBuilders](~/add/includes/ajax-current-ext-md.md).       Metodę Update pobiera wiersze z tabeli umieszczone w pierwszym mapowania przed wykonaniem operacji aktualizacji. Aktualizacja odświeży wiersza przy użyciu wartości <xref:System.Data.IDbCommand.UpdatedRowSource%2A>Właściwości.</xref:System.Data.IDbCommand.UpdatedRowSource%2A> Dodatkowe wiersze zwracane są ignorowane.       Po załadowaniu danych do <xref:System.Data.DataSet>, <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>zdarzenia, dzięki czemu użytkownik do sprawdzenia uzgodniony <xref:System.Data.DataSet>wiersza i wszystkie dane wyjściowe Parametry zwracane przez polecenie.</xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> </xref:System.Data.DataSet> Po wierszu aktualizacji pomyślnie, zmiany w tym wierszu są akceptowane.       Podczas korzystania z aktualizacji, kolejność wykonywania jest następująca: 1.  Wartości w <xref:System.Data.DataRow>zostaną przeniesione do wartości parametrów.</xref:System.Data.DataRow>      2.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A>Zdarzenie jest wywoływane.</xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A>      3.  Wykonuje polecenia.      4.  Jeśli polecenie ma ustawioną wartość `FirstReturnedRecord`, a następnie pierwszy zwrócony wynik jest umieszczany w <xref:System.Data.DataRow>.</xref:System.Data.DataRow>      5.  W przypadku parametrów wyjściowych są umieszczane w <xref:System.Data.DataRow>.</xref:System.Data.DataRow>      6.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>Zdarzenie jest wywoływane.</xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>      7.  <xref:System.Data.DataRow.AcceptChanges%2A>jest wywoływana.</xref:System.Data.DataRow.AcceptChanges%2A>       Każde polecenie skojarzone z <xref:System.Data.Common.DbDataAdapter>zwykle ma kolekcję parametrów skojarzonych z nim.</xref:System.Data.Common.DbDataAdapter> Parametry są zamapowane do bieżącego wiersza za pośrednictwem `SourceColumn` i `SourceVersion` właściwości dostawcy danych .NET Framework `Parameter` klasy. `SourceColumn`odwołuje się do <xref:System.Data.DataTable>kolumny który <xref:System.Data.Common.DbDataAdapter>odwołania do uzyskania wartości parametrów dla bieżącego wiersza.</xref:System.Data.Common.DbDataAdapter> </xref:System.Data.DataTable>       `SourceColumn`odwołuje się do nazwy kolumny Niemapowane przed mapowań tabeli zostały zastosowane. Jeśli `SourceColumn` odwołuje się do nieistniejącej kolumny akcję wykonywaną zależy od jednego z następujących <xref:System.Data.MissingMappingAction>wartości.</xref:System.Data.MissingMappingAction>      | Wartość wyliczenia | Działania podjęte |   |-----------------------|------------------|   | `MissingMappingAction.Passthrough`| Korzystać z nazwy kolumny źródła i nazwy tabeli w <xref:System.Data.DataSet>nie jest obecny. |   | `MissingMappingAction.Ignore`| A <xref:System.SystemException>jest generowany.</xref:System.SystemException> </xref:System.Data.DataSet> Podczas mapowania są jawnie ustawiona, brakuje mapowania w dla parametru wejściowego jest zazwyczaj wynikiem błędu. |   | `MissingMappingAction.Error`| Generowany jest <xref:System.SystemException>. |       `SourceColumn` Właściwości są również używane do mapowania wartości dla danych wyjściowych lub parametry wejścia/wyjścia z powrotem do `DataSet`.</xref:System.SystemException> Wyjątek jest generowany, gdy odwołuje się do nieistniejącej kolumny.       `SourceVersion` Właściwości dostawcy danych .NET Framework `Parameter` klasy określa, czy użyć wersji Original, Current lub Proposed wartości kolumny. Ta funkcja jest często używane do uwzględnienia oryginalnych wartości w klauzuli WHERE instrukcji UPDATE, aby wyszukać naruszeń optymistycznej współbieżności.      > [!NOTE] > Jeśli wystąpi błąd podczas aktualizowania wiersza, jest zgłaszany wyjątek i wykonywania aktualizacji nie jest już obsługiwana. Aby kontynuować operację aktualizacji bez generowania wyjątków, gdy wystąpi błąd, ustaw <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A>właściwości `true` przed wywołaniem aktualizacji.</xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> Mogą również odpowiadać błędów na podstawie na wiersz, w ramach `RowUpdated` zdarzeń element DataAdapter. Aby kontynuować operację aktualizacji bez generowania wyjątku `RowUpdated` zdarzeń, ustaw <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A>Właściwość <xref:System.Data.Common.RowUpdatedEventArgs>do <xref:System.Data.UpdateStatus>.</xref:System.Data.UpdateStatus> </xref:System.Data.Common.RowUpdatedEventArgs> </xref:System.Data.Common.RowUpdatedEventArgs.Status%2A>"
  example:
  - "The following example uses the derived class, <xref:System.Data.OleDb.OleDbDataAdapter>, to update the data source.  \n  \n [!code-vb[Classic WebData DbDataAdapter.Update Example#1](~/add/codesnippet/visualbasic/m-system.data.common.dbd_4_1.vb)]\n [!code-cs[Classic WebData DbDataAdapter.Update Example#1](~/add/codesnippet/csharp/m-system.data.common.dbd_4_1.cs)]"
  syntax:
    content: public override int Update (System.Data.DataSet dataSet);
    parameters:
    - id: dataSet
      type: System.Data.DataSet
      description: "<xref href=&quot;System.Data.DataSet&quot;> </xref> Używana do aktualizowania źródła danych."
    return:
      type: System.Int32
      description: "Liczba pomyślnie zaktualizowanych z <xref href=&quot;System.Data.DataSet&quot;> </xref>."
  overload: System.Data.Common.DbDataAdapter.Update*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Tabela źródłowa jest nieprawidłowa."
  - type: System.Data.DBConcurrencyException
    commentId: T:System.Data.DBConcurrencyException
    description: "Próba wykonania instrukcji INSERT, UPDATE lub DELETE spowodowała zero zmodyfikowanych rekordów."
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Update(System.Data.DataTable)
  id: Update(System.Data.DataTable)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Update(DataTable)
  nameWithType: DbDataAdapter.Update(DataTable)
  fullName: System.Data.Common.DbDataAdapter.Update(DataTable)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Aktualizuje wartości w bazie danych, wykonując odpowiednie instrukcje INSERT, UPDATE lub DELETE dla każdego wstawienia, aktualizacji lub usunięcia wiersza w określonej <xref href=&quot;System.Data.DataTable&quot;> </xref>."
  remarks: "Gdy aplikacja wywołuje <xref:System.Data.Common.DbDataAdapter.Update%2A>metody <xref:System.Data.Common.DbDataAdapter>sprawdza <xref:System.Data.DataRow.RowState%2A>Właściwości i wykonuje wymaganych instrukcji INSERT, UPDATE lub DELETE wielokrotnie powtarzane dla każdego wiersza, na podstawie kolejności indeksów skonfigurowane w <xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataRow.RowState%2A> </xref:System.Data.Common.DbDataAdapter> </xref:System.Data.Common.DbDataAdapter.Update%2A> Na przykład, <xref:System.Data.Common.DbDataAdapter.Update%2A>może wykonać instrukcji DELETE, a następnie instrukcji INSERT, a następnie inne instrukcji DELETE, ze względu na kolejność wierszy w <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter.Update%2A>       Należy zauważyć, że oświadczenia te nie są wykonywane jako przetwarzania wsadowego; Każdy wiersz jest aktualizowana pojedynczo. Aplikacja może wywołać <xref:System.Data.DataSet.GetChanges%2A>metody w sytuacjach, w którym musi sterowania sekwencją typów instrukcji (na przykład wstawia przed aktualizacji).</xref:System.Data.DataSet.GetChanges%2A> Aby uzyskać więcej informacji, zobacz [aktualizowanie źródła danych z obiektów DataAdapter](~/add/includes/ajax-current-ext-md.md).       Jeśli nie zostały określone instrukcji INSERT, UPDATE lub DELETE, <xref:System.Data.Common.DbDataAdapter.Update%2A>Metoda generuje wyjątek.</xref:System.Data.Common.DbDataAdapter.Update%2A> Można jednak utworzyć <xref:System.Data.SqlClient.SqlCommandBuilder>lub <xref:System.Data.OleDb.OleDbCommandBuilder>obiekt, aby automatycznie wygenerować instrukcji SQL aktualizacje pojedynczej tabeli, jeśli ustawisz `SelectCommand` właściwości dostawcy danych .NET Framework.</xref:System.Data.OleDb.OleDbCommandBuilder> </xref:System.Data.SqlClient.SqlCommandBuilder> Następnie żadnych dodatkowych instrukcji SQL, które nie zostały ustawione są generowane przez **CommandBuilder**. Tę logikę generowania wymaga informacji o kolumnie klucza znajdować się w <xref:System.Data.DataSet>.</xref:System.Data.DataSet> Aby uzyskać więcej informacji, zobacz [generowania poleceń CommandBuilders](~/add/includes/ajax-current-ext-md.md).       <xref:System.Data.Common.DbDataAdapter.Update%2A>Metoda pobiera wiersze z tabeli umieszczone w pierwszym mapowania przed wykonaniem operacji aktualizacji.</xref:System.Data.Common.DbDataAdapter.Update%2A> <xref:System.Data.Common.DbDataAdapter.Update%2A>Następnie odświeża wiersza przy użyciu wartości <xref:System.Data.IDbCommand.UpdatedRowSource%2A>Właściwości.</xref:System.Data.IDbCommand.UpdatedRowSource%2A> </xref:System.Data.Common.DbDataAdapter.Update%2A> Dodatkowe wiersze zwracane są ignorowane.       Po załadowaniu danych do <xref:System.Data.DataSet>, <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>zdarzenia, dzięki czemu użytkownik do sprawdzenia uzgodniony <xref:System.Data.DataSet>wiersza i wszystkie dane wyjściowe Parametry zwracane przez polecenie.</xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> </xref:System.Data.DataSet> Po wierszu aktualizacji pomyślnie, zmiany w tym wierszu są akceptowane.       Korzystając z <xref:System.Data.Common.DbDataAdapter.Update%2A>, kolejność wykonywania jest następująca: 1.</xref:System.Data.Common.DbDataAdapter.Update%2A>  Wartości w <xref:System.Data.DataRow>zostaną przeniesione do wartości parametrów.</xref:System.Data.DataRow>      2.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A>Zdarzenie jest wywoływane.</xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A>      3.  Wykonuje polecenia.      4.  Jeśli polecenie ma ustawioną wartość `FirstReturnedRecord`, a następnie pierwszy zwrócony wynik jest umieszczany w <xref:System.Data.DataRow>.</xref:System.Data.DataRow>      5.  W przypadku parametrów wyjściowych są umieszczane w <xref:System.Data.DataRow>.</xref:System.Data.DataRow>      6.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>Zdarzenie jest wywoływane.</xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>      7.  <xref:System.Data.DataRow.AcceptChanges%2A>jest wywoływana.</xref:System.Data.DataRow.AcceptChanges%2A>       Każde polecenie skojarzone z <xref:System.Data.Common.DbDataAdapter>zwykle ma kolekcję parametrów skojarzonych z nim.</xref:System.Data.Common.DbDataAdapter> Parametry są zamapowane do bieżącego wiersza za pośrednictwem `SourceColumn` i `SourceVersion` właściwości dostawcy danych .NET Framework `Parameter` klasy. `SourceColumn`odwołuje się do <xref:System.Data.DataTable>kolumny który <xref:System.Data.Common.DbDataAdapter>odwołania do uzyskania wartości parametrów dla bieżącego wiersza.</xref:System.Data.Common.DbDataAdapter> </xref:System.Data.DataTable>       `SourceColumn`odwołuje się do nazwy kolumny Niemapowane przed mapowań tabeli zostały zastosowane. Jeśli `SourceColumn` odwołuje się do nieistniejącej kolumny akcję wykonywaną zależy od jednego z następujących <xref:System.Data.MissingMappingAction>wartości.</xref:System.Data.MissingMappingAction>      | Wartość wyliczenia | Działania podjęte |   |-----------------------|------------------|   | `MissingMappingAction.Passthrough`| Korzystać z nazwy kolumny źródła i nazwy tabeli w <xref:System.Data.DataSet>nie jest obecny. |   | `MissingMappingAction.Ignore`| A <xref:System.SystemException>jest generowany.</xref:System.SystemException> </xref:System.Data.DataSet> Podczas mapowania są jawnie ustawiona, brakuje mapowania w dla parametru wejściowego jest zazwyczaj wynikiem błędu. |   | `MissingMappingAction.Error`| Generowany jest <xref:System.SystemException>. |       `SourceColumn` Właściwości są również używane do mapowania wartości dla danych wyjściowych lub parametry wejścia/wyjścia z powrotem do `DataSet`.</xref:System.SystemException> Wyjątek jest generowany, gdy odwołuje się do nieistniejącej kolumny.       `SourceVersion` Właściwości dostawcy danych .NET Framework `Parameter` klasy określa, czy użyć wersji Original, Current lub Proposed wartości kolumny. Ta funkcja jest często używane do uwzględnienia oryginalnych wartości w klauzuli WHERE instrukcji UPDATE, aby wyszukać naruszeń optymistycznej współbieżności.      > [!NOTE] > Jeśli wystąpi błąd podczas aktualizowania wiersza, jest zgłaszany wyjątek i wykonywania aktualizacji nie jest już obsługiwana. Aby kontynuować operację aktualizacji bez generowania wyjątków, gdy wystąpi błąd, ustaw <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A>właściwości `true` przed wywołaniem <xref:System.Data.Common.DbDataAdapter.Update%2A>.</xref:System.Data.Common.DbDataAdapter.Update%2A> </xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> Mogą również odpowiadać błędów na podstawie na wiersz, w ramach `RowUpdated` zdarzeń element DataAdapter. Aby kontynuować operację aktualizacji bez generowania wyjątku `RowUpdated` zdarzeń, ustaw <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A>Właściwość <xref:System.Data.Common.RowUpdatedEventArgs>do <xref:System.Data.UpdateStatus>.</xref:System.Data.UpdateStatus> </xref:System.Data.Common.RowUpdatedEventArgs> </xref:System.Data.Common.RowUpdatedEventArgs.Status%2A>"
  example:
  - "The following example uses the derived class, <xref:System.Data.OleDb.OleDbDataAdapter>, to update the data source.  \n  \n [!code-vb[Classic WebData DbDataAdapter.Update2 Example#1](~/add/codesnippet/visualbasic/m-system.data.common.dbd_1_1.vb)]\n [!code-cs[Classic WebData DbDataAdapter.Update2 Example#1](~/add/codesnippet/csharp/m-system.data.common.dbd_1_1.cs)]"
  syntax:
    content: public int Update (System.Data.DataTable dataTable);
    parameters:
    - id: dataTable
      type: System.Data.DataTable
      description: "<xref href=&quot;System.Data.DataTable&quot;> </xref> Używana do aktualizowania źródła danych."
    return:
      type: System.Int32
      description: "Liczba pomyślnie zaktualizowanych z <xref href=&quot;System.Data.DataTable&quot;> </xref>."
  overload: System.Data.Common.DbDataAdapter.Update*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<xref href=&quot;System.Data.DataSet&quot;> </xref> Jest nieprawidłowy."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Tabela źródłowa jest nieprawidłowa."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Nie <xref href=&quot;System.Data.DataRow&quot;> </xref> istnieje aktualizacji.       - lub - No <xref href=&quot;System.Data.DataTable&quot;> </xref> istnieje aktualizacji.       - lub - No <xref href=&quot;System.Data.DataSet&quot;> </xref> istnieje do użycia jako źródło."
  - type: System.Data.DBConcurrencyException
    commentId: T:System.Data.DBConcurrencyException
    description: "Próba wykonania instrukcji INSERT, UPDATE lub DELETE spowodowała zero zmodyfikowanych rekordów."
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Update(System.Data.DataRow[],System.Data.Common.DataTableMapping)
  id: Update(System.Data.DataRow[],System.Data.Common.DataTableMapping)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Update(DataRow[],DataTableMapping)
  nameWithType: DbDataAdapter.Update(DataRow[],DataTableMapping)
  fullName: System.Data.Common.DbDataAdapter.Update(DataRow[],DataTableMapping)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Aktualizuje wartości w bazie danych, wykonując odpowiednie instrukcje INSERT, UPDATE lub DELETE dla każdego wstawienia, aktualizacji lub usunięcia wiersza w określonej tablicy <xref href=&quot;System.Data.DataSet&quot;> </xref> obiektów."
  remarks: "Gdy aplikacja wywołuje <xref:System.Data.Common.DbDataAdapter.Update%2A>metody <xref:System.Data.Common.DbDataAdapter>sprawdza <xref:System.Data.DataRow.RowState%2A>Właściwości i wykonuje wymaganych instrukcji INSERT, UPDATE lub DELETE wielokrotnie powtarzane dla każdego wiersza, na podstawie kolejności indeksów skonfigurowane w <xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataRow.RowState%2A> </xref:System.Data.Common.DbDataAdapter> </xref:System.Data.Common.DbDataAdapter.Update%2A> Na przykład, <xref:System.Data.Common.DbDataAdapter.Update%2A>może wykonać instrukcji DELETE, a następnie instrukcji INSERT, a następnie inne instrukcji DELETE, ze względu na kolejność wierszy w <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter.Update%2A>       Należy zauważyć, że oświadczenia te nie są wykonywane jako przetwarzania wsadowego; Każdy wiersz jest aktualizowana pojedynczo. Aplikacja może wywołać <xref:System.Data.DataSet.GetChanges%2A>metody w sytuacjach, w którym musi sterowania sekwencją typów instrukcji (na przykład wstawia przed aktualizacji).</xref:System.Data.DataSet.GetChanges%2A> Aby uzyskać więcej informacji, zobacz [aktualizowanie źródła danych z obiektów DataAdapter](~/add/includes/ajax-current-ext-md.md).       Jeśli nie zostały określone instrukcji INSERT, UPDATE lub DELETE, <xref:System.Data.Common.DbDataAdapter.Update%2A>Metoda generuje wyjątek.</xref:System.Data.Common.DbDataAdapter.Update%2A> Można jednak utworzyć <xref:System.Data.SqlClient.SqlCommandBuilder>lub <xref:System.Data.OleDb.OleDbCommandBuilder>obiekt, aby automatycznie wygenerować instrukcji SQL aktualizacje pojedynczej tabeli, jeśli ustawisz `SelectCommand` właściwości dostawcy danych .NET Framework.</xref:System.Data.OleDb.OleDbCommandBuilder> </xref:System.Data.SqlClient.SqlCommandBuilder> Następnie żadnych dodatkowych instrukcji SQL, które nie zostały ustawione są generowane przez **CommandBuilder**. Tę logikę generowania wymaga informacji o kolumnie klucza znajdować się w <xref:System.Data.DataSet>.</xref:System.Data.DataSet> Aby uzyskać więcej informacji, zobacz [generowania poleceń CommandBuilders](~/add/includes/ajax-current-ext-md.md).       <xref:System.Data.Common.DbDataAdapter.Update%2A>Metoda pobiera wiersze z tabeli umieszczone w pierwszym mapowania przed wykonaniem operacji aktualizacji.</xref:System.Data.Common.DbDataAdapter.Update%2A> <xref:System.Data.Common.DbDataAdapter.Update%2A>Następnie odświeża wiersza przy użyciu wartości <xref:System.Data.IDbCommand.UpdatedRowSource%2A>Właściwości.</xref:System.Data.IDbCommand.UpdatedRowSource%2A> </xref:System.Data.Common.DbDataAdapter.Update%2A> Dodatkowe wiersze zwracane są ignorowane.       Po załadowaniu danych do <xref:System.Data.DataSet>, <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>zdarzenia, dzięki czemu użytkownik do sprawdzenia uzgodniony <xref:System.Data.DataSet>wiersza i wszystkie dane wyjściowe Parametry zwracane przez polecenie.</xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> </xref:System.Data.DataSet> Po wierszu aktualizacji pomyślnie, zmiany w tym wierszu są akceptowane.       Korzystając z <xref:System.Data.Common.DbDataAdapter.Update%2A>, kolejność wykonywania jest następująca: 1.</xref:System.Data.Common.DbDataAdapter.Update%2A>  Wartości w <xref:System.Data.DataRow>zostaną przeniesione do wartości parametrów.</xref:System.Data.DataRow>      2.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A>Zdarzenie jest wywoływane.</xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A>      3.  Wykonuje polecenia.      4.  Jeśli polecenie ma ustawioną wartość `FirstReturnedRecord`, a następnie pierwszy zwrócony wynik jest umieszczany w <xref:System.Data.DataRow>.</xref:System.Data.DataRow>      5.  W przypadku parametrów wyjściowych są umieszczane w <xref:System.Data.DataRow>.</xref:System.Data.DataRow>      6.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>Zdarzenie jest wywoływane.</xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>      7.  <xref:System.Data.DataRow.AcceptChanges%2A>jest wywoływana.</xref:System.Data.DataRow.AcceptChanges%2A>       Każde polecenie skojarzone z <xref:System.Data.Common.DbDataAdapter>zwykle ma kolekcję parametrów skojarzonych z nim.</xref:System.Data.Common.DbDataAdapter> Parametry są zamapowane do bieżącego wiersza za pośrednictwem `SourceColumn` i `SourceVersion` właściwości dostawcy danych .NET Framework `Parameter` klasy. `SourceColumn`odwołuje się do <xref:System.Data.DataTable>kolumny który <xref:System.Data.Common.DbDataAdapter>odwołania do uzyskania wartości parametrów dla bieżącego wiersza.</xref:System.Data.Common.DbDataAdapter> </xref:System.Data.DataTable>       `SourceColumn`odwołuje się do nazwy kolumny Niemapowane przed mapowań tabeli zostały zastosowane. Jeśli `SourceColumn` odwołuje się do nieistniejącej kolumny akcję wykonywaną zależy od jednego z następujących <xref:System.Data.MissingMappingAction>wartości.</xref:System.Data.MissingMappingAction>      | Wartość wyliczenia | Działania podjęte |   |-----------------------|------------------|   | `MissingMappingAction.Passthrough`| Korzystać z nazwy kolumny źródła i nazwy tabeli w <xref:System.Data.DataSet>nie jest obecny. |   | `MissingMappingAction.Ignore`| A <xref:System.SystemException>jest generowany.</xref:System.SystemException> </xref:System.Data.DataSet> Podczas mapowania są jawnie ustawiona, brakuje mapowania w dla parametru wejściowego jest zazwyczaj wynikiem błędu. |   | `MissingMappingAction.Error`| Generowany jest <xref:System.SystemException>. |       `SourceColumn` Właściwości są również używane do mapowania wartości dla danych wyjściowych lub parametry wejścia/wyjścia z powrotem do `DataSet`.</xref:System.SystemException> Wyjątek jest generowany, gdy odwołuje się do nieistniejącej kolumny.       `SourceVersion` Właściwości dostawcy danych .NET Framework `Parameter` klasy określa, czy użyć wersji Original, Current lub Proposed wartości kolumny. Ta funkcja jest często używane do uwzględnienia oryginalnych wartości w klauzuli WHERE instrukcji UPDATE, aby wyszukać naruszeń optymistycznej współbieżności.      > [!NOTE] > Jeśli wystąpi błąd podczas aktualizowania wiersza, jest zgłaszany wyjątek i wykonywania aktualizacji nie jest już obsługiwana. Aby kontynuować operację aktualizacji bez generowania wyjątków, gdy wystąpi błąd, ustaw <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A>właściwości `true` przed wywołaniem <xref:System.Data.Common.DbDataAdapter.Update%2A>.</xref:System.Data.Common.DbDataAdapter.Update%2A> </xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> Mogą również odpowiadać błędów na podstawie na wiersz, w ramach `RowUpdated` zdarzeń element DataAdapter. Aby kontynuować operację aktualizacji bez generowania wyjątku `RowUpdated` zdarzeń, ustaw <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A>Właściwość <xref:System.Data.Common.RowUpdatedEventArgs>do <xref:System.Data.UpdateStatus>.</xref:System.Data.UpdateStatus> </xref:System.Data.Common.RowUpdatedEventArgs> </xref:System.Data.Common.RowUpdatedEventArgs.Status%2A>"
  syntax:
    content: protected virtual int Update (System.Data.DataRow[] dataRows, System.Data.Common.DataTableMapping tableMapping);
    parameters:
    - id: dataRows
      type: System.Data.DataRow[]
      description: "Tablica <xref href=&quot;System.Data.DataRow&quot;> </xref> obiekty używane do aktualizowania źródła danych."
    - id: tableMapping
      type: System.Data.Common.DataTableMapping
      description: "<xref:System.Data.IDataAdapter.TableMappings*>Kolekcji do użycia.</xref:System.Data.IDataAdapter.TableMappings*>"
    return:
      type: System.Int32
      description: "Liczba pomyślnie zaktualizowanych z <xref href=&quot;System.Data.DataSet&quot;> </xref>."
  overload: System.Data.Common.DbDataAdapter.Update*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<xref href=&quot;System.Data.DataSet&quot;> </xref> Jest nieprawidłowy."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Tabela źródłowa jest nieprawidłowa."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Nie <xref href=&quot;System.Data.DataRow&quot;> </xref> istnieje aktualizacji.       - lub - No <xref href=&quot;System.Data.DataTable&quot;> </xref> istnieje aktualizacji.       - lub - No <xref href=&quot;System.Data.DataSet&quot;> </xref> istnieje do użycia jako źródło."
  - type: System.Data.DBConcurrencyException
    commentId: T:System.Data.DBConcurrencyException
    description: "Próba wykonania instrukcji INSERT, UPDATE lub DELETE spowodowała zero zmodyfikowanych rekordów."
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Update(System.Data.DataSet,System.String)
  id: Update(System.Data.DataSet,System.String)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Update(DataSet,String)
  nameWithType: DbDataAdapter.Update(DataSet,String)
  fullName: System.Data.Common.DbDataAdapter.Update(DataSet,String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Aktualizuje wartości w bazie danych, wykonując odpowiednie instrukcje INSERT, UPDATE lub DELETE dla każdego wstawienia, aktualizacji lub usunięcia wiersza w <xref href=&quot;System.Data.DataSet&quot;> </xref> z określonym <xref href=&quot;System.Data.DataTable&quot;> </xref> nazwy."
  remarks: "Gdy aplikacja wywołuje <xref:System.Data.Common.DbDataAdapter.Update%2A>metody <xref:System.Data.Common.DbDataAdapter>sprawdza <xref:System.Data.DataRow.RowState%2A>Właściwości i wykonuje wymaganych instrukcji INSERT, UPDATE lub DELETE wielokrotnie powtarzane dla każdego wiersza, na podstawie kolejności indeksów skonfigurowane w <xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataRow.RowState%2A> </xref:System.Data.Common.DbDataAdapter> </xref:System.Data.Common.DbDataAdapter.Update%2A> Na przykład, <xref:System.Data.Common.DbDataAdapter.Update%2A>może wykonać instrukcji DELETE, a następnie instrukcji INSERT, a następnie inne instrukcji DELETE, ze względu na kolejność wierszy w <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter.Update%2A>       Należy zauważyć, że oświadczenia te nie są wykonywane jako przetwarzania wsadowego; Każdy wiersz jest aktualizowana pojedynczo. Aplikacja może wywołać <xref:System.Data.DataSet.GetChanges%2A>metody w sytuacjach, w którym musi sterowania sekwencją typów instrukcji (na przykład, Wstaw przed AKTUALIZACJĄ).</xref:System.Data.DataSet.GetChanges%2A> Aby uzyskać więcej informacji, zobacz [aktualizowanie źródła danych z obiektów DataAdapter](~/add/includes/ajax-current-ext-md.md).       Jeśli nie zostały określone instrukcji INSERT, UPDATE lub DELETE, <xref:System.Data.Common.DbDataAdapter.Update%2A>Metoda generuje wyjątek.</xref:System.Data.Common.DbDataAdapter.Update%2A> Można jednak utworzyć <xref:System.Data.SqlClient.SqlCommandBuilder>lub <xref:System.Data.OleDb.OleDbCommandBuilder>obiekt, aby automatycznie wygenerować instrukcji SQL aktualizacje pojedynczej tabeli, jeśli ustawisz `SelectCommand` właściwości dostawcy danych .NET Framework.</xref:System.Data.OleDb.OleDbCommandBuilder> </xref:System.Data.SqlClient.SqlCommandBuilder> Następnie żadnych dodatkowych instrukcji SQL, które nie zostały ustawione są generowane przez **CommandBuilder**. Tę logikę generowania wymaga informacji o kolumnie klucza znajdować się w <xref:System.Data.DataSet>.</xref:System.Data.DataSet> Aby uzyskać więcej informacji, zobacz [generowania poleceń CommandBuilders](~/add/includes/ajax-current-ext-md.md).       <xref:System.Data.Common.DbDataAdapter.Update%2A>Metoda obsługuje scenariusze gdzie <xref:System.Data.DataSet>zawiera wiele <xref:System.Data.DataTable>obiektów, których nazwy różnią się tylko wielkością liter.</xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Update%2A> Jeśli istnieje kilka tabel o tej samej nazwy, ale inną wielkość liter, w `DataSet`, <xref:System.Data.Common.DbDataAdapter.Update%2A>przeprowadza porównanie uwzględniające wielkość liter można znaleźć odpowiedniej tabeli, a następnie generuje wyjątek, jeśli istnieje dokładnego dopasowania.</xref:System.Data.Common.DbDataAdapter.Update%2A> Poniższy kod C# ilustruje to zachowanie.      ```   DataSet ds = new DataSet();    ds.Tables.Add(&quot;aaa&quot;);    ds.Tables.Add(&quot;AAA&quot;);    adapter.Update(ds, &quot;aaa&quot;); // Updates &quot;aaa&quot;, which already exists in the DataSet.    adapter.Update(ds, &quot;AAA&quot;); // Updates &quot;AAA&quot;, which already exists in the DataSet.       adapter.Update(ds, &quot;Aaa&quot;); // Results in an exception.   ```Jeśli <xref:System.Data.Common.DbDataAdapter.Update%2A>nosi nazwę i <xref:System.Data.DataSet>zawiera tylko jeden <xref:System.Data.DataTable>o nazwie różni się tylko wielkością liter, która <xref:System.Data.DataTable>jest aktualizowany.</xref:System.Data.DataTable> </xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Update%2A> W tym scenariuszu wynik porównania ma bez uwzględniania wielkości liter. Poniższy kod C# ilustruje to zachowanie.      ```   DataSet dataset = new DataSet();    dataset.Tables.Add(&quot;aaa&quot;);       adapter.Update(dataset, &quot;AAA&quot;); // Updates table &quot;aaa&quot; because only one similarly named table is in the DataSet.   ```<xref:System.Data.Common.DbDataAdapter.Update%2A>Metoda pobiera wiersze z tabeli umieszczone w pierwszym mapowania przed wykonaniem operacji aktualizacji.</xref:System.Data.Common.DbDataAdapter.Update%2A> <xref:System.Data.Common.DbDataAdapter.Update%2A>Następnie odświeża wiersza przy użyciu wartości <xref:System.Data.IDbCommand.UpdatedRowSource%2A>Właściwości.</xref:System.Data.IDbCommand.UpdatedRowSource%2A> </xref:System.Data.Common.DbDataAdapter.Update%2A> Dodatkowe wiersze zwracane są ignorowane.       Po załadowaniu danych do <xref:System.Data.DataSet>, <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>zdarzenia, dzięki czemu użytkownik do sprawdzenia uzgodniony <xref:System.Data.DataSet>wiersza i wszystkie dane wyjściowe Parametry zwracane przez polecenie.</xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> </xref:System.Data.DataSet> Po wierszu aktualizacji pomyślnie, zmiany w tym wierszu są akceptowane.       Korzystając z <xref:System.Data.Common.DbDataAdapter.Update%2A>, kolejność wykonywania jest następująca: 1.</xref:System.Data.Common.DbDataAdapter.Update%2A>  Wartości w <xref:System.Data.DataRow>zostaną przeniesione do wartości parametrów.</xref:System.Data.DataRow>      2.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A>Zdarzenie jest wywoływane.</xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A>      3.  Wykonuje polecenia.      4.  Jeśli polecenie ma ustawioną wartość `FirstReturnedRecord`, a następnie pierwszy zwrócony wynik jest umieszczany w <xref:System.Data.DataRow>.</xref:System.Data.DataRow>      5.  W przypadku parametrów wyjściowych są umieszczane w <xref:System.Data.DataRow>.</xref:System.Data.DataRow>      6.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>Zdarzenie jest wywoływane.</xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>      7.  <xref:System.Data.DataRow.AcceptChanges%2A>jest wywoływana.</xref:System.Data.DataRow.AcceptChanges%2A>       Każde polecenie skojarzone z <xref:System.Data.Common.DbDataAdapter>zwykle ma kolekcję parametrów skojarzonych z nim.</xref:System.Data.Common.DbDataAdapter> Parametry są zamapowane do bieżącego wiersza za pośrednictwem `SourceColumn` i `SourceVersion` właściwości dostawcy danych .NET Framework `Parameter` klasy. `SourceColumn`odwołuje się do <xref:System.Data.DataTable>kolumny który <xref:System.Data.Common.DbDataAdapter>odwołania do uzyskania wartości parametrów dla bieżącego wiersza.</xref:System.Data.Common.DbDataAdapter> </xref:System.Data.DataTable>       `SourceColumn`odwołuje się do nazwy kolumny Niemapowane przed mapowań tabeli zostały zastosowane. Jeśli `SourceColumn` odwołuje się do nieistniejącej kolumny akcję wykonywaną zależy od jednego z następujących <xref:System.Data.MissingMappingAction>wartości.</xref:System.Data.MissingMappingAction>      | Wartość wyliczenia | Działania podjęte |   |-----------------------|------------------|   | `MissingMappingAction.Passthrough`| Korzystać z nazwy kolumny źródła i nazwy tabeli w <xref:System.Data.DataSet>nie jest obecny. |   | `MissingMappingAction.Ignore`| A <xref:System.SystemException>jest generowany.</xref:System.SystemException> </xref:System.Data.DataSet> Podczas mapowania są jawnie ustawiona, brakuje mapowania w dla parametru wejściowego jest zazwyczaj wynikiem błędu. |   | `MissingMappingAction.Error`| Generowany jest <xref:System.SystemException>. |       `SourceColumn` Właściwości są również używane do mapowania wartości dla danych wyjściowych lub parametry wejścia/wyjścia z powrotem do `DataSet`.</xref:System.SystemException> Wyjątek jest generowany, gdy odwołuje się do nieistniejącej kolumny.       `SourceVersion` Właściwości dostawcy danych .NET Framework `Parameter` klasy określa, czy użyć wersji Original, Current lub Proposed wartości kolumny. Ta funkcja jest często używane do uwzględnienia oryginalnych wartości w klauzuli WHERE instrukcji UPDATE, aby wyszukać naruszeń optymistycznej współbieżności.      > [!NOTE] > Jeśli wystąpi błąd podczas aktualizowania wiersza, jest zgłaszany wyjątek i wykonywania aktualizacji nie jest już obsługiwana. Aby kontynuować operację aktualizacji bez generowania wyjątków, gdy wystąpi błąd, ustaw <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A>właściwości `true` przed wywołaniem <xref:System.Data.Common.DbDataAdapter.Update%2A>.</xref:System.Data.Common.DbDataAdapter.Update%2A> </xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> Mogą również odpowiadać błędów na podstawie na wiersz, w ramach `RowUpdated` zdarzeń element DataAdapter. Aby kontynuować operację aktualizacji bez generowania wyjątku `RowUpdated` zdarzeń, ustaw <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A>Właściwość <xref:System.Data.Common.RowUpdatedEventArgs>do <xref:System.Data.UpdateStatus>.</xref:System.Data.UpdateStatus> </xref:System.Data.Common.RowUpdatedEventArgs> </xref:System.Data.Common.RowUpdatedEventArgs.Status%2A>"
  example:
  - "The following example uses the derived class, <xref:System.Data.OleDb.OleDbDataAdapter>, to update the data source.  \n  \n [!code-cs[Classic WebData DbDataAdapter.Update3#1](~/add/codesnippet/csharp/m-system.data.common.dbd_2_1.cs)]\n [!code-vb[Classic WebData DbDataAdapter.Update3#1](~/add/codesnippet/visualbasic/m-system.data.common.dbd_2_1.vb)]"
  syntax:
    content: public int Update (System.Data.DataSet dataSet, string srcTable);
    parameters:
    - id: dataSet
      type: System.Data.DataSet
      description: "<xref href=&quot;System.Data.DataSet&quot;> </xref> Używać do aktualizowania źródła danych."
    - id: srcTable
      type: System.String
      description: "Nazwa tabeli źródłowej na potrzeby mapowania tabeli."
    return:
      type: System.Int32
      description: "Liczba pomyślnie zaktualizowanych z <xref href=&quot;System.Data.DataSet&quot;> </xref>."
  overload: System.Data.Common.DbDataAdapter.Update*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<xref href=&quot;System.Data.DataSet&quot;> </xref> Jest nieprawidłowy."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Tabela źródłowa jest nieprawidłowa."
  - type: System.Data.DBConcurrencyException
    commentId: T:System.Data.DBConcurrencyException
    description: "Próba wykonania instrukcji INSERT, UPDATE lub DELETE spowodowała zero zmodyfikowanych rekordów."
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.UpdateBatchSize
  id: UpdateBatchSize
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: UpdateBatchSize
  nameWithType: DbDataAdapter.UpdateBatchSize
  fullName: System.Data.Common.DbDataAdapter.UpdateBatchSize
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Pobiera lub ustawia wartość, która włącza lub wyłącza obsługę przetwarzania wsadowego i określa liczbę poleceń, które mogą być wykonywane w partii."
  remarks: "Aby zaktualizować źródła danych o zmianach wprowadzonych od <xref:System.Data.DataSet>.</xref:System.Data.DataSet> , użyj właściwości UpdateBatchSize Jeśli dostawca danych obsługuje przetwarzania wsadowego, to zwiększyć wydajność aplikacji dzięki zmniejszeniu liczby operacji na serwerze. W programie 2.0 ADO.NET ta właściwość jest obsługiwana dla dostawcy danych .NET dla programu SQL Server (SqlClient) i Oracle (OracleClient).       Wykonywanie wsadowe bardzo dużą może obniżyć wydajność. W związku z tym należy przetestować ustawienie rozmiaru partii optymalne przed wdrożeniem aplikacji.       <xref:System.ArgumentOutOfRangeException>Zostanie wygenerowany, jeśli wartość jest ustawiona na liczbę, mniejsza od zera.</xref:System.ArgumentOutOfRangeException>"
  syntax:
    content: public virtual int UpdateBatchSize { get; set; }
    return:
      type: System.Int32
      description: "Liczba wierszy do przetwarzania na partię.       <table><thead><tr><th> Wartość to       </th><th> Efekt       </th></tr></thead><tbody><tr><td> 0       </td><td> Nie ma żadnego limitu rozmiaru partii.       </td></tr><tr><td> 1       </td><td> Wyłącza aktualizowania wsadowego.       </td></tr><tr><td> &gt; 1       </td><td> Zmiany są wysyłane przy użyciu partie operacji UpdateBatchSize naraz.       </td></tr></tbody></table>       Jeśli ustawienie to wartość inna niż 1, wszystkie polecenia skojarzony z <xref href=&quot;System.Data.Common.DbDataAdapter&quot;> </xref> musi mieć ich <> </> *> ustawioną właściwość * *Brak* * lub * *OutputParameters**. Zostanie wygenerowany wyjątek w przeciwnym razie wartość."
  overload: System.Data.Common.DbDataAdapter.UpdateBatchSize*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.UpdateCommand
  id: UpdateCommand
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: UpdateCommand
  nameWithType: DbDataAdapter.UpdateCommand
  fullName: System.Data.Common.DbDataAdapter.UpdateCommand
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "Pobiera lub ustawia polecenie używane do aktualizowania rekordów w źródle danych."
  remarks: "Podczas <xref:System.Data.Common.DbDataAdapter.Update%2A>, jeśli ta właściwość nie jest ustawiona i informacje o kluczu podstawowym znajduje się w <xref:System.Data.DataSet>, <xref:System.Data.IDbDataAdapter.UpdateCommand%2A>będą automatycznie generowane.</xref:System.Data.IDbDataAdapter.UpdateCommand%2A> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Update%2A>"
  example:
  - "The following example creates the derived class <xref:System.Data.OleDb.OleDbDataAdapter> and sets some of its properties.  \n  \n [!code-cs[Classic WebData DbDataAdapter.UpdateCommand Example#1](~/add/codesnippet/csharp/p-system.data.common.dbd_2_1.cs)]\n [!code-vb[Classic WebData DbDataAdapter.UpdateCommand Example#1](~/add/codesnippet/visualbasic/p-system.data.common.dbd_2_1.vb)]"
  syntax:
    content: public System.Data.Common.DbCommand UpdateCommand { get; set; }
    return:
      type: System.Data.Common.DbCommand
      description: "A <xref href=&quot;System.Data.IDbCommand&quot;> </xref> używane podczas <xref:System.Data.IDataAdapter.Update*>do aktualizowania rekordów w źródle danych dla zmodyfikowanych wierszy w zestawie danych.</xref:System.Data.IDataAdapter.Update*>"
  overload: System.Data.Common.DbDataAdapter.UpdateCommand*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Data.Common.DataAdapter
  isExternal: false
  name: System.Data.Common.DataAdapter
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.InvalidCastException
  isExternal: true
  name: System.InvalidCastException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.Data.DBConcurrencyException
  parent: System.Data
  isExternal: false
  name: DBConcurrencyException
  nameWithType: DBConcurrencyException
  fullName: System.Data.DBConcurrencyException
- uid: System.Data.Common.DbDataAdapter.#ctor
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: DbDataAdapter()
  nameWithType: DbDataAdapter.DbDataAdapter()
  fullName: System.Data.Common.DbDataAdapter.DbDataAdapter()
- uid: System.Data.Common.DbDataAdapter.#ctor(System.Data.Common.DbDataAdapter)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: DbDataAdapter(DbDataAdapter)
  nameWithType: DbDataAdapter.DbDataAdapter(DbDataAdapter)
  fullName: System.Data.Common.DbDataAdapter.DbDataAdapter(DbDataAdapter)
- uid: System.Data.Common.DbDataAdapter
  parent: System.Data.Common
  isExternal: false
  name: DbDataAdapter
  nameWithType: DbDataAdapter
  fullName: System.Data.Common.DbDataAdapter
- uid: System.Data.Common.DbDataAdapter.AddToBatch(System.Data.IDbCommand)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: AddToBatch(IDbCommand)
  nameWithType: DbDataAdapter.AddToBatch(IDbCommand)
  fullName: System.Data.Common.DbDataAdapter.AddToBatch(IDbCommand)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Data.IDbCommand
  parent: System.Data
  isExternal: false
  name: IDbCommand
  nameWithType: IDbCommand
  fullName: System.Data.IDbCommand
- uid: System.Data.Common.DbDataAdapter.ClearBatch
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: ClearBatch()
  nameWithType: DbDataAdapter.ClearBatch()
  fullName: System.Data.Common.DbDataAdapter.ClearBatch()
- uid: System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: CreateRowUpdatedEvent(DataRow,IDbCommand,StatementType,DataTableMapping)
  nameWithType: DbDataAdapter.CreateRowUpdatedEvent(DataRow,IDbCommand,StatementType,DataTableMapping)
  fullName: System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(DataRow,IDbCommand,StatementType,DataTableMapping)
- uid: System.Data.Common.RowUpdatedEventArgs
  parent: System.Data.Common
  isExternal: false
  name: RowUpdatedEventArgs
  nameWithType: RowUpdatedEventArgs
  fullName: System.Data.Common.RowUpdatedEventArgs
- uid: System.Data.DataRow
  parent: System.Data
  isExternal: false
  name: DataRow
  nameWithType: DataRow
  fullName: System.Data.DataRow
- uid: System.Data.StatementType
  parent: System.Data
  isExternal: false
  name: StatementType
  nameWithType: StatementType
  fullName: System.Data.StatementType
- uid: System.Data.Common.DataTableMapping
  parent: System.Data.Common
  isExternal: false
  name: DataTableMapping
  nameWithType: DataTableMapping
  fullName: System.Data.Common.DataTableMapping
- uid: System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: CreateRowUpdatingEvent(DataRow,IDbCommand,StatementType,DataTableMapping)
  nameWithType: DbDataAdapter.CreateRowUpdatingEvent(DataRow,IDbCommand,StatementType,DataTableMapping)
  fullName: System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(DataRow,IDbCommand,StatementType,DataTableMapping)
- uid: System.Data.Common.RowUpdatingEventArgs
  parent: System.Data.Common
  isExternal: false
  name: RowUpdatingEventArgs
  nameWithType: RowUpdatingEventArgs
  fullName: System.Data.Common.RowUpdatingEventArgs
- uid: System.Data.Common.DbDataAdapter.DefaultSourceTableName
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: DefaultSourceTableName
  nameWithType: DbDataAdapter.DefaultSourceTableName
  fullName: System.Data.Common.DbDataAdapter.DefaultSourceTableName
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Data.Common.DbDataAdapter.DeleteCommand
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: DeleteCommand
  nameWithType: DbDataAdapter.DeleteCommand
  fullName: System.Data.Common.DbDataAdapter.DeleteCommand
- uid: System.Data.Common.DbCommand
  parent: System.Data.Common
  isExternal: false
  name: DbCommand
  nameWithType: DbCommand
  fullName: System.Data.Common.DbCommand
- uid: System.Data.Common.DbDataAdapter.Dispose(System.Boolean)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: DbDataAdapter.Dispose(Boolean)
  fullName: System.Data.Common.DbDataAdapter.Dispose(Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Data.Common.DbDataAdapter.ExecuteBatch
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: ExecuteBatch()
  nameWithType: DbDataAdapter.ExecuteBatch()
  fullName: System.Data.Common.DbDataAdapter.ExecuteBatch()
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Fill(DataSet)
  nameWithType: DbDataAdapter.Fill(DataSet)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataSet)
- uid: System.Data.DataSet
  parent: System.Data
  isExternal: false
  name: DataSet
  nameWithType: DataSet
  fullName: System.Data.DataSet
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Fill(DataTable)
  nameWithType: DbDataAdapter.Fill(DataTable)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataTable)
- uid: System.Data.DataTable
  parent: System.Data
  isExternal: false
  name: DataTable
  nameWithType: DataTable
  fullName: System.Data.DataTable
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.String)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Fill(DataSet,String)
  nameWithType: DbDataAdapter.Fill(DataSet,String)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataSet,String)
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable,System.Data.IDbCommand,System.Data.CommandBehavior)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Fill(DataTable,IDbCommand,CommandBehavior)
  nameWithType: DbDataAdapter.Fill(DataTable,IDbCommand,CommandBehavior)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataTable,IDbCommand,CommandBehavior)
- uid: System.Data.CommandBehavior
  parent: System.Data
  isExternal: false
  name: CommandBehavior
  nameWithType: CommandBehavior
  fullName: System.Data.CommandBehavior
- uid: System.Data.Common.DbDataAdapter.Fill(System.Int32,System.Int32,System.Data.DataTable[])
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Fill(Int32,Int32,DataTable[])
  nameWithType: DbDataAdapter.Fill(Int32,Int32,DataTable[])
  fullName: System.Data.Common.DbDataAdapter.Fill(Int32,Int32,DataTable[])
- uid: System.Data.DataTable[]
  parent: System.Data
  isExternal: false
  name: DataTable
  nameWithType: DataTable
  fullName: System.Data.DataTable[]
  spec.csharp:
  - uid: System.Data.DataTable
    name: DataTable
    nameWithType: DataTable
    fullName: DataTable[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.Int32,System.Int32,System.String)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Fill(DataSet,Int32,Int32,String)
  nameWithType: DbDataAdapter.Fill(DataSet,Int32,Int32,String)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataSet,Int32,Int32,String)
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable[],System.Int32,System.Int32,System.Data.IDbCommand,System.Data.CommandBehavior)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Fill(DataTable[],Int32,Int32,IDbCommand,CommandBehavior)
  nameWithType: DbDataAdapter.Fill(DataTable[],Int32,Int32,IDbCommand,CommandBehavior)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataTable[],Int32,Int32,IDbCommand,CommandBehavior)
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.Int32,System.Int32,System.String,System.Data.IDbCommand,System.Data.CommandBehavior)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Fill(DataSet,Int32,Int32,String,IDbCommand,CommandBehavior)
  nameWithType: DbDataAdapter.Fill(DataSet,Int32,Int32,String,IDbCommand,CommandBehavior)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataSet,Int32,Int32,String,IDbCommand,CommandBehavior)
- uid: System.Data.Common.DbDataAdapter.FillCommandBehavior
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: FillCommandBehavior
  nameWithType: DbDataAdapter.FillCommandBehavior
  fullName: System.Data.Common.DbDataAdapter.FillCommandBehavior
- uid: System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: FillSchema(DataSet,SchemaType)
  nameWithType: DbDataAdapter.FillSchema(DataSet,SchemaType)
  fullName: System.Data.Common.DbDataAdapter.FillSchema(DataSet,SchemaType)
- uid: System.Data.SchemaType
  parent: System.Data
  isExternal: false
  name: SchemaType
  nameWithType: SchemaType
  fullName: System.Data.SchemaType
- uid: System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: FillSchema(DataTable,SchemaType)
  nameWithType: DbDataAdapter.FillSchema(DataTable,SchemaType)
  fullName: System.Data.Common.DbDataAdapter.FillSchema(DataTable,SchemaType)
- uid: System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.String)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: FillSchema(DataSet,SchemaType,String)
  nameWithType: DbDataAdapter.FillSchema(DataSet,SchemaType,String)
  fullName: System.Data.Common.DbDataAdapter.FillSchema(DataSet,SchemaType,String)
- uid: System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType,System.Data.IDbCommand,System.Data.CommandBehavior)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: FillSchema(DataTable,SchemaType,IDbCommand,CommandBehavior)
  nameWithType: DbDataAdapter.FillSchema(DataTable,SchemaType,IDbCommand,CommandBehavior)
  fullName: System.Data.Common.DbDataAdapter.FillSchema(DataTable,SchemaType,IDbCommand,CommandBehavior)
- uid: System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.Data.IDbCommand,System.String,System.Data.CommandBehavior)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: FillSchema(DataSet,SchemaType,IDbCommand,String,CommandBehavior)
  nameWithType: DbDataAdapter.FillSchema(DataSet,SchemaType,IDbCommand,String,CommandBehavior)
  fullName: System.Data.Common.DbDataAdapter.FillSchema(DataSet,SchemaType,IDbCommand,String,CommandBehavior)
- uid: System.Data.Common.DbDataAdapter.GetBatchedParameter(System.Int32,System.Int32)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: GetBatchedParameter(Int32,Int32)
  nameWithType: DbDataAdapter.GetBatchedParameter(Int32,Int32)
  fullName: System.Data.Common.DbDataAdapter.GetBatchedParameter(Int32,Int32)
- uid: System.Data.IDataParameter
  parent: System.Data
  isExternal: false
  name: IDataParameter
  nameWithType: IDataParameter
  fullName: System.Data.IDataParameter
- uid: System.Data.Common.DbDataAdapter.GetBatchedRecordsAffected(System.Int32,System.Int32@,System.Exception@)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: GetBatchedRecordsAffected(Int32,Int32,Exception)
  nameWithType: DbDataAdapter.GetBatchedRecordsAffected(Int32,Int32,Exception)
  fullName: System.Data.Common.DbDataAdapter.GetBatchedRecordsAffected(Int32,Int32,Exception)
- uid: System.Exception
  parent: System
  isExternal: true
  name: Exception
  nameWithType: Exception
  fullName: System.Exception
- uid: System.Data.Common.DbDataAdapter.GetFillParameters
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: GetFillParameters()
  nameWithType: DbDataAdapter.GetFillParameters()
  fullName: System.Data.Common.DbDataAdapter.GetFillParameters()
- uid: System.Data.IDataParameter[]
  parent: System.Data
  isExternal: false
  name: IDataParameter
  nameWithType: IDataParameter
  fullName: System.Data.IDataParameter[]
  spec.csharp:
  - uid: System.Data.IDataParameter
    name: IDataParameter
    nameWithType: IDataParameter
    fullName: IDataParameter[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Data.Common.DbDataAdapter.InitializeBatching
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: InitializeBatching()
  nameWithType: DbDataAdapter.InitializeBatching()
  fullName: System.Data.Common.DbDataAdapter.InitializeBatching()
- uid: System.Data.Common.DbDataAdapter.InsertCommand
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: InsertCommand
  nameWithType: DbDataAdapter.InsertCommand
  fullName: System.Data.Common.DbDataAdapter.InsertCommand
- uid: System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: OnRowUpdated(RowUpdatedEventArgs)
  nameWithType: DbDataAdapter.OnRowUpdated(RowUpdatedEventArgs)
  fullName: System.Data.Common.DbDataAdapter.OnRowUpdated(RowUpdatedEventArgs)
- uid: System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: OnRowUpdating(RowUpdatingEventArgs)
  nameWithType: DbDataAdapter.OnRowUpdating(RowUpdatingEventArgs)
  fullName: System.Data.Common.DbDataAdapter.OnRowUpdating(RowUpdatingEventArgs)
- uid: System.Data.Common.DbDataAdapter.SelectCommand
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: SelectCommand
  nameWithType: DbDataAdapter.SelectCommand
  fullName: System.Data.Common.DbDataAdapter.SelectCommand
- uid: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#DeleteCommand
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: System.Data.IDbDataAdapter.DeleteCommand
  nameWithType: DbDataAdapter.System.Data.IDbDataAdapter.DeleteCommand
  fullName: System.Data.Common.DbDataAdapter.System.Data.IDbDataAdapter.DeleteCommand
- uid: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#InsertCommand
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: System.Data.IDbDataAdapter.InsertCommand
  nameWithType: DbDataAdapter.System.Data.IDbDataAdapter.InsertCommand
  fullName: System.Data.Common.DbDataAdapter.System.Data.IDbDataAdapter.InsertCommand
- uid: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#SelectCommand
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: System.Data.IDbDataAdapter.SelectCommand
  nameWithType: DbDataAdapter.System.Data.IDbDataAdapter.SelectCommand
  fullName: System.Data.Common.DbDataAdapter.System.Data.IDbDataAdapter.SelectCommand
- uid: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#UpdateCommand
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: System.Data.IDbDataAdapter.UpdateCommand
  nameWithType: DbDataAdapter.System.Data.IDbDataAdapter.UpdateCommand
  fullName: System.Data.Common.DbDataAdapter.System.Data.IDbDataAdapter.UpdateCommand
- uid: System.Data.Common.DbDataAdapter.System#ICloneable#Clone
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: System.ICloneable.Clone()
  nameWithType: DbDataAdapter.System.ICloneable.Clone()
  fullName: System.Data.Common.DbDataAdapter.System.ICloneable.Clone()
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Data.Common.DbDataAdapter.TerminateBatching
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: TerminateBatching()
  nameWithType: DbDataAdapter.TerminateBatching()
  fullName: System.Data.Common.DbDataAdapter.TerminateBatching()
- uid: System.Data.Common.DbDataAdapter.Update(System.Data.DataRow[])
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Update(DataRow[])
  nameWithType: DbDataAdapter.Update(DataRow[])
  fullName: System.Data.Common.DbDataAdapter.Update(DataRow[])
- uid: System.Data.DataRow[]
  parent: System.Data
  isExternal: false
  name: DataRow
  nameWithType: DataRow
  fullName: System.Data.DataRow[]
  spec.csharp:
  - uid: System.Data.DataRow
    name: DataRow
    nameWithType: DataRow
    fullName: DataRow[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Update(DataSet)
  nameWithType: DbDataAdapter.Update(DataSet)
  fullName: System.Data.Common.DbDataAdapter.Update(DataSet)
- uid: System.Data.Common.DbDataAdapter.Update(System.Data.DataTable)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Update(DataTable)
  nameWithType: DbDataAdapter.Update(DataTable)
  fullName: System.Data.Common.DbDataAdapter.Update(DataTable)
- uid: System.Data.Common.DbDataAdapter.Update(System.Data.DataRow[],System.Data.Common.DataTableMapping)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Update(DataRow[],DataTableMapping)
  nameWithType: DbDataAdapter.Update(DataRow[],DataTableMapping)
  fullName: System.Data.Common.DbDataAdapter.Update(DataRow[],DataTableMapping)
- uid: System.Data.Common.DbDataAdapter.Update(System.Data.DataSet,System.String)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Update(DataSet,String)
  nameWithType: DbDataAdapter.Update(DataSet,String)
  fullName: System.Data.Common.DbDataAdapter.Update(DataSet,String)
- uid: System.Data.Common.DbDataAdapter.UpdateBatchSize
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: UpdateBatchSize
  nameWithType: DbDataAdapter.UpdateBatchSize
  fullName: System.Data.Common.DbDataAdapter.UpdateBatchSize
- uid: System.Data.Common.DbDataAdapter.UpdateCommand
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: UpdateCommand
  nameWithType: DbDataAdapter.UpdateCommand
  fullName: System.Data.Common.DbDataAdapter.UpdateCommand
- uid: System.Data.Common.DbDataAdapter.#ctor*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: DbDataAdapter
  nameWithType: DbDataAdapter.DbDataAdapter
- uid: System.Data.Common.DbDataAdapter.AddToBatch*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: AddToBatch
  nameWithType: DbDataAdapter.AddToBatch
- uid: System.Data.Common.DbDataAdapter.ClearBatch*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: ClearBatch
  nameWithType: DbDataAdapter.ClearBatch
- uid: System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: CreateRowUpdatedEvent
  nameWithType: DbDataAdapter.CreateRowUpdatedEvent
- uid: System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: CreateRowUpdatingEvent
  nameWithType: DbDataAdapter.CreateRowUpdatingEvent
- uid: System.Data.Common.DbDataAdapter.DeleteCommand*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: DeleteCommand
  nameWithType: DbDataAdapter.DeleteCommand
- uid: System.Data.Common.DbDataAdapter.Dispose*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Dispose
  nameWithType: DbDataAdapter.Dispose
- uid: System.Data.Common.DbDataAdapter.ExecuteBatch*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: ExecuteBatch
  nameWithType: DbDataAdapter.ExecuteBatch
- uid: System.Data.Common.DbDataAdapter.Fill*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Fill
  nameWithType: DbDataAdapter.Fill
- uid: System.Data.Common.DbDataAdapter.FillCommandBehavior*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: FillCommandBehavior
  nameWithType: DbDataAdapter.FillCommandBehavior
- uid: System.Data.Common.DbDataAdapter.FillSchema*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: FillSchema
  nameWithType: DbDataAdapter.FillSchema
- uid: System.Data.Common.DbDataAdapter.GetBatchedParameter*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: GetBatchedParameter
  nameWithType: DbDataAdapter.GetBatchedParameter
- uid: System.Data.Common.DbDataAdapter.GetBatchedRecordsAffected*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: GetBatchedRecordsAffected
  nameWithType: DbDataAdapter.GetBatchedRecordsAffected
- uid: System.Data.Common.DbDataAdapter.GetFillParameters*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: GetFillParameters
  nameWithType: DbDataAdapter.GetFillParameters
- uid: System.Data.Common.DbDataAdapter.InitializeBatching*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: InitializeBatching
  nameWithType: DbDataAdapter.InitializeBatching
- uid: System.Data.Common.DbDataAdapter.InsertCommand*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: InsertCommand
  nameWithType: DbDataAdapter.InsertCommand
- uid: System.Data.Common.DbDataAdapter.OnRowUpdated*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: OnRowUpdated
  nameWithType: DbDataAdapter.OnRowUpdated
- uid: System.Data.Common.DbDataAdapter.OnRowUpdating*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: OnRowUpdating
  nameWithType: DbDataAdapter.OnRowUpdating
- uid: System.Data.Common.DbDataAdapter.SelectCommand*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: SelectCommand
  nameWithType: DbDataAdapter.SelectCommand
- uid: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#DeleteCommand*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: System.Data.IDbDataAdapter.DeleteCommand
  nameWithType: DbDataAdapter.System.Data.IDbDataAdapter.DeleteCommand
- uid: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#InsertCommand*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: System.Data.IDbDataAdapter.InsertCommand
  nameWithType: DbDataAdapter.System.Data.IDbDataAdapter.InsertCommand
- uid: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#SelectCommand*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: System.Data.IDbDataAdapter.SelectCommand
  nameWithType: DbDataAdapter.System.Data.IDbDataAdapter.SelectCommand
- uid: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#UpdateCommand*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: System.Data.IDbDataAdapter.UpdateCommand
  nameWithType: DbDataAdapter.System.Data.IDbDataAdapter.UpdateCommand
- uid: System.Data.Common.DbDataAdapter.System#ICloneable#Clone*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: System.ICloneable.Clone
  nameWithType: DbDataAdapter.System.ICloneable.Clone
- uid: System.Data.Common.DbDataAdapter.TerminateBatching*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: TerminateBatching
  nameWithType: DbDataAdapter.TerminateBatching
- uid: System.Data.Common.DbDataAdapter.Update*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Update
  nameWithType: DbDataAdapter.Update
- uid: System.Data.Common.DbDataAdapter.UpdateBatchSize*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: UpdateBatchSize
  nameWithType: DbDataAdapter.UpdateBatchSize
- uid: System.Data.Common.DbDataAdapter.UpdateCommand*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: UpdateCommand
  nameWithType: DbDataAdapter.UpdateCommand
