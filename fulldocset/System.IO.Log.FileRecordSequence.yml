### YamlMime:ManagedReference
items:
- uid: System.IO.Log.FileRecordSequence
  id: FileRecordSequence
  children:
  - System.IO.Log.FileRecordSequence.#ctor(System.String)
  - System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess)
  - System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess,System.Int32)
  - System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  - System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.FileRecordSequence.BaseSequenceNumber
  - System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.CreateReservationCollection
  - System.IO.Log.FileRecordSequence.Dispose
  - System.IO.Log.FileRecordSequence.EndAppend(System.IAsyncResult)
  - System.IO.Log.FileRecordSequence.EndFlush(System.IAsyncResult)
  - System.IO.Log.FileRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  - System.IO.Log.FileRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  - System.IO.Log.FileRecordSequence.Flush
  - System.IO.Log.FileRecordSequence.Flush(System.IO.Log.SequenceNumber)
  - System.IO.Log.FileRecordSequence.LastSequenceNumber
  - System.IO.Log.FileRecordSequence.MaximumRecordLength
  - System.IO.Log.FileRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  - System.IO.Log.FileRecordSequence.ReadRestartAreas
  - System.IO.Log.FileRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.FileRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.FileRecordSequence.ReservedBytes
  - System.IO.Log.FileRecordSequence.RestartSequenceNumber
  - System.IO.Log.FileRecordSequence.RetryAppend
  - System.IO.Log.FileRecordSequence.TailPinned
  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  langs:
  - csharp
  name: FileRecordSequence
  nameWithType: FileRecordSequence
  fullName: System.IO.Log.FileRecordSequence
  type: Class
  summary: "Implementuje <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref> u góry pliku. Ta klasa nie może być dziedziczona."
  remarks: "Elementu FileRecordSequence jest sekwencją rekordu oparte na pojedynczy plik dziennika w systemie plików. Proste implementacji <xref:System.IO.Log.IRecordSequence>interfejsu, na podstawie prostego opartych na plikach dziennika.</xref:System.IO.Log.IRecordSequence>       Do manipulowania opartych na plikach dziennika, konta, na którym aplikacja jest uruchomiona w musi mieć wystarczające uprawnienia, zgodnie z ustawieniami zabezpieczeń systemu plików w czasie, który jest tworzony elementu FileRecordSequence. Ponadto podczas konstruowania staje się zażąda FullTrust. Wyniki weryfikacji uprawnienia są buforowane później zgodnie z modelem zabezpieczeń systemu Windows. Należy upewnić się, że użytkownik nie będą przypadkowo uwidaczniać zawartości sekwencja rekordów nieautoryzowanym użytkownikom."
  example:
  - "The following example creates a record sequence, appends record to it, and finally reads the records.  \n  \n [!code-vb[IRecordSequence#1](~/add/codesnippet/visualbasic/t-system.io.log.filereco_1.vb)]\n [!code-cs[IRecordSequence#1](~/add/codesnippet/csharp/t-system.io.log.filereco_1.cs)]"
  syntax:
    content: 'public sealed class FileRecordSequence : IDisposable, System.IO.Log.IRecordSequence'
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  - System.IO.Log.IRecordSequence
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: FileRecordSequence(String)
  nameWithType: FileRecordSequence.FileRecordSequence(String)
  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> klasy z określonego pliku."
  remarks: "Ten konstruktor tworzy dostępu odczytu i zapisu do pliku i umożliwia otwarcie pliku z udziału dostęp do odczytu. Oznacza to, że żądania do otwierania pliku do zapisu przez ten lub inny proces zakończy się niepowodzeniem tej <xref:System.IO.Log.FileRecordSequence>wystąpienia zostały usunięte, ale odczytu próbuje zostanie pomyślnie.</xref:System.IO.Log.FileRecordSequence> Jeśli `path` nie zostanie znaleziony, jest tworzony nowy plik o rozmiarze 0 bajtów."
  example:
  - "The following example creates a record sequence, appends record to it, reads the records, and finally diposes the sequence.  \n  \n [!code-vb[IRecordSequence#1](~/add/codesnippet/visualbasic/m-system.io.log.filereco_1.vb)]\n [!code-cs[IRecordSequence#1](~/add/codesnippet/csharp/m-system.io.log.filereco_1.cs)]"
  syntax:
    content: public FileRecordSequence (string path);
    parameters:
    - id: path
      type: System.String
      description: "Względna lub bezwzględna ścieżka do pliku tego <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> Hermetyzowanie spowoduje wystąpienie."
  overload: System.IO.Log.FileRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Plik określony przez <code> path </code> jest nieprawidłowy."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Plik określony przez <code> path </code> nie można odnaleźć."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu do magazynu określony dziennik przez system operacyjny."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileAccess)'
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: FileRecordSequence(String,FileAccess)
  nameWithType: FileRecordSequence.FileRecordSequence(String,FileAccess)
  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String,FileAccess)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> z określonego pliku i tryb dostępu."
  syntax:
    content: public FileRecordSequence (string path, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "Względna lub bezwzględna ścieżka do pliku tego <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> Hermetyzowanie spowoduje wystąpienie."
    - id: access
      type: System.IO.FileAccess
      description: "Prawidłowy <xref href=&quot;System.IO.FileAccess&quot;> </xref> ma wartość, która określa rodzaj użytkownikom dostępu do pliku dziennika."
  overload: System.IO.Log.FileRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Plik określony przez <code> path </code> jest nieprawidłowy."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Plik określony przez <code> path </code> nie można odnaleźć."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu do magazynu określony dziennik przez system operacyjny."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess,System.Int32)
  id: '#ctor(System.String,System.IO.FileAccess,System.Int32)'
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: FileRecordSequence(String,FileAccess,Int32)
  nameWithType: FileRecordSequence.FileRecordSequence(String,FileAccess,Int32)
  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String,FileAccess,Int32)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> z określonego pliku, tryb dostępu i rozmiar pliku."
  syntax:
    content: public FileRecordSequence (string path, System.IO.FileAccess access, int size);
    parameters:
    - id: path
      type: System.String
      description: "Względna lub bezwzględna ścieżka do pliku tego <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> Hermetyzowanie spowoduje wystąpienie."
    - id: access
      type: System.IO.FileAccess
      description: "Prawidłowy <xref href=&quot;System.IO.FileAccess&quot;> </xref> ma wartość, która określa rodzaj użytkownikom dostępu do pliku dziennika."
    - id: size
      type: System.Int32
      description: "Rozmiar pliku dziennika, aby go otworzyć."
  overload: System.IO.Log.FileRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Co najmniej jeden z parametrów jest poza prawidłowym zakresem."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Plik określony przez <code> path </code> jest nieprawidłowy."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Plik określony przez <code> path </code> nie można odnaleźć."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu do magazynu określony dziennik przez system operacyjny."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  id: AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: FileRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Przenosi do przodu numer sekwencji podstawowej dziennika. Ta metoda nie może być dziedziczona."
  syntax:
    content: public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Nowy numer sekwencji podstawowej sekwencja rekordów."
  overload: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSequenceNumber</code>jest nieprawidłowy."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSequenceNumber</code>nie jest od podstawowego do ostatniego numeru sekwencji."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas modyfikowania sekwencji."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Zapisuje rekord dziennika <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>. Ta metoda nie może być dziedziczona."
  remarks: "Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.FileRecordSequence.Flush%2A>metody.</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  example:
  - "The following example creates a record sequence, appends record to it, and finally reads the records.  \n  \n [!code-cs[FileRecordSequence#0](~/add/codesnippet/csharp/10554b85-231e-4dbf-ad02-_1.cs)]"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji rekordu dziennika dołączany."
  overload: System.IO.Log.FileRecordSequence.Append*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Co najmniej jeden z argumentów jest poza zakresem."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Zapisuje rekord dziennika <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>. Ta metoda nie może być dziedziczona."
  remarks: "Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.FileRecordSequence.Flush%2A>metody.</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  example:
  - "The following example shows how you can create a record sequence with this method.  \n  \n [!code-vb[IRecordSequence#3](~/add/codesnippet/visualbasic/5cdfd57c-5dff-4f9a-a7e0-_1.vb)]\n [!code-cs[IRecordSequence#3](~/add/codesnippet/csharp/5cdfd57c-5dff-4f9a-a7e0-_1.cs)]"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji rekordu dziennika dołączany."
  overload: System.IO.Log.FileRecordSequence.Append*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Co najmniej jeden z argumentów jest poza zakresem."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Zapisuje rekord dziennika <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>, przy użyciu wcześniej zastrzeżonej w sekwencji. Ta metoda nie może być dziedziczona."
  remarks: "Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Dołączany rekordu będzie zajmować dużo miejsca, wcześniej zarezerwowanych, za pomocą rezerwacji, określony przez `reservations` parametru. Dołącz zakończy się powodzeniem, zużyje na najmniejszą obszaru rezerwacji, który przechowywania danych, a obszar rezerwacji zostanie usunięty z kolekcji.       Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.FileRecordSequence.Flush%2A>metody.</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> zawierający rezerwacji, które mają być używane dla tego rekordu."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji rekordu dziennika dołączany."
  overload: System.IO.Log.FileRecordSequence.Append*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Co najmniej jeden z argumentów jest poza zakresem."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>nie została utworzona przez tę sekwencję rekordu."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Rezerwacja nie jest wystarczająco duży, aby zmieścić <code> data </code> znajdują się w <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Zapisuje rekord dziennika <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>, przy użyciu wcześniej zastrzeżonej w sekwencji. Ta metoda nie może być dziedziczona."
  remarks: "Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Dołączany rekordu będzie zajmować dużo miejsca, wcześniej zarezerwowanych, za pomocą rezerwacji, określony przez `reservations` parametru. Dołącz zakończy się powodzeniem, zużyje na najmniejszą obszaru rezerwacji, który przechowywania danych, a obszar rezerwacji zostanie usunięty z kolekcji.       Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.FileRecordSequence.Flush%2A>metody.</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> zawierający rezerwacji, które mają być używane dla tego rekordu."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji rekordu dziennika dołączany."
  overload: System.IO.Log.FileRecordSequence.Append*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Co najmniej jeden z argumentów jest poza zakresem."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>nie została utworzona przez tę sekwencję rekordu."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Rezerwacja nie jest wystarczająco duży, aby zmieścić <code> data </code> znajdują się w <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BaseSequenceNumber
  id: BaseSequenceNumber
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BaseSequenceNumber
  nameWithType: FileRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.FileRecordSequence.BaseSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Pobiera numer sekwencji pierwszy rekord prawidłowe w bieżącym <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>."
  remarks: "Prawidłowych numerów sekwencji jest większa niż lub równa BaseSequenceNumber i mniejsza niż <xref:System.IO.Log.FileRecordSequence.LastSequenceNumber%2A>.</xref:System.IO.Log.FileRecordSequence.LastSequenceNumber%2A> Wszystkie inne liczby sekwencji jest nieprawidłowy.       Wartość tej właściwości można zmienić przez wywołanie metody <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A>lub <xref:System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber%2A>metody.</xref:System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber%2A> </xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A>"
  example:
  - "The following example shows using BaseSequenceNumber in a loop:  \n  \n [!code-vb[IRecordSequence#2](~/add/codesnippet/visualbasic/p-system.io.log.filereco_1.vb)]\n [!code-cs[IRecordSequence#2](~/add/codesnippet/csharp/p-system.io.log.filereco_1.cs)]"
  syntax:
    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "Najniższy numer sekwencji, umożliwiająca prawidłowy rekord w <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>."
  overload: System.IO.Log.FileRecordSequence.BaseSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Właściwość uzyskano po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Rozpoczyna się asynchroniczną operację dołączania. Ta metoda nie może być dziedziczona."
  remarks: "Należy przekazać <xref:System.IAsyncResult>zwrócona przez tę metodę w celu <xref:System.IO.Log.FileRecordSequence.EndAppend%2A>metod w celu zapewnienia, że ukończono operacji dołączania i zasobów można odpowiednio zwalniane.</xref:System.IO.Log.FileRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Jeśli wystąpił błąd podczas dołączania asynchroniczne, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.FileRecordSequence.EndAppend%2A>Metoda jest wywoływana z <xref:System.IAsyncResult>zwracane przez tę metodę.</xref:System.IAsyncResult> </xref:System.IO.Log.FileRecordSequence.EndAppend%2A>       Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.FileRecordSequence.Flush%2A>metody.</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu dołączania."
    - id: state
      type: System.Object
      description: "Dostarczane przez użytkownika obiekt, który odróżni ten określonego asynchroniczne Dołącz żądań z innych żądań."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Reprezentujący Dołącz asynchroniczne mogą nadal oczekiwać.</xref:System.IAsyncResult>"
  overload: System.IO.Log.FileRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Co najmniej jeden z argumentów jest poza zakresem."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Rozpoczyna się asynchroniczną operację dołączania. Ta metoda nie może być dziedziczona."
  remarks: "Należy przekazać <xref:System.IAsyncResult>zwrócona przez tę metodę w celu <xref:System.IO.Log.FileRecordSequence.EndAppend%2A>metod w celu zapewnienia, że ukończono operacji dołączania i zasobów można odpowiednio zwalniane.</xref:System.IO.Log.FileRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Jeśli wystąpił błąd podczas dołączania asynchroniczne, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.FileRecordSequence.EndAppend%2A>Metoda jest wywoływana z <xref:System.IAsyncResult>zwracane przez tę metodę.</xref:System.IAsyncResult> </xref:System.IO.Log.FileRecordSequence.EndAppend%2A>       Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.FileRecordSequence.Flush%2A>metody.</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu dołączania."
    - id: state
      type: System.Object
      description: "Dostarczane przez użytkownika obiekt, który odróżni ten określonego asynchroniczne Dołącz żądań z innych żądań."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Reprezentujący Dołącz asynchroniczne mogą nadal oczekiwać.</xref:System.IAsyncResult>"
  overload: System.IO.Log.FileRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Co najmniej jeden z argumentów jest poza zakresem."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Rozpoczyna się asynchronicznego Dołącz operację przy użyciu wcześniej zastrzeżonej w sekwencji. Ta metoda nie może być dziedziczona."
  remarks: "Należy przekazać <xref:System.IAsyncResult>zwrócona przez tę metodę w celu <xref:System.IO.Log.FileRecordSequence.EndAppend%2A>metod w celu zapewnienia, że ukończono operacji dołączania i zasobów można odpowiednio zwalniane.</xref:System.IO.Log.FileRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Jeśli wystąpił błąd podczas dołączania asynchroniczne, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.FileRecordSequence.EndAppend%2A>Metoda jest wywoływana z <xref:System.IAsyncResult>zwracane przez tę metodę.</xref:System.IAsyncResult> </xref:System.IO.Log.FileRecordSequence.EndAppend%2A>       Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Dołączany rekordu będzie zajmować dużo miejsca, wcześniej zarezerwowanych, za pomocą rezerwacji, określony przez `reservations` parametru. Dołącz zakończy się powodzeniem, zużyje na najmniejszą obszaru rezerwacji, który przechowywania danych, a obszar rezerwacji zostanie usunięty z kolekcji.       Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.FileRecordSequence.Flush%2A>metody.</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> zawierający rezerwacji, które mają być używane dla tego rekordu."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu dołączania."
    - id: state
      type: System.Object
      description: "Dostarczane przez użytkownika obiekt, który odróżni ten określonego asynchroniczne Dołącz żądań z innych żądań."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Reprezentujący Dołącz asynchroniczne mogą nadal oczekiwać.</xref:System.IAsyncResult>"
  overload: System.IO.Log.FileRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Co najmniej jeden z argumentów jest poza zakresem."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>nie została utworzona przez tę sekwencję rekordu."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Rezerwacja nie jest wystarczająco duży, aby zmieścić <code> data </code> znajdują się w <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Rozpoczyna się asynchronicznego Dołącz operację przy użyciu wcześniej zastrzeżonej w sekwencji. Ta metoda nie może być dziedziczona."
  remarks: "Należy przekazać <xref:System.IAsyncResult>zwrócona przez tę metodę w celu <xref:System.IO.Log.FileRecordSequence.EndAppend%2A>metod w celu zapewnienia, że ukończono operacji dołączania i zasobów można odpowiednio zwalniane.</xref:System.IO.Log.FileRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Jeśli wystąpił błąd podczas dołączania asynchroniczne, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.FileRecordSequence.EndAppend%2A>Metoda jest wywoływana z <xref:System.IAsyncResult>zwracane przez tę metodę.</xref:System.IAsyncResult> </xref:System.IO.Log.FileRecordSequence.EndAppend%2A>       Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Dołączany rekordu będzie zajmować dużo miejsca, wcześniej zarezerwowanych, za pomocą rezerwacji, określony przez `reservations` parametru. Dołącz zakończy się powodzeniem, zużyje na najmniejszą obszaru rezerwacji, który przechowywania danych, a obszar rezerwacji zostanie usunięty z kolekcji.       Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.FileRecordSequence.Flush%2A>metody.</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> zawierający rezerwacji, które mają być używane dla tego rekordu."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu dołączania."
    - id: state
      type: System.Object
      description: "Dostarczane przez użytkownika obiekt, który odróżni ten określonego asynchroniczne Dołącz żądań z innych żądań."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Reprezentujący Dołącz asynchroniczne mogą nadal oczekiwać.</xref:System.IAsyncResult>"
  overload: System.IO.Log.FileRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Co najmniej jeden z argumentów jest poza zakresem."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>nie została utworzona przez tę sekwencję rekordu."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Rezerwacja nie jest wystarczająco duży, aby zmieścić <code> data </code> znajdują się w <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  id: BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Rozpoczyna operację asynchroniczną opróżniania, przy użyciu wcześniej zastrzeżonej w sekwencji. Ta metoda nie może być dziedziczona."
  remarks: "Należy przekazać <xref:System.IAsyncResult>zwróconych przez metodę bieżącego <xref:System.IO.Log.FileRecordSequence.EndFlush%2A>metodę, aby zapewnić, że zakończeniu opróżniania i zasoby są zwalniane odpowiednio.</xref:System.IO.Log.FileRecordSequence.EndFlush%2A> </xref:System.IAsyncResult> Jeśli wystąpi błąd podczas asynchronicznego opróżniania, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.FileRecordSequence.EndFlush%2A>Metoda jest wywoływana z <xref:System.IAsyncResult>zwracane przez tę metodę.</xref:System.IAsyncResult> </xref:System.IO.Log.FileRecordSequence.EndFlush%2A>       Wywołanie tej metody gwarantuje, że wszystkie rekordy, które zostały dołączone do <xref:System.IO.Log.FileRecordSequence>trwałym są zapisywane.</xref:System.IO.Log.FileRecordSequence>       Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchronicznego opróżniania, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.FileRecordSequence.EndFlush%2A>Metoda jest wywoływana.</xref:System.IO.Log.FileRecordSequence.EndFlush%2A>"
  syntax:
    content: public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji najnowsze rekordu, który musi być napisana. Jeśli <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> jest nieprawidłowy, a następnie wszystkie rekordy muszą być zapisane."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu flush."
    - id: state
      type: System.Object
      description: "Obiekt dostarczane przez użytkownika, która odróżnia to asynchroniczne żądanie opróżniania od innych żądań."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Czy reprezentuje asynchroniczną opróżnić operacja, która może nadal oczekiwać.</xref:System.IAsyncResult>"
  overload: System.IO.Log.FileRecordSequence.BeginFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa.       <code>sequenceNumber</code>jest nieprawidłowy dla tej sekwencji."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>sequenceNumber</code>nie jest od podstawowego do ostatniego numeru sekwencji."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas opróżniania danych."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Rozpoczyna się rezerwy asynchroniczne i Dołącz operacji. Ta metoda nie może być dziedziczona."
  remarks: "Należy przekazać <xref:System.IAsyncResult>zwrócona przez tę metodę w celu <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>metod w celu zapewnienia, że ukończono operacji dołączania i zasobów można odpowiednio zwalniane.</xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> Jeśli wystąpił błąd podczas dołączania asynchroniczne, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>Metoda jest wywoływana z <xref:System.IAsyncResult>zwracane przez tę metodę.</xref:System.IAsyncResult> </xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>       Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Określony rezerwacji są dodawane podana rezerwacji operację dołączania kolekcji w niepodzielną operację z rekordu. W przypadku niepowodzenia Dołącz miejsce nie jest zarezerwowana.       Zwykle ta metoda może zakończyć się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.FileRecordSequence.Flush%2A>metody.</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>Metoda jest wywoływana.</xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "Kolekcja rezerwacji dokonanie rezerwacji w."
    - id: reservations
      type: System.Int64[]
      description: "Zastrzeżenia dokonanie w bajtach."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu dołączania."
    - id: state
      type: System.Object
      description: "Dostarczane przez użytkownika obiekt, który odróżni ten określonego asynchroniczne Dołącz żądań z innych żądań."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Reprezentujący operację asynchroniczną, która może być oczekujące.</xref:System.IAsyncResult>"
  overload: System.IO.Log.FileRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Co najmniej jeden z argumentów jest poza zakresem."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>nie została utworzona przez tę sekwencję rekordu."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Rezerwacja nie jest wystarczająco duży, aby zmieścić <code> data </code> znajdują się w <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Rozpoczyna się rezerwy asynchroniczne i Dołącz operacji. Ta metoda nie może być dziedziczona."
  remarks: "Należy przekazać <xref:System.IAsyncResult>zwrócona przez tę metodę w celu <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>metod w celu zapewnienia, że ukończono operacji dołączania i zasobów można odpowiednio zwalniane.</xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> Jeśli wystąpił błąd podczas dołączania asynchroniczne, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>Metoda jest wywoływana z <xref:System.IAsyncResult>zwracane przez tę metodę.</xref:System.IAsyncResult> </xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>       Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Określony rezerwacji są dodawane podana rezerwacji operację dołączania kolekcji w niepodzielną operację z rekordu. W przypadku niepowodzenia Dołącz miejsce nie jest zarezerwowana.       Zwykle ta metoda może zakończyć się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.FileRecordSequence.Flush%2A>metody.</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>Metoda jest wywoływana.</xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "Kolekcja rezerwacji dokonanie rezerwacji w."
    - id: reservations
      type: System.Int64[]
      description: "Zastrzeżenia dokonanie w bajtach."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu dołączania."
    - id: state
      type: System.Object
      description: "Dostarczane przez użytkownika obiekt, który odróżni ten określonego asynchroniczne Dołącz żądań z innych żądań."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Reprezentujący operację asynchroniczną, która może być oczekujące.</xref:System.IAsyncResult>"
  overload: System.IO.Log.FileRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Co najmniej jeden z argumentów jest poza zakresem."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>nie została utworzona przez tę sekwencję rekordu."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Rezerwacja nie jest wystarczająco duży, aby zmieścić <code> data </code> znajdują się w <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Rozpoczyna się operacji zapisu obszaru asynchroniczne ponowne uruchomienie, przy użyciu wcześniej zastrzeżonej w sekwencji. Ta metoda nie może być dziedziczona."
  remarks: "Należy przekazać <xref:System.IAsyncResult>zwrócona przez tę metodę w celu <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>metody, aby zapewnić, że operacja zapisu obszaru ponowne uruchomienie zostało ukończone i zasobów można odpowiednio zwalniane.</xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> Jeśli wystąpił błąd podczas operacji zapisu obszaru asynchroniczne ponowne uruchomienie, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>Metoda jest wywoływana z <xref:System.IAsyncResult>zwracane przez tę metodę.</xref:System.IAsyncResult> </xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>       Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Po pomyślnym zakończeniu operacji numer sekwencyjny podstawowy został zaktualizowany. Rejestrowania wszystkich rekordów z numerami sekwencji mniej niż nowy numer sekwencji podstawowej są niedostępne.       Jeśli <xref:System.IO.Log.ReservationCollection>określono obszaru napisane ponownego uruchamiania będą korzystać z miejsca wcześniej zarezerwowanych, za pomocą rezerwacji zawartych w kolekcji.</xref:System.IO.Log.ReservationCollection> Jeśli metoda zakończy się powodzeniem, zużyje najmniejszą rezerwacji, który przechowywania danych, a rezerwacji zostanie usunięty z kolekcji.       Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>Metoda jest wywoływana.</xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa bieżący numer sekwencyjny podstawowej."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> zawierający rezerwacji, które mają być używane dla tego obszaru ponownego uruchomienia."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu zapisu obszaru ponownego uruchomienia."
    - id: state
      type: System.Object
      description: "Obiekt dostarczane przez użytkownika, która odróżnia to żądanie zapisu obszaru określonego asynchroniczne ponownego uruchomienia od innych żądań."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>o reprezentuje asynchroniczną uruchomienie obszaru operacji zapisu, które można nadal oczekiwać.</xref:System.IAsyncResult>"
  overload: System.IO.Log.FileRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSeqNum</code>nie jest od podstawowego do ostatniego numeru sekwencji.       - lub - nowy lub istniejący element archiwum albo podstawa aktywnego dziennika jest nieprawidłowa."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>nie została utworzona przez tę sekwencję rekordu.       - lub - <code>newBaseSeqNum</code> jest nieprawidłowy dla tej sekwencji."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Rezerwacja nie jest wystarczająco duży, aby zmieścić <code> data </code> znajdują się w <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Rozpoczyna się operacji zapisu obszaru asynchroniczne ponowne uruchomienie, przy użyciu wcześniej zastrzeżonej w sekwencji. Ta metoda nie może być dziedziczona."
  remarks: "Należy przekazać <xref:System.IAsyncResult>zwrócona przez tę metodę w celu <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>metody, aby zapewnić, że operacja zapisu obszaru ponowne uruchomienie zostało ukończone i zasobów można odpowiednio zwalniane.</xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> Jeśli wystąpił błąd podczas operacji zapisu obszaru asynchroniczne ponowne uruchomienie, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>Metoda jest wywoływana z <xref:System.IAsyncResult>zwracane przez tę metodę.</xref:System.IAsyncResult> </xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>       Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Po pomyślnym zakończeniu operacji numer sekwencyjny podstawowy został zaktualizowany. Rejestrowania wszystkich rekordów z numerami sekwencji mniej niż nowy numer sekwencji podstawowej są niedostępne.       Jeśli <xref:System.IO.Log.ReservationCollection>określono obszaru napisane ponownego uruchamiania będą korzystać z miejsca wcześniej zarezerwowanych, za pomocą rezerwacji zawartych w kolekcji.</xref:System.IO.Log.ReservationCollection> Jeśli metoda zakończy się powodzeniem, zużyje najmniejszą rezerwacji, który przechowywania danych, a rezerwacji zostanie usunięty z kolekcji.       Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>Metoda jest wywoływana.</xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa bieżący numer sekwencyjny podstawowej."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> zawierający rezerwacji, które mają być używane dla tego obszaru ponownego uruchomienia."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu zapisu obszaru ponownego uruchomienia."
    - id: state
      type: System.Object
      description: "Obiekt dostarczane przez użytkownika, która odróżnia to żądanie zapisu obszaru określonego asynchroniczne ponownego uruchomienia od innych żądań."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>o reprezentuje asynchroniczną uruchomienie obszaru operacji zapisu, które można nadal oczekiwać.</xref:System.IAsyncResult>"
  overload: System.IO.Log.FileRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSeqNum</code>nie jest od podstawowego do ostatniego numeru sekwencji.       - lub - nowy lub istniejący element archiwum albo podstawa aktywnego dziennika jest nieprawidłowa."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>nie została utworzona przez tę sekwencję rekordu.       - lub - <code>newBaseSeqNum</code> jest nieprawidłowy dla tej sekwencji."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Rezerwacja nie jest wystarczająco duży, aby zmieścić <code> data </code> znajdują się w <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.CreateReservationCollection
  id: CreateReservationCollection
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: CreateReservationCollection()
  nameWithType: FileRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.FileRecordSequence.CreateReservationCollection()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Tworzy nowy <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>. Ta metoda nie może być dziedziczona."
  syntax:
    content: public System.IO.Log.ReservationCollection CreateReservationCollection ();
    parameters: []
    return:
      type: System.IO.Log.ReservationCollection
      description: "Nowo utworzony <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>."
  overload: System.IO.Log.FileRecordSequence.CreateReservationCollection*
  exceptions:
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Dispose
  id: Dispose
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Dispose()
  nameWithType: FileRecordSequence.Dispose()
  fullName: System.IO.Log.FileRecordSequence.Dispose()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Natychmiast zwalnia zasoby niezarządzane używane przez obiekt."
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: System.IO.Log.FileRecordSequence.Dispose*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas opróżniania danych."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.EndAppend(System.IAsyncResult)
  id: EndAppend(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: EndAppend(IAsyncResult)
  nameWithType: FileRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Kończy się asynchroniczne Dołącz operacji. Ta metoda nie może być dziedziczona."
  remarks: "Ta metoda umożliwia blokowanie dopiero po ukończeniu operacji We/Wy. Błędów występujących podczas żądania asynchronicznego zapisu, takiej jak awaria dysku podczas wykonywania żądania We/Wy stają się widoczne, gdy jest wywoływana EndAppend.       Ta metoda musi zostać wywołana tylko raz w każdej <xref:System.IAsyncResult>zwrócony przez <xref:System.IO.Log.FileRecordSequence.BeginAppend%2A>metody.</xref:System.IO.Log.FileRecordSequence.BeginAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Odwołanie do oczekujących żądania asynchroniczne We/Wy."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji rekordu dziennika dołączany."
  overload: System.IO.Log.FileRecordSequence.EndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>jest nieprawidłowy."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>została już wywołana dla tej operacji asynchronicznej."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.EndFlush(System.IAsyncResult)
  id: EndFlush(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: EndFlush(IAsyncResult)
  nameWithType: FileRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndFlush(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Kończy operację asynchroniczną opróżniania. Ta metoda nie może być dziedziczona."
  remarks: "Ta metoda umożliwia blokowanie dopiero po ukończeniu operacji We/Wy. Błędów występujących podczas opróżniania żądania asynchronicznego, takiej jak awaria dysku podczas wykonywania żądania We/Wy stają się widoczne, gdy jest wywoływana EndFlush.       Ta metoda musi zostać wywołana tylko raz w każdej <xref:System.IAsyncResult>zwrócony przez <xref:System.IO.Log.FileRecordSequence.BeginFlush%2A>metody.</xref:System.IO.Log.FileRecordSequence.BeginFlush%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Odwołanie do oczekujących żądania asynchroniczne We/Wy."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji ostatni rekord zapisywane."
  overload: System.IO.Log.FileRecordSequence.EndFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>jest nieprawidłowy."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>została już wywołana dla tej operacji asynchronicznej."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  id: EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: FileRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndReserveAndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Kończy się asynchroniczne rezerwowa i Dołącz operacji. Ta metoda nie może być dziedziczona."
  remarks: "Ta metoda umożliwia blokowanie dopiero po ukończeniu operacji We/Wy. Błędów występujących podczas żądania asynchronicznego zapisu, takiej jak awaria dysku podczas wykonywania żądania We/Wy stają się widoczne, gdy jest wywoływana EndReserveAndAppend.       Ta metoda musi zostać wywołana tylko raz w każdej <xref:System.IAsyncResult>zwrócony przez <xref:System.IO.Log.FileRecordSequence.BeginReserveAndAppend%2A>metody.</xref:System.IO.Log.FileRecordSequence.BeginReserveAndAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Odwołanie do oczekujących żądania asynchroniczne We/Wy."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji rekordu dziennika dołączany."
  overload: System.IO.Log.FileRecordSequence.EndReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>jest nieprawidłowy."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>została już wywołana dla tej operacji asynchronicznej."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  id: EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: FileRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndWriteRestartArea(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Kończy operację zapisu obszaru asynchroniczne ponownego uruchomienia. Ta metoda nie może być dziedziczona."
  remarks: "Ta metoda umożliwia blokowanie dopiero po ukończeniu operacji We/Wy. Błędów występujących podczas żądania asynchronicznego zapisu, takiej jak awaria dysku podczas wykonywania żądania We/Wy stają się widoczne, gdy jest wywoływana EndWriteRestartArea.       Ta metoda musi zostać wywołana tylko raz w każdej <xref:System.IAsyncResult>zwrócony przez <xref:System.IO.Log.FileRecordSequence.BeginWriteRestartArea%2A>metody.</xref:System.IO.Log.FileRecordSequence.BeginWriteRestartArea%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Odwołanie do oczekujących żądania asynchroniczne We/Wy."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji rekordu dziennika napisane."
  overload: System.IO.Log.FileRecordSequence.EndWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>jest nieprawidłowy."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>została już wywołana dla tej operacji asynchronicznej."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Flush
  id: Flush
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Flush()
  nameWithType: FileRecordSequence.Flush()
  fullName: System.IO.Log.FileRecordSequence.Flush()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Zapewnia zapisano wszystkich dołączonych rekordów. Ta metoda nie może być dziedziczona."
  remarks: "Wywołanie tej metody gwarantuje, że wszystkie rekordy, które zostały dołączone do <xref:System.IO.Log.FileRecordSequence>trwale zapisano.</xref:System.IO.Log.FileRecordSequence>"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush ();
    parameters: []
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji ostatni rekord zapisywane."
  overload: System.IO.Log.FileRecordSequence.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas opróżniania danych."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Flush(System.IO.Log.SequenceNumber)
  id: Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Flush(SequenceNumber)
  nameWithType: FileRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.Flush(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Zapewnia zapisano wszystkich dołączonych rekordów. Ta metoda nie może być dziedziczona."
  remarks: "Wywołanie tej metody powoduje do liczby wszystkich rekordów z sekwencją i określony numer sekwencji, w tym trwale zapisano."
  syntax:
    content: public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji najnowsze rekordu, który musi być napisana. Jeśli <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> jest nieprawidłowy, a następnie wszystkie rekordy muszą być zapisane."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji ostatni rekord zapisywane."
  overload: System.IO.Log.FileRecordSequence.Flush*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>sequenceNumber</code>nie jest od podstawowego do ostatniego numeru sekwencji."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>jest nieprawidłowy dla tej sekwencji."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas opróżniania danych."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.LastSequenceNumber
  id: LastSequenceNumber
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: LastSequenceNumber
  nameWithType: FileRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.FileRecordSequence.LastSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Pobiera numer sekwencji jest ona większa niż ostatni rekord dołączane."
  remarks: "Ta właściwość zawiera numer sekwencji, który może być większa niż liczba sekwencji ostatniej dołączany rekordu. Prawidłowych numerów sekwencji są większe niż lub równe <xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A>i mniejsza niż LastSequenceNumber.</xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A> Wszystkie inne liczby sekwencji jest nieprawidłowy."
  syntax:
    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji jest ona większa niż ostatni rekord dołączane."
  overload: System.IO.Log.FileRecordSequence.LastSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Właściwość uzyskano po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.MaximumRecordLength
  id: MaximumRecordLength
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: MaximumRecordLength
  nameWithType: FileRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.FileRecordSequence.MaximumRecordLength
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Pobiera rozmiar największego rekordu, które mogą być dołączane do lub odczytu z tej sekwencji, w bajtach."
  syntax:
    content: public long MaximumRecordLength { get; }
    return:
      type: System.Int64
      description: "Rozmiar największego rekordu, które mogą być dołączane do lub odczytu z tej sekwencji, w bajtach."
  overload: System.IO.Log.FileRecordSequence.MaximumRecordLength*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Właściwość uzyskano po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  id: ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: FileRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.FileRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Zwraca wyliczalny kolekcji rekordów w sekwencji. Ta metoda nie może być dziedziczona."
  remarks: "Ta metoda zwraca wyliczalny kolekcji rekordów w sekwencji. Kolejność wyliczany rekordów zależy od wartości `logRecordEnum` parametru."
  example:
  - "The following example shows how you can use this method to read the records in a log sequence.  \n  \n [!code-vb[IRecordSequence#2](~/add/codesnippet/visualbasic/5d31b2a4-d7cf-41cf-80bb-_1.vb)]\n [!code-cs[IRecordSequence#2](~/add/codesnippet/csharp/5d31b2a4-d7cf-41cf-80bb-_1.cs)]"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);
    parameters:
    - id: start
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji pierwszy rekord, gdy rozpoczyna się odczyt."
    - id: logRecordEnum
      type: System.IO.Log.LogRecordEnumeratorType
      description: "Prawidłowy <xref href=&quot;System.IO.Log.LogRecordEnumeratorType&quot;> </xref> wartość, która określa sposób (to znaczy, do przodu lub wstecz), w którym rejestrowane są odczytywane z <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>."
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "Ustalony zbiór rekordów w sekwencji."
  overload: System.IO.Log.FileRecordSequence.ReadLogRecords*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Co najmniej jeden z argumentów jest poza zakresem."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do zapisu."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Sekwencja rekordów jest uszkodzona.       - lub - rekord został zapisany za pomocą niezgodnej wersji sekwencja rekordów."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Wyliczanie zostało zakończone.       - lub - wyliczenia nie został uruchomiony. Wywołanie <xref:System.Collections.IEnumerator.MoveNext*>muszą być wprowadzane.</xref:System.Collections.IEnumerator.MoveNext*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.ReadRestartAreas
  id: ReadRestartAreas
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: ReadRestartAreas()
  nameWithType: FileRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.FileRecordSequence.ReadRestartAreas()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Zwraca wyliczalny kolekcji obszarów ponownego uruchomienia w sekwencji. Ta metoda nie może być dziedziczona."
  remarks: "Obszarów ponownego uruchomienia są wymienione w kolejności odwrotnej kolejności, oznacza to, z najwyższym numerem najniższy numer sekwencyjny. Tylko ponownie obszarów z numerami sekwencji między ostatni numer sekwencji i numer sekwencyjny podstawowej są wyliczone."
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadRestartAreas ();
    parameters: []
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "Wyliczalny kolekcja obszarów ponownego uruchomienia w sekwencji."
  overload: System.IO.Log.FileRecordSequence.ReadRestartAreas*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do zapisu."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Sekwencja rekordów jest uszkodzona.       - lub - rekord został zapisany za pomocą niezgodnej wersji sekwencja rekordów."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Wyliczanie zostało zakończone.       - lub - wyliczenia nie został uruchomiony. Wywołanie <xref:System.Collections.IEnumerator.MoveNext*>muszą być wprowadzane.</xref:System.Collections.IEnumerator.MoveNext*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: FileRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.FileRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Automatycznie sprawia, że pojedynczy rezerwacji i dołącza do sekwencji rekordu. Ta metoda nie może być dziedziczona."
  remarks: "Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Określony rezerwacji są dodawane podana rezerwacji operację dołączania kolekcji w niepodzielną operację z rekordu. W przypadku niepowodzenia Dołącz miejsce nie jest zarezerwowana.       Zwykle ta metoda może zakończyć się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.FileRecordSequence.Flush%2A>metody.</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> zawierający dokonanie rezerwacji w kolekcji."
    - id: reservations
      type: System.Int64[]
      description: "Zastrzeżenia dokonanie w bajtach."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji rekordu dziennika dołączany."
  overload: System.IO.Log.FileRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Co najmniej jeden z argumentów jest poza zakresem."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>nie została utworzona przez tę sekwencję rekordu."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: FileRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.FileRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Automatycznie sprawia, że pojedynczy rezerwacji i dołącza do sekwencji rekordu. Ta metoda nie może być dziedziczona."
  remarks: "Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Określony rezerwacji są dodawane podana rezerwacji operację dołączania kolekcji w niepodzielną operację z rekordu. W przypadku niepowodzenia Dołącz miejsce nie jest zarezerwowana.       Zwykle ta metoda może zakończyć się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.FileRecordSequence.Flush%2A>metody.</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "Kolekcja rezerwacji dokonanie rezerwacji w."
    - id: reservations
      type: System.Int64[]
      description: "Zastrzeżenia dokonanie w bajtach."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji rekordu dziennika dołączany."
  overload: System.IO.Log.FileRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Co najmniej jeden z argumentów jest poza zakresem."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>nie została utworzona przez tę sekwencję rekordu."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.ReservedBytes
  id: ReservedBytes
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: ReservedBytes
  nameWithType: FileRecordSequence.ReservedBytes
  fullName: System.IO.Log.FileRecordSequence.ReservedBytes
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Pobiera całkowitą liczbę bajtów, które zostały zarezerwowane."
  syntax:
    content: public long ReservedBytes { get; }
    return:
      type: System.Int64
      description: "Całkowity rozmiar wszystkich rezerwacji dokonanych w tej sekwencji rekordu."
  overload: System.IO.Log.FileRecordSequence.ReservedBytes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Właściwość uzyskano po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.RestartSequenceNumber
  id: RestartSequenceNumber
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: RestartSequenceNumber
  nameWithType: FileRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.FileRecordSequence.RestartSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Pobiera numer sekwencyjny niedawno napisanych obszaru ponownego uruchomienia."
  remarks: "Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Typowe dziennika File System (CLFS) obsługuje dwa obszary, aby zagwarantować, że co najmniej jeden nieprawidłowy obszar jest zawsze dostępna po ponownym uruchomieniu. Podczas odzyskiwania jest niezbędne, CLFS odczytuje obszaru jego ponownego uruchomienia i wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania."
  syntax:
    content: public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji najbardziej ostatnio zapisany ponownie obszar."
  overload: System.IO.Log.FileRecordSequence.RestartSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Właściwość uzyskano po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.RetryAppend
  id: RetryAppend
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: RetryAppend
  nameWithType: FileRecordSequence.RetryAppend
  fullName: System.IO.Log.FileRecordSequence.RetryAppend
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Pobiera lub ustawia wartość wskazującą, czy dołącza są automatycznie podjęta, jeśli dziennik jest zapełniony."
  remarks: "Jeśli wartość tej właściwości jest `true`i <xref:System.IO.Log.FileRecordSequence.Append%2A>Wywołanie zakończy się niepowodzeniem, ponieważ nie ma wystarczającej ilości miejsca w sekwencji, sekwencja rekordów spróbuje wolnego miejsca, a następnie spróbuj ponownie Dołącz.</xref:System.IO.Log.FileRecordSequence.Append%2A>"
  syntax:
    content: public bool RetryAppend { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli dołącza są automatycznie podjęta, jeśli dziennik jest zapełniony; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Wartość domyślna to <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.Log.FileRecordSequence.RetryAppend*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Właściwość uzyskano po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.TailPinned
  id: TailPinned
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: TailPinned
  nameWithType: FileRecordSequence.TailPinned
  fullName: System.IO.Log.FileRecordSequence.TailPinned
  type: Event
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Występuje, gdy sekwencja rekordów Określa, że końcowego fragmentu musi zostać przeniesiona do przodu. Ta metoda nie może być dziedziczona."
  remarks: "Mogą wyzwalać to zdarzenie, gdy sekwencja rekordów zabrakło miejsca. To zdarzenie jest wywoływane, tail sekwencji (to znaczy numer sekwencji podstawowej) jest przenoszony do przodu w celu zwolnienia miejsca."
  syntax:
    content: public event EventHandler<System.IO.Log.TailPinnedEventArgs> TailPinned;
    return:
      type: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  id: WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Zapisuje obszar ponownego uruchomienia <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>. Ta metoda nie może być dziedziczona."
  remarks: "Obszar ponowne uruchomienie może służyć do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Podczas odzyskiwania jest niezbędne, można czytać obszaru ponownego uruchomienia i pobrać wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania.       Obszar ponowne uruchomienie może zostać odczytany przy użyciu <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>metody.</xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>       Dane w segmentach tablicy bajtów zostaną połączone tablicy bajtów pojedynczego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów przeczytaniu obszaru ponownego uruchamiania."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji zapisany ponownie obszar."
  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Zapisuje obszar ponownego uruchomienia <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>. Ta metoda nie może być dziedziczona."
  remarks: "Obszar ponowne uruchomienie może służyć do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Podczas odzyskiwania jest niezbędne, można czytać obszaru ponownego uruchomienia i pobrać wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania.       Obszar ponowne uruchomienie może zostać odczytany przy użyciu <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>metody.</xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>       Dane w segmentach tablicy bajtów zostaną połączone tablicy bajtów pojedynczego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów przeczytaniu obszaru ponownego uruchamiania."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji zapisany ponownie obszar."
  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Zapisuje obszar ponownego uruchomienia <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>. Ta metoda nie może być dziedziczona."
  remarks: "Obszar ponowne uruchomienie może służyć do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Podczas odzyskiwania jest niezbędne, można czytać obszaru ponownego uruchomienia i pobrać wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania.       Obszar ponowne uruchomienie może zostać odczytany przy użyciu <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>metody.</xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>       Gdy obszar ponownego uruchomienia zostanie zapisany, dane w segmentach tablicy typu byte są łączone tablicy bajtów pojedynczego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów przeczytaniu obszaru ponownego uruchamiania.       Po pomyślnym zakończeniu tej metody, numer sekwencyjny podstawowy został zaktualizowany. Rejestrowania wszystkich rekordów z numerami sekwencji mniej niż nowy numer sekwencji podstawowej są niedostępne."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa bieżący numer sekwencyjny podstawowej."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji zapisany ponownie obszar."
  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSeqNum</code>nie jest od podstawowego do ostatniego numeru sekwencji.       - lub - nowy lub istniejący element archiwum albo podstawa aktywnego dziennika jest nieprawidłowa."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>jest nieprawidłowy dla tej sekwencji."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Zapisuje obszar ponownego uruchomienia <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>. Ta metoda nie może być dziedziczona."
  remarks: "Obszar ponowne uruchomienie może służyć do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Podczas odzyskiwania jest niezbędne, można czytać obszaru ponownego uruchomienia i pobrać wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania.       Obszar ponowne uruchomienie może zostać odczytany przy użyciu <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>metody.</xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>       Gdy obszar ponownego uruchomienia zostanie zapisany, dane w segmentach tablicy typu byte są łączone tablicy bajtów pojedynczego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów przeczytaniu obszaru ponownego uruchamiania.       Po pomyślnym zakończeniu tej metody, numer sekwencyjny podstawowy został zaktualizowany. Rejestrowania wszystkich rekordów z numerami sekwencji mniej niż nowy numer sekwencji podstawowej są niedostępne."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa bieżący numer sekwencyjny podstawowej."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji zapisany ponownie obszar."
  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSeqNum</code>nie jest od podstawowego do ostatniego numeru sekwencji.       - lub - nowy lub istniejący element archiwum albo podstawa aktywnego dziennika jest nieprawidłowa."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>jest nieprawidłowy dla tej sekwencji."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Zapisuje obszar ponownego uruchomienia <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>. Ta metoda nie może być dziedziczona."
  remarks: "Obszar ponowne uruchomienie może służyć do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Podczas odzyskiwania jest niezbędne, można czytać obszaru ponownego uruchomienia i pobrać wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania.       Obszar ponowne uruchomienie może zostać odczytany przy użyciu <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>metody.</xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>       Gdy obszar ponownego uruchomienia zostanie zapisany, dane w segmentach tablicy typu byte są łączone tablicy bajtów pojedynczego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów przeczytaniu obszaru ponownego uruchamiania.       Jeśli określono zastrzeżenie, obszar napisane ponownego uruchamiania będą korzystać z miejsca wcześniej zarezerwowanych, za pomocą rezerwacji zawartych w kolekcji. Jeśli metoda zakończy się powodzeniem, zużyje najmniejszą rezerwacji zawierające dane, a rezerwacji zostanie usunięty z kolekcji.       Po pomyślnym zakończeniu tej metody, numer sekwencyjny podstawowy został zaktualizowany. Rejestrowania wszystkich rekordów z numerami sekwencji mniej niż nowy numer sekwencji podstawowej są niedostępne.       Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>Metoda jest wywoływana.</xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa bieżący numer sekwencyjny podstawowej."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> zawierający rezerwacji, które mają być używane dla tego obszaru ponownego uruchomienia."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji zapisany ponownie obszar."
  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSeqNum</code>nie jest od podstawowego do ostatniego numeru sekwencji.       - lub - nowy lub istniejący element archiwum albo podstawa aktywnego dziennika jest nieprawidłowa."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>nie została utworzona przez tę sekwencję rekordu.       - lub - <code>newBaseSeqNum</code> jest nieprawidłowy dla tej sekwencji."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Rezerwacja nie jest wystarczająco duży, aby zmieścić <code> data </code> znajdują się w <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Zapisuje obszar ponownego uruchomienia <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>. Ta metoda nie może być dziedziczona."
  remarks: "Obszar ponowne uruchomienie może służyć do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Podczas odzyskiwania jest niezbędne, można czytać obszaru ponownego uruchomienia i pobrać wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania.       Obszar ponowne uruchomienie może zostać odczytany przy użyciu <xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>metody.</xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>       Gdy obszar ponownego uruchomienia zostanie zapisany, dane w segmentach tablicy typu byte są łączone tablicy bajtów pojedynczego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów przeczytaniu obszaru ponownego uruchamiania.       Jeśli określono zastrzeżenie, obszar napisane ponownego uruchamiania będą korzystać z miejsca wcześniej zarezerwowanych, za pomocą rezerwacji zawartych w kolekcji. Jeśli metoda zakończy się powodzeniem, zużyje najmniejszą rezerwacji zawierające dane, a rezerwacji zostanie usunięty z kolekcji.       Po pomyślnym zakończeniu tej metody, numer sekwencyjny podstawowy został zaktualizowany. Rejestrowania wszystkich rekordów z numerami sekwencji mniej niż nowy numer sekwencji podstawowej są niedostępne.       Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>Metoda jest wywoływana.</xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa bieżący numer sekwencyjny podstawowej."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> zawierający rezerwacji, które mają być używane dla tego obszaru ponownego uruchomienia."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji zapisany ponownie obszar."
  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSeqNum</code>nie jest od podstawowego do ostatniego numeru sekwencji.       - lub - nowy lub istniejący element archiwum albo podstawa aktywnego dziennika jest nieprawidłowa."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>nie została utworzona przez tę sekwencję rekordu.       - lub - <code>newBaseSeqNum</code> jest nieprawidłowy dla tej sekwencji."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Rezerwacja nie jest wystarczająco duży, aby zmieścić <code> data </code> znajdują się w <code> reservations </code>."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.IO.Log.ReservationNotFoundException
  parent: System.IO.Log
  isExternal: false
  name: ReservationNotFoundException
  nameWithType: ReservationNotFoundException
  fullName: System.IO.Log.ReservationNotFoundException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.IO.Log.FileRecordSequence.#ctor(System.String)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: FileRecordSequence(String)
  nameWithType: FileRecordSequence.FileRecordSequence(String)
  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: FileRecordSequence(String,FileAccess)
  nameWithType: FileRecordSequence.FileRecordSequence(String,FileAccess)
  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess,System.Int32)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: FileRecordSequence(String,FileAccess,Int32)
  nameWithType: FileRecordSequence.FileRecordSequence(String,FileAccess,Int32)
  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String,FileAccess,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: FileRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
- uid: System.IO.Log.SequenceNumber
  parent: System.IO.Log
  isExternal: false
  name: SequenceNumber
  nameWithType: SequenceNumber
  fullName: System.IO.Log.SequenceNumber
- uid: System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.ArraySegment{System.Byte}
  parent: System
  isExternal: true
  name: ArraySegment<Byte>
  nameWithType: ArraySegment<Byte>
  fullName: System.ArraySegment<System.Byte>
  spec.csharp:
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.RecordAppendOptions
  parent: System.IO.Log
  isExternal: false
  name: RecordAppendOptions
  nameWithType: RecordAppendOptions
  fullName: System.IO.Log.RecordAppendOptions
- uid: System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
  parent: System.Collections.Generic
  isExternal: true
  name: IList<ArraySegment<Byte>>
  nameWithType: IList<ArraySegment<Byte>>
  fullName: System.Collections.Generic.IList<System.ArraySegment<System.Byte>>
  spec.csharp:
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: IList<System.ArraySegment<System.Byte>>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.ReservationCollection
  parent: System.IO.Log
  isExternal: false
  name: ReservationCollection
  nameWithType: ReservationCollection
  fullName: System.IO.Log.ReservationCollection
- uid: System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.FileRecordSequence.BaseSequenceNumber
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: FileRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.FileRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.Int64[]
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64[]
  spec.csharp:
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: Int64[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.CreateReservationCollection
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: CreateReservationCollection()
  nameWithType: FileRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.FileRecordSequence.CreateReservationCollection()
- uid: System.IO.Log.FileRecordSequence.Dispose
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Dispose()
  nameWithType: FileRecordSequence.Dispose()
  fullName: System.IO.Log.FileRecordSequence.Dispose()
- uid: System.IO.Log.FileRecordSequence.EndAppend(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndAppend(IAsyncResult)
  nameWithType: FileRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndAppend(IAsyncResult)
- uid: System.IO.Log.FileRecordSequence.EndFlush(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndFlush(IAsyncResult)
  nameWithType: FileRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndFlush(IAsyncResult)
- uid: System.IO.Log.FileRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: FileRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndReserveAndAppend(IAsyncResult)
- uid: System.IO.Log.FileRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: FileRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndWriteRestartArea(IAsyncResult)
- uid: System.IO.Log.FileRecordSequence.Flush
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Flush()
  nameWithType: FileRecordSequence.Flush()
  fullName: System.IO.Log.FileRecordSequence.Flush()
- uid: System.IO.Log.FileRecordSequence.Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Flush(SequenceNumber)
  nameWithType: FileRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.Flush(SequenceNumber)
- uid: System.IO.Log.FileRecordSequence.LastSequenceNumber
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: FileRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.FileRecordSequence.LastSequenceNumber
- uid: System.IO.Log.FileRecordSequence.MaximumRecordLength
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: FileRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.FileRecordSequence.MaximumRecordLength
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.FileRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: FileRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.FileRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
- uid: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<LogRecord>
  nameWithType: IEnumerable<LogRecord>
  fullName: System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.IO.Log.LogRecord>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.LogRecord
    name: LogRecord
    nameWithType: LogRecord
    fullName: LogRecord
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordEnumeratorType
  parent: System.IO.Log
  isExternal: false
  name: LogRecordEnumeratorType
  nameWithType: LogRecordEnumeratorType
  fullName: System.IO.Log.LogRecordEnumeratorType
- uid: System.IO.Log.FileRecordSequence.ReadRestartAreas
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReadRestartAreas()
  nameWithType: FileRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.FileRecordSequence.ReadRestartAreas()
- uid: System.IO.Log.FileRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: FileRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.FileRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.FileRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: FileRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.FileRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.FileRecordSequence.ReservedBytes
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: FileRecordSequence.ReservedBytes
  fullName: System.IO.Log.FileRecordSequence.ReservedBytes
- uid: System.IO.Log.FileRecordSequence.RestartSequenceNumber
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: FileRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.FileRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.FileRecordSequence.RetryAppend
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: FileRecordSequence.RetryAppend
  fullName: System.IO.Log.FileRecordSequence.RetryAppend
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.FileRecordSequence.TailPinned
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: TailPinned
  nameWithType: FileRecordSequence.TailPinned
  fullName: System.IO.Log.FileRecordSequence.TailPinned
- uid: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<TailPinnedEventArgs>
  nameWithType: EventHandler<TailPinnedEventArgs>
  fullName: System.EventHandler<System.IO.Log.TailPinnedEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.IO.Log.TailPinnedEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.TailPinnedEventArgs
    name: TailPinnedEventArgs
    nameWithType: TailPinnedEventArgs
    fullName: TailPinnedEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>)
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.FileRecordSequence.#ctor*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: FileRecordSequence
  nameWithType: FileRecordSequence.FileRecordSequence
- uid: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber
  nameWithType: FileRecordSequence.AdvanceBaseSequenceNumber
- uid: System.IO.Log.FileRecordSequence.Append*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Append
  nameWithType: FileRecordSequence.Append
- uid: System.IO.Log.FileRecordSequence.BaseSequenceNumber*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: FileRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.FileRecordSequence.BeginAppend*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginAppend
  nameWithType: FileRecordSequence.BeginAppend
- uid: System.IO.Log.FileRecordSequence.BeginFlush*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginFlush
  nameWithType: FileRecordSequence.BeginFlush
- uid: System.IO.Log.FileRecordSequence.BeginReserveAndAppend*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginReserveAndAppend
  nameWithType: FileRecordSequence.BeginReserveAndAppend
- uid: System.IO.Log.FileRecordSequence.BeginWriteRestartArea*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginWriteRestartArea
  nameWithType: FileRecordSequence.BeginWriteRestartArea
- uid: System.IO.Log.FileRecordSequence.CreateReservationCollection*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: CreateReservationCollection
  nameWithType: FileRecordSequence.CreateReservationCollection
- uid: System.IO.Log.FileRecordSequence.Dispose*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Dispose
  nameWithType: FileRecordSequence.Dispose
- uid: System.IO.Log.FileRecordSequence.EndAppend*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndAppend
  nameWithType: FileRecordSequence.EndAppend
- uid: System.IO.Log.FileRecordSequence.EndFlush*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndFlush
  nameWithType: FileRecordSequence.EndFlush
- uid: System.IO.Log.FileRecordSequence.EndReserveAndAppend*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndReserveAndAppend
  nameWithType: FileRecordSequence.EndReserveAndAppend
- uid: System.IO.Log.FileRecordSequence.EndWriteRestartArea*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndWriteRestartArea
  nameWithType: FileRecordSequence.EndWriteRestartArea
- uid: System.IO.Log.FileRecordSequence.Flush*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Flush
  nameWithType: FileRecordSequence.Flush
- uid: System.IO.Log.FileRecordSequence.LastSequenceNumber*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: FileRecordSequence.LastSequenceNumber
- uid: System.IO.Log.FileRecordSequence.MaximumRecordLength*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: FileRecordSequence.MaximumRecordLength
- uid: System.IO.Log.FileRecordSequence.ReadLogRecords*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReadLogRecords
  nameWithType: FileRecordSequence.ReadLogRecords
- uid: System.IO.Log.FileRecordSequence.ReadRestartAreas*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReadRestartAreas
  nameWithType: FileRecordSequence.ReadRestartAreas
- uid: System.IO.Log.FileRecordSequence.ReserveAndAppend*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReserveAndAppend
  nameWithType: FileRecordSequence.ReserveAndAppend
- uid: System.IO.Log.FileRecordSequence.ReservedBytes*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: FileRecordSequence.ReservedBytes
- uid: System.IO.Log.FileRecordSequence.RestartSequenceNumber*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: FileRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.FileRecordSequence.RetryAppend*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: FileRecordSequence.RetryAppend
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea
  nameWithType: FileRecordSequence.WriteRestartArea
