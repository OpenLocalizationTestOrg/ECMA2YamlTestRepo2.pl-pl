### YamlMime:ManagedReference
items:
- uid: System.Windows.Interop.D3DImage
  id: D3DImage
  children:
  - System.Windows.Interop.D3DImage.#ctor
  - System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)
  - System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)
  - System.Windows.Interop.D3DImage.Clone
  - System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)
  - System.Windows.Interop.D3DImage.CloneCurrentValue
  - System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)
  - System.Windows.Interop.D3DImage.CopyBackBuffer
  - System.Windows.Interop.D3DImage.CreateInstanceCore
  - System.Windows.Interop.D3DImage.Finalize
  - System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)
  - System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)
  - System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)
  - System.Windows.Interop.D3DImage.Height
  - System.Windows.Interop.D3DImage.IsFrontBufferAvailable
  - System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged
  - System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty
  - System.Windows.Interop.D3DImage.Lock
  - System.Windows.Interop.D3DImage.Metadata
  - System.Windows.Interop.D3DImage.PixelHeight
  - System.Windows.Interop.D3DImage.PixelWidth
  - System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)
  - System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)
  - System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)
  - System.Windows.Interop.D3DImage.Unlock
  - System.Windows.Interop.D3DImage.Width
  langs:
  - csharp
  name: D3DImage
  nameWithType: D3DImage
  fullName: System.Windows.Interop.D3DImage
  type: Class
  summary: "<xref href=&quot;System.Windows.Media.ImageSource&quot;> </xref> Wyświetlający powierzchni Direct3D utworzonych przez użytkownika."
  remarks: "Aby udostępnić zawartość Direct3D w aplikacji Windows Presentation Foundation (WPF), należy użyć klasy D3DImage.       Wywołanie <xref:System.Windows.Interop.D3DImage.Lock%2A>metodę, aby zmienić wyświetlane przez D3DImage zawartość Direct3D.</xref:System.Windows.Interop.D3DImage.Lock%2A> Wywołanie <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>metodę, aby przypisać powierzchni Direct3D D3DImage.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Wywołanie <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A>metody do śledzenia aktualizacje na powierzchnię Direct3D.</xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> Wywołanie <xref:System.Windows.Interop.D3DImage.Unlock%2A>metodę w celu wyświetlenia zmienione obszary.</xref:System.Windows.Interop.D3DImage.Unlock%2A>       Klasa D3DImage zarządza dwa bufory wyświetlania, które są nazywane *buforu zapasowego* i *front buforu*. Buforu zapasowego jest obszar Direct3D.  Zmiany buforu zapasowego są kopiowane do przodu do przodu buforu podczas wywoływania <xref:System.Windows.Interop.D3DImage.Unlock%2A>metody, w którym jest wyświetlana na urządzeniu.</xref:System.Windows.Interop.D3DImage.Unlock%2A> Czasami front buforu staje się niedostępna. Ten brak dostępności może być spowodowane blokady ekranu, wyłączne aplikacje Direct3D pełnego ekranu, przełączanie użytkowników lub inne działania systemu. W takim przypadku aplikacji WPF jest powiadamiany o Obsługa <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>zdarzeń.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>  Sposób odpowiadania przez aplikację do przodu buforu niedostępności zależy od tego, czy włączono WPF wrócił do renderowania oprogramowania. <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>Metoda ma przeciążenia, które przyjmuje parametr, który określa, czy WPF powraca do renderowania oprogramowania.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>      ## Odpowiada na niedostępny buforu przodu, gdy jest WPF nie wracały do renderowania oprogramowania podczas wywoływania <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29>przeciążenia lub zadzwoń <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>przeciążenia z `enableSoftwareFallback` parametru `false`, system renderowania zwalnia jego odwołania do buforu zapasowego podczas front buforu staje się niedostępny i nie będą wyświetlane żadne.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> </xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> Gdy front buforu jest ponownie dostępny, system renderowania zgłasza <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>zdarzeń do powiadamiania aplikacji WPF.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>  Można utworzyć programu obsługi zdarzeń dla <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>zdarzeń, aby ponownie uruchomić renderowania ponownie, podając prawidłowy powierzchni Direct3D.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Aby ponownie uruchomić renderowania, należy wywołać <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>      ## Odpowiada na żądania niedostępny buforu przodu podczas WPF znajduje się wstecz, aby oprogramowanie renderowania podczas wywoływania <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>przeciążenia z `enableSoftwareFallback` ustawiona `true`, system renderowania ma zachowywać odwołanie do buforu zapasowego, gdy front buforu jest niedostępna, więc nie trzeba wywołać <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>Jeśli front bufor nie jest dostępny ponownie.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> </xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>  Mogą wystąpić sytuacje, gdy urządzenie użytkownika jest niedostępny.  Jeśli ma to miejsce, należy wywołać <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>zwolnienia odwołania w WPF do buforu zapasowego.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>  Jeśli zachodzi potrzeba zresetowania urządzenia, wywołanie <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>z `backBuffer` ustawiona `null`, a następnie wywołać <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>ponownie, podając `backBuffer` ustawioną prawidłową powierzchni Direct3D.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> </xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>      > [!NOTE] > Wydajności zależy od znacznie ustawień powierzchni Direct3D. Aby uzyskać więcej informacji, zobacz [zagadnienia dotyczące wydajności Direct3D9 i współdziałanie WPF](~/add/includes/ajax-current-ext-md.md).      > [!NOTE] > Klasy D3DImage nie wyświetla zawartość Direct3D podczas renderowania WPF w oprogramowania, takie jak przez połączenie pulpitu zdalnego, chyba że wywołania <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>i określ `true` dla `enableSoftwareFallback` parametru.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>"
  example:
  - "The following code example shows how to declare a D3DImage in XAML. You must map the <xref:System.Windows.Interop> namespace, because it is not included in the default XAML namespaces. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-xml[System.Windows.Interop.D3DImage#10](~/add/codesnippet/xaml/d3dhost/window1.xaml#10)]"
  syntax:
    content: 'public class D3DImage : System.Windows.Media.ImageSource'
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  - System.Windows.DependencyObject
  - System.Windows.Freezable
  - System.Windows.Media.Animation.Animatable
  - System.Windows.Media.ImageSource
  implements: []
  inheritedMembers:
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.DependencyObjectType
  - System.Windows.DependencyObject.Equals(System.Object)
  - System.Windows.DependencyObject.GetHashCode
  - System.Windows.DependencyObject.GetLocalValueEnumerator
  - System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.IsSealed
  - System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)
  - System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)
  - System.Windows.Freezable.CanFreeze
  - System.Windows.Freezable.Changed
  - System.Windows.Freezable.CreateInstance
  - System.Windows.Freezable.Freeze
  - System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)
  - System.Windows.Freezable.GetAsFrozen
  - System.Windows.Freezable.GetCurrentValueAsFrozen
  - System.Windows.Freezable.IsFrozen
  - System.Windows.Freezable.OnChanged
  - System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)
  - System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)
  - System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.Freezable.ReadPreamble
  - System.Windows.Freezable.WritePostscript
  - System.Windows.Freezable.WritePreamble
  - System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  - System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  - System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.Media.Animation.Animatable.GetAnimationBaseValue(System.Windows.DependencyProperty)
  - System.Windows.Media.Animation.Animatable.HasAnimatedProperties
  - System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference(System.Windows.DependencyObject)
  - System.Windows.Media.ImageSource.PixelsToDIPs(System.Double,System.Int32)
  - System.Windows.Media.ImageSource.System#IFormattable#ToString(System.String,System.IFormatProvider)
  - System.Windows.Media.ImageSource.ToString
  - System.Windows.Media.ImageSource.ToString(System.IFormatProvider)
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.#ctor
  id: '#ctor'
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: D3DImage()
  nameWithType: D3DImage.D3DImage()
  fullName: System.Windows.Interop.D3DImage.D3DImage()
  type: Constructor
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> klasy."
  remarks: "Domyślnej rozdzielczości jest 1/96 cala."
  syntax:
    content: public D3DImage ();
    parameters: []
  overload: System.Windows.Interop.D3DImage.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)
  id: '#ctor(System.Double,System.Double)'
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: D3DImage(Double,Double)
  nameWithType: D3DImage.D3DImage(Double,Double)
  fullName: System.Windows.Interop.D3DImage.D3DImage(Double,Double)
  type: Constructor
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> klasy z określonej rozdzielczości."
  remarks: "Domyślnej rozdzielczości jest 1/96 cala."
  syntax:
    content: public D3DImage (double dpiX, double dpiY);
    parameters:
    - id: dpiX
      type: System.Double
      description: "Rozdzielczość ekranu na osi x."
    - id: dpiY
      type: System.Double
      description: "Rozdzielczość ekranu na osi y."
  overload: System.Windows.Interop.D3DImage.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>dpiX</code>lub <code>dpiY</code> jest mniejsza od zera."
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)
  id: AddDirtyRect(System.Windows.Int32Rect)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: AddDirtyRect(Int32Rect)
  nameWithType: D3DImage.AddDirtyRect(Int32Rect)
  fullName: System.Windows.Interop.D3DImage.AddDirtyRect(Int32Rect)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Określa obszar buforu zapasowego, zmienić."
  remarks: "Wywołaj metodę AddDirtyRect celu wskazania zmiany wprowadzone do buforu zapasowego kodu. Do renderowania, obszarze zmienione na buforu zapasowego musi mieć odpowiadający mu obszar zmienione na <xref:System.Windows.Interop.D3DImage>.</xref:System.Windows.Interop.D3DImage>       Wywołanie <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>i <xref:System.Windows.Interop.D3DImage.Lock%2A>metody przed wywołaniem metody AddDirtyRect.</xref:System.Windows.Interop.D3DImage.Lock%2A> </xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>       Wywołanie <xref:System.Windows.Interop.D3DImage.Unlock%2A>metodę, aby skopiować zmienione obszary do przodu buforu.</xref:System.Windows.Interop.D3DImage.Unlock%2A>      > [!NOTE] > Po kilku wywołania metody AddDirtyRect, zmienione obszary są scalane w jednym obszarze. Oznacza to, że masz prawidłowe dane poza zmienione obszary."
  example:
  - "The following code example shows how to call the AddDirtyRect method to specify the changed region in the back buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public void AddDirtyRect (System.Windows.Int32Rect dirtyRect);
    parameters:
    - id: dirtyRect
      type: System.Windows.Int32Rect
      description: "<xref href=&quot;System.Windows.Int32Rect&quot;> </xref> Reprezentujący obszaru zmienione."
  overload: System.Windows.Interop.D3DImage.AddDirtyRect*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Mapa bitowa nie został zablokowany przez wywołanie do <> </> *> lub <> </> *> metody.       - lub - buforu zapasowego nie został przypisany przez wywołanie do <xref:System.Windows.Interop.D3DImage.SetBackBuffer*>metody.</xref:System.Windows.Interop.D3DImage.SetBackBuffer*>"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Co najmniej jeden z następujących warunków jest true.       <code>dirtyRect.X</code>&lt; 0       <code>dirtyRect.Y</code> &lt; 0       <code>dirtyRect.Width</code> &lt; 0 or <code>dirtyRect.Width</code> &gt; <>*>       <code>dirtyRect.Height</code> &lt; 0 or <code>dirtyRect.Height</code> &gt;<>*>"
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Clone
  id: Clone
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Clone()
  nameWithType: D3DImage.Clone()
  fullName: System.Windows.Interop.D3DImage.Clone()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Tworzy modyfikowalną klonu tego <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> obiekt Tworzenie bezpośrednich kopii wartości tego obiektu. Podczas kopiowania właściwości zależności, ta metoda umożliwia skopiowanie zasobów odniesienia i danych powiązania (które mogą być już rozpoznawane), ale nie animacji lub ich bieżącymi wartościami."
  remarks: "Ta metoda służy do tworzenia kopii można modyfikować zablokowane <xref:System.Windows.Freezable>obiektów (lub dowolnej <xref:System.Windows.Freezable>obiektu).</xref:System.Windows.Freezable> </xref:System.Windows.Freezable> Dla wygody ta metoda zasłania dziedziczone wersji z silnie typizowaną implementację.       Aby uzyskać więcej informacji zobacz <xref:System.Windows.Freezable.Clone%2A?displayProperty=fullName>.</xref:System.Windows.Freezable.Clone%2A?displayProperty=fullName>"
  syntax:
    content: public System.Windows.Interop.D3DImage Clone ();
    parameters: []
    return:
      type: System.Windows.Interop.D3DImage
      description: "Można modyfikować klonu bieżącego obiektu. Sklonowany obiekt <> </> *> właściwość będzie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> nawet wtedy, gdy źródło <> </> *> właściwość<xref uid=&quot;langword_csharp_true.&quot; name=&quot;true.&quot; href=&quot;&quot;></xref>"
  overload: System.Windows.Interop.D3DImage.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)
  id: CloneCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: CloneCore(Freezable)
  nameWithType: D3DImage.CloneCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.CloneCore(Freezable)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Sprawia, że wystąpienie klonowania (bezpośrednich kopii) z określonym <xref href=&quot;System.Windows.Freezable&quot;> </xref> przy użyciu wartości podstawowej właściwości (z systemem innym niż animowane)."
  syntax:
    content: protected override void CloneCore (System.Windows.Freezable sourceFreezable);
    parameters:
    - id: sourceFreezable
      type: System.Windows.Freezable
      description: "Obiekt do klonowania."
  overload: System.Windows.Interop.D3DImage.CloneCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.CloneCurrentValue
  id: CloneCurrentValue
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: CloneCurrentValue()
  nameWithType: D3DImage.CloneCurrentValue()
  fullName: System.Windows.Interop.D3DImage.CloneCurrentValue()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Tworzy modyfikowalną klonu tego <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> obiekt Tworzenie bezpośrednich kopii wartości bieżących tego obiektu. Odwołania do zasobu, powiązania danych i animacji nie są kopiowane, ale ich bieżącymi wartościami są kopiowane."
  remarks: "Ta metoda służy do tworzenia kopii można modyfikować zablokowane <xref:System.Windows.Freezable>obiektów (lub dowolnej <xref:System.Windows.Freezable>obiektu).</xref:System.Windows.Freezable> </xref:System.Windows.Freezable> Dla wygody ta metoda zasłania dziedziczone wersji z silnie typizowaną implementację.       Aby uzyskać więcej informacji zobacz <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=fullName>.</xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=fullName>"
  syntax:
    content: public System.Windows.Interop.D3DImage CloneCurrentValue ();
    parameters: []
    return:
      type: System.Windows.Interop.D3DImage
      description: "Można modyfikować klonu bieżącego obiektu. Sklonowany obiekt <> </> *> właściwość będzie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> nawet wtedy, gdy źródło <> </> *> właściwość <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Interop.D3DImage.CloneCurrentValue*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)
  id: CloneCurrentValueCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: CloneCurrentValueCore(Freezable)
  nameWithType: D3DImage.CloneCurrentValueCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.CloneCurrentValueCore(Freezable)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Sprawia, że wystąpienie można modyfikować klonowania (bezpośrednich kopii) z określonym <xref href=&quot;System.Windows.Freezable&quot;> </xref> przy użyciu bieżącej wartości właściwości."
  syntax:
    content: protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);
    parameters:
    - id: sourceFreezable
      type: System.Windows.Freezable
      description: "<xref href=&quot;System.Windows.Freezable&quot;> </xref> Klonowania."
  overload: System.Windows.Interop.D3DImage.CloneCurrentValueCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.CopyBackBuffer
  id: CopyBackBuffer
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: CopyBackBuffer()
  nameWithType: D3DImage.CopyBackBuffer()
  fullName: System.Windows.Interop.D3DImage.CopyBackBuffer()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Tworzy kopię oprogramowania <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>."
  remarks: "Metoda CopyBackBuffer jest wywoływana przez klientów, takich jak system drukowania i <xref:System.Windows.Media.Imaging.RenderTargetBitmap>klasy.</xref:System.Windows.Media.Imaging.RenderTargetBitmap>       Opcjonalnie zastąpić metodę CopyBackBuffer do implementacji logiki niestandardowej, a następnie wróć różnych <xref:System.Windows.Media.Imaging.BitmapSource>.</xref:System.Windows.Media.Imaging.BitmapSource> Na przykład można zwrócić symbol zastępczy <xref:System.Windows.Media.Imaging.BitmapSource>Jeśli domyślna implementacja CopyBackBuffer zwraca `null`.</xref:System.Windows.Media.Imaging.BitmapSource>"
  syntax:
    content: protected virtual System.Windows.Media.Imaging.BitmapSource CopyBackBuffer ();
    parameters: []
    return:
      type: System.Windows.Media.Imaging.BitmapSource
      description: "A <xref href=&quot;System.Windows.Media.Imaging.BitmapSource&quot;> </xref> czyli oprogramowania kopię bieżącego stanu buforu zapasowego; w przeciwnym razie <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Jeśli buforu zapasowego nie można odczytać."
  overload: System.Windows.Interop.D3DImage.CopyBackBuffer*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.CreateInstanceCore
  id: CreateInstanceCore
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: CreateInstanceCore()
  nameWithType: D3DImage.CreateInstanceCore()
  fullName: System.Windows.Interop.D3DImage.CreateInstanceCore()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Po zaimplementowaniu w klasie pochodnej tworzy nowe wystąpienie klasy <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> klasy."
  remarks: "Jeśli pochodzi od <xref:System.Windows.Interop.D3DImage>klasy, konieczne jest przesłonięcie metody CreateInstanceCore włączania poprawne klonowania.</xref:System.Windows.Interop.D3DImage> Domyślna implementacja wykonuje `return new D3DImage()`, które nie będą poprawne, jeśli wystąpienie jest inną klasę."
  syntax:
    content: protected override System.Windows.Freezable CreateInstanceCore ();
    parameters: []
    return:
      type: System.Windows.Freezable
      description: "Nowe wystąpienie."
  overload: System.Windows.Interop.D3DImage.CreateInstanceCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Finalize
  id: Finalize
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Finalize()
  nameWithType: D3DImage.Finalize()
  fullName: System.Windows.Interop.D3DImage.Finalize()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Zwalnia zasoby i wykonuje inne operacje oczyszczania przed <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> jest odzyskana przez wyrzucanie elementów bezużytecznych."
  remarks: "Ta metoda zastępuje <xref:System.Object.Finalize%2A>.</xref:System.Object.Finalize%2A> Kod aplikacji nie powinny wywoływać tej metody; obiekt `Finalize` metoda jest wywoływana automatycznie podczas wyrzucania elementów bezużytecznych, chyba że finalizacji przez moduł garbage collector została wyłączona przez wywołanie do <xref:System.GC.SuppressFinalize%2A>metody.</xref:System.GC.SuppressFinalize%2A>       Aby uzyskać więcej informacji, zobacz [metody Finalize i destruktory](http://msdn.microsoft.com/en-us/fd376774-1643-499b-869e-9546a3aeea70), [czyszczenie zasobów niezarządzanych](~/add/includes/ajax-current-ext-md.md), i [przesłaniania metody Finalize](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)."
  syntax:
    content: ~D3DImage ();
    parameters: []
  overload: System.Windows.Interop.D3DImage.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)
  id: FreezeCore(System.Boolean)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: FreezeCore(Boolean)
  nameWithType: D3DImage.FreezeCore(Boolean)
  fullName: System.Windows.Interop.D3DImage.FreezeCore(Boolean)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Sprawia, że <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> unmodifiable lub określa, czy można go było unmodifiable."
  remarks: "<xref:System.Windows.Interop.D3DImage>Klasa nie zezwala na blokowanie, ponieważ zmiany są zawsze możliwe z powodu dostępności front buforu.</xref:System.Windows.Interop.D3DImage>"
  syntax:
    content: protected override sealed bool FreezeCore (bool isChecking);
    parameters:
    - id: isChecking
      type: System.Boolean
      description: "Nie ma znaczenia."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>we wszystkich przypadkach."
  overload: System.Windows.Interop.D3DImage.FreezeCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)
  id: GetAsFrozenCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: GetAsFrozenCore(Freezable)
  nameWithType: D3DImage.GetAsFrozenCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.GetAsFrozenCore(Freezable)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Sprawia, że wystąpienie zablokowane klonowania określonego <xref href=&quot;System.Windows.Freezable&quot;> </xref> przy użyciu wartości podstawowej właściwości (z systemem innym niż animowane)."
  syntax:
    content: protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);
    parameters:
    - id: sourceFreezable
      type: System.Windows.Freezable
      description: "Wystąpienie do skopiowania."
  overload: System.Windows.Interop.D3DImage.GetAsFrozenCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)
  id: GetCurrentValueAsFrozenCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: GetCurrentValueAsFrozenCore(Freezable)
  nameWithType: D3DImage.GetCurrentValueAsFrozenCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(Freezable)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Sprawia, że bieżące wystąpienie zablokowane klonowania określonego <xref href=&quot;System.Windows.Freezable&quot;> </xref>. Jeśli obiekt ma właściwości zależności animowany, ich bieżącymi wartościami animowany są kopiowane."
  syntax:
    content: protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);
    parameters:
    - id: sourceFreezable
      type: System.Windows.Freezable
      description: "<xref href=&quot;System.Windows.Freezable&quot;> </xref> Do skopiowania i zablokować."
  overload: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Height
  id: Height
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Height
  nameWithType: D3DImage.Height
  fullName: System.Windows.Interop.D3DImage.Height
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Pobiera wysokość <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>."
  remarks: "Wartość wysokości można zmienić, gdy nowy buforu zapasowego jest przypisany przez wywołanie do <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>metody.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>"
  syntax:
    content: public override sealed double Height { get; }
    return:
      type: System.Double
      description: "Wysokość <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>w jednostki pomiaru. Jednostki miary jest 1/96 cala."
  overload: System.Windows.Interop.D3DImage.Height*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailable
  id: IsFrontBufferAvailable
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: IsFrontBufferAvailable
  nameWithType: D3DImage.IsFrontBufferAvailable
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailable
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Pobiera wartość wskazującą, czy istnieje front buforu."
  remarks: "Czasami front buforu staje się niedostępna. Ten brak dostępności może być spowodowane blokady ekranu, wyłączne aplikacje Direct3D pełnego ekranu, przełączanie użytkowników lub inne działania systemu. W takim przypadku aplikacji WPF jest powiadamiany o Obsługa <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>zdarzeń.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>  Sposób odpowiadania przez aplikację do przodu buforu niedostępności zależy od tego, czy włączono WPF wrócił do renderowania oprogramowania. <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>Metoda ma przeciążenia, które przyjmuje parametr, który określa, czy WPF powraca do renderowania oprogramowania.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Aby uzyskać więcej informacji zobacz uwagi w <xref:System.Windows.Interop.D3DImage>klasie.</xref:System.Windows.Interop.D3DImage>      <a name=&quot;dependencyPropertyInfo_IsFrontBufferAvailable&quot;></a>## Informacje dotyczące właściwości zależności |||   |-|-|   | Pole identyfikatora | <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty>|   | Wartość właściwości metadanych `true`| None |</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty>"
  example:
  - "The following code example shows how to check the IsFrontBufferAvailable property when rendering the composition target. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#2](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#2)]"
  syntax:
    content: public bool IsFrontBufferAvailable { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli istnieje front buforu; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Interop.D3DImage.IsFrontBufferAvailable*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged
  id: IsFrontBufferAvailableChanged
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: IsFrontBufferAvailableChanged
  nameWithType: D3DImage.IsFrontBufferAvailableChanged
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged
  type: Event
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Występuje, gdy <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable*>zmiany właściwości.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable*>"
  remarks: "Obsługa IsFrontBufferAvailableChanged zgłaszane po zmianie stanu front buforu. Sposób odpowiadania przez aplikację do przodu buforu niedostępności zależy od tego, czy włączono WPF wrócił do renderowania oprogramowania. <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>Metoda ma przeciążenia, które przyjmuje parametr, który określa, czy WPF powraca do renderowania oprogramowania.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Aby uzyskać więcej informacji zobacz uwagi w <xref:System.Windows.Interop.D3DImage>klasie.</xref:System.Windows.Interop.D3DImage>"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler IsFrontBufferAvailableChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty
  id: IsFrontBufferAvailableProperty
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: IsFrontBufferAvailableProperty
  nameWithType: D3DImage.IsFrontBufferAvailableProperty
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty
  type: Field
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Identyfikuje <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable*>Właściwości zależności.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsFrontBufferAvailableProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Lock
  id: Lock
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Lock()
  nameWithType: D3DImage.Lock()
  fullName: System.Windows.Interop.D3DImage.Lock()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Blokuje <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> i umożliwia operacji na buforu zapasowego."
  remarks: "Wywołanie metody Lock zmiany wywołując buforu zapasowego <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A>i <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>metody.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> </xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> Gdy <xref:System.Windows.Interop.D3DImage>jest zablokowany, aplikacji również może renderować na powierzchnię Direct3D przypisane do buforu zapasowego.</xref:System.Windows.Interop.D3DImage>      > [!NOTE] > Zablokuje Lock — Metoda odczytuje systemu renderowania buforu zapasowego zaktualizować front buforu. Użyj <xref:System.Windows.Interop.D3DImage.TryLock%2A>metody w celu unikania blokowania nieskończoność.</xref:System.Windows.Interop.D3DImage.TryLock%2A>"
  example:
  - "The following code example shows how to call the Lock method to enable updates to the back buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public void Lock ();
    parameters: []
  overload: System.Windows.Interop.D3DImage.Lock*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Liczba blokad równa <xref:System.UInt32.MaxValue>.</xref:System.UInt32.MaxValue>"
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Metadata
  id: Metadata
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Metadata
  nameWithType: D3DImage.Metadata
  fullName: System.Windows.Interop.D3DImage.Metadata
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Pobiera metadane skojarzone z obrazu źródłowego."
  syntax:
    content: public override sealed System.Windows.Media.ImageMetadata Metadata { get; }
    return:
      type: System.Windows.Media.ImageMetadata
      description: "<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>we wszystkich przypadkach."
  overload: System.Windows.Interop.D3DImage.Metadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.PixelHeight
  id: PixelHeight
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: PixelHeight
  nameWithType: D3DImage.PixelHeight
  fullName: System.Windows.Interop.D3DImage.PixelHeight
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Pobiera wysokość <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>, w pikselach."
  remarks: "Wartość PixelHeight można zmienić, gdy nowy buforu zapasowego jest przypisany przez wywołanie do <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>metody.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>"
  example:
  - "The following code example shows how to use the PixelHeight property to specify the changed region in the back buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public int PixelHeight { get; }
    return:
      type: System.Int32
      description: "Wysokość <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>, w pikselach."
  overload: System.Windows.Interop.D3DImage.PixelHeight*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.PixelWidth
  id: PixelWidth
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: PixelWidth
  nameWithType: D3DImage.PixelWidth
  fullName: System.Windows.Interop.D3DImage.PixelWidth
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Pobiera szerokość <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>, w pikselach."
  remarks: "Wartość PixelWidth można zmienić, gdy nowy buforu zapasowego jest przypisany przez wywołanie do <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>metody.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>"
  example:
  - "The following code example shows how to use the PixelWidth property to specify the changed region in the back buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public int PixelWidth { get; }
    return:
      type: System.Int32
      description: "Szerokość <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>, w pikselach."
  overload: System.Windows.Interop.D3DImage.PixelWidth*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)
  id: SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: SetBackBuffer(D3DResourceType,IntPtr)
  nameWithType: D3DImage.SetBackBuffer(D3DResourceType,IntPtr)
  fullName: System.Windows.Interop.D3DImage.SetBackBuffer(D3DResourceType,IntPtr)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Przypisuje powierzchni Direct3D jako źródło buforu zapasowego."
  remarks: "Wywołaj metodę SetBackBuffer można przypisać do buforu zapasowego powierzchni Direct3D.      > [!NOTE] > Wydajności zależy od znacznie ustawień powierzchni Direct3D. Aby uzyskać więcej informacji, zobacz [zagadnienia dotyczące wydajności Direct3D9 i współdziałanie WPF](~/add/includes/ajax-current-ext-md.md).       Wywołania przeciążenia SetBackBuffer jest taka sama jak wywołanie <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>przeciążenia z `enableSoftwareFallback` ustawiona `false`.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> Podczas wywoływania SetBackBuffer lub wywołanie <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29>z `enableSoftwareFallback` parametru `false`, system renderowania zwalnia jego odwołania do buforu zapasowego po front buforu staje się niedostępny i nie będą wyświetlane żadne.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> Gdy front buforu jest ponownie dostępny, system renderowania zgłasza <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>zdarzeń do powiadamiania aplikacji WPF.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>  Można utworzyć programu obsługi zdarzeń dla <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>zdarzeń, aby ponownie uruchomić renderowania ponownie, podając prawidłowy powierzchni Direct3D.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Aby ponownie uruchomić renderowania, należy wywołać SetBackBuffer.       Poniższa lista zawiera ustawienia wymagane buforu zapasowego `IDirect3DSurface9` typu.      - `D3DFMT_A8R8G8B8` lub `D3DFMT_X8R8G8B8`       -    `D3DUSAGE_RENDERTARGET`       -    `D3DPOOL_DEFAULT` Multisampling jest dozwolona w `IDirect3DSurface9Ex` tylko powierzchni."
  example:
  - "The following code example shows how to call the SetBackBuffer method to assign a Direct3D surface. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public void SetBackBuffer (System.Windows.Interop.D3DResourceType backBufferType, IntPtr backBuffer);
    parameters:
    - id: backBufferType
      type: System.Windows.Interop.D3DResourceType
      description: "Typ powierzchni Direct3D. Musi być prawidłową <xref href=&quot;System.Windows.Interop.D3DResourceType&quot;> </xref>."
    - id: backBuffer
      type: System.IntPtr
      description: "Obszar Direct3D można przypisać jako buforu zapasowego."
  overload: System.Windows.Interop.D3DImage.SetBackBuffer*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> Nie został zablokowany przez wywołanie do <> </> *> lub <> </> *> metody."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>backBufferType</code>nie jest prawidłową <xref href=&quot;System.Windows.Interop.D3DResourceType&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Parametry tworzenia <code> backBuffer </code> nie spełnia wymagań dotyczących <code> backBufferType </code>- lub - <code> backBuffer </code> urządzenie nie jest prawidłowy."
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)
  id: SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: SetBackBuffer(D3DResourceType,IntPtr,Boolean)
  nameWithType: D3DImage.SetBackBuffer(D3DResourceType,IntPtr,Boolean)
  fullName: System.Windows.Interop.D3DImage.SetBackBuffer(D3DResourceType,IntPtr,Boolean)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Przypisuje powierzchni Direct3D jako źródło buforu zapasowego."
  remarks: "Podczas wywoływania <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29>przeciążenia lub wywoływać przeciążenia SetBackBuffer z `enableSoftwareFallback` parametru `false`, system renderowania zwalnia jego odwołania do buforu zapasowego podczas front buforu staje się niedostępny i nie będą wyświetlane żadne.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> Gdy front buforu jest ponownie dostępny, system renderowania zgłasza <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>zdarzeń do powiadamiania aplikacji WPF.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>  Można utworzyć programu obsługi zdarzeń dla <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged>zdarzeń, aby ponownie uruchomić renderowania ponownie, podając prawidłowy powierzchni Direct3D.</xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Aby ponownie uruchomić renderowania, należy wywołać <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>       Podczas wywoływania SetBackBuffer z `enableSoftwareFallback` ustawiona `true`, system renderowania ma zachowywać odwołanie do buforu zapasowego, gdy front buforu jest niedostępna, więc nie trzeba wywołać <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>Jeśli front bufor nie jest dostępny ponownie.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>  Mogą wystąpić sytuacje, gdy urządzenie użytkownika jest niedostępny.  Jeśli ma to miejsce, należy wywołać <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>zwolnienia odwołania w WPF do buforu zapasowego.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>  Jeśli zachodzi potrzeba zresetowania urządzenia, wywołanie <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>z `backBuffer` ustawioną `null`, a następnie wywołać <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>ponownie, podając `backBuffer` ustawioną prawidłową powierzchni Direct3D.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> </xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>       Poniższa lista zawiera ustawienia wymagane buforu zapasowego `IDirect3DSurface9` typu.      - `D3DFMT_A8R8G8B8` lub `D3DFMT_X8R8G8B8`       -    `D3DUSAGE_RENDERTARGET`       -    `D3DPOOL_DEFAULT` Multisampling jest dozwolona w `IDirect3DSurface9Ex` tylko powierzchni."
  syntax:
    content: public void SetBackBuffer (System.Windows.Interop.D3DResourceType backBufferType, IntPtr backBuffer, bool enableSoftwareFallback);
    parameters:
    - id: backBufferType
      type: System.Windows.Interop.D3DResourceType
      description: "Typ powierzchni Direct3D. Musi być prawidłową <xref href=&quot;System.Windows.Interop.D3DResourceType&quot;> </xref>."
    - id: backBuffer
      type: System.IntPtr
      description: "Obszar Direct3D można przypisać jako buforu zapasowego."
    - id: enableSoftwareFallback
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby przełączyć na renderowanie oprogramowania; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Interop.D3DImage.SetBackBuffer*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)
  id: TryLock(System.Windows.Duration)
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: TryLock(Duration)
  nameWithType: D3DImage.TryLock(Duration)
  fullName: System.Windows.Interop.D3DImage.TryLock(Duration)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Próbuje zablokować <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref> i czeka na określony czas trwania."
  syntax:
    content: public bool TryLock (System.Windows.Duration timeout);
    parameters:
    - id: timeout
      type: System.Windows.Duration
      description: "Czas trwania blokady dla oczekiwania."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli uzyskano blokady; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Interop.D3DImage.TryLock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>timeout</code>ustawiono <xref:System.Windows.Duration.Automatic*>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Liczba blokad równa <xref:System.UInt32.MaxValue>.</xref:System.UInt32.MaxValue>"
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Unlock
  id: Unlock
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Unlock()
  nameWithType: D3DImage.Unlock()
  fullName: System.Windows.Interop.D3DImage.Unlock()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Zmniejsza liczbę blokad dla <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>."
  remarks: "Gdy liczbę blokad dla <xref:System.Windows.Interop.D3DImage>osiągnie wartość&0;, <xref:System.Windows.Interop.D3DImage>jest w pełni odblokowane.</xref:System.Windows.Interop.D3DImage> </xref:System.Windows.Interop.D3DImage> <xref:System.Windows.Interop.D3DImage>Jest oznaczony do renderowania, jeśli obraz został zmieniony obszarów, które zostały określone przez poprzedniego wywołania <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A>metody.</xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> </xref:System.Windows.Interop.D3DImage>       Podczas zmiany zostały zastosowane, i występuje renderowania, dodatkowe wywołania <xref:System.Windows.Interop.D3DImage.Lock%2A>bloku metody do momentu wątku renderowania została skopiowana zawartość buforu zapasowego do przodu buforu.</xref:System.Windows.Interop.D3DImage.Lock%2A> Synchronizacja pozwala uniknąć wyświetlania artefaktów, takich jak przerwanie.      > [!NOTE] > Nie zaktualizować powierzchni Direct3D podczas <xref:System.Windows.Interop.D3DImage>jest odblokowany.</xref:System.Windows.Interop.D3DImage>"
  example:
  - "The following code example shows how to call the Unlock method to copy the updated back buffer to the front buffer. For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[System.Windows.Interop.D3DImage#3](~/add/codesnippet/csharp/d3dhost/window1.xaml.cs#3)]"
  syntax:
    content: public void Unlock ();
    parameters: []
  overload: System.Windows.Interop.D3DImage.Unlock*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Interop.D3DImage.Width
  id: Width
  parent: System.Windows.Interop.D3DImage
  langs:
  - csharp
  name: Width
  nameWithType: D3DImage.Width
  fullName: System.Windows.Interop.D3DImage.Width
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Interop
  summary: "Pobiera szerokość <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>."
  remarks: "Wartość szerokości można zmienić, gdy nowy buforu zapasowego jest przypisany przez wywołanie do <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>metody.</xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>"
  syntax:
    content: public override sealed double Width { get; }
    return:
      type: System.Double
      description: "Szerokość <xref href=&quot;System.Windows.Interop.D3DImage&quot;> </xref>w jednostki pomiaru. Jednostki miary jest 1/96 cala."
  overload: System.Windows.Interop.D3DImage.Width*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.Media.ImageSource
  isExternal: false
  name: System.Windows.Media.ImageSource
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Windows.Interop.D3DImage.#ctor
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: D3DImage()
  nameWithType: D3DImage.D3DImage()
  fullName: System.Windows.Interop.D3DImage.D3DImage()
- uid: System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: D3DImage(Double,Double)
  nameWithType: D3DImage.D3DImage(Double,Double)
  fullName: System.Windows.Interop.D3DImage.D3DImage(Double,Double)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: AddDirtyRect(Int32Rect)
  nameWithType: D3DImage.AddDirtyRect(Int32Rect)
  fullName: System.Windows.Interop.D3DImage.AddDirtyRect(Int32Rect)
- uid: System.Windows.Int32Rect
  parent: System.Windows
  isExternal: false
  name: Int32Rect
  nameWithType: Int32Rect
  fullName: System.Windows.Int32Rect
- uid: System.Windows.Interop.D3DImage.Clone
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Clone()
  nameWithType: D3DImage.Clone()
  fullName: System.Windows.Interop.D3DImage.Clone()
- uid: System.Windows.Interop.D3DImage
  parent: System.Windows.Interop
  isExternal: false
  name: D3DImage
  nameWithType: D3DImage
  fullName: System.Windows.Interop.D3DImage
- uid: System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCore(Freezable)
  nameWithType: D3DImage.CloneCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.CloneCore(Freezable)
- uid: System.Windows.Freezable
  parent: System.Windows
  isExternal: false
  name: Freezable
  nameWithType: Freezable
  fullName: System.Windows.Freezable
- uid: System.Windows.Interop.D3DImage.CloneCurrentValue
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCurrentValue()
  nameWithType: D3DImage.CloneCurrentValue()
  fullName: System.Windows.Interop.D3DImage.CloneCurrentValue()
- uid: System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCurrentValueCore(Freezable)
  nameWithType: D3DImage.CloneCurrentValueCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.CloneCurrentValueCore(Freezable)
- uid: System.Windows.Interop.D3DImage.CopyBackBuffer
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CopyBackBuffer()
  nameWithType: D3DImage.CopyBackBuffer()
  fullName: System.Windows.Interop.D3DImage.CopyBackBuffer()
- uid: System.Windows.Media.Imaging.BitmapSource
  parent: System.Windows.Media.Imaging
  isExternal: false
  name: BitmapSource
  nameWithType: BitmapSource
  fullName: System.Windows.Media.Imaging.BitmapSource
- uid: System.Windows.Interop.D3DImage.CreateInstanceCore
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CreateInstanceCore()
  nameWithType: D3DImage.CreateInstanceCore()
  fullName: System.Windows.Interop.D3DImage.CreateInstanceCore()
- uid: System.Windows.Interop.D3DImage.Finalize
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Finalize()
  nameWithType: D3DImage.Finalize()
  fullName: System.Windows.Interop.D3DImage.Finalize()
- uid: System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: FreezeCore(Boolean)
  nameWithType: D3DImage.FreezeCore(Boolean)
  fullName: System.Windows.Interop.D3DImage.FreezeCore(Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: GetAsFrozenCore(Freezable)
  nameWithType: D3DImage.GetAsFrozenCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.GetAsFrozenCore(Freezable)
- uid: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: GetCurrentValueAsFrozenCore(Freezable)
  nameWithType: D3DImage.GetCurrentValueAsFrozenCore(Freezable)
  fullName: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(Freezable)
- uid: System.Windows.Interop.D3DImage.Height
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Height
  nameWithType: D3DImage.Height
  fullName: System.Windows.Interop.D3DImage.Height
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailable
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: IsFrontBufferAvailable
  nameWithType: D3DImage.IsFrontBufferAvailable
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailable
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: IsFrontBufferAvailableChanged
  nameWithType: D3DImage.IsFrontBufferAvailableChanged
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged
- uid: System.Windows.DependencyPropertyChangedEventHandler
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventHandler
  nameWithType: DependencyPropertyChangedEventHandler
  fullName: System.Windows.DependencyPropertyChangedEventHandler
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: IsFrontBufferAvailableProperty
  nameWithType: D3DImage.IsFrontBufferAvailableProperty
  fullName: System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Windows.Interop.D3DImage.Lock
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Lock()
  nameWithType: D3DImage.Lock()
  fullName: System.Windows.Interop.D3DImage.Lock()
- uid: System.Windows.Interop.D3DImage.Metadata
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Metadata
  nameWithType: D3DImage.Metadata
  fullName: System.Windows.Interop.D3DImage.Metadata
- uid: System.Windows.Media.ImageMetadata
  parent: System.Windows.Media
  isExternal: false
  name: ImageMetadata
  nameWithType: ImageMetadata
  fullName: System.Windows.Media.ImageMetadata
- uid: System.Windows.Interop.D3DImage.PixelHeight
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: PixelHeight
  nameWithType: D3DImage.PixelHeight
  fullName: System.Windows.Interop.D3DImage.PixelHeight
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.Interop.D3DImage.PixelWidth
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: PixelWidth
  nameWithType: D3DImage.PixelWidth
  fullName: System.Windows.Interop.D3DImage.PixelWidth
- uid: System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: SetBackBuffer(D3DResourceType,IntPtr)
  nameWithType: D3DImage.SetBackBuffer(D3DResourceType,IntPtr)
  fullName: System.Windows.Interop.D3DImage.SetBackBuffer(D3DResourceType,IntPtr)
- uid: System.Windows.Interop.D3DResourceType
  parent: System.Windows.Interop
  isExternal: false
  name: D3DResourceType
  nameWithType: D3DResourceType
  fullName: System.Windows.Interop.D3DResourceType
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: SetBackBuffer(D3DResourceType,IntPtr,Boolean)
  nameWithType: D3DImage.SetBackBuffer(D3DResourceType,IntPtr,Boolean)
  fullName: System.Windows.Interop.D3DImage.SetBackBuffer(D3DResourceType,IntPtr,Boolean)
- uid: System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: TryLock(Duration)
  nameWithType: D3DImage.TryLock(Duration)
  fullName: System.Windows.Interop.D3DImage.TryLock(Duration)
- uid: System.Windows.Duration
  parent: System.Windows
  isExternal: false
  name: Duration
  nameWithType: Duration
  fullName: System.Windows.Duration
- uid: System.Windows.Interop.D3DImage.Unlock
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Unlock()
  nameWithType: D3DImage.Unlock()
  fullName: System.Windows.Interop.D3DImage.Unlock()
- uid: System.Windows.Interop.D3DImage.Width
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Width
  nameWithType: D3DImage.Width
  fullName: System.Windows.Interop.D3DImage.Width
- uid: System.Windows.Interop.D3DImage.#ctor*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: D3DImage
  nameWithType: D3DImage.D3DImage
- uid: System.Windows.Interop.D3DImage.AddDirtyRect*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: AddDirtyRect
  nameWithType: D3DImage.AddDirtyRect
- uid: System.Windows.Interop.D3DImage.Clone*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Clone
  nameWithType: D3DImage.Clone
- uid: System.Windows.Interop.D3DImage.CloneCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCore
  nameWithType: D3DImage.CloneCore
- uid: System.Windows.Interop.D3DImage.CloneCurrentValue*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCurrentValue
  nameWithType: D3DImage.CloneCurrentValue
- uid: System.Windows.Interop.D3DImage.CloneCurrentValueCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CloneCurrentValueCore
  nameWithType: D3DImage.CloneCurrentValueCore
- uid: System.Windows.Interop.D3DImage.CopyBackBuffer*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CopyBackBuffer
  nameWithType: D3DImage.CopyBackBuffer
- uid: System.Windows.Interop.D3DImage.CreateInstanceCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: CreateInstanceCore
  nameWithType: D3DImage.CreateInstanceCore
- uid: System.Windows.Interop.D3DImage.Finalize*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Finalize
  nameWithType: D3DImage.Finalize
- uid: System.Windows.Interop.D3DImage.FreezeCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: FreezeCore
  nameWithType: D3DImage.FreezeCore
- uid: System.Windows.Interop.D3DImage.GetAsFrozenCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: GetAsFrozenCore
  nameWithType: D3DImage.GetAsFrozenCore
- uid: System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: GetCurrentValueAsFrozenCore
  nameWithType: D3DImage.GetCurrentValueAsFrozenCore
- uid: System.Windows.Interop.D3DImage.Height*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Height
  nameWithType: D3DImage.Height
- uid: System.Windows.Interop.D3DImage.IsFrontBufferAvailable*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: IsFrontBufferAvailable
  nameWithType: D3DImage.IsFrontBufferAvailable
- uid: System.Windows.Interop.D3DImage.Lock*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Lock
  nameWithType: D3DImage.Lock
- uid: System.Windows.Interop.D3DImage.Metadata*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Metadata
  nameWithType: D3DImage.Metadata
- uid: System.Windows.Interop.D3DImage.PixelHeight*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: PixelHeight
  nameWithType: D3DImage.PixelHeight
- uid: System.Windows.Interop.D3DImage.PixelWidth*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: PixelWidth
  nameWithType: D3DImage.PixelWidth
- uid: System.Windows.Interop.D3DImage.SetBackBuffer*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: SetBackBuffer
  nameWithType: D3DImage.SetBackBuffer
- uid: System.Windows.Interop.D3DImage.TryLock*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: TryLock
  nameWithType: D3DImage.TryLock
- uid: System.Windows.Interop.D3DImage.Unlock*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Unlock
  nameWithType: D3DImage.Unlock
- uid: System.Windows.Interop.D3DImage.Width*
  parent: System.Windows.Interop.D3DImage
  isExternal: false
  name: Width
  nameWithType: D3DImage.Width
