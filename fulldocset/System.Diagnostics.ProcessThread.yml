### YamlMime:ManagedReference
items:
- uid: System.Diagnostics.ProcessThread
  id: ProcessThread
  children:
  - System.Diagnostics.ProcessThread.BasePriority
  - System.Diagnostics.ProcessThread.CurrentPriority
  - System.Diagnostics.ProcessThread.Id
  - System.Diagnostics.ProcessThread.IdealProcessor
  - System.Diagnostics.ProcessThread.PriorityBoostEnabled
  - System.Diagnostics.ProcessThread.PriorityLevel
  - System.Diagnostics.ProcessThread.PrivilegedProcessorTime
  - System.Diagnostics.ProcessThread.ProcessorAffinity
  - System.Diagnostics.ProcessThread.ResetIdealProcessor
  - System.Diagnostics.ProcessThread.StartAddress
  - System.Diagnostics.ProcessThread.StartTime
  - System.Diagnostics.ProcessThread.ThreadState
  - System.Diagnostics.ProcessThread.TotalProcessorTime
  - System.Diagnostics.ProcessThread.UserProcessorTime
  - System.Diagnostics.ProcessThread.WaitReason
  langs:
  - csharp
  name: ProcessThread
  nameWithType: ProcessThread
  fullName: System.Diagnostics.ProcessThread
  type: Class
  summary: "Reprezentuje wątku procesu systemu operacyjnego."
  remarks: "ProcessThread umożliwia uzyskanie informacji o wątku, który jest obecnie uruchomiony w systemie. Umożliwi to można na przykład monitorować charakterystyki wydajności wątku.      > [!IMPORTANT] > Ten typ implementuje <xref:System.IDisposable>interfejsu.</xref:System.IDisposable> Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niego. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A>metody w `try` / `catch` bloku.</xref:System.IDisposable.Dispose%2A> Do usunięcia ich pośrednio, użyj konstrukcji języka takiego jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję &quot;Przy użyciu obiektu który implementuje interfejs IDisposable&quot; w <xref:System.IDisposable>tematu interfejsu.</xref:System.IDisposable>       Wątek jest ścieżką wykonywania za pośrednictwem programu. Jest to najmniejsza jednostka wykonanie, które planuje Win32. Składa się z stosu, stan rejestrów Procesora i wpis na liście wykonywania Harmonogram systemu.       Proces składa się z co najmniej jeden wątek i kod, danych i innych zasobów programu w pamięci. Zasoby typowego programu są otwarte pliki, semaforów i dynamicznej alokacji pamięci. Każdy zasób procesu jest współużytkowana przez wszystkie te wątków procesu.       Program wykonuje się, gdy Harmonogram systemu zapewnia kontrolę wykonywania na jeden z wątków programu. Określa harmonogram wątków, które powinno być ono uruchomione i kiedy. Wątek o niższym priorytecie może wymusić Zaczekaj, aż wątki wyższy priorytet zadania. Na komputerach wieloprocesorowych harmonogram można przenieść poszczególne wątki różnych procesorów, w związku z tym Równoważenie obciążenia Procesora.       Rozpoczyna każdy proces z jednym wątkiem, znany jako podstawowy wątku. Którymkolwiek wątku można utworzyć dodatkowe wątki. Wszystkie wątki w ramach procesu udostępniania przestrzeni adresowej procesu.       Podstawowy wątek nie jest zawsze znajduje się w pierwszym indeksem w kolekcji.      > [!NOTE] > W programie .NET Framework w wersji 2.0, możliwość odwołania licznika wydajności dla wielu właściwości i metod .NET Framework został wyeliminowany danych na innych komputerach. Ta zmiana została wprowadzona, aby zwiększyć wydajność i umożliwić niż administratorzy mogą używać klasy ProcessThread. W związku z tym niektóre aplikacje, które nie pobrały wyjątków we wcześniejszych wersjach programu .NET Framework może teraz zostać <xref:System.NotSupportedException>.</xref:System.NotSupportedException> Zbyt duża, aby wyświetlić w tym miejscu są metody i właściwości, których to dotyczy, ale informacje o wyjątku został dodany do tematów dotyczy elementu członkowskiego.       Wątki tego procesu wykonaj indywidualnie i są zna sobie wzajemnie, chyba że użytkownik stały się widoczne ze sobą. Za pomocą semaforów lub innej metody komunikacji międzyprocesowej wątków, które Udostępnianie wspólnych zasobów, jednak musi koordynować pracę.       Aby uzyskać kolekcję obiektów ProcessThread skojarzony z obecnym procesem, Pobierz <xref:System.Diagnostics.Process.Threads%2A>Właściwość <xref:System.Diagnostics.Process>wystąpienia.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Threads%2A>"
  syntax:
    content: >-
      [System.ComponentModel.Designer("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      public class ProcessThread : System.ComponentModel.Component
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements: []
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Dispose(System.Boolean)
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.BasePriority
  id: BasePriority
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: BasePriority
  nameWithType: ProcessThread.BasePriority
  fullName: System.Diagnostics.ProcessThread.BasePriority
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Pobiera priorytet podstawowy wątku."
  remarks: "BasePriority jest początkowy priorytet wątku procesu. Można przeglądać informacje o priorytet podstawowy licznik priorytet podstawowy Monitor systemu.       System operacyjny oblicza priorytet podstawowy wątku, łącząc zakres poziom priorytetu wątku z klasy priorytetu procesu. Można ustawić procesu <xref:System.Diagnostics.Process.PriorityClass%2A?displayProperty=fullName>właściwości do jednej z wartości w <xref:System.Diagnostics.ProcessPriorityClass>wyliczenia, które są <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, lub <xref:System.Diagnostics.ProcessPriorityClass>.</xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.Process.PriorityClass%2A?displayProperty=fullName> Można ustawić wątku <xref:System.Diagnostics.ProcessThread.PriorityLevel%2A>Właściwości zakresu wartości zakresem priorytet podstawowy wątku.</xref:System.Diagnostics.ProcessThread.PriorityLevel%2A> Win32 używa czterech klasy priorytetów z siedmiu poziomów podstawowy priorytet dla klasy.       Bieżący priorytet wątku mogą różni się od priorytet podstawowy. Na przykład można zmienić system operacyjny <xref:System.Diagnostics.ProcessThread.CurrentPriority%2A>Właściwości na podstawie czasu, jaki upłynął lub innych zwiększenie, gdy proces musi znajdować się przed innymi dostępu do procesora.</xref:System.Diagnostics.ProcessThread.CurrentPriority%2A> Ponadto można ustawić <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>właściwość, aby spowodować, że system tymczasowo zwiększania priorytetu wątku zawsze, gdy proces jest zajęty ze stanu oczekiwania.</xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> Priorytet jest resetowany, gdy proces powróci do stanu oczekiwania."
  syntax:
    content: public int BasePriority { get; }
    return:
      type: System.Int32
      description: "Priorytet podstawowy wątku, który oblicza systemu operacyjnego, łącząc klasy priorytetu procesu z poziom priorytetu wątku skojarzone."
  overload: System.Diagnostics.ProcessThread.BasePriority*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.CurrentPriority
  id: CurrentPriority
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: CurrentPriority
  nameWithType: ProcessThread.CurrentPriority
  fullName: System.Diagnostics.ProcessThread.CurrentPriority
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Pobiera bieżący priorytet wątku."
  remarks: "Bieżący priorytet wątku mogą różni się od priorytet podstawowy. Na przykład systemu operacyjnego można zmienić CurrentPriority właściwości na podstawie czasu, jaki upłynął lub innych zwiększenie, kiedy proces musi znajdować się przed innymi dostępu do procesora. Ponadto można ustawić <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>właściwość, aby spowodować, że system tymczasowo zwiększania priorytetu wątku zawsze, gdy proces jest zajęty ze stanu oczekiwania.</xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> Priorytet jest resetowany, gdy proces powróci do stanu oczekiwania."
  syntax:
    content: public int CurrentPriority { get; }
    return:
      type: System.Int32
      description: "Bieżący priorytet wątku, który może różnić się od priorytet podstawowy oparty na sposób planowania wątku jest system operacyjny. Priorytet może tymczasowo boosted dla aktywnego wątku."
  overload: System.Diagnostics.ProcessThread.CurrentPriority*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.Id
  id: Id
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: Id
  nameWithType: ProcessThread.Id
  fullName: System.Diagnostics.ProcessThread.Id
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Pobiera unikatowy identyfikator wątku."
  remarks: "System operacyjny ponownie używa numery identyfikacyjne wątku, który zidentyfikować wątków tylko podczas ich życia."
  syntax:
    content: public int Id { get; }
    return:
      type: System.Int32
      description: "Unikatowy identyfikator skojarzony z konkretnym wątkiem."
  overload: System.Diagnostics.ProcessThread.Id*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.IdealProcessor
  id: IdealProcessor
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: IdealProcessor
  nameWithType: ProcessThread.IdealProcessor
  fullName: System.Diagnostics.ProcessThread.IdealProcessor
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ustawia preferowany procesora dla tego wątku do uruchamiania na."
  remarks: "Wartość IdealProcessor jest liczony od zera.  Innymi słowy koligacji wątków dla pierwszego procesora, ustawia właściwość na wartość zero.       System planuje wątków na ich preferowanego procesorów, jeśli to możliwe.       Wątek procesu można migrować z procesora do procesora, za pomocą każdej migracji ponownego ładowania pamięci podręcznej procesora. Określanie procesora dla wątku umożliwiają poprawę wydajności pod obciążeniem duże systemu dzięki zmniejszeniu liczby powtórzeń załadowaniu pamięci podręcznej procesora."
  example:
  - "The following example demonstrates how to set the IdealProcessor property for an instance of Notepad to the first processor.  \n  \n [!code-vb[ProcessThreadIdealProcessor#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_25_1.vb)]\n [!code-cs[ProcessThreadIdealProcessor#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_25_1.cs)]"
  syntax:
    content: public int IdealProcessor { set; }
    return:
      type: System.Int32
      description: "Preferowany procesora dla wątku używany, gdy system planuje wątków, aby określić, który procesor do uruchomienia na wątek."
  overload: System.Diagnostics.ProcessThread.IdealProcessor*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "System nie może ustawić wątku do uruchomienia w określonym procesorem."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Platforma to Windows 98 lub Windows Millennium Edition."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Proces odbywa się na komputerze zdalnym."
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.PriorityBoostEnabled
  id: PriorityBoostEnabled
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: PriorityBoostEnabled
  nameWithType: ProcessThread.PriorityBoostEnabled
  fullName: System.Diagnostics.ProcessThread.PriorityBoostEnabled
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Pobiera lub ustawia wartość wskazującą, czy system operacyjny tymczasowo powinien zwiększania priorytetu wątku skojarzone zawsze, gdy fokus głównego okna procesu wątku."
  remarks: "Gdy jest PriorityBoostEnabled `true`, gdy jego skojarzony proces jest zajęty ze stanu oczekiwania system tymczasowo zwiększa priorytet wątku. Ta akcja uniemożliwia inne procesy przerywania przetwarzania bieżącego wątku. Ustawienie PriorityBoostEnabled ma wpływ na wszystkie wątki istniejących, a także wszystkie wątki następnie utworzone przez proces. Aby przywrócić normalne działanie, należy ustawić <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>właściwości `false`.</xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>       PriorityBoostEnabled przynosi efekty tylko wtedy, gdy wątek jest uruchomiony w ramach procesu, który ma <xref:System.Diagnostics.Process.PriorityClass%2A>ustawić jedną z wartości wyliczenia priorytet dynamiczny (<xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, lub <xref:System.Diagnostics.ProcessPriorityClass>).</xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.Process.PriorityClass%2A>      > [!NOTE] > Zwiększania zbyt wysoki priorytet może opróżnienia zasobów z podstawowych systemu operacyjnego i funkcji sieciowych. Może to spowodować problemy z innych zadań systemu operacyjnego."
  syntax:
    content: public bool PriorityBoostEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>do zwiększania priorytetu wątku, gdy użytkownik wchodzi w interakcję z procesem przez interfejs; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Wartość domyślna to <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessThread.PriorityBoostEnabled*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Nie można pobrać informacji o priorytecie zwiększanie wyniku.       - lub - nie można ustawić priorytet informacji zwiększanie wyniku."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Platforma to Windows 98 lub Windows Millennium Edition."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Proces odbywa się na komputerze zdalnym."
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.PriorityLevel
  id: PriorityLevel
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: PriorityLevel
  nameWithType: ProcessThread.PriorityLevel
  fullName: System.Diagnostics.ProcessThread.PriorityLevel
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Pobiera lub ustawia poziom priorytetu wątku."
  remarks: "Poziom priorytetu nie jest pojedynczą wartość, ale raczej zakresu wartości. System operacyjny oblicza priorytet podstawowy wątku przy użyciu procesu <xref:System.Diagnostics.Process.PriorityClass%2A>wybrać wartość z zakresu określonego we właściwości PriorityLevel.</xref:System.Diagnostics.Process.PriorityClass%2A>"
  syntax:
    content: public System.Diagnostics.ThreadPriorityLevel PriorityLevel { get; set; }
    return:
      type: System.Diagnostics.ThreadPriorityLevel
      description: "Jeden z <xref href=&quot;System.Diagnostics.ThreadPriorityLevel&quot;> </xref> wartości określenie zakresu, który zakresem priorytetu wątku."
  overload: System.Diagnostics.ProcessThread.PriorityLevel*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Nie można pobrać informacji o poziom priorytetu wątku.       - lub - nie można ustawić poziom priorytetu wątku."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Platforma to Windows 98 lub Windows Millennium Edition."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Proces odbywa się na komputerze zdalnym."
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.PrivilegedProcessorTime
  id: PrivilegedProcessorTime
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: PrivilegedProcessorTime
  nameWithType: ProcessThread.PrivilegedProcessorTime
  fullName: System.Diagnostics.ProcessThread.PrivilegedProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Pobiera czas spędzony wątek kodu wewnątrz rdzenia systemu operacyjnego."
  remarks: "System Windows używa kilku różne mechanizmy ochrony i w katalogu głównym wszystkich jest różnica między tryb użytkownika i w trybie uprzywilejowanym. PrivilegedProcessorTime odpowiada ilość czasu spędzony aplikacji działających w trybie uprzywilejowanym wewnątrz rdzenia systemu operacyjnego. <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A>Właściwość wskazuje czas spędzony aplikacji kodu w trybie użytkownika, poza rdzeniem systemu.</xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A>       Tryb użytkownika ogranicza aplikację na dwa sposoby ważne. Najpierw aplikacji nie może bezpośrednio uzyskać dostępu do urządzenia peryferyjne, ale zamiast tego należy wywołać rdzeniem systemu operacyjnego można pobrać lub ustawić peryferyjne danych. System operacyjny w związku z tym zapewnia jedną aplikację zniszczy peryferyjne danych, który jest wymagany przez inny. Po drugie aplikacja nie może odczytać lub zmień dane, które przechowuje sam system operacyjny. To ograniczenie uniemożliwia aplikacji przypadkowo lub celowo uszkodzenia podstawowego. Jeśli aplikacja wymaga systemu operacyjnego, można wykonać operacji, wywołuje jedną z procedur systemu. Wiele z tych przejścia w trybie uprzywilejowanym wykonania tej operacji, a sprawnie wrócisz do trybu użytkownika."
  syntax:
    content: public TimeSpan PrivilegedProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "A <xref:System.TimeSpan>wskazująca czas spędzony wątek kodu wewnątrz rdzenia systemu operacyjnego.</xref:System.TimeSpan>"
  overload: System.Diagnostics.ProcessThread.PrivilegedProcessorTime*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Nie można pobrać czasu wątku."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Platforma to Windows 98 lub Windows Millennium Edition."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Proces odbywa się na komputerze zdalnym."
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.ProcessorAffinity
  id: ProcessorAffinity
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: ProcessorAffinity
  nameWithType: ProcessThread.ProcessorAffinity
  fullName: System.Diagnostics.ProcessThread.ProcessorAffinity
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Ustawia procesory, na których można uruchomić wątku skojarzone."
  remarks: "Koligacja procesorów wątku jest zestaw procesorów, które ma ona relację. Innymi słowy te, które mogą być planowane na.       ProcessorAffinity reprezentuje jako nieco każdego procesora. Bit 0 oznacza procesora, co, bit 1 oznacza procesora dwa i tak dalej. W poniższej tabeli przedstawiono podzestaw możliwości ProcessorAffinity systemu czteroprocesorowym.      | Wartość właściwości (w formacie szesnastkowym) | Nieprawidłowa procesorów |   |---------------------------------------|----------------------|   | 0x0001 | 1 |   | 0x0002 | 2 |   | 0x0003 | 1 lub 2 |   | 0x0004 | 3 |   | 0x0005 | 1 lub 3 |   | 0x0007 | 1, 2 lub 3 |   | 0x000F | 1, 2, 3 lub 4 |       Można również określić pojedynczy, preferowane procesor do wątku przez ustawienie <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A>Właściwości.</xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> Wątek procesu można migrować z procesora do procesora, za pomocą każdej migracji ponownego ładowania pamięci podręcznej procesora. Określanie procesora dla wątku umożliwiają poprawę wydajności pod obciążeniem duże systemu dzięki zmniejszeniu liczby powtórzeń załadowaniu pamięci podręcznej procesora."
  example:
  - "The following example shows how to set the ProcessorAffinity property for an instance of Notepad to the first processor.  \n  \n [!code-vb[ProcessThreadIdealProcessor#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_22_1.vb)]\n [!code-cs[ProcessThreadIdealProcessor#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_22_1.cs)]"
  syntax:
    content: public IntPtr ProcessorAffinity { set; }
    return:
      type: System.IntPtr
      description: "<xref:System.IntPtr>Zestawu usługi bits, z których każdy reprezentuje procesor, które można uruchomić wątku, na który wskazuje.</xref:System.IntPtr>"
  overload: System.Diagnostics.ProcessThread.ProcessorAffinity*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Nie można ustawić koligacji procesora."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Platforma to Windows 98 lub Windows Millennium Edition."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Proces odbywa się na komputerze zdalnym."
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.ResetIdealProcessor
  id: ResetIdealProcessor
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: ResetIdealProcessor()
  nameWithType: ProcessThread.ResetIdealProcessor()
  fullName: System.Diagnostics.ProcessThread.ResetIdealProcessor()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Resetuje idealne procesora dla tego wątku do wskazywania nie pojedynczy procesor idealne. Innymi słowy, aby doskonale dowolnego procesora."
  syntax:
    content: public void ResetIdealProcessor ();
    parameters: []
  overload: System.Diagnostics.ProcessThread.ResetIdealProcessor*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Nie można zresetować idealne procesora."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Platforma to Windows 98 lub Windows Millennium Edition."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Proces odbywa się na komputerze zdalnym."
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.StartAddress
  id: StartAddress
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: StartAddress
  nameWithType: ProcessThread.StartAddress
  fullName: System.Diagnostics.ProcessThread.StartAddress
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Pobiera adres pamięci funkcji, która wywołuje systemu operacyjnego i rozpoczęcia tego wątku."
  remarks: "Rozpoczyna każdy proces z jednym wątkiem, znany jako podstawowy wątku. Którymkolwiek wątku można utworzyć dodatkowe wątki.       Proces ma wirtualnej przestrzeni adresowej, kodu wykonywalnego, danych, uchwytami, zmienne środowiskowe, priorytet podstawowy i minimalna i maksymalny rozmiar zestawu roboczego. Wszystkie wątki tego procesu udostępniania zasobów systemu i miejsca jego wirtualnego adresu. Ponadto każdy wątek zapewnia obsługę wyjątków, priorytetu planowania i zestaw struktur, w których system zapisuje kontekst wątku, gdy wątek oczekuje do zaplanowania. Kontekst wątku zawiera zestaw wątku rejestrów maszyny, stosu jądra blok środowiska wątku i stosu użytkownika w przestrzeni adresowej procesu wątku.       Każdy wątek Windows faktycznie rozpoczyna wykonanie w funkcji dostarczanych przez system, nie funkcja dostarczone przez aplikację. Początkowy adres podstawowy wątku jest, w związku z tym takie same (ponieważ reprezentuje on adresu funkcji dostarczanych przez system) dla każdego procesu systemu Windows w systemie. Jednak Właściwość StartAddress pozwala uzyskać początkowy adres funkcja, która jest specyficzna dla aplikacji."
  syntax:
    content: public IntPtr StartAddress { get; }
    return:
      type: System.IntPtr
      description: "Wątku początkowy adres, który wskazuje wykonujący wątku funkcji zdefiniowanych przez aplikację."
  overload: System.Diagnostics.ProcessThread.StartAddress*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Platforma to Windows 98 lub Windows Millennium Edition."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Proces odbywa się na komputerze zdalnym."
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.StartTime
  id: StartTime
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: StartTime
  nameWithType: ProcessThread.StartTime
  fullName: System.Diagnostics.ProcessThread.StartTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Pobiera czas uruchomienia wątku systemu operacyjnego."
  syntax:
    content: public DateTime StartTime { get; }
    return:
      type: System.DateTime
      description: "A <xref:System.DateTime>reprezentującą godzinę, który był w systemie, gdy system operacyjny uruchomiony wątek.</xref:System.DateTime>"
  overload: System.Diagnostics.ProcessThread.StartTime*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Nie można pobrać czasu wątku."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Platforma to Windows 98 lub Windows Millennium Edition."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Proces odbywa się na komputerze zdalnym."
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.ThreadState
  id: ThreadState
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: ThreadState
  nameWithType: ProcessThread.ThreadState
  fullName: System.Diagnostics.ProcessThread.ThreadState
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Pobiera bieżący stan tego wątku."
  remarks: "<xref:System.Diagnostics.ProcessThread.WaitReason%2A>Wartość właściwości jest prawidłowa tylko wtedy, gdy wartość ThreadState <xref:System.Diagnostics.ThreadState>.</xref:System.Diagnostics.ThreadState> </xref:System.Diagnostics.ProcessThread.WaitReason%2A> W związku z tym Sprawdź wartość ThreadState, zanim będzie można pobrać <xref:System.Diagnostics.ProcessThread.WaitReason%2A>Właściwości.</xref:System.Diagnostics.ProcessThread.WaitReason%2A>"
  syntax:
    content: public System.Diagnostics.ThreadState ThreadState { get; }
    return:
      type: System.Diagnostics.ThreadState
      description: "A <xref href=&quot;System.Diagnostics.ThreadState&quot;> </xref> wskazujące wykonanie wątku, na przykład uruchomiony Oczekiwanie lub został zakończony."
  overload: System.Diagnostics.ProcessThread.ThreadState*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Platforma to Windows 98 lub Windows Millennium Edition."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Proces odbywa się na komputerze zdalnym."
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.TotalProcessorTime
  id: TotalProcessorTime
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: TotalProcessorTime
  nameWithType: ProcessThread.TotalProcessorTime
  fullName: System.Diagnostics.ProcessThread.TotalProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Pobiera całkowitą ilość czasu spędzony tego wątku przy użyciu procesora."
  remarks: "Właściwość TotalProcessorTime wskazuje łączny czas trwania, że system ma podjąć ze stanu oczekiwania wątku i priorytet go na dowolnego procesora. W wielu systemach procesora ta wartość obejmuje czas spędzony na każdy procesor wątek użycie więcej niż jeden procesor.       Właściwość TotalProcessorTime jest sumą <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A>i <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A>Właściwości.</xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> </xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A>"
  syntax:
    content: public TimeSpan TotalProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "A <xref:System.TimeSpan>wskazująca czas były wątek kontroli procesora.</xref:System.TimeSpan>"
  overload: System.Diagnostics.ProcessThread.TotalProcessorTime*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Nie można pobrać czasu wątku."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Platforma to Windows 98 lub Windows Millennium Edition."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Proces odbywa się na komputerze zdalnym."
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.UserProcessorTime
  id: UserProcessorTime
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: UserProcessorTime
  nameWithType: ProcessThread.UserProcessorTime
  fullName: System.Diagnostics.ProcessThread.UserProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Pobiera czas spędzony skojarzone wątku kodu wewnątrz aplikacji."
  remarks: "Windows NT używa kilku różne mechanizmy ochrony i w katalogu głównym wszystkich jest różnica między tryb użytkownika i w trybie uprzywilejowanym. UserProcessorTime odpowiada ilość czasu spędzony aplikacji działających w trybie użytkownika, poza rdzeniem systemu operacyjnego. <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A>Odpowiada czas spędzony aplikacji uruchamianie kodu w trybie uprzywilejowanym wewnątrz rdzenia systemu.</xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A>       Tryb użytkownika ogranicza aplikację na dwa sposoby ważne. Najpierw aplikacji nie może bezpośrednio uzyskać dostępu do urządzenia peryferyjne, ale zamiast tego należy wywołać rdzeniem systemu operacyjnego można pobrać lub ustawić peryferyjne danych. System operacyjny w związku z tym zapewnia jedną aplikację zniszczy peryferyjne danych, który jest wymagany przez inny. Po drugie aplikacja nie może odczytać lub zmień dane, które przechowuje sam system operacyjny. To ograniczenie uniemożliwia aplikacji przypadkowo lub celowo uszkodzenia podstawowego. Jeśli aplikacja wymaga systemu operacyjnego, można wykonać operacji, wywołuje jedną z procedur systemu. Wiele z tych przejścia w trybie uprzywilejowanym wykonania tej operacji, a sprawnie wrócisz do trybu użytkownika."
  syntax:
    content: public TimeSpan UserProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "A <xref:System.TimeSpan>wskazująca czas spędzony wątek uruchamianie kodu w aplikacji, w przeciwieństwie do wewnątrz rdzenia systemu operacyjnego.</xref:System.TimeSpan>"
  overload: System.Diagnostics.ProcessThread.UserProcessorTime*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Nie można pobrać czasu wątku."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Platforma to Windows 98 lub Windows Millennium Edition."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Proces odbywa się na komputerze zdalnym."
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.WaitReason
  id: WaitReason
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: WaitReason
  nameWithType: ProcessThread.WaitReason
  fullName: System.Diagnostics.ProcessThread.WaitReason
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Pobiera Przyczyna oczekiwania wątku."
  remarks: "Właściwość WaitReason jest prawidłowy tylko wtedy, gdy <xref:System.Diagnostics.ProcessThread.ThreadState%2A>jest <xref:System.Diagnostics.ThreadState>.</xref:System.Diagnostics.ThreadState> </xref:System.Diagnostics.ProcessThread.ThreadState%2A> Sprawdź, w związku z tym <xref:System.Diagnostics.ProcessThread.ThreadState%2A>wartość, zanim będzie można pobrać właściwości WaitReason.</xref:System.Diagnostics.ProcessThread.ThreadState%2A>"
  syntax:
    content: public System.Diagnostics.ThreadWaitReason WaitReason { get; }
    return:
      type: System.Diagnostics.ThreadWaitReason
      description: "A <xref href=&quot;System.Diagnostics.ThreadWaitReason&quot;> </xref> reprezentujący powód wątek znajduje się w stanie oczekiwania."
  overload: System.Diagnostics.ProcessThread.WaitReason*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Wątek nie jest w stanie oczekiwania."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Platforma to Windows 98 lub Windows Millennium Edition."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Proces odbywa się na komputerze zdalnym."
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.ComponentModel.Win32Exception
  parent: System.ComponentModel
  isExternal: false
  name: Win32Exception
  nameWithType: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Diagnostics.ProcessThread.BasePriority
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: BasePriority
  nameWithType: ProcessThread.BasePriority
  fullName: System.Diagnostics.ProcessThread.BasePriority
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Diagnostics.ProcessThread.CurrentPriority
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: CurrentPriority
  nameWithType: ProcessThread.CurrentPriority
  fullName: System.Diagnostics.ProcessThread.CurrentPriority
- uid: System.Diagnostics.ProcessThread.Id
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: Id
  nameWithType: ProcessThread.Id
  fullName: System.Diagnostics.ProcessThread.Id
- uid: System.Diagnostics.ProcessThread.IdealProcessor
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: IdealProcessor
  nameWithType: ProcessThread.IdealProcessor
  fullName: System.Diagnostics.ProcessThread.IdealProcessor
- uid: System.Diagnostics.ProcessThread.PriorityBoostEnabled
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: PriorityBoostEnabled
  nameWithType: ProcessThread.PriorityBoostEnabled
  fullName: System.Diagnostics.ProcessThread.PriorityBoostEnabled
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Diagnostics.ProcessThread.PriorityLevel
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: PriorityLevel
  nameWithType: ProcessThread.PriorityLevel
  fullName: System.Diagnostics.ProcessThread.PriorityLevel
- uid: System.Diagnostics.ThreadPriorityLevel
  parent: System.Diagnostics
  isExternal: false
  name: ThreadPriorityLevel
  nameWithType: ThreadPriorityLevel
  fullName: System.Diagnostics.ThreadPriorityLevel
- uid: System.Diagnostics.ProcessThread.PrivilegedProcessorTime
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: PrivilegedProcessorTime
  nameWithType: ProcessThread.PrivilegedProcessorTime
  fullName: System.Diagnostics.ProcessThread.PrivilegedProcessorTime
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Diagnostics.ProcessThread.ProcessorAffinity
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: ProcessorAffinity
  nameWithType: ProcessThread.ProcessorAffinity
  fullName: System.Diagnostics.ProcessThread.ProcessorAffinity
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Diagnostics.ProcessThread.ResetIdealProcessor
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: ResetIdealProcessor()
  nameWithType: ProcessThread.ResetIdealProcessor()
  fullName: System.Diagnostics.ProcessThread.ResetIdealProcessor()
- uid: System.Diagnostics.ProcessThread.StartAddress
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: StartAddress
  nameWithType: ProcessThread.StartAddress
  fullName: System.Diagnostics.ProcessThread.StartAddress
- uid: System.Diagnostics.ProcessThread.StartTime
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: StartTime
  nameWithType: ProcessThread.StartTime
  fullName: System.Diagnostics.ProcessThread.StartTime
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: System.Diagnostics.ProcessThread.ThreadState
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: ThreadState
  nameWithType: ProcessThread.ThreadState
  fullName: System.Diagnostics.ProcessThread.ThreadState
- uid: System.Diagnostics.ThreadState
  parent: System.Diagnostics
  isExternal: false
  name: ThreadState
  nameWithType: ThreadState
  fullName: System.Diagnostics.ThreadState
- uid: System.Diagnostics.ProcessThread.TotalProcessorTime
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: TotalProcessorTime
  nameWithType: ProcessThread.TotalProcessorTime
  fullName: System.Diagnostics.ProcessThread.TotalProcessorTime
- uid: System.Diagnostics.ProcessThread.UserProcessorTime
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: UserProcessorTime
  nameWithType: ProcessThread.UserProcessorTime
  fullName: System.Diagnostics.ProcessThread.UserProcessorTime
- uid: System.Diagnostics.ProcessThread.WaitReason
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: WaitReason
  nameWithType: ProcessThread.WaitReason
  fullName: System.Diagnostics.ProcessThread.WaitReason
- uid: System.Diagnostics.ThreadWaitReason
  parent: System.Diagnostics
  isExternal: false
  name: ThreadWaitReason
  nameWithType: ThreadWaitReason
  fullName: System.Diagnostics.ThreadWaitReason
- uid: System.Diagnostics.ProcessThread.BasePriority*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: BasePriority
  nameWithType: ProcessThread.BasePriority
- uid: System.Diagnostics.ProcessThread.CurrentPriority*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: CurrentPriority
  nameWithType: ProcessThread.CurrentPriority
- uid: System.Diagnostics.ProcessThread.Id*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: Id
  nameWithType: ProcessThread.Id
- uid: System.Diagnostics.ProcessThread.IdealProcessor*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: IdealProcessor
  nameWithType: ProcessThread.IdealProcessor
- uid: System.Diagnostics.ProcessThread.PriorityBoostEnabled*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: PriorityBoostEnabled
  nameWithType: ProcessThread.PriorityBoostEnabled
- uid: System.Diagnostics.ProcessThread.PriorityLevel*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: PriorityLevel
  nameWithType: ProcessThread.PriorityLevel
- uid: System.Diagnostics.ProcessThread.PrivilegedProcessorTime*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: PrivilegedProcessorTime
  nameWithType: ProcessThread.PrivilegedProcessorTime
- uid: System.Diagnostics.ProcessThread.ProcessorAffinity*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: ProcessorAffinity
  nameWithType: ProcessThread.ProcessorAffinity
- uid: System.Diagnostics.ProcessThread.ResetIdealProcessor*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: ResetIdealProcessor
  nameWithType: ProcessThread.ResetIdealProcessor
- uid: System.Diagnostics.ProcessThread.StartAddress*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: StartAddress
  nameWithType: ProcessThread.StartAddress
- uid: System.Diagnostics.ProcessThread.StartTime*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: StartTime
  nameWithType: ProcessThread.StartTime
- uid: System.Diagnostics.ProcessThread.ThreadState*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: ThreadState
  nameWithType: ProcessThread.ThreadState
- uid: System.Diagnostics.ProcessThread.TotalProcessorTime*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: TotalProcessorTime
  nameWithType: ProcessThread.TotalProcessorTime
- uid: System.Diagnostics.ProcessThread.UserProcessorTime*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: UserProcessorTime
  nameWithType: ProcessThread.UserProcessorTime
- uid: System.Diagnostics.ProcessThread.WaitReason*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: WaitReason
  nameWithType: ProcessThread.WaitReason
