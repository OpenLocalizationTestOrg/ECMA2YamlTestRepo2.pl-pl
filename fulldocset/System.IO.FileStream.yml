### YamlMime:ManagedReference
items:
- uid: System.IO.FileStream
  id: FileStream
  children:
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  - System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.FileStream.CanRead
  - System.IO.FileStream.CanSeek
  - System.IO.FileStream.CanWrite
  - System.IO.FileStream.Dispose(System.Boolean)
  - System.IO.FileStream.EndRead(System.IAsyncResult)
  - System.IO.FileStream.EndWrite(System.IAsyncResult)
  - System.IO.FileStream.Finalize
  - System.IO.FileStream.Flush
  - System.IO.FileStream.Flush(System.Boolean)
  - System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  - System.IO.FileStream.GetAccessControl
  - System.IO.FileStream.Handle
  - System.IO.FileStream.IsAsync
  - System.IO.FileStream.Length
  - System.IO.FileStream.Lock(System.Int64,System.Int64)
  - System.IO.FileStream.Name
  - System.IO.FileStream.Position
  - System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.FileStream.ReadByte
  - System.IO.FileStream.SafeFileHandle
  - System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  - System.IO.FileStream.SetLength(System.Int64)
  - System.IO.FileStream.Unlock(System.Int64,System.Int64)
  - System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.FileStream.WriteByte(System.Byte)
  langs:
  - csharp
  name: FileStream
  nameWithType: FileStream
  fullName: System.IO.FileStream
  type: Class
  summary: "Udostępnia <xref:System.IO.Stream>dla pliku, obsługa synchroniczne i asynchroniczne operacje odczytu i zapisu.</xref:System.IO.Stream>       Aby przejrzeć kod źródłowy .NET Framework dla tego typu, zobacz [źródło odwołania](http://referencesource.microsoft.com/#mscorlib/system/io/filestream.cs#e23a38af5d11ddd3)."
  remarks: "> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/io/filestream.cs#e23a38af5d11ddd3). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n Use the FileStream class to read from, write to, open, and close files on a file system, and to manipulate other file-related operating system handles, including pipes, standard input, and standard output. You can use the [Read(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True), [Write(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True), <xref:System.IO.Stream.CopyTo%2A>, and <xref:System.IO.FileStream.Flush%2A> methods to perform synchronous operations, or the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.FileStream.FlushAsync%2A> methods to perform asynchronous operations. Use the asynchronous methods to perform resource-intensive file operations without blocking the main thread. This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working. FileStream buffers input and output for better performance.  \n  \n> [!IMPORTANT]\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n The <xref:System.IO.FileStream.IsAsync%2A> property detects whether the file handle was opened asynchronously. You specify this value when you create an instance of the FileStream class using a constructor that has an `isAsync`, `useAsync`, or `options` parameter. When the property is `true`, the stream utilizes overlapped I/O to perform file operations asynchronously. However, the <xref:System.IO.FileStream.IsAsync%2A> property does not have to be `true` to call the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, or <xref:System.IO.Stream.CopyToAsync%2A> method. When the <xref:System.IO.FileStream.IsAsync%2A> property is `false` and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.  \n  \n The <xref:System.IO.FileStream.Seek%2A> method supports random access to files. <xref:System.IO.FileStream.Seek%2A> allows the read/write position to be moved to any position within the file. This is done with byte offset reference point parameters. The byte offset is relative to the seek reference point, which can be the beginning, the current position, or the end of the underlying file, as represented by the three members of the <xref:System.IO.SeekOrigin> enumeration.  \n  \n> [!NOTE]\n>  Disk files always support random access. At the time of construction, the <xref:System.IO.FileStream.CanSeek%2A> property value is set to `true` or `false` depending on the underlying file type.If the underlying file type is FILE_TYPE_DISK, as defined in winbase.h, the <xref:System.IO.FileStream.CanSeek%2A> property value is `true`. Otherwise, the <xref:System.IO.FileStream.CanSeek%2A> property value is `false`.  \n  \n If a process terminates with part of a file locked or closes a file that has outstanding locks, the behavior is undefined.  \n  \n For directory operations and other file operations, see the <xref:System.IO.File>, <xref:System.IO.Directory>, and <xref:System.IO.Path> classes. The <xref:System.IO.File> class is a utility class that has static methods primarily for the creation of FileStream objects based on file paths. The <xref:System.IO.MemoryStream> class creates a stream from a byte array and is similar to the FileStream class.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md).  \n  \n## Detection of Stream Position Changes  \n When a FileStream object does not have an exclusive hold on its handle, another thread could access the file handle concurrently and change the position of the operating system's file pointer that is associated with the file handle. In this case, the cached position in the FileStream object and the cached data in the buffer could be compromised. The FileStream object routinely performs checks on methods that access the cached buffer to ensure that the operating system's handle position is the same as the cached position used by the FileStream object.  \n  \n If an unexpected change in the handle position is detected in a call to the <xref:System.IO.FileStream.Read%2A> method, the .NET Framework discards the contents of the buffer and reads the stream from the file again. This can affect performance, depending on the size of the file and any other processes that could affect the position of the file stream.  \n  \n If an unexpected change in the handle position is detected in a call to the <xref:System.IO.FileStream.Write%2A> method, the contents of the buffer are discarded and an <xref:System.IO.IOException> exception is thrown.  \n  \n A FileStream object will not have an exclusive hold on its handle when either the <xref:System.IO.FileStream.SafeFileHandle%2A> property is accessed to expose the handle or the FileStream object is given the <xref:System.IO.FileStream.SafeFileHandle%2A> property in its constructor."
  example:
  - "The following example demonstrates some of the FileStream constructors.  \n  \n [!code-cs[fstream class#1](~/add/codesnippet/csharp/t-system.io.filestream_1.cs)]\n [!code-vb[fstream class#1](~/add/codesnippet/visualbasic/t-system.io.filestream_1.vb)]\n [!code-cpp[fstream class#1](~/add/codesnippet/cpp/t-system.io.filestream_1.cpp)]  \n  \n The following example shows how to write to a file asynchronously. This code runs in a WPF app that has a TextBlock named UserInput and a button hooked up to a Click event handler that is named Button_Click. The file path needs to be changed to a file than exits on the computer.  \n  \n [!code-vb[Asynchronous_File_IO_async#3](~/add/codesnippet/visualbasic/t-system.io.filestream_2.vb)]\n [!code-cs[Asynchronous_File_IO_async#3](~/add/codesnippet/csharp/t-system.io.filestream_2.cs)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public class FileStream : System.IO.Stream
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.FileStream&quot;> </xref> klasy dla określone dojście do pliku, z uprawnieniami do odczytu/zapisu w określonym."
  remarks: "Gdy <xref:System.IO.Stream.Close%2A>jest wywoływana, dojście jest również zamknięte, a liczba dojście do pliku jest zmniejszany.</xref:System.IO.Stream.Close%2A>       `FileStream`przyjęto założenie, że ma on wyłączną kontrolę nad dojście. Odczytywanie, pisania lub wyszukiwania podczas `FileStream` również wstrzymał dojścia może doprowadzić do uszkodzenia danych. Dla bezpieczeństwa danych, należy wywołać <xref:System.IO.FileStream.Flush%2A>przed przy użyciu dojścia i unikaj wywoływania żadnych metod innych niż `Close` po zakończeniu pracy przy użyciu dojścia.</xref:System.IO.FileStream.Flush%2A>      > [!CAUTION] > Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.       `FileShare.Read`Wartość domyślna to tych <xref:System.IO.FileStream>konstruktorów bez `FileShare` parametru.</xref:System.IO.FileStream>       Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "Dojście do pliku dla pliku który bieżącego <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> będzie Hermetyzowanie obiektu."
    - id: access
      type: System.IO.FileAccess
      description: "Stała, która ustawia <> </> *> i <> </> *> właściwości <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> obiektu."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>nie jest polem z <xref href=&quot;System.IO.FileAccess&quot;> </xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Obiekt wywołujący nie ma wymaganych uprawnień."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy, takich jak awaria dysku.       - lub - strumień został zamknięty."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Żądanie nie jest dozwolona przez system operacyjny określone dojście do pliku, takie jak kiedy <code> access </code> jest <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> lub <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> i dojście do pliku jest ustawiony na dostęp tylko do odczytu."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  id: '#ctor(System.IntPtr,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.FileStream&quot;> </xref> klasy dla określone dojście do pliku, z uprawnieniami do odczytu/zapisu w określonym."
  remarks: "Gdy <xref:System.IO.Stream.Close%2A>jest wywoływana, dojście jest również zamknięte, a liczba dojście do pliku jest zmniejszany.</xref:System.IO.Stream.Close%2A>       `FileStream`przyjęto założenie, że ma on wyłączną kontrolę nad dojście. Odczytywanie, pisania lub wyszukiwania podczas `FileStream` również wstrzymał dojścia może doprowadzić do uszkodzenia danych. Dla bezpieczeństwa danych, należy wywołać <xref:System.IO.FileStream.Flush%2A>przed przy użyciu dojścia i unikaj wywoływania żadnych metod innych niż `Close` po zakończeniu pracy przy użyciu dojścia.</xref:System.IO.FileStream.Flush%2A>      > [!CAUTION] > Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.       `FileShare.Read`Wartość domyślna to tych <xref:System.IO.FileStream>konstruktorów bez `FileShare` parametru.</xref:System.IO.FileStream>       Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "Dojście do pliku dla pliku który bieżącego <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> będzie Hermetyzowanie obiektu."
    - id: access
      type: System.IO.FileAccess
      description: "Stała, która ustawia <> </> *> i <> </> *> właściwości <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> obiektu."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>nie jest polem z <xref href=&quot;System.IO.FileAccess&quot;> </xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Obiekt wywołujący nie ma wymaganych uprawnień."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy, takich jak awaria dysku.       - lub - strumień został zamknięty."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Żądanie nie jest dozwolona przez system operacyjny określone dojście do pliku, takie jak kiedy <code> access </code> jest <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> lub <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> i dojście do pliku jest ustawiony na dostęp tylko do odczytu."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  id: '#ctor(System.String,System.IO.FileMode)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode)
  nameWithType: FileStream.FileStream(String,FileMode)
  fullName: System.IO.FileStream.FileStream(String,FileMode)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.FileStream&quot;> </xref> klasy z określonym trybem ścieżkę i tworzenia."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed).  \n  \n You cannot use this constructor to open read-only files; instead, you must use a constructor that accepts a `FileAccess` parameter with the value set to `FileAccess.Read`.  \n  \n The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n `FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.  \n  \n For constructors without a <xref:System.IO.FileAccess> parameter, if the `mode` parameter is set to <xref:System.IO.FileMode>, <xref:System.IO.FileAccess> is the default access. Otherwise, the access is set to <xref:System.IO.FileAccess>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.s_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.s_0_1.cpp)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode);
    parameters:
    - id: path
      type: System.String
      description: "Względna lub bezwzględna ścieżka do pliku który bieżącego <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> będzie Hermetyzowanie obiektu."
    - id: mode
      type: System.IO.FileMode
      description: "Stała, która określa sposób otwarcia lub utworzenia pliku."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>to ciąg pusty (&quot;&quot;), zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków.       - lub - <code>path</code> odwołuje się do urządzenia z systemem innym niż plik, takich jak &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. w środowisku systemu plików NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>odwołuje się do urządzenia z systemem innym niż plik, takich jak &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. w środowisku z systemem innym niż NTFS."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Obiekt wywołujący nie ma wymaganych uprawnień."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Nie można odnaleźć pliku, takie jak kiedy <code> mode </code> jest <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> lub <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>, a plik określony przez <code> path </code> nie istnieje. Plik musi już istnieć w tych trybach."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy, takich jak określanie <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> gdy plik określony przez <code> path </code> już istnieje, wystąpił.       - lub - strumień został zamknięty."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Określona ścieżka i nazwa pliku przekracza maksymalną długość zdefiniowana w systemie. Na przykład na platformach opartych na systemie Windows, ścieżki musi być mniejsza niż 248 znaków i nazwy pliku musi być mniejsza niż 260 znaków."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>zawiera nieprawidłową wartość."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess,Int32)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.FileStream&quot;> </xref> klasy dla określone dojście do pliku, z uprawnieniami określonego odczytu/zapisu, a rozmiar buforu."
  remarks: "`FileStream`przyjęto założenie, że ma on wyłączną kontrolę nad dojście. Odczytywanie, pisania lub wyszukiwania podczas `FileStream` również wstrzymał dojścia może doprowadzić do uszkodzenia danych. Dla bezpieczeństwa danych, należy wywołać <xref:System.IO.FileStream.Flush%2A>przed przy użyciu dojścia i unikaj wywoływania żadnych metod innych niż `Close` po zakończeniu pracy przy użyciu dojścia.</xref:System.IO.FileStream.Flush%2A> Alternatywnie do odczytu i zapisu dojście przed wywołaniem to `FileStream` konstruktora.       `FileShare.Read`Wartość domyślna to tych <xref:System.IO.FileStream>konstruktorów bez `FileShare` parametru.</xref:System.IO.FileStream>      > [!CAUTION] > Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.       Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "Dojście do pliku dla pliku który bieżącego <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> będzie Hermetyzowanie obiektu."
    - id: access
      type: System.IO.FileAccess
      description: "A <xref href=&quot;System.IO.FileAccess&quot;> </xref> stała, która ustawia <> </> *> i <> </> *> właściwości <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> obiektu."
    - id: bufferSize
      type: System.Int32
      description: "Dodatnią <xref:System.Int32>wartość większą niż 0, rozmiar buforu wskazująca.</xref:System.Int32> Domyślny rozmiar buforu to 4096."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> handle </code> Parametr jest nieprawidłowy uchwyt.       - lub - <code> handle </code> parametr ma uchwyt synchroniczne i użyto asynchronicznie."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> bufferSize </code> Parametru jest ujemna."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy, takich jak awaria dysku.       - lub - strumień został zamknięty."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Obiekt wywołujący nie ma wymaganych uprawnień."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Żądanie nie jest dozwolona przez system operacyjny określone dojście do pliku, takie jak kiedy <code> access </code> jest <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> lub <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> i dojście do pliku jest ustawiony na dostęp tylko do odczytu."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.FileStream&quot;> </xref> klasy dla określone dojście do pliku, z uprawnieniami do odczytu/zapisu w określonym i <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> wystąpienie własności."
  remarks: "`FileStream` Obiektu znajduje określony dostępu do pliku. Własność dojście będzie jak określono. Jeśli ten proces jest właścicielem dojście wywołania <xref:System.IO.Stream.Close%2A>Metoda zostaną także zamknięte dojście i liczby dojść pliku zostanie zmniejszona.</xref:System.IO.Stream.Close%2A> `FileStream` Obiektu podano domyślny rozmiar buforu 4096 bajtów.       `FileStream`przyjęto założenie, że ma on wyłączną kontrolę nad dojście. Odczytywanie, pisania lub wyszukiwania podczas `FileStream` również wstrzymał dojścia może doprowadzić do uszkodzenia danych. Dla bezpieczeństwa danych, należy wywołać <xref:System.IO.FileStream.Flush%2A>przed przy użyciu dojścia i unikaj wywoływania metod innych niż `Close` po zakończeniu pracy przy użyciu dojścia.</xref:System.IO.FileStream.Flush%2A>       `FileShare.Read`Wartość domyślna to tych <xref:System.IO.FileStream>konstruktorów bez `FileShare` parametru.</xref:System.IO.FileStream>      > [!CAUTION] > Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.       Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "Dojście do pliku dla pliku który bieżącego <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> będzie Hermetyzowanie obiektu."
    - id: access
      type: System.IO.FileAccess
      description: "Stała, która ustawia <> </> *> i <> </> *> właściwości <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> obiektu."
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli dojście do pliku są własnością to <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> wystąpienia; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>nie jest polem z <xref href=&quot;System.IO.FileAccess&quot;> </xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Obiekt wywołujący nie ma wymaganych uprawnień."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy, takich jak awaria dysku.       - lub - strumień został zamknięty."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Żądanie nie jest dozwolona przez system operacyjny określone dojście do pliku, takie jak kiedy <code> access </code> jest <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> lub <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> i dojście do pliku jest ustawiony na dostęp tylko do odczytu."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.FileStream&quot;> </xref> klasy z określonej ścieżki, tryb tworzenia oraz uprawnienia odczytu/zapisu."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed). The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n `FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "Względna lub bezwzględna ścieżka do pliku który bieżącego <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> będzie Hermetyzowanie obiektu."
    - id: mode
      type: System.IO.FileMode
      description: "Stała, która określa sposób otwarcia lub utworzenia pliku."
    - id: access
      type: System.IO.FileAccess
      description: "Stała, która określa, jak można uzyskać dostępu do pliku <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> obiektu. Wartości zwracane przez określa również <> </> *> i <> </> *> właściwości <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> obiektu. <xref:System.IO.FileStream.CanSeek*>jest <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> Jeśli `path` Określa plik dysku.</xref:System.IO.FileStream.CanSeek*>"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>to ciąg pusty (&quot;&quot;), zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków.       - lub - <code>path</code> odwołuje się do urządzenia z systemem innym niż plik, takich jak &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. w środowisku systemu plików NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>odwołuje się do urządzenia z systemem innym niż plik, takich jak &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. w środowisku z systemem innym niż NTFS."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Nie można odnaleźć pliku, takie jak kiedy <code> mode </code> jest <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> lub <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>, a plik określony przez <code> path </code> nie istnieje. Plik musi już istnieć w tych trybach."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy, takich jak określanie <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> gdy plik określony przez <code> path </code> już istnieje, wystąpił.       - lub - strumień został zamknięty."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Obiekt wywołujący nie ma wymaganych uprawnień."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Żądanie nie jest dozwolona przez system operacyjny dla określonego <code> path </code>, takie jak kiedy <code> access </code> jest <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> lub <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> i plik lub katalog jest ustawiony na dostęp tylko do odczytu."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Określona ścieżka i nazwa pliku przekracza maksymalną długość zdefiniowana w systemie. Na przykład na platformach opartych na systemie Windows, ścieżki musi być mniejsza niż 248 znaków i nazwy pliku musi być mniejsza niż 260 znaków."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>zawiera nieprawidłową wartość."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.FileStream&quot;> </xref> klasy dla określone dojście do pliku, uprawnienia odczytu/zapisu w określonym, rozmiar buforu i stan synchroniczna lub asynchroniczna."
  remarks: "Możesz ustawić `isAsync` parametr `true` można otworzyć dojścia do pliku asynchronicznie. Jeśli parametr jest `true`, strumienia wykorzystuje pokrywającej się z inną operacji We/Wy do wykonywania operacji na plikach asynchronicznie. Jednak parametr nie ma być `true` do wywołania <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, lub <xref:System.IO.Stream.CopyToAsync%2A>metody.</xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A> Gdy `isAsync` parametr jest `false` wywołania asynchronicznego odczytu i zapisu, wątku interfejsu użytkownika nie nadal jest zablokowany, ale rzeczywisty operacji We/Wy jest wykonywana synchronicznie.       `FileStream`przyjęto założenie, że ma on wyłączną kontrolę nad dojście. Odczytywanie, pisania lub wyszukiwania podczas `FileStream` również wstrzymał dojścia może doprowadzić do uszkodzenia danych. Dla bezpieczeństwa danych, należy wywołać <xref:System.IO.FileStream.Flush%2A>przed przy użyciu dojścia i unikaj wywoływania żadnych metod innych niż `Close` po zakończeniu pracy przy użyciu dojścia.</xref:System.IO.FileStream.Flush%2A> Alternatywnie do odczytu i zapisu dojście przed wywołaniem to `FileStream` konstruktora.       `FileShare.Read`Wartość domyślna to tych <xref:System.IO.FileStream>konstruktorów bez `FileShare` parametru.</xref:System.IO.FileStream>      > [!CAUTION] > Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.       Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "Dojście do pliku dla pliku tego <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> będzie Hermetyzowanie obiektu."
    - id: access
      type: System.IO.FileAccess
      description: "Stała, która ustawia <> </> *> i <> </> *> właściwości <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> obiektu."
    - id: bufferSize
      type: System.Int32
      description: "Dodatnią <xref:System.Int32>wartość większą niż 0, rozmiar buforu wskazująca.</xref:System.Int32> Domyślny rozmiar buforu to 4096."
    - id: isAsync
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli dojście zostało otwarte asynchronicznie (to znaczy w pokrywający się trybie We/Wy); w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> handle </code> Parametr jest nieprawidłowy uchwyt.       - lub - <code> handle </code> parametr ma uchwyt synchroniczne i użyto asynchronicznie."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> bufferSize </code> Parametru jest ujemna."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy, takich jak awaria dysku.       - lub - strumień został zamknięty."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Obiekt wywołujący nie ma wymaganych uprawnień."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Żądanie nie jest dozwolona przez system operacyjny określone dojście do pliku, takie jak kiedy <code> access </code> jest <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> lub <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> i dojście do pliku jest ustawiony na dostęp tylko do odczytu."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean,Int32)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.FileStream&quot;> </xref> klasy dla określone dojście do pliku, z uprawnieniami odczytu/zapisu w określonym <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> wystąpienia własność oraz rozmiar buforu."
  remarks: "`FileStream` Obiektu znajduje określony dostępu do pliku. Własność dojście będzie jak określono. Jeśli `FileStream` właścicielem dojście wywołania <xref:System.IO.Stream.Close%2A>Metoda zostaną także zamknięte dojście.</xref:System.IO.Stream.Close%2A> W szczególności liczby dojść pliku zostanie zmniejszona. `FileStream` Obiektu znajduje określony rozmiar buforu.       `FileStream`przyjęto założenie, że ma on wyłączną kontrolę nad dojście. Odczytywanie, pisania lub wyszukiwania podczas `FileStream` również wstrzymał dojścia może doprowadzić do uszkodzenia danych. Dla bezpieczeństwa danych, należy wywołać <xref:System.IO.FileStream.Flush%2A>przed przy użyciu dojścia i unikaj wywoływania żadnych metod innych niż `Close` po zakończeniu pracy przy użyciu dojścia.</xref:System.IO.FileStream.Flush%2A> Alternatywnie do odczytu i zapisu dojście przed wywołaniem to `FileStream` konstruktora.       `FileShare.Read`Wartość domyślna to tych <xref:System.IO.FileStream>konstruktorów bez `FileShare` parametru.</xref:System.IO.FileStream>      > [!CAUTION] > Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.       Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "Dojście do pliku dla pliku tego <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> będzie Hermetyzowanie obiektu."
    - id: access
      type: System.IO.FileAccess
      description: "Stała, która ustawia <> </> *> i <> </> *> właściwości <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> obiektu."
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli dojście do pliku są własnością to <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> wystąpienia; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: bufferSize
      type: System.Int32
      description: "Dodatnią <xref:System.Int32>wartość większą niż 0, rozmiar buforu wskazująca.</xref:System.Int32> Domyślny rozmiar buforu to 4096."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>jest ujemna."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy, takich jak awaria dysku.       - lub - strumień został zamknięty."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Obiekt wywołujący nie ma wymaganych uprawnień."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Żądanie nie jest dozwolona przez system operacyjny określone dojście do pliku, takie jak kiedy <code> access </code> jest <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> lub <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> i dojście do pliku jest ustawiony na dostęp tylko do odczytu."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.FileStream&quot;> </xref> z określonej ścieżki, tryb tworzenia, uprawnienia odczytu/zapisu i uprawnienia udostępniania."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed). The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#2](~/add/codesnippet/csharp/904a8302-b9b6-44f1-89c4-_1.cs)]\n [!code-cpp[System.IO.FileStream3#2](~/add/codesnippet/cpp/904a8302-b9b6-44f1-89c4-_1.cpp)]\n [!code-vb[System.IO.FileStream3#2](~/add/codesnippet/visualbasic/904a8302-b9b6-44f1-89c4-_1.vb)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: path
      type: System.String
      description: "Względna lub bezwzględna ścieżka do pliku który bieżącego <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> będzie Hermetyzowanie obiektu."
    - id: mode
      type: System.IO.FileMode
      description: "Stała, która określa sposób otwarcia lub utworzenia pliku."
    - id: access
      type: System.IO.FileAccess
      description: "Stała, która określa, jak można uzyskać dostępu do pliku <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> obiektu. Wartości zwracane przez określa również <> </> *> i <> </> *> właściwości <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> obiektu. <xref:System.IO.FileStream.CanSeek*>jest <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> Jeśli `path` Określa plik dysku.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "Stała określającą, jak plik zostanie udostępniony przez procesy."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>to ciąg pusty (&quot;&quot;), zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków.       - lub - <code>path</code> odwołuje się do urządzenia z systemem innym niż plik, takich jak &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. w środowisku systemu plików NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>odwołuje się do urządzenia z systemem innym niż plik, takich jak &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. w środowisku z systemem innym niż NTFS."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Nie można odnaleźć pliku, takie jak kiedy <code> mode </code> jest <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> lub <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>, a plik określony przez <code> path </code> nie istnieje. Plik musi już istnieć w tych trybach."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy, takich jak określanie <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> gdy plik określony przez <code> path </code> już istnieje, wystąpił.       w systemie Windows 98 lub Windows 98 Wydanie drugie - lub - i <code> share </code> ustawiono <xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;> </xref>.       - lub - strumień został zamknięty."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Obiekt wywołujący nie ma wymaganych uprawnień."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Żądanie nie jest dozwolona przez system operacyjny dla określonego <code> path </code>, takie jak kiedy <code> access </code> jest <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> lub <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> i plik lub katalog jest ustawiony na dostęp tylko do odczytu."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Określona ścieżka i nazwa pliku przekracza maksymalną długość zdefiniowana w systemie. Na przykład na platformach opartych na systemie Windows, ścieżki musi być mniejsza niż 248 znaków i nazwy pliku musi być mniejsza niż 260 znaków."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>zawiera nieprawidłową wartość."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.FileStream&quot;> </xref> klasy dla określone dojście do pliku, z uprawnieniami odczytu/zapisu w określonym <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> wystąpienie własność, rozmiar buforu i stan synchroniczna lub asynchroniczna."
  remarks: "`FileStream` Obiektu znajduje określony dostępu do pliku. Własność dojście będzie jak określono. Jeśli `FileStream` właścicielem dojście wywołania <xref:System.IO.Stream.Close%2A>Metoda zostaną także zamknięte dojście.</xref:System.IO.Stream.Close%2A> W szczególności liczby dojść pliku zostanie zmniejszona. `FileStream` Obiektu znajduje określony rozmiar buforu.       `FileStream`przyjęto założenie, że ma on wyłączną kontrolę nad dojście. Odczytywanie, pisania lub wyszukiwania podczas `FileStream` również wstrzymał dojścia może doprowadzić do uszkodzenia danych. Dla bezpieczeństwa danych, należy wywołać <xref:System.IO.FileStream.Flush%2A>przed przy użyciu dojścia i unikaj wywoływania żadnych metod innych niż `Close` po zakończeniu pracy przy użyciu dojścia.</xref:System.IO.FileStream.Flush%2A> Alternatywnie do odczytu i zapisu dojście przed wywołaniem to `FileStream` konstruktora.       `FileShare.Read`Wartość domyślna to tych <xref:System.IO.FileStream>konstruktorów bez `FileShare` parametru.</xref:System.IO.FileStream>      > [!CAUTION] > Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.       Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "Dojście do pliku dla pliku tego <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> będzie Hermetyzowanie obiektu."
    - id: access
      type: System.IO.FileAccess
      description: "Stała, która ustawia <> </> *> i <> </> *> właściwości <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> obiektu."
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli dojście do pliku są własnością to <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> wystąpienia; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: bufferSize
      type: System.Int32
      description: "Dodatnią <xref:System.Int32>wartość większą niż 0, rozmiar buforu wskazująca.</xref:System.Int32> Domyślny rozmiar buforu to 4096."
    - id: isAsync
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli dojście zostało otwarte asynchronicznie (to znaczy w pokrywający się trybie We/Wy); w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>access</code>jest mniejsza niż <xref uid=&quot;langword_csharp_FileAccess.Read&quot; name=&quot;FileAccess.Read&quot; href=&quot;&quot;> </xref> lub większa niż <xref uid=&quot;langword_csharp_FileAccess.ReadWrite&quot; name=&quot;FileAccess.ReadWrite&quot; href=&quot;&quot;> </xref> lub <code>bufferSize</code> jest mniejsza niż lub równa 0."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Dojście jest nieprawidłowe."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy, takich jak awaria dysku.       - lub - strumień został zamknięty."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Obiekt wywołujący nie ma wymaganych uprawnień."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Żądanie nie jest dozwolona przez system operacyjny określone dojście do pliku, takie jak kiedy <code> access </code> jest <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> lub <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> i dojście do pliku jest ustawiony na dostęp tylko do odczytu."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.FileStream&quot;> </xref> klasy z określonej ścieżki, tryb tworzenia, odczytu i zapisu oraz udostępniania tych uprawnień, a rozmiar buforu."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);
    parameters:
    - id: path
      type: System.String
      description: "Względna lub bezwzględna ścieżka do pliku który bieżącego <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> będzie Hermetyzowanie obiektu."
    - id: mode
      type: System.IO.FileMode
      description: "Stała, która określa sposób otwarcia lub utworzenia pliku."
    - id: access
      type: System.IO.FileAccess
      description: "Stała, która określa, jak można uzyskać dostępu do pliku <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> obiektu. Wartości zwracane przez określa również <> </> *> i <> </> *> właściwości <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> obiektu. <xref:System.IO.FileStream.CanSeek*>jest <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> Jeśli `path` Określa plik dysku.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "Stała określającą, jak plik zostanie udostępniony przez procesy."
    - id: bufferSize
      type: System.Int32
      description: "Dodatnią <xref:System.Int32>wartość większą niż 0, rozmiar buforu wskazująca.</xref:System.Int32> Domyślny rozmiar buforu to 4096."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>to ciąg pusty (&quot;&quot;), zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków.       - lub - <code>path</code> odwołuje się do urządzenia z systemem innym niż plik, takich jak &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. w środowisku systemu plików NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>odwołuje się do urządzenia z systemem innym niż plik, takich jak &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. w środowisku z systemem innym niż NTFS."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>ma wartość ujemną lub wartość zero.       - lub - <code>mode</code>, <code>access</code>, lub <code>share</code> zawiera nieprawidłową wartość."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Nie można odnaleźć pliku, takie jak kiedy <code> mode </code> jest <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> lub <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>, a plik określony przez <code> path </code> nie istnieje. Plik musi już istnieć w tych trybach."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy, takich jak określanie <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> gdy plik określony przez <code> path </code> już istnieje, wystąpił.       w systemie Windows 98 lub Windows 98 Wydanie drugie - lub - i <code> share </code> ustawiono <xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;> </xref>.       - lub - strumień został zamknięty."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Obiekt wywołujący nie ma wymaganych uprawnień."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Żądanie nie jest dozwolona przez system operacyjny dla określonego <code> path </code>, takie jak kiedy <code> access </code> jest <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> lub <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> i plik lub katalog jest ustawiony na dostęp tylko do odczytu."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Określona ścieżka i nazwa pliku przekracza maksymalną długość zdefiniowana w systemie. Na przykład na platformach opartych na systemie Windows, ścieżki musi być mniejsza niż 248 znaków i nazwy pliku musi być mniejsza niż 260 znaków."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.FileStream&quot;> </xref> klasy z określonej ścieżki, tryb tworzenia, odczytu/zapisu i zezwolenia na udostępnienie, buforować stanu rozmiarze, a synchroniczna lub asynchroniczna."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example shows how to asynchronously write data to a file and then verify that the data was written correctly. A `State` object is created to pass information from the main thread to the `EndReadCallback` and `EndWriteCallback` methods.  \n  \n [!code-cs[System.IO.FileStream2#1](~/add/codesnippet/csharp/ff94fabb-a26d-4ac2-a74e-_1.cs)]\n [!code-vb[System.IO.FileStream2#1](~/add/codesnippet/visualbasic/ff94fabb-a26d-4ac2-a74e-_1.vb)]\n [!code-cpp[System.IO.FileStream2#1](~/add/codesnippet/cpp/ff94fabb-a26d-4ac2-a74e-_1.cpp)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);
    parameters:
    - id: path
      type: System.String
      description: "Względna lub bezwzględna ścieżka do pliku który bieżącego <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> będzie Hermetyzowanie obiektu."
    - id: mode
      type: System.IO.FileMode
      description: "Stała, która określa sposób otwarcia lub utworzenia pliku."
    - id: access
      type: System.IO.FileAccess
      description: "Stała, która określa, jak można uzyskać dostępu do pliku <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> obiektu. Wartości zwracane przez określa również <> </> *> i <> </> *> właściwości <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> obiektu. <xref:System.IO.FileStream.CanSeek*>jest <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> Jeśli `path` Określa plik dysku.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "Stała określającą, jak plik zostanie udostępniony przez procesy."
    - id: bufferSize
      type: System.Int32
      description: "Dodatnią <xref:System.Int32>wartość większą niż 0, rozmiar buforu wskazująca.</xref:System.Int32> Domyślny rozmiar buforu to 4096."
    - id: useAsync
      type: System.Boolean
      description: "Określa, czy używać asynchroniczne We/Wy lub synchroniczne we/wy. Jednak należy pamiętać, że system operacyjny może nie obsługiwać asynchroniczne We/Wy, dlatego podczas określania <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, dojście może być otwarte synchronicznie, w zależności od platformy. Po otwarciu asynchronicznie, <> </> *> i <> </> *> metody lepiej na duże odczyty lub zapisy, ale są znacznie wolniejsze dla małych odczytów i zapisów. Jeśli aplikacja jest przeznaczony do zalet asynchroniczne We/Wy, ustaw `useAsync` parametr <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>. Przy użyciu asynchroniczne We/Wy poprawnie przyspieszyć aplikacji przez jak współczynnik 10, ale przy użyciu jego bez zmiany projektu aplikacji dla asynchroniczne We/Wy może obniżyć wydajność przez tyle jako 10."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>to ciąg pusty (&quot;&quot;), zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków.       - lub - <code>path</code> odwołuje się do urządzenia z systemem innym niż plik, takich jak &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. w środowisku systemu plików NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>odwołuje się do urządzenia z systemem innym niż plik, takich jak &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. w środowisku z systemem innym niż NTFS."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>ma wartość ujemną lub wartość zero.       - lub - <code>mode</code>, <code>access</code>, lub <code>share</code> zawiera nieprawidłową wartość."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Nie można odnaleźć pliku, takie jak kiedy <code> mode </code> jest <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> lub <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>, a plik określony przez <code> path </code> nie istnieje. Plik musi już istnieć w tych trybach."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy, takich jak określanie <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> gdy plik określony przez <code> path </code> już istnieje, wystąpił.       w systemie Windows 98 lub Windows 98 Wydanie drugie - lub - i <code> share </code> ustawiono <xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;> </xref>.       - lub - strumień został zamknięty."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Obiekt wywołujący nie ma wymaganych uprawnień."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Żądanie nie jest dozwolona przez system operacyjny dla określonego <code> path </code>, takie jak kiedy <code> access </code> jest <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> lub <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> i plik lub katalog jest ustawiony na dostęp tylko do odczytu."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Określona ścieżka i nazwa pliku przekracza maksymalną długość zdefiniowana w systemie. Na przykład na platformach opartych na systemie Windows, ścieżki musi być mniejsza niż 248 znaków i nazwy pliku musi być mniejsza niż 260 znaków."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.FileStream&quot;> </xref> przy użyciu określonej ścieżki, tryb tworzenia, odczytu/zapisu i udostępnianie uprawnienia dostępu do tego samego pliku, rozmiar buforu i dodatkowe opcje pliku może mieć inne FileStreams."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example writes data to a file and then reads the data using the <xref:System.IO.FileStream> object.  \n  \n [!code-cpp[IO.FileStream.ctor1#1](~/add/codesnippet/cpp/53f739ba-7c4d-43ff-a387-_1.cpp)]\n [!code-vb[IO.FileStream.ctor1#1](~/add/codesnippet/visualbasic/53f739ba-7c4d-43ff-a387-_1.vb)]\n [!code-cs[IO.FileStream.ctor1#1](~/add/codesnippet/csharp/53f739ba-7c4d-43ff-a387-_1.cs)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);
    parameters:
    - id: path
      type: System.String
      description: "Względna lub bezwzględna ścieżka do pliku który bieżącego <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> będzie Hermetyzowanie obiektu."
    - id: mode
      type: System.IO.FileMode
      description: "Stała, która określa sposób otwarcia lub utworzenia pliku."
    - id: access
      type: System.IO.FileAccess
      description: "Stała, która określa, jak można uzyskać dostępu do pliku <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> obiektu. Wartości zwracane przez określa również <> </> *> i <> </> *> właściwości <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> obiektu. <xref:System.IO.FileStream.CanSeek*>jest <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> Jeśli `path` Określa plik dysku.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "Stała określającą, jak plik zostanie udostępniony przez procesy."
    - id: bufferSize
      type: System.Int32
      description: "Dodatnią <xref:System.Int32>wartość większą niż 0, rozmiar buforu wskazująca.</xref:System.Int32> Domyślny rozmiar buforu to 4096."
    - id: options
      type: System.IO.FileOptions
      description: "Wartość, która określa dodatkowe opcje pliku."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>to ciąg pusty (&quot;&quot;), zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków.       - lub - <code>path</code> odwołuje się do urządzenia z systemem innym niż plik, takich jak &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. w środowisku systemu plików NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>odwołuje się do urządzenia z systemem innym niż plik, takich jak &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. w środowisku z systemem innym niż NTFS."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>ma wartość ujemną lub wartość zero.       - lub - <code>mode</code>, <code>access</code>, lub <code>share</code> zawiera nieprawidłową wartość."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Nie można odnaleźć pliku, takie jak kiedy <code> mode </code> jest <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> lub <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>, a plik określony przez <code> path </code> nie istnieje. Plik musi już istnieć w tych trybach."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy, takich jak określanie <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> gdy plik określony przez <code> path </code> już istnieje, wystąpił.       - lub - strumień został zamknięty."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Obiekt wywołujący nie ma wymaganych uprawnień."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Żądanie nie jest dozwolona przez system operacyjny dla określonego <code> path </code>, takie jak kiedy <code> access </code> jest <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> lub <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> i plik lub katalog jest ustawiony na dostęp tylko do odczytu.       - lub - <xref href=&quot;System.IO.FileOptions&quot;> </xref> określono <code> options </code>, ale szyfrowania plików nie jest obsługiwane na bieżącej platformie."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Określona ścieżka i nazwa pliku przekracza maksymalną długość zdefiniowana w systemie. Na przykład na platformach opartych na systemie Windows, ścieżki musi być mniejsza niż 248 znaków i nazwy pliku musi być mniejsza niż 260 znaków."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  id: '#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.FileStream&quot;> </xref> z określonej ścieżki, tryb tworzenia, prawa dostępu i uprawnienia do udostępniania, opcje rozmiarze i dodatkowe pliku buforu."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n Use this FileStream constructor to apply access rights at the point of creation of a file. To access or modify rights on an existing file, consider using the <xref:System.IO.File.GetAccessControl%2A> and <xref:System.IO.File.SetAccessControl%2A> methods.  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);
    parameters:
    - id: path
      type: System.String
      description: "Względna lub bezwzględna ścieżka do pliku który bieżącego <xref href=&quot;System.IO.FileStream&quot;> </xref> będzie Hermetyzowanie obiektu."
    - id: mode
      type: System.IO.FileMode
      description: "Stała, która określa sposób otwarcia lub utworzenia pliku."
    - id: rights
      type: System.Security.AccessControl.FileSystemRights
      description: "Stała, który określa prawa dostępu do użycia podczas tworzenia reguł dostępu i inspekcji dla pliku."
    - id: share
      type: System.IO.FileShare
      description: "Stała określającą, jak plik zostanie udostępniony przez procesy."
    - id: bufferSize
      type: System.Int32
      description: "Dodatnią <xref:System.Int32>wartość większą niż 0, rozmiar buforu wskazująca.</xref:System.Int32> Domyślny rozmiar buforu to 4096."
    - id: options
      type: System.IO.FileOptions
      description: "Stała, który określa dodatkowe opcje pliku."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>to ciąg pusty (&quot;&quot;), zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków.       - lub - <code>path</code> odwołuje się do urządzenia z systemem innym niż plik, takich jak &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. w środowisku systemu plików NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>odwołuje się do urządzenia z systemem innym niż plik, takich jak &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. w środowisku z systemem innym niż NTFS."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>ma wartość ujemną lub wartość zero.       - lub - <code>mode</code>, <code>access</code>, lub <code>share</code> zawiera nieprawidłową wartość."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Nie można odnaleźć pliku, takie jak kiedy <code> mode </code> jest <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> lub <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>, a plik określony przez <code> path </code> nie istnieje. Plik musi już istnieć w tych trybach."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Bieżący system operacyjny nie jest częścią systemu Windows NT lub nowszego."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy, takich jak określanie <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> gdy plik określony przez <code> path </code> już istnieje, wystąpił.       - lub - strumień został zamknięty."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Obiekt wywołujący nie ma wymaganych uprawnień."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Żądanie nie jest dozwolona przez system operacyjny dla określonego <code> path </code>, takie jak kiedy <code> access </code> jest <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> lub <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> i plik lub katalog jest ustawiony na dostęp tylko do odczytu.       - lub - <xref href=&quot;System.IO.FileOptions&quot;> </xref> określono <code> options </code>, ale szyfrowania plików nie jest obsługiwane na bieżącej platformie."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Określony <code> path </code>, nazwa pliku albo oba przekracza maksymalną długość zdefiniowana w systemie. Na przykład na platformach opartych na systemie Windows, ścieżki musi być mniejsza niż 248 znaków i nazwy pliku musi być mniejsza niż 260 znaków."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  id: '#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.FileStream&quot;> </xref> klasy z określonej ścieżki, tryb tworzenia, prawa dostępu i udostępniania uprawnień, rozmiar buforu, dodatkowe opcje pliku, kontroli dostępu i inspekcji zabezpieczeń."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n Use this FileStream constructor to apply access rights at the point of creation of a file. To access or modify rights on an existing file, consider using the <xref:System.IO.File.GetAccessControl%2A> and <xref:System.IO.File.SetAccessControl%2A> methods.  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example writes data to a file and then reads the data using the <xref:System.IO.FileStream> object.  \n  \n [!code-cpp[IO.FileStream.ctor2#1](~/add/codesnippet/cpp/7f323125-1dac-495a-a4ee-_1.cpp)]\n [!code-cs[IO.FileStream.ctor2#1](~/add/codesnippet/csharp/7f323125-1dac-495a-a4ee-_1.cs)]\n [!code-vb[IO.FileStream.ctor2#1](~/add/codesnippet/visualbasic/7f323125-1dac-495a-a4ee-_1.vb)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: path
      type: System.String
      description: "Względna lub bezwzględna ścieżka do pliku który bieżącego <xref href=&quot;System.IO.FileStream&quot;> </xref> będzie Hermetyzowanie obiektu."
    - id: mode
      type: System.IO.FileMode
      description: "Stała, która określa sposób otwarcia lub utworzenia pliku."
    - id: rights
      type: System.Security.AccessControl.FileSystemRights
      description: "Stała, który określa prawa dostępu do użycia podczas tworzenia reguł dostępu i inspekcji dla pliku."
    - id: share
      type: System.IO.FileShare
      description: "Stała określającą, jak plik zostanie udostępniony przez procesy."
    - id: bufferSize
      type: System.Int32
      description: "Dodatnią <xref:System.Int32>wartość większą niż 0, rozmiar buforu wskazująca.</xref:System.Int32> Domyślny rozmiar buforu to 4096."
    - id: options
      type: System.IO.FileOptions
      description: "Stała, który określa dodatkowe opcje pliku."
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "Stała, który określa kontroli dostępu i inspekcji zabezpieczeń dla pliku."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>to ciąg pusty (&quot;&quot;), zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków.       - lub - <code>path</code> odwołuje się do urządzenia z systemem innym niż plik, takich jak &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. w środowisku systemu plików NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>odwołuje się do urządzenia z systemem innym niż plik, takich jak &quot;con:&quot;, &quot;com1:&quot;, &quot;lpt1:&quot;, etc. w środowisku z systemem innym niż NTFS."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>ma wartość ujemną lub wartość zero.       - lub - <code>mode</code>, <code>access</code>, lub <code>share</code> zawiera nieprawidłową wartość."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Nie można odnaleźć pliku, takie jak kiedy <code> mode </code> jest <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> lub <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>, a plik określony przez <code> path </code> nie istnieje. Plik musi już istnieć w tych trybach."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy, takich jak określanie <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> gdy plik określony przez <code> path </code> już istnieje, wystąpił.       - lub - strumień został zamknięty."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Obiekt wywołujący nie ma wymaganych uprawnień."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Żądanie nie jest dozwolona przez system operacyjny dla określonego <code> path </code>, takie jak kiedy <code> access </code> jest <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> lub <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> i plik lub katalog jest ustawiony na dostęp tylko do odczytu.       - lub - <xref href=&quot;System.IO.FileOptions&quot;> </xref> określono <code> options </code>, ale szyfrowania plików nie jest obsługiwane na bieżącej platformie."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Określony <code> path </code>, nazwa pliku albo oba przekracza maksymalną długość zdefiniowana w systemie. Na przykład na platformach opartych na systemie Windows, ścieżki musi być mniejsza niż 248 znaków i nazwy pliku musi być mniejsza niż 260 znaków."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Bieżący system operacyjny nie jest częścią systemu Windows NT lub nowszego."
  platform:
  - net462
- uid: System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Rozpoczyna operację asynchroniczną odczytu. (Rozważ użycie <xref:System.IO.FileStream.ReadAsync*>zamiast; sekcji uwag.)</xref:System.IO.FileStream.ReadAsync*>"
  remarks: "W programie .NET Framework 4 i wcześniejszych wersjach, należy użyć metody, takie jak BeginRead i <xref:System.IO.FileStream.EndRead%2A>do wykonania operacji na plikach asynchronicznego.</xref:System.IO.FileStream.EndRead%2A> Te metody są nadal dostępne w [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] do obsługi starszego kodu; jednak nowych metod asynchronicznych, takich jak <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, i <xref:System.IO.FileStream.FlushAsync%2A>, łatwiej implementuje operacji asynchronicznych pliku pomocy.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       <xref:System.IO.FileStream.EndRead%2A>musi zostać wywołana tylko raz dla każdego wywołania BeginRead.</xref:System.IO.FileStream.EndRead%2A> Nie można zakończyć proces odczytu przed rozpoczęciem innego odczytu może spowodować niepożądane zachowanie, takie jak zakleszczenia.       <xref:System.IO.FileStream>udostępnia dwa różne tryby działania: We/Wy synchroniczne i asynchroniczne We/Wy.</xref:System.IO.FileStream> Chociaż albo mogą być używane, zasobów systemu operacyjnego mogą zezwalać na dostęp tylko jednej z tych trybów. Domyślnie <xref:System.IO.FileStream>zostanie otwarte dojście systemu operacyjnego synchronicznie.</xref:System.IO.FileStream> W systemie Windows to spowalnia metod asynchronicznych. Jeśli używane są metod asynchronicznych, użyj <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>konstruktora.</xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>      > [!NOTE] > Użyj <xref:System.IO.FileStream.CanRead%2A>Właściwości w celu określenia, czy bieżące wystąpienie obsługuje odczytu.</xref:System.IO.FileStream.CanRead%2A> Aby uzyskać dodatkowe informacje zobacz <xref:System.IO.Stream.CanRead%2A>.</xref:System.IO.Stream.CanRead%2A>       Jeśli strumień jest zamknięty lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu z BeginRead. Błędów występujących podczas odczytu żądania asynchronicznego, takiej jak awaria dysku podczas wykonywania żądania We/Wy wystąpić w wątku puli wątków i stają się widoczne po wywołaniu <xref:System.IO.FileStream.EndRead%2A>.</xref:System.IO.FileStream.EndRead%2A>       <xref:System.IO.Stream.EndRead%2A>musi zostać wywołany z tym <xref:System.IAsyncResult>Aby dowiedzieć się, odczytano liczbę bajtów.</xref:System.IAsyncResult></xref:System.IO.Stream.EndRead%2A>       Wiele równoczesnych żądań asynchronicznych renderowania wiedzą kolejności wykonania żądania.       Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#3](~/add/codesnippet/csharp/82be2bd0-0603-4287-b351-_1.cs)]\n [!code-vb[System.IO.FileStream2#3](~/add/codesnippet/visualbasic/82be2bd0-0603-4287-b351-_1.vb)]\n [!code-cpp[System.IO.FileStream2#3](~/add/codesnippet/cpp/82be2bd0-0603-4287-b351-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    parameters:
    - id: array
      type: System.Byte[]
      description: "Bufor do wczytania danych."
    - id: offset
      type: System.Int32
      description: "Przesunięcie bajtów w `array` w którym ma rozpocząć się odczyt."
    - id: numBytes
      type: System.Int32
      description: "Maksymalna liczba bajtów do odczytania."
    - id: userCallback
      type: System.AsyncCallback
      description: "Metoda wywoływana, gdy operacja odczytu asynchronicznego zostanie ukończona."
    - id: stateObject
      type: System.Object
      description: "Obiekt dostarczane przez użytkownika, która odróżnia to asynchroniczne żądanie odczytu z innych żądań."
    return:
      type: System.IAsyncResult
      description: "Obiekt, który odwołuje się do odczytu asynchronicznego."
  overload: System.IO.FileStream.BeginRead*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Długość tablicy minus <code> offset </code> jest mniejsza niż <code> numBytes </code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>lub <code>numBytes</code> jest ujemna."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Podjęto próbę asynchroniczny odczyt poza końcem pliku."
  platform:
  - net462
- uid: System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Rozpoczyna operację asynchronicznego zapisu. (Rozważ użycie <xref:System.IO.FileStream.WriteAsync*>zamiast; sekcji uwag.)</xref:System.IO.FileStream.WriteAsync*>"
  remarks: "W programie .NET Framework 4 i wcześniejszych wersjach, należy użyć metody, takie jak BeginWrite i <xref:System.IO.FileStream.EndWrite%2A>do wykonania operacji na plikach asynchronicznego.</xref:System.IO.FileStream.EndWrite%2A> Te metody są nadal dostępne w [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] do obsługi starszego kodu; jednak nowych metod asynchronicznych, takich jak <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, i <xref:System.IO.FileStream.FlushAsync%2A>, łatwiej implementuje operacji asynchronicznych pliku pomocy.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       <xref:System.IO.FileStream.EndWrite%2A>musi zostać wywołana tylko raz w każdym <xref:System.IAsyncResult>z BeginWrite.</xref:System.IAsyncResult></xref:System.IO.FileStream.EndWrite%2A> <xref:System.IO.FileStream.EndWrite%2A>blokuje dopiero po ukończeniu operacji We/Wy.</xref:System.IO.FileStream.EndWrite%2A>       Ta metoda zastępuje <xref:System.IO.Stream.BeginWrite%2A>.</xref:System.IO.Stream.BeginWrite%2A>       <xref:System.IO.FileStream>udostępnia dwa różne tryby działania: We/Wy synchroniczne i asynchroniczne We/Wy.</xref:System.IO.FileStream> Chociaż albo mogą być używane, zasobów systemu operacyjnego mogą zezwalać na dostęp tylko jednej z tych trybów. Domyślnie <xref:System.IO.FileStream>zostanie otwarte dojście systemu operacyjnego synchronicznie.</xref:System.IO.FileStream> W systemie Windows to spowalnia metod asynchronicznych. Jeśli używane są metod asynchronicznych, użyj <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>konstruktora.</xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>       Jeśli strumień jest zamknięty lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu z BeginWrite. Błędów występujących podczas żądania asynchronicznego zapisu, takiej jak awaria dysku podczas wykonywania żądania We/Wy wystąpić w wątku puli wątków i stają się widoczne po wywołaniu <xref:System.IO.FileStream.EndWrite%2A>.</xref:System.IO.FileStream.EndWrite%2A>       Wiele równoczesnych żądań asynchronicznych renderowania wiedzą kolejności wykonania żądania.       Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#2](~/add/codesnippet/csharp/439bdb1f-5241-4046-a4ad-_1.cs)]\n [!code-vb[System.IO.FileStream2#2](~/add/codesnippet/visualbasic/439bdb1f-5241-4046-a4ad-_1.vb)]\n [!code-cpp[System.IO.FileStream2#2](~/add/codesnippet/cpp/439bdb1f-5241-4046-a4ad-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    parameters:
    - id: array
      type: System.Byte[]
      description: "Bufor zawierający dane do zapisania bieżącego strumienia."
    - id: offset
      type: System.Int32
      description: "Zerze przesunięcie w `array` jaką należy zacząć kopiowanie bajtów do bieżącego strumienia."
    - id: numBytes
      type: System.Int32
      description: "Maksymalna liczba bajtów do zapisania."
    - id: userCallback
      type: System.AsyncCallback
      description: "Metoda wywoływana po zakończeniu operacji zapis asynchroniczny."
    - id: stateObject
      type: System.Object
      description: "Obiekt dostarczane przez użytkownika, która odróżnia to żądanie określonego zapis asynchroniczny od innych żądań."
    return:
      type: System.IAsyncResult
      description: "Obiekt, który odwołuje się do asynchronicznego zapisu."
  overload: System.IO.FileStream.BeginWrite*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>Długość minus <code>offset</code> jest mniejsza niż <code>numBytes</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>lub <code>numBytes</code> jest ujemna."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Strumień nie obsługuje zapisywania."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Strumień jest zamknięty."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy."
  platform:
  - net462
- uid: System.IO.FileStream.CanRead
  id: CanRead
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanRead
  nameWithType: FileStream.CanRead
  fullName: System.IO.FileStream.CanRead
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Pobiera wartość wskazującą, czy bieżący strumień obsługuje odczytu."
  remarks: "Jeśli klasą pochodną <xref:System.IO.Stream>nie obsługuje operacji odczytu, wywołań <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.ReadByte%2A>oraz <xref:System.IO.FileStream.BeginRead%2A>metody throw <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.FileStream.BeginRead%2A> </xref:System.IO.FileStream.ReadByte%2A> </xref:System.IO.FileStream.Read%2A> </xref:System.IO.Stream>       Jeśli strumień jest zamknięty, ta właściwość zwraca `false`."
  example:
  - "The following example demonstrates a use of the `CanRead` property. The output of this code is \"MyFile.txt is not writable.\" To get the output message \"MyFile.txt can be both written to and read from.\", change the `FileAccess` parameter to `ReadWrite` in the `FileStream` constructor.  \n  \n [!code-cs[Classic FileStream.CanRead Example#1](~/add/codesnippet/csharp/p-system.io.filestream.c_1_1.cs)]\n [!code-cpp[Classic FileStream.CanRead Example#1](~/add/codesnippet/cpp/p-system.io.filestream.c_1_1.cpp)]\n [!code-vb[Classic FileStream.CanRead Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_1_1.vb)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli strumień nie udostępnia możliwości czytania; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> strumień jest zamknięty lub została otwarta z dostępem tylko do zapisu."
  overload: System.IO.FileStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.CanSeek
  id: CanSeek
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: FileStream.CanSeek
  fullName: System.IO.FileStream.CanSeek
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Pobiera wartość wskazującą, czy bieżący strumień obsługuje operacji wyszukiwania."
  remarks: "Jeśli klasą pochodną <xref:System.IO.Stream>nie obsługuje wyszukiwania, wywołań <xref:System.IO.FileStream.Length%2A>, <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Position%2A>i <xref:System.IO.FileStream.Seek%2A>zgłosić <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.FileStream.Seek%2A> </xref:System.IO.FileStream.Position%2A> </xref:System.IO.FileStream.SetLength%2A> </xref:System.IO.FileStream.Length%2A> </xref:System.IO.Stream>       Jeśli strumień jest zamknięty, ta właściwość zwraca `false`."
  example:
  - "The following example uses the `CanSeek` property to check whether a stream supports seeking.  \n  \n [!code-cpp[fstream canseek#1](~/add/codesnippet/cpp/p-system.io.filestream.c_0_1.cpp)]\n [!code-vb[fstream canseek#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_0_1.vb)]\n [!code-cs[fstream canseek#1](~/add/codesnippet/csharp/p-system.io.filestream.c_0_1.cs)]"
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>w przypadku strumienia obsługuje operacji wyszukiwania; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Jeśli strumień jest zamknięty lub <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> został skonstruowany na podstawie dojścia systemu operacyjnego, takich jak potoku lub dane wyjściowe do konsoli."
  overload: System.IO.FileStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.CanWrite
  id: CanWrite
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: FileStream.CanWrite
  fullName: System.IO.FileStream.CanWrite
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Pobiera wartość wskazującą, czy bieżący strumień obsługuje zapisu."
  remarks: "Jeśli klasą pochodną <xref:System.IO.Stream>nie obsługuje zapisywania wywołanie <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.FileStream.BeginWrite%2A>, lub <xref:System.IO.FileStream.WriteByte%2A>zgłasza <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.FileStream.WriteByte%2A> </xref:System.IO.FileStream.BeginWrite%2A> </xref:System.IO.FileStream.Write%2A> </xref:System.IO.FileStream.SetLength%2A> </xref:System.IO.Stream>       Jeśli strumień jest zamknięty, ta właściwość zwraca `false`."
  example:
  - "The following example uses the `CanWrite` property to check whether a stream supports writing.  \n  \n [!code-cs[fstream canwrite#1](~/add/codesnippet/csharp/p-system.io.filestream.c_2_1.cs)]\n [!code-cpp[fstream canwrite#1](~/add/codesnippet/cpp/p-system.io.filestream.c_2_1.cpp)]\n [!code-vb[fstream canwrite#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_2_1.vb)]  \n  \n The following is an example using the `CanWrite` property. The output of this code is \"MyFile.txt is writable.\" To get the output message \"MyFile.txt can be both written to and read from.\", change the `FileAccess` parameter to `ReadWrite` in the `FileStream` constructor.  \n  \n [!code-cs[Classic FileStream.CanWrite Example#1](~/add/codesnippet/csharp/p-system.io.filestream.c_2_2.cs)]\n [!code-vb[Classic FileStream.CanWrite Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_2_2.vb)]\n [!code-cpp[Classic FileStream.CanWrite Example#1](~/add/codesnippet/cpp/p-system.io.filestream.c_2_2.cpp)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli strumienia obsługuje zapis; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> strumień jest zamknięty lub została otwarta z dostępem tylko do odczytu."
  overload: System.IO.FileStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: FileStream.Dispose(Boolean)
  fullName: System.IO.FileStream.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Zwalnia zasoby niezarządzane używane przez <xref href=&quot;System.IO.FileStream&quot;> </xref> i opcjonalnie zwalnia zasoby zarządzane."
  remarks: "Ta metoda jest wywoływana przez metodę publiczną <xref:System.ComponentModel.Component.Dispose%2A>— Metoda i <xref:System.Object.Finalize%2A>metody.</xref:System.Object.Finalize%2A> </xref:System.ComponentModel.Component.Dispose%2A> <xref:System.ComponentModel.Component.Dispose%2A>wywołuje metodę Dispose chronionego z `disposing` ustawiona `true`.</xref:System.ComponentModel.Component.Dispose%2A> <xref:System.Object.Finalize%2A>wywołuje metodę Dispose z `disposing` ustawioną `false`.</xref:System.Object.Finalize%2A>       Gdy `disposing` parametr jest `true`, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane przez to <xref:System.IO.FileStream>odwołań.</xref:System.IO.FileStream> Ta metoda wywołuje <xref:System.ComponentModel.Component.Dispose%2A>metody każdego odwołuje się do obiektu.</xref:System.ComponentModel.Component.Dispose%2A>"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby zwolnić zasoby zarządzane i niezarządzane; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> aby zwolnić tylko zasoby niezarządzane."
  overload: System.IO.FileStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: FileStream.EndRead(IAsyncResult)
  fullName: System.IO.FileStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Czeka na ukończenie oczekujących operacji odczytu asynchronicznego. (Rozważ użycie <xref:System.IO.FileStream.ReadAsync*>zamiast; sekcji uwag.)</xref:System.IO.FileStream.ReadAsync*>"
  remarks: "W programie .NET Framework 4 i wcześniejszych wersjach, należy użyć metody takie jak <xref:System.IO.FileStream.BeginRead%2A>i EndRead można wywołać do wykonania operacji na plikach asynchronicznego.</xref:System.IO.FileStream.BeginRead%2A> Te metody są nadal dostępne w [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] do obsługi starszego kodu; jednak nowych metod asynchronicznych, takich jak <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, i <xref:System.IO.FileStream.FlushAsync%2A>, łatwiej implementuje operacji asynchronicznych pliku pomocy.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       Musi zostać wywołana metoda EndRead dokładnie dla każdego wywołania <xref:System.IO.FileStream.BeginRead%2A>.</xref:System.IO.FileStream.BeginRead%2A> Nie można zakończyć proces odczytu przed rozpoczęciem innego odczytu może spowodować niepożądane zachowanie, takie jak zakleszczenia.       Ta metoda zastępuje <xref:System.IO.Stream.EndRead%2A>.</xref:System.IO.Stream.EndRead%2A>       Funkcję EndRead można wywołać dla każdego <xref:System.IAsyncResult>z <xref:System.IO.FileStream.BeginRead%2A>.</xref:System.IO.FileStream.BeginRead%2A> </xref:System.IAsyncResult> Wywoływanie EndRead można wywołać informuje odczytano liczbę bajtów ze strumienia. Blokuje EndRead można wywołać dopiero po ukończeniu operacji We/Wy."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#4](~/add/codesnippet/csharp/m-system.io.filestream.e_0_1.cs)]\n [!code-vb[System.IO.FileStream2#4](~/add/codesnippet/visualbasic/m-system.io.filestream.e_0_1.vb)]\n [!code-cpp[System.IO.FileStream2#4](~/add/codesnippet/cpp/m-system.io.filestream.e_0_1.cpp)]"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "Odwołanie do oczekujące żądania asynchronicznego oczekiwania."
    return:
      type: System.Int32
      description: "Liczba odczytanych bajtów ze strumienia, między 0 a liczba bajtów, żądana. Strumienie zwracać tylko 0 na koniec strumienia, w przeciwnym razie należy zablokować, dopóki nie będzie dostępne co najmniej 1 bajt."
  overload: System.IO.FileStream.EndRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Ten <xref:System.IAsyncResult>obiekt nie został utworzony przez wywołanie metody <xref:System.IO.FileStream.BeginRead*>w tej klasie.</xref:System.IO.FileStream.BeginRead*> </xref:System.IAsyncResult>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Funkcję EndRead jest wywołana wiele razy."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Strumień jest zamknięty lub wystąpił błąd wewnętrzny."
  platform:
  - net462
- uid: System.IO.FileStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: FileStream.EndWrite(IAsyncResult)
  fullName: System.IO.FileStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Kończy operację asynchronicznego zapisu i bloków, aż do zakończenia operacji We/Wy. (Rozważ użycie <xref:System.IO.FileStream.WriteAsync*>zamiast; sekcji uwag.)</xref:System.IO.FileStream.WriteAsync*>"
  remarks: "W programie .NET Framework 4 i wcześniejszych wersjach, należy użyć metody takie jak <xref:System.IO.FileStream.BeginWrite%2A>i metoda EndWrite do wykonania operacji na plikach asynchronicznego.</xref:System.IO.FileStream.BeginWrite%2A> Te metody są nadal dostępne w [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] do obsługi starszego kodu; jednak nowych metod asynchronicznych, takich jak <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, i <xref:System.IO.FileStream.FlushAsync%2A>, łatwiej implementuje operacji asynchronicznych pliku pomocy.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       Ta metoda zastępuje <xref:System.IO.Stream.EndWrite%2A>.</xref:System.IO.Stream.EndWrite%2A>       Metoda EndWrite musi zostać wywołana tylko raz w każdym <xref:System.IAsyncResult>z <xref:System.IO.FileStream.BeginWrite%2A>.</xref:System.IO.FileStream.BeginWrite%2A> </xref:System.IAsyncResult> Metoda EndWrite zablokuje dopiero po ukończeniu operacji We/Wy."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#3](~/add/codesnippet/csharp/m-system.io.filestream.e_1_1.cs)]\n [!code-vb[System.IO.FileStream2#3](~/add/codesnippet/visualbasic/m-system.io.filestream.e_1_1.vb)]\n [!code-cpp[System.IO.FileStream2#3](~/add/codesnippet/cpp/m-system.io.filestream.e_1_1.cpp)]"
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "Oczekujące żądania We/Wy asynchronicznego."
  overload: System.IO.FileStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Ten <xref:System.IAsyncResult>obiekt nie został utworzony przez wywołanie metody <xref:System.IO.Stream.BeginWrite*>w tej klasie.</xref:System.IO.Stream.BeginWrite*> </xref:System.IAsyncResult>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Metoda EndWrite jest wywołana wiele razy."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Strumień jest zamknięty lub wystąpił błąd wewnętrzny."
  platform:
  - net462
- uid: System.IO.FileStream.Finalize
  id: Finalize
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Finalize()
  nameWithType: FileStream.Finalize()
  fullName: System.IO.FileStream.Finalize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Gwarantuje, że zasoby są zwalniane i inne operacje oczyszczania są wykonywane, gdy moduł garbage collector zwraca <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>."
  remarks: "Wywołania modułu zbierającego elementy bezużyteczne `Finalize` Jeśli bieżący obiekt jest gotowy do przetwarzania. `Finalize`Zamyka `FileStream`."
  syntax:
    content: ~FileStream ();
    parameters: []
  overload: System.IO.FileStream.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Flush
  id: Flush
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Flush()
  nameWithType: FileStream.Flush()
  fullName: System.IO.FileStream.Flush()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Czyści buforów dla tego strumienia i powoduje, że wszystkie buforowane dane są zapisywane w pliku."
  remarks: "Ta metoda zastępuje <xref:System.IO.Stream.Flush%2A?displayProperty=fullName>.</xref:System.IO.Stream.Flush%2A?displayProperty=fullName>       Po wywołaniu metody opróżniania buforu systemu operacyjnego we/wy również jest opróżniany.       Koder strumienia nie jest opróżniany, chyba że jawnie wywołać opróżnić lub usunięcia obiektu. Ustawienie <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=fullName>do `true` oznacza, że dane zostaną opróżnione z buforu w strumieniu, ale nie zostaną opróżnione stanu kodera.</xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=fullName> Dzięki temu koder ma zachowywać stan (częściowe znaki), aby ją poprawnie kodowania kolejny blok znaków. Ten scenariusz dotyczy UTF8 i UTF7, w której niektóre znaki mogą być kodowane tylko po otrzymaniu koder sąsiedniego znaku ani znaków.       Ponieważ bufor może służyć do odczytu lub zapisu, opróżniania wykonuje następujące dwie funkcje: — wszystkie dane zapisane wcześniej w buforze jest kopiowana do pliku, a bufor jest wyczyszczone z wyjątkiem stanu kodera.      -Jeśli <xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=fullName>jest `true` i danych został wcześniej skopiowany z pliku do buforu odczytu, czy bieżące położenie w pliku jest zmniejszany przez liczbę nieprzeczytana bajtów w buforze.</xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=fullName> Bufor jest następnie wyczyszczone.       Użyj <xref:System.IO.FileStream.Flush%28System.Boolean%29>przeciążenie metody, gdy chcesz zapewnić wszystkie buforowane dane w pliku pośredniego buforów są zapisywane na dysku.</xref:System.IO.FileStream.Flush%28System.Boolean%29>"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#4](~/add/codesnippet/csharp/m-system.io.filestream.f_1.cs)]\n [!code-cpp[System.IO.FileStream3#4](~/add/codesnippet/cpp/m-system.io.filestream.f_1.cpp)]\n [!code-vb[System.IO.FileStream3#4](~/add/codesnippet/visualbasic/m-system.io.filestream.f_1.vb)]"
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.IO.FileStream.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Strumień jest zamknięty."
  platform:
  - net462
- uid: System.IO.FileStream.Flush(System.Boolean)
  id: Flush(System.Boolean)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Flush(Boolean)
  nameWithType: FileStream.Flush(Boolean)
  fullName: System.IO.FileStream.Flush(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Czyści buforów dla tego strumienia i powoduje, że wszystkie buforowane dane są zapisywane w pliku, a także czyści wszystkie bufory pośredniego pliku."
  remarks: "Użyj tego przeciążenia, gdy chcesz zapewnić wszystkie buforowane dane w pliku pośredniego buforów są zapisywane na dysku.       Po wywołaniu metody opróżniania buforu systemu operacyjnego we/wy również jest opróżniany."
  syntax:
    content: public virtual void Flush (bool flushToDisk);
    parameters:
    - id: flushToDisk
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby opróżnić wszystkie bufory pliku pośredniego; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: FileStream.FlushAsync(CancellationToken)
  fullName: System.IO.FileStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Asynchronicznie usuwa wszystkie bufory dla tego strumienia, powoduje, że wszystkie buforowane dane są zapisywane w podstawowej urządzenia i monitoruje żądania anulowania."
  remarks: "Po wywołaniu metody FlushAsync również jest opróżniany buforu systemu operacyjnego we/wy.       Jeśli operacja została anulowana przed ukończeniem działania, zwrócone zadania zawiera <xref:System.Threading.Tasks.TaskStatus>wartość <xref:System.Threading.Tasks.Task.Status%2A>Właściwości.</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus> Jeśli zostanie usunięty, dojście do pliku, zwrócone zadania zawiera <xref:System.ObjectDisposedException>wyjątek w <xref:System.Threading.Tasks.Task.Exception%2A>Właściwości.</xref:System.Threading.Tasks.Task.Exception%2A> </xref:System.ObjectDisposedException>"
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Token do monitorowania żądań anulowania."
    return:
      type: System.Threading.Tasks.Task
      description: "Zadanie reprezentujące asynchroniczną operację opróżniania."
  overload: System.IO.FileStream.FlushAsync*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Strumień został usunięty."
  platform:
  - net462
- uid: System.IO.FileStream.GetAccessControl
  id: GetAccessControl
  parent: System.IO.FileStream
  langs:
  - csharp
  name: GetAccessControl()
  nameWithType: FileStream.GetAccessControl()
  fullName: System.IO.FileStream.GetAccessControl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Pobiera <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref> obiekt hermetyzujący listę kontroli dostępu (ACL) wpisy kontroli dostępu dla pliku opisanego przez bieżący <xref href=&quot;System.IO.FileStream&quot;> </xref> obiektu."
  remarks: "Gdy <xref:System.IO.FileStream>klasy i GetAccessControl można pobrać listę kontroli dostępu (ACL) wpisy kontroli dostępu do istniejącego pliku, należy rozważyć użycie <xref:System.IO.File.GetAccessControl%2A?displayProperty=fullName>metody, w jakiej jest łatwiejsza w użyciu.</xref:System.IO.File.GetAccessControl%2A?displayProperty=fullName> </xref:System.IO.FileStream>       Metoda GetAccessControl można pobrać wpisów list ACL dla pliku.       Listy ACL opisuje fizycznych i/lub grup, którzy lub nie ma praw do określonych akcji na dany plik. Aby uzyskać więcej informacji, zobacz [porady: Dodawanie lub usuwanie pozycji listy kontroli dostępu](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Security.AccessControl.FileSecurity GetAccessControl ();
    parameters: []
    return:
      type: System.Security.AccessControl.FileSecurity
      description: "Obiekt hermetyzujący ustawienia kontroli dostępu dla pliku opisanego przez bieżący <xref href=&quot;System.IO.FileStream&quot;> </xref> obiektu."
  overload: System.IO.FileStream.GetAccessControl*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ten plik będzie zamknięty."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas otwierania pliku."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Nie można odnaleźć pliku."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Ta operacja nie jest obsługiwane na bieżącej platformie.       - lub - obiekt wywołujący nie ma wymaganych uprawnień."
  platform:
  - net462
- uid: System.IO.FileStream.Handle
  id: Handle
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Handle
  nameWithType: FileStream.Handle
  fullName: System.IO.FileStream.Handle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Pobiera dojście do pliku systemu operacyjnego dla pliku bieżącego <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> hermetyzuje obiektu."
  remarks: "Ta właściwość jest dojścia systemu operacyjnego do użycia z wywołań systemu operacyjnego — dostarczane przez system (takich jak `ReadFile` w systemie Windows). Nie będą działać funkcje biblioteki C, które oczekują deskryptorów plików, takich jak `fread`.       Dojście systemu operacyjnego może być otwarte synchronicznie lub asynchronicznie, w zależności od tego, który `FileStream` konstruktor został wywołany. Użyj <xref:System.IO.FileStream.IsAsync%2A>Właściwości, aby dowiedzieć się, czy to dojście zostało otwarte asynchronicznie.</xref:System.IO.FileStream.IsAsync%2A> W Win32, oznacza, że dojście zostało otwarte dla pokrywającej się z inną operacji We/Wy i wymaga różnych parametrów do `ReadFile` i `WriteFile`.      > [!CAUTION] > Może spowodować uszkodzenie danych, jeśli `FileStream` jest utworzony, jest przekazywany uchwytu, niektórych operacji przesunie wskaźnik pliku uchwytu, a następnie `FileStream` jest używane ponownie. Wiele wątków nie może bezpiecznie zapisać do tego samego pliku jednocześnie, oraz `FileStream` buforowanie kodu zakłada, że wyłącznie kontroluje dojście. `FileStream`może zgłosić <xref:System.IO.IOException>Jeśli `FileStream` wykryje, że w innym procesie przeniósł wskaźnika pliku.</xref:System.IO.IOException> Aby tego uniknąć, nie zapisuj żadnych danych do części pliku, który `FileStream` może mieć buforowane i przywrócić wskaźnika pliku lokalizacji miał zostały ostatnio wywołanego metod na `FileStream`."
  syntax:
    content: public virtual IntPtr Handle { get; }
    return:
      type: System.IntPtr
      description: "Dojście do pliku systemu operacyjnego dla pliku hermetyzowany to <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> obiektu lub wartość-1, jeśli <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> został zamknięty."
  overload: System.IO.FileStream.Handle*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Obiekt wywołujący nie ma wymaganych uprawnień."
  platform:
  - net462
- uid: System.IO.FileStream.IsAsync
  id: IsAsync
  parent: System.IO.FileStream
  langs:
  - csharp
  name: IsAsync
  nameWithType: FileStream.IsAsync
  fullName: System.IO.FileStream.IsAsync
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Pobiera wartość wskazującą czy <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> zostało otwarte asynchronicznie lub synchronicznie."
  remarks: "`IsAsync` Właściwości wykrywa, czy `FileStream` dojście zostało otwarte asynchronicznie, włączanie kod, aby używał <xref:System.IO.FileStream.Handle%2A>Właściwości poprawnie.</xref:System.IO.FileStream.Handle%2A> W systemie Win32 `IsAsync` jest wartość PRAWDA oznacza, że dojście zostało otwarte dla pokrywającej się z inną operacji We/Wy i w związku z tym wymaga różnych parametrów do `ReadFile` i `WriteFile`.       Tę wartość można określić podczas tworzenia wystąpienia <xref:System.IO.FileStream>przy użyciu konstruktora, który ma `isAsync`, `useAsync`, lub `options` parametru.</xref:System.IO.FileStream> Gdy ta właściwość jest `true`, strumienia wykorzystuje pokrywającej się z inną operacji We/Wy do wykonywania operacji na plikach asynchronicznie. Jednak właściwość IsAsync nie ma być `true` do wywołania <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, lub <xref:System.IO.Stream.CopyToAsync%2A>metody.</xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A> Gdy właściwość IsAsync jest `false` wywołania asynchronicznego odczytu i zapisu, wątku interfejsu użytkownika nie nadal jest zablokowany, ale rzeczywisty operacji We/Wy jest wykonywana synchronicznie."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#2](~/add/codesnippet/csharp/p-system.io.filestream.i_1.cs)]\n [!code-vb[System.IO.FileStream2#2](~/add/codesnippet/visualbasic/p-system.io.filestream.i_1.vb)]\n [!code-cpp[System.IO.FileStream2#2](~/add/codesnippet/cpp/p-system.io.filestream.i_1.cpp)]"
  syntax:
    content: public virtual bool IsAsync { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> zostało otwarte asynchronicznie; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.IsAsync*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Length
  id: Length
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Length
  nameWithType: FileStream.Length
  fullName: System.IO.FileStream.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Pobiera długość w bajtach strumienia."
  remarks: "Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example uses the `Length` and `Position` properties to check for an end-of-file condition.  \n  \n [!code-cpp[Classic FileStream.Length Example#1](~/add/codesnippet/cpp/p-system.io.filestream.l_1.cpp)]\n [!code-cs[Classic FileStream.Length Example#1](~/add/codesnippet/csharp/p-system.io.filestream.l_1.cs)]\n [!code-vb[Classic FileStream.Length Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.l_1.vb)]"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "Wartość typu long reprezentujący długość strumienia w bajtach."
  overload: System.IO.FileStream.Length*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref:System.IO.FileStream.CanSeek*>Ten strumień jest <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.IO.FileStream.CanSeek*>"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy, takich jak plik zostanie zamknięty."
  platform:
  - net462
- uid: System.IO.FileStream.Lock(System.Int64,System.Int64)
  id: Lock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Lock(Int64,Int64)
  nameWithType: FileStream.Lock(Int64,Int64)
  fullName: System.IO.FileStream.Lock(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Zapobiega inne procesy Odczyt lub zapis do <xref href=&quot;System.IO.FileStream&quot;> </xref>."
  remarks: "Blokowanie zakresu strumień pliku daje wątki blokowania wyłącznego dostępu procesu do tego zakresu strumienia pliku.       Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file. Run the program simultaneously in different command windows and investigate using the different console input options.  \n  \n [!code-cs[System.IO.FileStream3#1](~/add/codesnippet/csharp/m-system.io.filestream.l_1.cs)]\n [!code-cpp[System.IO.FileStream3#1](~/add/codesnippet/cpp/m-system.io.filestream.l_1.cpp)]\n [!code-vb[System.IO.FileStream3#1](~/add/codesnippet/visualbasic/m-system.io.filestream.l_1.vb)]"
  syntax:
    content: public virtual void Lock (long position, long length);
    parameters:
    - id: position
      type: System.Int64
      description: "Początek zakresu do zablokowania. Wartość tego parametru musi być równa lub większa niż zero (0)."
    - id: length
      type: System.Int64
      description: "Zakres do zablokowania."
  overload: System.IO.FileStream.Lock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>position</code>lub <code>length</code> jest ujemna."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ten plik będzie zamknięty."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Proces nie może uzyskać dostępu do pliku, ponieważ inny proces zablokował część pliku."
  platform:
  - net462
- uid: System.IO.FileStream.Name
  id: Name
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Name
  nameWithType: FileStream.Name
  fullName: System.IO.FileStream.Name
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Pobiera nazwę <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> przekazany do konstruktora."
  remarks: "Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#4](~/add/codesnippet/csharp/p-system.io.filestream.n_1.cs)]\n [!code-vb[System.IO.FileStream2#4](~/add/codesnippet/visualbasic/p-system.io.filestream.n_1.vb)]\n [!code-cpp[System.IO.FileStream2#4](~/add/codesnippet/cpp/p-system.io.filestream.n_1.cpp)]"
  syntax:
    content: public string Name { get; }
    return:
      type: System.String
      description: "Ciąg znaków będący nazwą <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.Name*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Position
  id: Position
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Position
  nameWithType: FileStream.Position
  fullName: System.IO.FileStream.Position
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Pobiera lub ustawia bieżącą pozycję tego strumienia."
  remarks: "Wyszukiwanie w dowolne miejsce powyżej długość strumienia jest obsługiwana.  Podczas wyszukiwania powyżej długość pliku zwiększania rozmiaru pliku.  W systemie Microsoft Windows NT i nowszych danymi, które zostały dodane na końcu pliku zostaje ustawiony na zero.  W systemie Microsoft Windows 98 lub starszym danymi, które zostały dodane na końcu pliku nie ustawiono na wartość 0, co oznacza, że wcześniej usunięty danych jest widoczny w strumieniu. Ustawienie pozycji strumienia duża wartość za końcem strumienia w systemie Windows 98 lub starszym może spowodować wyjątek.       Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example uses the `Length` and `Position` properties to check for an end-of-file condition.  \n  \n [!code-cpp[Classic FileStream.Length Example#1](~/add/codesnippet/cpp/p-system.io.filestream.p_1.cpp)]\n [!code-cs[Classic FileStream.Length Example#1](~/add/codesnippet/csharp/p-system.io.filestream.p_1.cs)]\n [!code-vb[Classic FileStream.Length Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.p_1.vb)]"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "Bieżąca pozycja tego strumienia."
  overload: System.IO.FileStream.Position*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Strumień nie obsługuje wyszukiwania."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred.  \n  \n \\- or -  \n  \n The position was set to a very large value beyond the end of the stream in Windows 98 or earlier."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Podjęto próbę ustawienia pozycji w wartości ujemnej."
  - type: System.IO.EndOfStreamException
    commentId: T:System.IO.EndOfStreamException
    description: "Nastąpiła próba znalezienia poza koniec strumienia, który nie jest to obsługiwane."
  platform:
  - net462
- uid: System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: FileStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Odczytuje blok bajtów ze strumienia i zapisuje dane w buforze danego."
  remarks: "Ta metoda zastępuje <xref:System.IO.Stream.Read%2A>.</xref:System.IO.Stream.Read%2A>       `offset` Parametru zapewnia Przesunięcie bajtów w `array` (indeks bufora) w którym ma rozpocząć się odczyt i `count` parametru zapewnia maksymalną liczbę bajtów do odczytu tego strumienia. Zwrócona wartość jest rzeczywista liczba bajtów odczytanych lub zero, jeśli zostanie osiągnięty koniec strumienia. Jeśli operacja odczytu zakończy się pomyślnie, bieżącej pozycji strumienia jest zaawansowane przez liczbę bajtów do odczytu. Jeśli wystąpi wyjątek, bieżącej pozycji strumienia jest bez zmian.       Metody Read zwraca zero tylko po dojściu do końca strumienia. W przeciwnym razie odczytu ma zawsze wartość co najmniej jednego bajtu ze strumienia przed zwróceniem. Jeśli dane są niedostępne ze strumienia podczas wywołania odczytu, metoda zablokuje dopóki co najmniej jednego bajtu danych może być zwracany. Implementacja jest bezpłatna do zwrócenia mniej bajtów niż żądana, nawet jeżeli nie osiągnięto koniec strumienia.       Użyj <xref:System.IO.BinaryReader>do odczytywania danych pierwotnych typów.</xref:System.IO.BinaryReader>       Nie przerywają pracy wątku, który wykonuje operację odczytu. Mimo że aplikacja może pojawić się działał poprawnie, gdy wątek jest odblokowany, przerwanie może spowodować spadek wydajności i niezawodności aplikacji.       Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example reads the contents from a <xref:System.IO.FileStream> and writes it into another <xref:System.IO.FileStream>.  \n  \n [!code-vb[FSRead#1](~/add/codesnippet/visualbasic/m-system.io.filestream.r_1_1.vb)]\n [!code-cs[FSRead#1](~/add/codesnippet/csharp/m-system.io.filestream.r_1_1.cs)]"
  syntax:
    content: public override int Read (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "Po powrocie z tej metody zawiera określonej tablicy bajtów z wartością pomiędzy `offset` i (`offset`  +  `count` - 1`)` zastępuje Bajty odczytane z bieżącego źródła."
    - id: offset
      type: System.Int32
      description: "Przesunięcie bajtów w `array` , w której zostaną umieszczone odczytywanych bajtów."
    - id: count
      type: System.Int32
      description: "Maksymalna liczba bajtów do odczytania."
    return:
      type: System.Int32
      description: "Całkowita liczba bajtów odczytanych w buforze. Przyczyną może być mniejsza niż żądana liczba bajtów podanej liczby bajtów nie są obecnie dostępne, czy zero, jeśli osiągnięto koniec strumienia."
  overload: System.IO.FileStream.Read*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>lub <code>count</code> jest ujemna."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Strumień nie obsługuje odczytu."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset</code>i <code>count</code> opisano nieprawidłowy zakres w <code>array</code>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metody wywołane po strumień został zamknięty."
  platform:
  - net462
- uid: System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Asynchronicznie odczytuje sekwencję bajtów ze strumienia bieżącego zmienia pozycję w strumieniu przez liczbę bajtów odczytanych i monitoruje żądań anulowania."
  remarks: "Metoda ReadAsync umożliwia wykonywanie operacji na plikach obciążający zasoby bez blokowania głównego wątku. Uwaga dotycząca wydajności jest szczególnie ważne w [!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)] aplikacji lub [!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)] aplikacji, gdy operacja czasochłonne strumienia można blokować wątku interfejsu użytkownika i zapewnić aplikacji są wyświetlane tak, jakby nie działa. Metody asynchroniczne są używane w połączeniu z `async` i `await` słów kluczowych w języku Visual Basic i C#.       Użyj <xref:System.IO.FileStream.CanRead%2A>Właściwości w celu określenia, czy bieżące wystąpienie obsługuje odczytu.</xref:System.IO.FileStream.CanRead%2A>       Jeśli operacja została anulowana przed ukończeniem działania, zwrócone zadania zawiera <xref:System.Threading.Tasks.TaskStatus>wartość <xref:System.Threading.Tasks.Task.Status%2A>Właściwości.</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus> Jeśli zostanie usunięty, dojście do pliku, zwrócone zadania zawiera <xref:System.ObjectDisposedException>wyjątek w <xref:System.Threading.Tasks.Task.Exception%2A>Właściwości.</xref:System.Threading.Tasks.Task.Exception%2A> </xref:System.ObjectDisposedException>"
  example:
  - "The following example shows how to read from a file asynchronously.  \n  \n [!code-vb[Asynchronous_File_IO_async#4](~/add/codesnippet/visualbasic/9c5ba435-5f90-4f89-b415-_1.vb)]\n [!code-cs[Asynchronous_File_IO_async#4](~/add/codesnippet/csharp/9c5ba435-5f90-4f89-b415-_1.cs)]"
  syntax:
    content: public override System.Threading.Tasks.Task<int> ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Bufor zapisu danych do."
    - id: offset
      type: System.Int32
      description: "Przesunięcie bajtów w `buffer` jaką rozpocząć pisanie danych ze strumienia."
    - id: count
      type: System.Int32
      description: "Maksymalna liczba bajtów do odczytania."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Token do monitorowania żądań anulowania."
    return:
      type: System.Threading.Tasks.Task{System.Int32}
      description: "Zadanie reprezentujące asynchroniczną operacja odczytu. Wartość <code> TResult </code> parametr zawiera całkowitą liczbę bajtów odczytanych w buforze. Wartość wyniku może być mniejsza niż żądana liczba bajtów Liczba dostępnych bajtów jest mniejsza niż żądany numer, czy może być 0 (zero), jeśli osiągnięto koniec strumienia."
  overload: System.IO.FileStream.ReadAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>lub <code>count</code> jest ujemna."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Suma <code> offset </code> i <code> count </code> jest większa niż długość buforu."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Strumień nie obsługuje odczytu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Strumień został usunięty."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Strumień jest obecnie używany przez poprzednią operację odczytu."
  platform:
  - net462
- uid: System.IO.FileStream.ReadByte
  id: ReadByte
  parent: System.IO.FileStream
  langs:
  - csharp
  name: ReadByte()
  nameWithType: FileStream.ReadByte()
  fullName: System.IO.FileStream.ReadByte()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Odczytuje bajt z pliku i zwiększa położenie odczytu jednego bajtu."
  remarks: "Ta metoda zastępuje <xref:System.IO.Stream.ReadByte%2A>.</xref:System.IO.Stream.ReadByte%2A>      > [!NOTE] > Użyj <xref:System.IO.FileStream.CanRead%2A>Właściwości w celu określenia, czy bieżące wystąpienie obsługuje odczytu.</xref:System.IO.FileStream.CanRead%2A> Aby uzyskać dodatkowe informacje zobacz <xref:System.IO.Stream.CanRead%2A>.</xref:System.IO.Stream.CanRead%2A>"
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.r_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.r_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.r_0_1.cpp)]"
  syntax:
    content: public override int ReadByte ();
    parameters: []
    return:
      type: System.Int32
      description: "Byte, rzutować <xref:System.Int32>, lub wartość -1, jeśli osiągnięto koniec strumienia.</xref:System.Int32>"
  overload: System.IO.FileStream.ReadByte*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Bieżący strumień nie obsługuje odczytu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Bieżący strumień jest zamknięty."
  platform:
  - net462
- uid: System.IO.FileStream.SafeFileHandle
  id: SafeFileHandle
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
  fullName: System.IO.FileStream.SafeFileHandle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Pobiera <xref href=&quot;Microsoft.Win32.SafeHandles.SafeFileHandle&quot;> </xref> obiekt, który reprezentuje dojście do pliku systemu operacyjnego dla pliku który bieżącego <xref href=&quot;System.IO.FileStream&quot;> </xref> hermetyzuje obiektu."
  remarks: "Właściwość SafeFileHandle opróżnienia strumienia i automatycznie ustawia bieżącej pozycji strumienia na 0.  Dzięki temu można przenieść pliku lub pozycji strumienia zostaną zresetowane przez inny strumień przy użyciu SafeFileHandle zwracane przez tę właściwość."
  syntax:
    content: public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "Obiekt reprezentujący dojście do pliku systemu operacyjnego dla pliku który bieżącego <xref href=&quot;System.IO.FileStream&quot;> </xref> hermetyzuje obiektu."
  overload: System.IO.FileStream.SafeFileHandle*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: FileStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.FileStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Ustawia bieżącą pozycję tego strumienia podanej wartości."
  remarks: "Ta metoda zastępuje <xref:System.IO.Stream.Seek%2A?displayProperty=fullName>.</xref:System.IO.Stream.Seek%2A?displayProperty=fullName>      > [!NOTE] > Użyj <xref:System.IO.FileStream.CanSeek%2A?displayProperty=fullName>Właściwości w celu określenia, czy bieżące wystąpienie obsługuje operacji wyszukiwania.</xref:System.IO.FileStream.CanSeek%2A?displayProperty=fullName> Aby uzyskać dodatkowe informacje zobacz <xref:System.IO.Stream.CanSeek%2A?displayProperty=fullName>.</xref:System.IO.Stream.CanSeek%2A?displayProperty=fullName>       Można wyszukiwać, w dowolnej lokalizacji poza długość strumienia. Podczas wyszukiwania powyżej długość pliku zwiększania rozmiaru pliku. W systemie Windows NT i nowszych wersjach danych dodawane na końcu pliku jest równa zero. Windows 98 lub starszych wersji danych dodawane na końcu pliku nie ustawiono na wartość 0, co oznacza, że wcześniej usunięty danych jest widoczny w strumieniu.       Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_1_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.s_1_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.s_1_1.cpp)]  \n  \n The following example reads text in the reverse direction, from the end of file to the beginning of the file, by using the various <xref:System.IO.SeekOrigin> values with the Seek method.  \n  \n [!code-vb[System.IO.FileStream.Seek#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_1_2.vb)]\n [!code-cs[System.IO.FileStream.Seek#1](~/add/codesnippet/csharp/m-system.io.filestream.s_1_2.cs)]"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "Punkt względem `origin` w której chcesz rozpocząć wyszukiwanie."
    - id: origin
      type: System.IO.SeekOrigin
      description: "Określa początek, końcu lub bieżącą pozycję jako punkt odniesienia dla `offset`, za pomocą wartości typu <xref:System.IO.SeekOrigin>.</xref:System.IO.SeekOrigin>"
    return:
      type: System.Int64
      description: "Nowa pozycja w strumieniu."
  overload: System.IO.FileStream.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Strumień nie obsługuje wyszukiwania, np. Jeśli <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> jest tworzony z potoku lub konsola danych wyjściowych."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Wyszukiwanie nastąpiła przed początkiem strumienia."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metody wywołane po strumień został zamknięty."
  platform:
  - net462
- uid: System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  id: SetAccessControl(System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SetAccessControl(FileSecurity)
  nameWithType: FileStream.SetAccessControl(FileSecurity)
  fullName: System.IO.FileStream.SetAccessControl(FileSecurity)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Stosuje listę kontroli dostępu (ACL) wpisów kontroli dostępu, opisanego przez <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref> obiektu do pliku opisanego przez bieżący <xref href=&quot;System.IO.FileStream&quot;> </xref> obiektu."
  remarks: "Podczas <xref:System.IO.FileStream>klasy i SetAccessControl mogą być używane na istniejący plik, należy rozważyć użycie <xref:System.IO.File.SetAccessControl%2A?displayProperty=fullName>metody, w jakiej jest łatwiejsza w użyciu.</xref:System.IO.File.SetAccessControl%2A?displayProperty=fullName> </xref:System.IO.FileStream>       Metoda SetAccessControl stosowana wpisów listę kontroli dostępu (ACL) kontroli dostępu do pliku, który reprezentuje noninherited listy ACL.      > [!CAUTION] > Określonej listy ACL dla `fileSecurity` parametru zastępuje istniejące listy ACL dla pliku. Aby dodać uprawnienia dla nowego użytkownika, należy użyć <xref:System.IO.FileStream.GetAccessControl%2A>metodę, aby uzyskać istniejące listy ACL, zmodyfikuj go, a następnie użyj SetAccessControl Aby zastosować go z powrotem do pliku.</xref:System.IO.FileStream.GetAccessControl%2A>       Listy ACL opisuje fizycznych i/lub grup, którzy lub nie ma praw do określonych akcji na dany plik. Aby uzyskać więcej informacji, zobacz [porady: Dodawanie lub usuwanie pozycji listy kontroli dostępu](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "Obiekt wpisu na liście ACL, aby zastosować do bieżącego pliku."
  overload: System.IO.FileStream.SetAccessControl*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ten plik będzie zamknięty."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>fileSecurity</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Nie można odnaleźć lub modyfikacji pliku."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Bieżący proces nie ma dostępu do otwierania pliku."
  platform:
  - net462
- uid: System.IO.FileStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: FileStream.SetLength(Int64)
  fullName: System.IO.FileStream.SetLength(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Ustawia długości tego strumienia podanej wartości."
  remarks: "Ta metoda zastępuje <xref:System.IO.Stream.SetLength%2A>.</xref:System.IO.Stream.SetLength%2A>       Jeśli dana wartość jest mniejsza niż bieżąca długość strumienia, zostanie obcięta strumienia. W tym scenariuszu jeśli bieżące położenie jest większa niż długość nowego bieżące położenie jest przenoszony do ostatniego bajtu strumienia. Jeśli dana wartość jest większa niż bieżąca długość strumienia, strumień jest rozwinięty, a bieżące położenie jest taka sama. Jeśli strumień jest rozwinięty, zawartość strumienia między stary i nowy długość jest niezdefiniowany.       Strumień musi obsługiwać zarówno zapisu i wyszukiwania dla `SetLength` do pracy.      > [!NOTE] > Użyj <xref:System.IO.FileStream.CanWrite%2A>Właściwości w celu określenia, czy bieżące wystąpienie obsługuje zapis i <xref:System.IO.FileStream.CanSeek%2A>Właściwości w celu określenia, czy wyszukiwanie jest obsługiwane.</xref:System.IO.FileStream.CanSeek%2A> </xref:System.IO.FileStream.CanWrite%2A> Aby uzyskać dodatkowe informacje zobacz <xref:System.IO.Stream.CanWrite%2A>i <xref:System.IO.Stream.CanSeek%2A>.</xref:System.IO.Stream.CanSeek%2A> </xref:System.IO.Stream.CanWrite%2A>       Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "Nowe długość strumienia."
  overload: System.IO.FileStream.SetLength*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Strumień nie obsługuje zarówno zapisu i wyszukiwania."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Podjęto próbę ustawienia <code> value </code> parametr mniejszy niż 0."
  platform:
  - net462
- uid: System.IO.FileStream.Unlock(System.Int64,System.Int64)
  id: Unlock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Unlock(Int64,Int64)
  nameWithType: FileStream.Unlock(Int64,Int64)
  fullName: System.IO.FileStream.Unlock(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Umożliwia dostęp przez inne procesy do całości lub części pliku, który wcześniej był zablokowany."
  remarks: "Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file, and then unlock the specified part of the file . Run the program simultaneously in different command windows and investigate using the different console input options.  \n  \n [!code-cs[System.IO.FileStream3#1](~/add/codesnippet/csharp/m-system.io.filestream.u_1.cs)]\n [!code-cpp[System.IO.FileStream3#1](~/add/codesnippet/cpp/m-system.io.filestream.u_1.cpp)]\n [!code-vb[System.IO.FileStream3#1](~/add/codesnippet/visualbasic/m-system.io.filestream.u_1.vb)]"
  syntax:
    content: public virtual void Unlock (long position, long length);
    parameters:
    - id: position
      type: System.Int64
      description: "Początek zakresu do odblokowania."
    - id: length
      type: System.Int64
      description: "Zakres do odblokowania."
  overload: System.IO.FileStream.Unlock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>position</code>lub <code>length</code> jest ujemna."
  platform:
  - net462
- uid: System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: FileStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Zapisuje blok bajtów do strumienia pliku."
  remarks: "Ta metoda zastępuje <xref:System.IO.Stream.Write%2A>.</xref:System.IO.Stream.Write%2A>       `offset` Parametru zapewnia Przesunięcie bajtów w `array` (indeks bufora) od którego należy zacząć kopiowanie i `count` parametru zapewnia liczba bajtów, które zostaną zapisane w strumieniu. Jeśli operacja zapisu zakończy się pomyślnie, bieżącej pozycji strumienia jest zaawansowane przez liczba zapisanych bajtów. Jeśli wystąpi wyjątek, bieżącej pozycji strumienia jest bez zmian.      > [!NOTE] > Użyj <xref:System.IO.FileStream.CanWrite%2A>Właściwości w celu określenia, czy bieżące wystąpienie obsługuje zapisu.</xref:System.IO.FileStream.CanWrite%2A> Aby uzyskać dodatkowe informacje zobacz <xref:System.IO.Stream.CanWrite%2A>.</xref:System.IO.Stream.CanWrite%2A>       Nie przerywają pracy wątku, który wykonuje operację zapisu. Mimo że aplikacja może pojawić się działał poprawnie, gdy wątek jest odblokowany, przerwanie może spowodować spadek wydajności i niezawodności aplikacji.       Listę typowych plików i działań katalogu zawiera [typowe zadania we/wy](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#3](~/add/codesnippet/csharp/m-system.io.filestream.w_1_1.cs)]\n [!code-cpp[System.IO.FileStream3#3](~/add/codesnippet/cpp/m-system.io.filestream.w_1_1.cpp)]\n [!code-vb[System.IO.FileStream3#3](~/add/codesnippet/visualbasic/m-system.io.filestream.w_1_1.vb)]"
  syntax:
    content: public override void Write (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "Bufor zawierający dane do zapisania w strumieniu."
    - id: offset
      type: System.Int32
      description: "Zerze przesunięcie w `array` z którego należy zacząć kopiowanie bajtów do strumienia."
    - id: count
      type: System.Int32
      description: "Maksymalna liczba bajtów do zapisania."
  overload: System.IO.FileStream.Write*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset</code>i <code>count</code> opisano nieprawidłowy zakres w <code>array</code>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>lub <code>count</code> jest ujemna."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred.  \n  \n \\- or -  \n  \n Another thread may have caused an unexpected change in the position of the operating system's file handle."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Strumień jest zamknięty."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Bieżące wystąpienie strumień nie obsługuje zapisywania."
  platform:
  - net462
- uid: System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Asynchronicznie zapisuje sekwencję bajtów do strumienia bieżącego przesuwa bieżącą pozycję w tym strumieniu przez liczba zapisanych bajtów i monitoruje żądania anulowania."
  remarks: "Metoda WriteAsync umożliwia wykonywanie operacji na plikach obciążający zasoby bez blokowania głównego wątku. Uwaga dotycząca wydajności jest szczególnie ważne w [!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)] aplikacji lub [!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)] aplikacji, gdy operacja czasochłonne strumienia można blokować wątku interfejsu użytkownika i zapewnić aplikacji są wyświetlane tak, jakby nie działa. Metody asynchroniczne są używane w połączeniu z `async` i `await` słów kluczowych w języku Visual Basic i C#.       Użyj <xref:System.IO.FileStream.CanWrite%2A>Właściwości w celu określenia, czy bieżące wystąpienie obsługuje odczytu.</xref:System.IO.FileStream.CanWrite%2A>       Jeśli operacja została anulowana przed ukończeniem działania, zwrócone zadania zawiera <xref:System.Threading.Tasks.TaskStatus>wartość <xref:System.Threading.Tasks.Task.Status%2A>Właściwości.</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus> Jeśli zostanie usunięty, dojście do pliku, zwrócone zadania zawiera <xref:System.ObjectDisposedException>wyjątek w <xref:System.Threading.Tasks.Task.Exception%2A>Właściwości.</xref:System.Threading.Tasks.Task.Exception%2A> </xref:System.ObjectDisposedException>"
  example:
  - "The following example shows how to write asynchronously to a file.  \n  \n [!code-vb[Asynchronous_File_IO_async#3](~/add/codesnippet/visualbasic/7726d527-d678-42ba-9864-_1.vb)]\n [!code-cs[Asynchronous_File_IO_async#3](~/add/codesnippet/csharp/7726d527-d678-42ba-9864-_1.cs)]"
  syntax:
    content: public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Bufor zapisywania danych z."
    - id: offset
      type: System.Int32
      description: "Zerze przesunięcie w `buffer` z którego należy zacząć kopiowanie bajtów do strumienia."
    - id: count
      type: System.Int32
      description: "Maksymalna liczba bajtów do zapisania."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Token do monitorowania żądań anulowania."
    return:
      type: System.Threading.Tasks.Task
      description: "Zadanie reprezentujące operację asynchronicznego zapisu."
  overload: System.IO.FileStream.WriteAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>lub <code>count</code> jest ujemna."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Suma <code> offset </code> i <code> count </code> jest większa niż długość buforu."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Strumień nie obsługuje zapisywania."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Strumień został usunięty."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Strumień jest obecnie używany przez poprzednią operację zapisu."
  platform:
  - net462
- uid: System.IO.FileStream.WriteByte(System.Byte)
  id: WriteByte(System.Byte)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: WriteByte(Byte)
  nameWithType: FileStream.WriteByte(Byte)
  fullName: System.IO.FileStream.WriteByte(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Zapisuje bajt bieżącą pozycję w strumieniu plików."
  remarks: "Ta metoda zastępuje <xref:System.IO.Stream.WriteByte%2A>.</xref:System.IO.Stream.WriteByte%2A>       Użyj `WriteByte` do bajtów do zapisania `FileStream` wydajnie. Jeśli strumień jest zamknięty lub nie jest zapisywalny, zostanie wygenerowany wyjątek.      > [!NOTE] > Użyj <xref:System.IO.FileStream.CanWrite%2A>Właściwości w celu określenia, czy bieżące wystąpienie obsługuje zapisu.</xref:System.IO.FileStream.CanWrite%2A> Aby uzyskać dodatkowe informacje zobacz <xref:System.IO.Stream.CanWrite%2A>.</xref:System.IO.Stream.CanWrite%2A>"
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.w_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.w_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.w_0_1.cpp)]"
  syntax:
    content: public override void WriteByte (byte value);
    parameters:
    - id: value
      type: System.Byte
      description: "Bajtów do zapisania w strumieniu."
  overload: System.IO.FileStream.WriteByte*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Strumień jest zamknięty."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Strumień nie obsługuje zapisywania."
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.DirectoryNotFoundException
  isExternal: true
  name: System.IO.DirectoryNotFoundException
- uid: System.IO.PathTooLongException
  isExternal: true
  name: System.IO.PathTooLongException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.IO.EndOfStreamException
  isExternal: true
  name: System.IO.EndOfStreamException
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess)
- uid: Microsoft.Win32.SafeHandles.SafeFileHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeFileHandle
  nameWithType: SafeFileHandle
  fullName: Microsoft.Win32.SafeHandles.SafeFileHandle
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess)
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode)
  nameWithType: FileStream.FileStream(String,FileMode)
  fullName: System.IO.FileStream.FileStream(String,FileMode)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess,Int32)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess)
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean,Int32)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
- uid: System.IO.FileOptions
  parent: System.IO
  isExternal: false
  name: FileOptions
  nameWithType: FileOptions
  fullName: System.IO.FileOptions
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
- uid: System.Security.AccessControl.FileSystemRights
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSystemRights
  nameWithType: FileSystemRights
  fullName: System.Security.AccessControl.FileSystemRights
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
- uid: System.Security.AccessControl.FileSecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSecurity
  nameWithType: FileSecurity
  fullName: System.Security.AccessControl.FileSecurity
- uid: System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IO.FileStream.CanRead
  parent: System.IO.FileStream
  isExternal: false
  name: CanRead
  nameWithType: FileStream.CanRead
  fullName: System.IO.FileStream.CanRead
- uid: System.IO.FileStream.CanSeek
  parent: System.IO.FileStream
  isExternal: false
  name: CanSeek
  nameWithType: FileStream.CanSeek
  fullName: System.IO.FileStream.CanSeek
- uid: System.IO.FileStream.CanWrite
  parent: System.IO.FileStream
  isExternal: false
  name: CanWrite
  nameWithType: FileStream.CanWrite
  fullName: System.IO.FileStream.CanWrite
- uid: System.IO.FileStream.Dispose(System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: FileStream.Dispose(Boolean)
  fullName: System.IO.FileStream.Dispose(Boolean)
- uid: System.IO.FileStream.EndRead(System.IAsyncResult)
  parent: System.IO.FileStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: FileStream.EndRead(IAsyncResult)
  fullName: System.IO.FileStream.EndRead(IAsyncResult)
- uid: System.IO.FileStream.EndWrite(System.IAsyncResult)
  parent: System.IO.FileStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: FileStream.EndWrite(IAsyncResult)
  fullName: System.IO.FileStream.EndWrite(IAsyncResult)
- uid: System.IO.FileStream.Finalize
  parent: System.IO.FileStream
  isExternal: false
  name: Finalize()
  nameWithType: FileStream.Finalize()
  fullName: System.IO.FileStream.Finalize()
- uid: System.IO.FileStream.Flush
  parent: System.IO.FileStream
  isExternal: false
  name: Flush()
  nameWithType: FileStream.Flush()
  fullName: System.IO.FileStream.Flush()
- uid: System.IO.FileStream.Flush(System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: Flush(Boolean)
  nameWithType: FileStream.Flush(Boolean)
  fullName: System.IO.FileStream.Flush(Boolean)
- uid: System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: FileStream.FlushAsync(CancellationToken)
  fullName: System.IO.FileStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.IO.FileStream.GetAccessControl
  parent: System.IO.FileStream
  isExternal: false
  name: GetAccessControl()
  nameWithType: FileStream.GetAccessControl()
  fullName: System.IO.FileStream.GetAccessControl()
- uid: System.IO.FileStream.Handle
  parent: System.IO.FileStream
  isExternal: false
  name: Handle
  nameWithType: FileStream.Handle
  fullName: System.IO.FileStream.Handle
- uid: System.IO.FileStream.IsAsync
  parent: System.IO.FileStream
  isExternal: false
  name: IsAsync
  nameWithType: FileStream.IsAsync
  fullName: System.IO.FileStream.IsAsync
- uid: System.IO.FileStream.Length
  parent: System.IO.FileStream
  isExternal: false
  name: Length
  nameWithType: FileStream.Length
  fullName: System.IO.FileStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.FileStream.Lock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: Lock(Int64,Int64)
  nameWithType: FileStream.Lock(Int64,Int64)
  fullName: System.IO.FileStream.Lock(Int64,Int64)
- uid: System.IO.FileStream.Name
  parent: System.IO.FileStream
  isExternal: false
  name: Name
  nameWithType: FileStream.Name
  fullName: System.IO.FileStream.Name
- uid: System.IO.FileStream.Position
  parent: System.IO.FileStream
  isExternal: false
  name: Position
  nameWithType: FileStream.Position
  fullName: System.IO.FileStream.Position
- uid: System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: FileStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Read(Byte[],Int32,Int32)
- uid: System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.Threading.Tasks.Task{System.Int32}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<Int32>
  nameWithType: Task<Int32>
  fullName: System.Threading.Tasks.Task<System.Int32>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Int32>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.FileStream.ReadByte
  parent: System.IO.FileStream
  isExternal: false
  name: ReadByte()
  nameWithType: FileStream.ReadByte()
  fullName: System.IO.FileStream.ReadByte()
- uid: System.IO.FileStream.SafeFileHandle
  parent: System.IO.FileStream
  isExternal: false
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
  fullName: System.IO.FileStream.SafeFileHandle
- uid: System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.FileStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: FileStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.FileStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  isExternal: false
  name: SetAccessControl(FileSecurity)
  nameWithType: FileStream.SetAccessControl(FileSecurity)
  fullName: System.IO.FileStream.SetAccessControl(FileSecurity)
- uid: System.IO.FileStream.SetLength(System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: FileStream.SetLength(Int64)
  fullName: System.IO.FileStream.SetLength(Int64)
- uid: System.IO.FileStream.Unlock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: Unlock(Int64,Int64)
  nameWithType: FileStream.Unlock(Int64,Int64)
  fullName: System.IO.FileStream.Unlock(Int64,Int64)
- uid: System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: FileStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Write(Byte[],Int32,Int32)
- uid: System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.IO.FileStream.WriteByte(System.Byte)
  parent: System.IO.FileStream
  isExternal: false
  name: WriteByte(Byte)
  nameWithType: FileStream.WriteByte(Byte)
  fullName: System.IO.FileStream.WriteByte(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.IO.FileStream.#ctor*
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream
  nameWithType: FileStream.FileStream
- uid: System.IO.FileStream.BeginRead*
  parent: System.IO.FileStream
  isExternal: false
  name: BeginRead
  nameWithType: FileStream.BeginRead
- uid: System.IO.FileStream.BeginWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: BeginWrite
  nameWithType: FileStream.BeginWrite
- uid: System.IO.FileStream.CanRead*
  parent: System.IO.FileStream
  isExternal: false
  name: CanRead
  nameWithType: FileStream.CanRead
- uid: System.IO.FileStream.CanSeek*
  parent: System.IO.FileStream
  isExternal: false
  name: CanSeek
  nameWithType: FileStream.CanSeek
- uid: System.IO.FileStream.CanWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: CanWrite
  nameWithType: FileStream.CanWrite
- uid: System.IO.FileStream.Dispose*
  parent: System.IO.FileStream
  isExternal: false
  name: Dispose
  nameWithType: FileStream.Dispose
- uid: System.IO.FileStream.EndRead*
  parent: System.IO.FileStream
  isExternal: false
  name: EndRead
  nameWithType: FileStream.EndRead
- uid: System.IO.FileStream.EndWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: EndWrite
  nameWithType: FileStream.EndWrite
- uid: System.IO.FileStream.Finalize*
  parent: System.IO.FileStream
  isExternal: false
  name: Finalize
  nameWithType: FileStream.Finalize
- uid: System.IO.FileStream.Flush*
  parent: System.IO.FileStream
  isExternal: false
  name: Flush
  nameWithType: FileStream.Flush
- uid: System.IO.FileStream.FlushAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: FlushAsync
  nameWithType: FileStream.FlushAsync
- uid: System.IO.FileStream.GetAccessControl*
  parent: System.IO.FileStream
  isExternal: false
  name: GetAccessControl
  nameWithType: FileStream.GetAccessControl
- uid: System.IO.FileStream.Handle*
  parent: System.IO.FileStream
  isExternal: false
  name: Handle
  nameWithType: FileStream.Handle
- uid: System.IO.FileStream.IsAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: IsAsync
  nameWithType: FileStream.IsAsync
- uid: System.IO.FileStream.Length*
  parent: System.IO.FileStream
  isExternal: false
  name: Length
  nameWithType: FileStream.Length
- uid: System.IO.FileStream.Lock*
  parent: System.IO.FileStream
  isExternal: false
  name: Lock
  nameWithType: FileStream.Lock
- uid: System.IO.FileStream.Name*
  parent: System.IO.FileStream
  isExternal: false
  name: Name
  nameWithType: FileStream.Name
- uid: System.IO.FileStream.Position*
  parent: System.IO.FileStream
  isExternal: false
  name: Position
  nameWithType: FileStream.Position
- uid: System.IO.FileStream.Read*
  parent: System.IO.FileStream
  isExternal: false
  name: Read
  nameWithType: FileStream.Read
- uid: System.IO.FileStream.ReadAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: ReadAsync
  nameWithType: FileStream.ReadAsync
- uid: System.IO.FileStream.ReadByte*
  parent: System.IO.FileStream
  isExternal: false
  name: ReadByte
  nameWithType: FileStream.ReadByte
- uid: System.IO.FileStream.SafeFileHandle*
  parent: System.IO.FileStream
  isExternal: false
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
- uid: System.IO.FileStream.Seek*
  parent: System.IO.FileStream
  isExternal: false
  name: Seek
  nameWithType: FileStream.Seek
- uid: System.IO.FileStream.SetAccessControl*
  parent: System.IO.FileStream
  isExternal: false
  name: SetAccessControl
  nameWithType: FileStream.SetAccessControl
- uid: System.IO.FileStream.SetLength*
  parent: System.IO.FileStream
  isExternal: false
  name: SetLength
  nameWithType: FileStream.SetLength
- uid: System.IO.FileStream.Unlock*
  parent: System.IO.FileStream
  isExternal: false
  name: Unlock
  nameWithType: FileStream.Unlock
- uid: System.IO.FileStream.Write*
  parent: System.IO.FileStream
  isExternal: false
  name: Write
  nameWithType: FileStream.Write
- uid: System.IO.FileStream.WriteAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: WriteAsync
  nameWithType: FileStream.WriteAsync
- uid: System.IO.FileStream.WriteByte*
  parent: System.IO.FileStream
  isExternal: false
  name: WriteByte
  nameWithType: FileStream.WriteByte
