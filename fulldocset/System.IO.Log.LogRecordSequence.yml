### YamlMime:ManagedReference
items:
- uid: System.IO.Log.LogRecordSequence
  id: LogRecordSequence
  children:
  - System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)
  - System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)
  - System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.LogRecordSequence.BaseSequenceNumber
  - System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.CreateReservationCollection
  - System.IO.Log.LogRecordSequence.Dispose
  - System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.Flush
  - System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.LastSequenceNumber
  - System.IO.Log.LogRecordSequence.LogStore
  - System.IO.Log.LogRecordSequence.MaximumRecordLength
  - System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  - System.IO.Log.LogRecordSequence.ReadRestartAreas
  - System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.LogRecordSequence.ReservedBytes
  - System.IO.Log.LogRecordSequence.RestartSequenceNumber
  - System.IO.Log.LogRecordSequence.RetryAppend
  - System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.TailPinned
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  langs:
  - csharp
  name: LogRecordSequence
  nameWithType: LogRecordSequence
  fullName: System.IO.Log.LogRecordSequence
  type: Class
  summary: "Reprezentuje sekwencję rekordu przechowywane w <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>."
  remarks: "Klasa LogRecordSequence zawiera implementację interfejsu sekwencja rekordów na górze dziennika wspólnej dziennika File System (CLFS). Oprócz standardowych funkcji zorientowane na rekordy zapewnia model zasad pozwala to uniknąć warunków dziennika pełnej i Multipleksowanie klientów na tym samym pliku fizycznego. W przypadku <xref:System.IO.Log.LogStore>klasy, która zapewnia interfejs bezpośrednio manipulacji i zarządzanie CLFS pliku dziennika.</xref:System.IO.Log.LogStore> Relacja między <xref:System.IO.Log.LogStore>klasy i LogRecordSequence klasy jest podobna do relacji między pliku na dysku i <xref:System.IO.FileStream>obiektu.</xref:System.IO.FileStream> </xref:System.IO.Log.LogStore> Plik dysku zapewnia konkretnych magazynu i atrybuty, takie jak długość i czas ostatniego dostępu; Podczas <xref:System.IO.FileStream>obiektu zawiera widok na plik, który może służyć do odczytu i zapisu do niego.</xref:System.IO.FileStream> Podobnie <xref:System.IO.Log.LogStore>Klasa ma atrybutów, takich jak zasady i kolekcję zakresów dysków; i klasy LogRecordSequence zapewnia mechanizm zorientowane na rekordy do odczytywania i zapisywania danych.</xref:System.IO.Log.LogStore>"
  example:
  - "This example shows how to use the LogRecordSequence class:  \n  \n [!code-cs[S_UELogRecordSequence#0](~/add/codesnippet/csharp/t-system.io.log.logrecor_1.cs)]\n [!code-vb[S_UELogRecordSequence#0](~/add/codesnippet/visualbasic/t-system.io.log.logrecor_1.vb)]"
  syntax:
    content: 'public sealed class LogRecordSequence : IDisposable, System.IO.Log.IRecordSequence'
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  - System.IO.Log.IRecordSequence
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)
  id: '#ctor(System.IO.Log.LogStore)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(LogStore)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> klasy ze sklepem określony dziennik."
  remarks: "Rozmiar buforu określa maksymalny rozmiar rekordu, które mogą być dołączane lub odczytu. W tym konstruktorze ustawiono wartość domyślną 64. Odpowiednią liczbę buforów jest ustawiony na 10."
  syntax:
    content: public LogRecordSequence (System.IO.Log.LogStore logStore);
    parameters:
    - id: logStore
      type: System.IO.Log.LogStore
      description: "<xref href=&quot;System.IO.Log.LogStore&quot;> </xref> Która powinna być używana przez tę sekwencję rekordu."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>logStore</code>jest nieprawidłowy."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)
  id: '#ctor(System.String,System.IO.FileMode)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> klasy z określonej ścieżki do magazynu dziennika i tryb dostępu."
  remarks: "Ten konstruktor inicjuje nowy <xref:System.IO.Log.LogRecordSequence>na nowym <xref:System.IO.Log.LogStore>obiekt, który zostanie otwarty z określoną ścieżką i trybu.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> Otrzymuje dostęp do odczytu/zapisu w magazynie, a Magazyn jest otwarty, udostępnianie dostęp do odczytu."
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode);
    parameters:
    - id: path
      type: System.String
      description: "Względna lub bezwzględna ścieżka pliku podstawowego magazynu dziennika do otwarcia."
    - id: mode
      type: System.IO.FileMode
      description: "Jeden z <xref href=&quot;System.IO.FileMode&quot;> </xref> wartości, które określa, jak otworzyć lub utworzyć magazynu."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>to ciąg pusty (&quot;&quot;).       - lub - <code>path</code> zawiera tylko biały znak.       - lub - <code>path</code> zawiera jeden lub więcej nieprawidłowych znaków."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>zawiera nieprawidłową wartość."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Nie można odnaleźć pliku."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Występuje błąd We/Wy podczas otwierania magazynu dziennika."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Ta operacja nie jest obsługiwana."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>Nie można użyć, ponieważ wymagany składnik wspólnej dziennika File System (CLFS) nie jest zainstalowany. Zainstaluj składnik CLFS, jeśli jest dostępna dla danej platformy, lub użyj <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> klasy."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)
  id: '#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(LogStore,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> klasy ze sklepem dziennika określony rozmiar buforu dla każdego rekordu, a numer buforu."
  remarks: "Użyj tego konstruktora, jeśli chcesz określić wartości dla `bufferSize` i `bufferCount` i nie chcesz używać domyślnej wartości 64 dla `bufferSize` i 10 dla `bufferCount`."
  syntax:
    content: public LogRecordSequence (System.IO.Log.LogStore logStore, int bufferSize, int bufferCount);
    parameters:
    - id: logStore
      type: System.IO.Log.LogStore
      description: "<xref href=&quot;System.IO.Log.LogStore&quot;> </xref> Która powinna być używana przez tę sekwencję rekordu."
    - id: bufferSize
      type: System.Int32
      description: "Bufor żądany rozmiar w bajtach. Rozmiar buforu określa maksymalny rozmiar rekordu, które mogą być dołączane lub odczytu."
    - id: bufferCount
      type: System.Int32
      description: "Odpowiednią liczbę buforów."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>logStore</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize </code>ma wartość ujemną lub wartość zero.       - lub - <code>bufferCount</code> jest ujemny lub zero."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> klasy z określonej ścieżki do magazynu dziennika i tryby dostępu i udostępniania."
  remarks: "Ten konstruktor inicjuje nowy <xref:System.IO.Log.LogRecordSequence>na nowym <xref:System.IO.Log.LogStore>obiekt, który zostanie otwarty z określonej ścieżki, tryb i dostępu.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> Magazyn jest otwarty, udostępnianie dostęp do odczytu."
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "Względna lub bezwzględna ścieżka pliku podstawowego magazynu dziennika do otwarcia."
    - id: mode
      type: System.IO.FileMode
      description: "Jeden z <xref href=&quot;System.IO.FileMode&quot;> </xref> wartości, które określa, jak otworzyć lub utworzyć magazynu."
    - id: access
      type: System.IO.FileAccess
      description: "Jeden z <xref href=&quot;System.IO.FileAccess&quot;> </xref> wartości, które określa, jak można uzyskać dostępu do pliku <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>to ciąg pusty (&quot;&quot;).       - lub - <code>path</code> zawiera tylko biały znak.       - lub - <code>path</code> zawiera jeden lub więcej nieprawidłowych znaków."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>zawiera nieprawidłową wartość."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Nie można odnaleźć pliku."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Występuje błąd We/Wy podczas otwierania magazynu dziennika."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Ta operacja nie jest obsługiwana."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>Nie można użyć, ponieważ wymagany składnik wspólnej dziennika File System (CLFS) nie jest zainstalowany. Zainstaluj składnik CLFS, jeśli jest dostępna dla danej platformy, lub użyj <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> klasy."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> klasy z określonej ścieżki do magazynu dziennika i tryb dostępu."
  remarks: "Ten konstruktor inicjuje nowy <xref:System.IO.Log.LogRecordSequence>na nowym <xref:System.IO.Log.LogStore>obiekt, który zostanie otwarty z określonej ścieżki, tryb i dostępu.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> Magazyn jest otwarty, udostępnianie określonego dostępu."
  example:
  - "This example shows how to use this <xref:System.IO.Log.LogRecordSequence> constructor:  \n  \n [!code-cs[S_UELogRecordSequence#1](~/add/codesnippet/csharp/5a33f64b-b9a0-4b07-9df4-_1.cs)]\n [!code-vb[S_UELogRecordSequence#1](~/add/codesnippet/visualbasic/5a33f64b-b9a0-4b07-9df4-_1.vb)]"
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: path
      type: System.String
      description: "Względna lub bezwzględna ścieżka pliku podstawowego magazynu dziennika do otwarcia."
    - id: mode
      type: System.IO.FileMode
      description: "Jeden z <xref href=&quot;System.IO.FileMode&quot;> </xref> wartości, które określa, jak otworzyć lub utworzyć magazynu."
    - id: access
      type: System.IO.FileAccess
      description: "Jeden z <xref href=&quot;System.IO.FileAccess&quot;> </xref> wartości, które określa, jak można uzyskać dostępu do pliku <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>."
    - id: share
      type: System.IO.FileShare
      description: "Jeden z <xref href=&quot;System.IO.FileShare&quot;> </xref> wartości, które określa, jak magazynu dziennika będzie współdzielona przez procesy."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>to ciąg pusty (&quot;&quot;).       - lub - <code>path</code> zawiera tylko biały znak.       - lub - <code>path</code> zawiera jeden lub więcej nieprawidłowych znaków."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>zawiera nieprawidłową wartość."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Nie można odnaleźć pliku."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Występuje błąd We/Wy podczas otwierania magazynu dziennika."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Ta operacja nie jest obsługiwana."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>Nie można użyć, ponieważ wymagany składnik wspólnej dziennika File System (CLFS) nie jest zainstalowany. Zainstaluj składnik CLFS, jeśli jest dostępna dla danej platformy, lub użyj <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> klasy."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> klasy z określonej ścieżki do magazynu dziennika, uprawnień do pliku, trybami dostępu i udostępniania, a rozmiar buforu i liczby rekordów."
  remarks: "Ten konstruktor inicjuje nowy <xref:System.IO.Log.LogRecordSequence>na nowym <xref:System.IO.Log.LogStore>obiekt, który zostanie otwarty z określonej ścieżki, tryb i dostępu.</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> Magazyn jest otwarty, udostępnianie określonego dostępu."
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount);
    parameters:
    - id: path
      type: System.String
      description: "Względna lub bezwzględna ścieżka pliku podstawowego magazynu dziennika do otwarcia."
    - id: mode
      type: System.IO.FileMode
      description: "Jeden z <xref href=&quot;System.IO.FileMode&quot;> </xref> wartości, które określa, jak otworzyć lub utworzyć magazynu."
    - id: access
      type: System.IO.FileAccess
      description: "Jeden z <xref href=&quot;System.IO.FileAccess&quot;> </xref> wartości, które określa, jak można uzyskać dostępu do pliku <xref href=&quot;System.IO.Log.LogStore&quot;> </xref>."
    - id: share
      type: System.IO.FileShare
      description: "Jeden z <xref href=&quot;System.IO.FileShare&quot;> </xref> wartości, które określa, jak magazynu dziennika będzie współdzielona przez procesy."
    - id: bufferSize
      type: System.Int32
      description: "Bufor żądany rozmiar w bajtach. Rozmiar buforu określa maksymalny rozmiar rekordu, które mogą być dołączane lub odczytu."
    - id: bufferCount
      type: System.Int32
      description: "Odpowiednią liczbę buforów."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>to ciąg pusty (&quot;&quot;).       - lub - <code>path</code> zawiera tylko biały znak.       - lub - <code>path</code> zawiera jeden lub więcej nieprawidłowych znaków."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>zawiera nieprawidłową wartość."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Nie można odnaleźć pliku."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Występuje błąd We/Wy podczas otwierania magazynu dziennika."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Ta operacja nie jest obsługiwana."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>Nie można użyć, ponieważ wymagany składnik wspólnej dziennika File System (CLFS) nie jest zainstalowany. Zainstaluj składnik CLFS, jeśli jest dostępna dla danej platformy, lub użyj <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> klasy."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> klasy."
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount, System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: path
      type: System.String
      description: "Względna lub bezwzględna ścieżka pliku podstawowego magazynu dziennika do otwarcia."
    - id: mode
      type: System.IO.FileMode
      description: "Prawidłowy <xref href=&quot;System.IO.FileMode&quot;> </xref> wartość określającą, jak otworzyć lub utworzyć magazynu."
    - id: access
      type: System.IO.FileAccess
      description: "Prawidłowy <xref href=&quot;System.IO.FileAccess&quot;> </xref> wartość, która określa, jak można uzyskać dostępu do magazynu dziennika."
    - id: share
      type: System.IO.FileShare
      description: "Prawidłowy <xref href=&quot;System.IO.FileShare&quot;> </xref> wartość, która określa, jak magazynu dziennika będzie współdzielona przez procesy."
    - id: bufferSize
      type: System.Int32
      description: "Bufor żądany rozmiar w bajtach. Rozmiar buforu określa maksymalny rozmiar rekordu, które mogą być dołączane lub odczytu."
    - id: bufferCount
      type: System.Int32
      description: "Odpowiednią liczbę buforów."
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "Prawidłowy <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref> wartość, która określa zabezpieczeń można ustawić na nowo utworzony magazyn, jeśli magazyn musi zostać utworzony."
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Plik określony przez <code> path </code> jest nieprawidłowy.       - lub - nazwa pliku magazynu określony dziennik jest nieprawidłowa.       - lub - <code> mode </code> ma wartość <xref href=&quot;System.IO.FileMode&quot;> </xref>i nie można używać bez dostępu do zapisu.       - lub - <code> mode </code> ma wartość <xref href=&quot;System.IO.FileMode&quot;> </xref>i nie można używać bez dostępu do zapisu."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Co najmniej jeden z argumentów jest poza zakresem."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Plik określony przez <code> path </code> nie można odnaleźć."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.       - lub - plik określony przez <code> path </code> jest niedostępny, ponieważ jest on używany przez inny proces.       - lub - plik określony przez <code> path </code> nie można utworzyć, ponieważ plik lub katalog już istnieje.       - lub - nie można powiązać dojścia dziennika z pulą wątków.       - lub - format pliku dziennika określonego lub wersja jest nieprawidłowa."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Ta operacja nie jest obsługiwana."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>Nie można użyć, ponieważ wymagany składnik wspólnej dziennika File System (CLFS) nie jest zainstalowany. Zainstaluj składnik CLFS, jeśli jest dostępna dla danej platformy, lub użyj <xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref> klasy."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  id: AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Przenosi do przodu numer sekwencji podstawowej dziennika. Ta metoda nie może być dziedziczona."
  remarks: "Ta metoda jest często używane z <xref:System.IO.Log.LogRecordSequence.TailPinned>zdarzeń w celu zwolnienia miejsca w rekordzie.</xref:System.IO.Log.LogRecordSequence.TailPinned> <xref:System.IO.Log.LogRecordSequence.TailPinned>Zdarzeń wskazuje tail sekwencji (to znaczy numer sekwencji podstawowej) musi zostać przesunięty w celu zwolnienia miejsca.</xref:System.IO.Log.LogRecordSequence.TailPinned> Zwalnianie miejsca może odbywać się za pomocą albo ponownie uruchom za pomocą <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>metody, lub obcinanie dziennika i przy użyciu metody AdvanceBaseSequenceNumber przesuwających numer sekwencji podstawowej dziennika do określonego przez `newBaseSequenceNumber` parametru.</xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> Przykładowy kod w sekcji przykładzie pokazano drugiej metody.       Należy pamiętać, że wywołanie tej metody jest taka sama jak ustawienie nowego podstawowego sekwencji numeru przy użyciu <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>metody, z wyjątkiem tego, że żaden rekord ponownego uruchomienia komputera są zapisywane w dzienniku</xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>"
  example:
  - "This example shows how to use the AdvanceBaseSequenceNumber method with the <xref:System.IO.Log.LogRecordSequence.TailPinned> event to free up space in a log sequence.  \n  \n```  \nrecordSequence.RetryAppend = true;  \nrecordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  \n  \nvoid HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  \n{  \n   // tailPinnedEventArgs.TargetSequenceNumber is the target   \n   // sequence number to free up space to.    \n   // However, this sequence number is not necessarily valid.  We have  \n   // to use this sequence number as a starting point for finding a  \n   // valid point within the log to advance toward. You need to  \n   // identify a record with a sequence number equal to, or greater  \n   // than TargetSequenceNumber; let's call this   \n   // realTargetSequenceNumber. Once found, move the base  \n  \n   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  \n  \n}  \n```"
  syntax:
    content: public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Określa nowe base <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> dziennika. To musi znajdować się w zakresie od bieżący numer sekwencyjny podstawowej i ostatni numer sekwencyjny dziennika (włącznie)."
  overload: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSequenceNumber</code>jest nieprawidłowy dla tej sekwencji."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Nowy lub istniejący element archiwum albo podstawa aktywnego dziennika jest nieprawidłowa.       - lub - <code> newBaseSequenceNumber </code> nie jest od podstawowego do ostatniego numeru sekwencji."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.       - lub - nie można wykonać żądania z powodu błędu urządzenia We/Wy."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Określony dziennik nie zawiera żadnych zakresów. Było użyć sekwencji rekordu, należy utworzyć jeden lub więcej zakresów."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Zapisuje rekord dziennika <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>. Ta metoda nie może być dziedziczona."
  remarks: "Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A>metody.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  example:
  - "The following example demonstrates how to use this method to append a log record to the sequence.  \n  \n [!code-cs[S_UELogRecordSequence#13](~/add/codesnippet/csharp/11cb4ef9-9d52-4994-983c-_1.cs)]\n [!code-vb[S_UELogRecordSequence#13](~/add/codesnippet/visualbasic/11cb4ef9-9d52-4994-983c-_1.vb)]"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji rekordu dziennika dołączany."
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>lub <code>previousRecord</code> jest nieprawidłowy dla tej sekwencji.       - lub - <code>data</code> nie można dołączyć, ponieważ ma on większy niż maksymalna wielkość rekordu.       - lub - <code>reservations</code> nie został utworzony przez tę sekwencję rekordu."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>lub <code>previousRecord</code> nie jest od podstawowego do ostatniego numeru sekwencji."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.       - lub - nie można wykonać żądania z powodu błędu urządzenia We/Wy."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Dołącza do rekordu dziennika <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>. Ta metoda nie może być dziedziczona."
  remarks: "Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A>metody.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji rekordu dziennika dołączany."
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>lub <code>previousRecord</code> jest nieprawidłowy dla tej sekwencji.       - lub - <code>data</code> nie można dołączyć, ponieważ ma on większy niż maksymalna wielkość rekordu.       - lub - <code>reservations</code> nie został utworzony przez tę sekwencję rekordu."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>lub <code>previousRecord</code> nie jest od podstawowego do ostatniego numeru sekwencji."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.       - lub - nie można wykonać żądania z powodu błędu urządzenia We/Wy."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Dołącza do rekordu dziennika <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>, przy użyciu wcześniej zastrzeżonej w sekwencji. Ta metoda nie może być dziedziczona."
  remarks: "Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Dołączany rekordu będzie zajmować dużo miejsca, wcześniej zarezerwowanych, za pomocą rezerwacji, określony przez `reservations` parametru. Dołącz zakończy się powodzeniem, zużyje na najmniejszą obszaru rezerwacji, który przechowywania danych, a obszar rezerwacji zostanie usunięty z kolekcji.       Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A>metody.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> zawierający rezerwacji, które mają być używane dla tego rekordu."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji rekordu dziennika dołączany."
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>lub <code>previousRecord</code> jest nieprawidłowy dla tej sekwencji.       - lub - <code>data</code> nie można dołączyć, ponieważ ma on większy niż maksymalna wielkość rekordu.       - lub - <code>reservations</code> nie został utworzony przez tę sekwencję rekordu."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>lub <code>previousRecord</code> nie jest od podstawowego do ostatniego numeru sekwencji."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.       - lub - nie można wykonać żądania z powodu błędu urządzenia We/Wy."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Rezerwacja nie jest wystarczająco duży, aby zmieścić <code> data </code> znajdują się w <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Dołącza do rekordu dziennika <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>, przy użyciu wcześniej zastrzeżonej w sekwencji. Ta metoda nie może być dziedziczona."
  remarks: "Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Dołączany rekordu będzie zajmować dużo miejsca, wcześniej zarezerwowanych, za pomocą rezerwacji, określony przez `reservations` parametru. Dołącz zakończy się powodzeniem, zużyje na najmniejszą obszaru rezerwacji, który przechowywania danych, a obszar rezerwacji zostanie usunięty z kolekcji.       Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.IRecordSequence.Flush%2A>metody.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> zawierający rezerwacji, które mają być używane dla tego rekordu."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji rekordu dziennika dołączany."
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>lub <code>previousRecord</code> jest nieprawidłowy dla tej sekwencji.       - lub - <code>data</code> nie można dołączyć, ponieważ ma on większy niż maksymalna wielkość rekordu.       - lub - <code>reservations</code> nie został utworzony przez tę sekwencję rekordu."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>lub <code>previousRecord</code> nie jest od podstawowego do ostatniego numeru sekwencji."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.       - lub - nie można wykonać żądania z powodu błędu urządzenia We/Wy."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Rezerwacja nie jest wystarczająco duży, aby zmieścić <code> data </code> znajdują się w <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BaseSequenceNumber
  id: BaseSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BaseSequenceNumber
  nameWithType: LogRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.BaseSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Pobiera numer sekwencji pierwszy rekord prawidłowe w bieżącym <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>."
  remarks: "Prawidłowych numerów sekwencji jest większa niż lub równa BaseSequenceNumber i mniejsza niż <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.</xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>       Wartość tej właściwości można zmienić przez wywołanie metody <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>metody lub <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>metody.</xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> </xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>"
  example:
  - "This example shows how to use the BaseSequenceNumber member in a loop.  \n  \n [!code-cs[S_UELogRecordSequence#10](~/add/codesnippet/csharp/p-system.io.log.logrecor_2_1.cs)]\n [!code-vb[S_UELogRecordSequence#10](~/add/codesnippet/visualbasic/p-system.io.log.logrecor_2_1.vb)]"
  syntax:
    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "Najniższy numer sekwencji, umożliwiająca prawidłowy rekord w <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>."
  overload: System.IO.Log.LogRecordSequence.BaseSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Właściwość uzyskano po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Rozpoczyna się asynchroniczną operację dołączania. Ta metoda nie może być dziedziczona."
  remarks: "Należy przekazać <xref:System.IAsyncResult>zwrócona przez tę metodę w celu <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>metodę, aby zapewnić, że ukończono operacji dołączania i zasobów można odpowiednio zwalniane.</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Jeśli wystąpił błąd podczas dołączania asynchroniczne, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>Metoda jest wywoływana z <xref:System.IAsyncResult>zwracane przez tę metodę.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A>metody.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu dołączania."
    - id: state
      type: System.Object
      description: "Dostarczane przez użytkownika obiekt, który odróżni ten określonego asynchroniczne Dołącz żądań z innych żądań."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Reprezentujący Dołącz asynchroniczne mogą nadal oczekiwać.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>nextUndoRecord</code>lub <code>previousRecord</code> jest nieprawidłowy dla tej sekwencji.       - lub - <code>data</code> nie można dołączyć, ponieważ ma on większy niż maksymalna wielkość rekordu.       - lub - <code>reservations</code> nie został utworzony przez tę sekwencję rekordu."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>nextUndoRecord</code>lub <code>previousRecord</code> nie jest od podstawowego do ostatniego numeru sekwencji."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.       - lub - nie można wykonać żądania z powodu błędu urządzenia We/Wy."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Rozpoczyna się asynchroniczną operację dołączania. Ta metoda nie może być dziedziczona."
  remarks: "Należy przekazać <xref:System.IAsyncResult>zwrócona przez tę metodę w celu <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>metodę, aby zapewnić, że ukończono operacji dołączania i zasobów można odpowiednio zwalniane.</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Jeśli wystąpił błąd podczas dołączania asynchroniczne, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>Metoda jest wywoływana z <xref:System.IAsyncResult>zwracane przez tę metodę.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A>metody.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu dołączania."
    - id: state
      type: System.Object
      description: "Dostarczane przez użytkownika obiekt, który odróżni ten określonego asynchroniczne Dołącz żądań z innych żądań."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Reprezentujący Dołącz asynchroniczne mogą nadal oczekiwać.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>lub <code>previousRecord</code> jest nieprawidłowy dla tej sekwencji.       - lub - <code>data</code> nie można dołączyć, ponieważ ma on większy niż maksymalna wielkość rekordu.       - lub - <code>reservations</code> nie został utworzony przez tę sekwencję rekordu."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>lub <code>previousRecord</code> nie jest od podstawowego do ostatniego numeru sekwencji."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.       - lub - nie można wykonać żądania z powodu błędu urządzenia We/Wy."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Rozpoczyna się asynchroniczną operację dołączania. Ta metoda nie może być dziedziczona."
  remarks: "Należy przekazać <xref:System.IAsyncResult>zwrócona przez tę metodę w celu <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>metodę, aby zapewnić, że ukończono operacji dołączania i zasobów można odpowiednio zwalniane.</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Jeśli wystąpił błąd podczas dołączania asynchroniczne, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>Metoda jest wywoływana z <xref:System.IAsyncResult>zwracane przez tę metodę.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Dołączany rekordu będzie zajmować dużo miejsca, wcześniej zarezerwowanych, za pomocą rezerwacji, określony przez `reservations` parametru. Dołącz zakończy się powodzeniem, zużyje na najmniejszą obszaru rezerwacji, który przechowywania danych, a obszar rezerwacji zostanie usunięty z kolekcji.       Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A>metody.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> zawierający rezerwacji, które mają być używane dla tego rekordu."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu dołączania."
    - id: state
      type: System.Object
      description: "Dostarczane przez użytkownika obiekt, który odróżni ten określonego asynchroniczne Dołącz żądań z innych żądań."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Reprezentujący Dołącz asynchroniczne mogą nadal oczekiwać.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>lub <code>previousRecord</code> jest nieprawidłowy dla tej sekwencji.       - lub - <code>data</code> nie można dołączyć, ponieważ ma on większy niż maksymalna wielkość rekordu.       - lub - <code>reservations</code> nie został utworzony przez tę sekwencję rekordu."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>lub <code>previousRecord</code> nie jest od podstawowego do ostatniego numeru sekwencji."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.       - lub - nie można wykonać żądania z powodu błędu urządzenia We/Wy."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Rezerwacja nie jest wystarczająco duży, aby zmieścić <code> data </code> znajdują się w <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Rozpoczyna się asynchroniczną operację dołączania. Ta metoda nie może być dziedziczona."
  remarks: "Należy przekazać <xref:System.IAsyncResult>zwrócona przez tę metodę w celu <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>metodę, aby zapewnić, że ukończono operacji dołączania i zasobów można odpowiednio zwalniane.</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Jeśli wystąpił błąd podczas dołączania asynchroniczne, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.LogRecordSequence.EndAppend%2A>Metoda jest wywoływana z <xref:System.IAsyncResult>zwracane przez tę metodę.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Dołączany rekordu będzie zajmować dużo miejsca, wcześniej zarezerwowanych, za pomocą rezerwacji, określony przez `reservations` parametru. Dołącz zakończy się powodzeniem, zużyje na najmniejszą obszaru rezerwacji, który przechowywania danych, a obszar rezerwacji zostanie usunięty z kolekcji.       Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A>metody.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> zawierający rezerwacji, które mają być używane dla tego rekordu."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu dołączania."
    - id: state
      type: System.Object
      description: "Dostarczane przez użytkownika obiekt, który odróżni ten określonego asynchroniczne Dołącz żądań z innych żądań."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Reprezentujący Dołącz asynchroniczne mogą nadal oczekiwać.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>lub <code>previousRecord</code> jest nieprawidłowy dla tej sekwencji.       - lub - <code>data</code> nie można dołączyć, ponieważ ma on większy niż maksymalna wielkość rekordu.       - lub - <code>reservations</code> nie został utworzony przez tę sekwencję rekordu."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>lub <code>previousRecord</code> nie jest od podstawowego do ostatniego numeru sekwencji."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.       - lub - nie można wykonać żądania z powodu błędu urządzenia We/Wy."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Rezerwacja nie jest wystarczająco duży, aby zmieścić <code> data </code> znajdują się w <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  id: BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Rozpoczyna operację asynchroniczną opróżniania, przy użyciu wcześniej zastrzeżonej w sekwencji. Ta metoda nie może być dziedziczona."
  remarks: "Należy przekazać <xref:System.IAsyncResult>zwróconych przez metodę bieżącego <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>metodę, aby zapewnić, że zakończeniu opróżniania i zasoby są zwalniane odpowiednio.</xref:System.IO.Log.LogRecordSequence.EndFlush%2A> </xref:System.IAsyncResult> Jeśli wystąpi błąd podczas asynchronicznego opróżniania, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>Metoda jest wywoływana z <xref:System.IAsyncResult>zwracane przez tę metodę.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndFlush%2A>       Wywołanie tej metody gwarantuje, że wszystkie rekordy, które zostały dołączone do <xref:System.IO.Log.LogRecordSequence>trwałym są zapisywane.</xref:System.IO.Log.LogRecordSequence>       Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchronicznego opróżniania, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.LogRecordSequence.EndFlush%2A>Metoda jest wywoływana.</xref:System.IO.Log.LogRecordSequence.EndFlush%2A>"
  syntax:
    content: public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji najnowsze rekordu, który musi być napisana. Jeśli <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> jest nieprawidłowy, a następnie wszystkie rekordy muszą być zapisane."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu flush."
    - id: state
      type: System.Object
      description: "Obiekt dostarczane przez użytkownika, która odróżnia to asynchroniczne żądanie opróżniania od innych żądań."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Czy reprezentuje asynchroniczną opróżnić operacja, która może nadal oczekiwać.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>jest nieprawidłowy dla tej sekwencji."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>sequenceNumber</code>nie jest od podstawowego do ostatniego numeru sekwencji."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Określony dziennik nie zawiera żadnych zakresów. Przed użyciem sekwencja rekordów, należy utworzyć jeden lub więcej zakresów."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Rozpoczyna się rezerwy asynchroniczne i Dołącz operacji. Ta metoda nie może być dziedziczona."
  remarks: "Należy przekazać <xref:System.IAsyncResult>zwrócona przez tę metodę w celu <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>metodę, aby zapewnić, że ukończono operacji dołączania i zasobów można odpowiednio zwalniane.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> Jeśli wystąpił błąd podczas dołączania asynchroniczne, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>Metoda jest wywoływana z <xref:System.IAsyncResult>zwracane przez tę metodę.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>       Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Określony rezerwacji są dodawane podana rezerwacji operację dołączania kolekcji w niepodzielną operację z rekordu. W przypadku niepowodzenia Dołącz miejsce nie jest zarezerwowana.       Zwykle ta metoda może zakończyć się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A>metody.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>Metoda jest wywoływana.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "Kolekcja rezerwacji dokonanie rezerwacji w."
    - id: reservations
      type: System.Int64[]
      description: "Zastrzeżenia dokonanie w bajtach."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu dołączania."
    - id: state
      type: System.Object
      description: "Dostarczane przez użytkownika obiekt, który odróżni ten określonego asynchroniczne Dołącz żądań z innych żądań."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Reprezentujący operację asynchroniczną, która może być oczekujące.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>lub <code>previousRecord</code> jest nieprawidłowy dla tej sekwencji.       - lub - <code>data</code> nie można dołączyć, ponieważ ma on większy niż maksymalna wielkość rekordu.       - lub - <code>reservations</code> nie został utworzony przez tę sekwencję rekordu."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>lub <code>previousRecord</code> nie jest od podstawowego do ostatniego numeru sekwencji."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.       - lub - nie można wykonać żądania z powodu błędu urządzenia We/Wy."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Rezerwacja nie jest wystarczająco duży, aby zmieścić <code> data </code> znajdują się w <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Rozpoczyna się rezerwy asynchroniczne i Dołącz operacji. Ta metoda nie może być dziedziczona."
  remarks: "Należy przekazać <xref:System.IAsyncResult>zwrócona przez tę metodę w celu <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>metodę, aby zapewnić, że ukończono operacji dołączania i zasobów można odpowiednio zwalniane.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> Jeśli wystąpił błąd podczas dołączania asynchroniczne, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>Metoda jest wywoływana z <xref:System.IAsyncResult>zwracane przez tę metodę.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>       Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Określony rezerwacji są dodawane podana rezerwacji operację dołączania kolekcji w niepodzielną operację z rekordu. W przypadku niepowodzenia Dołącz miejsce nie jest zarezerwowana.       Zwykle ta metoda może zakończyć się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A>metody.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>Metoda jest wywoływana.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "Kolekcja rezerwacji dokonanie rezerwacji w."
    - id: reservations
      type: System.Int64[]
      description: "Zastrzeżenia dokonanie w bajtach."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu dołączania."
    - id: state
      type: System.Object
      description: "Dostarczane przez użytkownika obiekt, który odróżni ten określonego asynchroniczne Dołącz żądań z innych żądań."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Reprezentujący operację asynchroniczną, która może być oczekujące.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas dołączania rekordu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów nie można utworzyć wystarczającej ilości wolnego miejsca na zawierają nowy rekord lub aby wprowadzić zastrzeżenie."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Rozpoczyna się operacji zapisu obszaru asynchroniczne ponowne uruchomienie, przy użyciu wcześniej zastrzeżonej w sekwencji. Ta metoda nie może być dziedziczona."
  remarks: "Należy przekazać <xref:System.IAsyncResult>zwrócona przez tę metodę w celu <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>metodę, aby zapewnić, że operacja zapisu obszaru ponowne uruchomienie zostało ukończone i zasobów można odpowiednio zwalniane.</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> Jeśli wystąpił błąd podczas operacji zapisu obszaru asynchroniczne ponowne uruchomienie, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>Metoda jest wywoływana z <xref:System.IAsyncResult>zwracane przez tę metodę.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>       Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Po pomyślnym zakończeniu operacji numer sekwencyjny podstawowy został zaktualizowany. Rejestrowania wszystkich rekordów z numerami sekwencji mniej niż nowy numer sekwencji podstawowej są niedostępne.       Jeśli <xref:System.IO.Log.ReservationCollection>określono obszaru napisane ponownego uruchamiania będą korzystać z miejsca wcześniej zarezerwowanych, za pomocą rezerwacji zawartych w kolekcji.</xref:System.IO.Log.ReservationCollection> Jeśli metoda zakończy się powodzeniem, zużyje najmniejszą rezerwacji, który przechowywania danych, a rezerwacji zostanie usunięty z kolekcji.       Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>Metoda jest wywoływana.</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Segmentów tablicy bajtów, które będą połączone i dołączone jako rekord."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa bieżący numer sekwencyjny podstawowej."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> zawierający rezerwacji, które mają być używane dla tego obszaru ponownego uruchomienia."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu zapisu obszaru ponownego uruchomienia."
    - id: state
      type: System.Object
      description: "Obiekt dostarczane przez użytkownika, która odróżnia to żądanie zapisu obszaru określonego asynchroniczne ponownego uruchomienia od innych żądań."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>o reprezentuje asynchroniczną uruchomienie obszaru operacji zapisu, które można nadal oczekiwać.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>jest nieprawidłowy dla tej sekwencji.       - lub - numer sekwencji rozpoczęcia rejestracji dziennika określona jest nieprawidłowa.       - lub - <code>data</code> nie można dołączyć, ponieważ ma on większy niż maksymalna wielkość rekordu.       - lub - <code>reservation</code> nie został utworzony przez tę sekwencję rekordu."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z parametrów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Nowy lub istniejący element archiwum albo podstawa aktywnego dziennika jest nieprawidłowa.       - lub - <code> newBaseSeqNum </code> nie jest od podstawowego do ostatniego numeru sekwencji."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.       - lub - nie można wykonać żądania z powodu błędu urządzenia We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Rozpoczyna się operacji zapisu obszaru asynchroniczne ponowne uruchomienie, przy użyciu wcześniej zastrzeżonej w sekwencji. Ta metoda nie może być dziedziczona."
  remarks: "Należy przekazać <xref:System.IAsyncResult>zwrócona przez tę metodę w celu <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>metodę, aby zapewnić, że operacja zapisu obszaru ponowne uruchomienie zostało ukończone i zasobów można odpowiednio zwalniane.</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> Jeśli wystąpił błąd podczas operacji zapisu obszaru asynchroniczne ponowne uruchomienie, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>Metoda jest wywoływana z <xref:System.IAsyncResult>zwracane przez tę metodę.</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>       Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Po pomyślnym zakończeniu operacji numer sekwencyjny podstawowy został zaktualizowany. Rejestrowania wszystkich rekordów z numerami sekwencji mniej niż nowy numer sekwencji podstawowej są niedostępne.       Jeśli <xref:System.IO.Log.ReservationCollection>określono obszaru napisane ponownego uruchamiania będą korzystać z miejsca wcześniej zarezerwowanych, za pomocą rezerwacji zawartych w kolekcji.</xref:System.IO.Log.ReservationCollection> Jeśli metoda zakończy się powodzeniem, zużyje najmniejszą rezerwacji, który przechowywania danych, a rezerwacji zostanie usunięty z kolekcji.       Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>Metoda jest wywoływana.</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa bieżący numer sekwencyjny podstawowej."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> zawierający rezerwacji, które mają być używane dla tego obszaru ponownego uruchomienia."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu zapisu obszaru ponownego uruchomienia."
    - id: state
      type: System.Object
      description: "Obiekt dostarczane przez użytkownika, która odróżnia to żądanie zapisu obszaru określonego asynchroniczne ponownego uruchomienia od innych żądań."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>o reprezentuje asynchroniczną uruchomienie obszaru operacji zapisu, które można nadal oczekiwać.</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>jest nieprawidłowy dla tej sekwencji.       - lub - numer sekwencji rozpoczęcia rejestracji dziennika określona jest nieprawidłowa.       - lub - <code>data</code> nie można dołączyć, ponieważ ma on większy niż maksymalna wielkość rekordu.       - lub - <code>reservationCollection</code> nie został utworzony przez tę sekwencję rekordu."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z parametrów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Nowy lub istniejący element archiwum albo podstawa aktywnego dziennika jest nieprawidłowa.       - lub - <code> newBaseSeqNum </code> nie jest od podstawowego do ostatniego numeru sekwencji."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.       - lub - nie można wykonać żądania z powodu błędu urządzenia We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.CreateReservationCollection
  id: CreateReservationCollection
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: CreateReservationCollection()
  nameWithType: LogRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.LogRecordSequence.CreateReservationCollection()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Tworzy nowy <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>. Ta metoda nie może być dziedziczona."
  remarks: ''
  example:
  - "Reservations can be performed in two ways as shown in the following examples. You can adopt the practices in the samples for robust processing. Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.  \n  \n```  \n//Using the ReserveAndAppend Method  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nlong[] lengthOfUndoRecords = new long[] { 1000 };  \nrecordSequence.ReserveAndAppend(recordData,  \n                                                     userSqn,  \n                                                     previousSqn,  \n                                                     RecordSequenceAppendOptions.None,  \n                                                     reservations,  \n                                                     lengthOfUndoRecords);  \nrecordSequence.Append(undoRecordData,    // If necessary …  \n                                    userSqn,  \n                                    previousSqn,  \n                                    RecordSequenceAppendOptions.ForceFlush,  \n                                    reservations);  \n  \n// Using the Manual Approach  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nreservations.Add(lengthOfUndoRecord);  \ntry  \n{  \n   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  \n}  \ncatch (Exception)  \n{  \n   reservations.Remove(lengthOfUndoRecord);  \n   throw;  \n}  \n  \nrecordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  \n```"
  syntax:
    content: public System.IO.Log.ReservationCollection CreateReservationCollection ();
    parameters: []
    return:
      type: System.IO.Log.ReservationCollection
      description: "Nowo utworzony <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>."
  overload: System.IO.Log.LogRecordSequence.CreateReservationCollection*
  exceptions:
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Dispose
  id: Dispose
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Dispose()
  nameWithType: LogRecordSequence.Dispose()
  fullName: System.IO.Log.LogRecordSequence.Dispose()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Zwalnia zasoby używane przez składnik."
  remarks: ''
  example:
  - "This example shows how to use Dispose to release resource:  \n  \n [!code-cs[S_UELogRecordSequence#11](~/add/codesnippet/csharp/m-system.io.log.logrecor_1.cs)]\n [!code-vb[S_UELogRecordSequence#11](~/add/codesnippet/visualbasic/m-system.io.log.logrecor_1.vb)]  \n  \n [!code-cs[S_UELogRecordSequence#12](~/add/codesnippet/csharp/m-system.io.log.logrecor_2.cs)]\n [!code-vb[S_UELogRecordSequence#12](~/add/codesnippet/visualbasic/m-system.io.log.logrecor_2.vb)]"
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: System.IO.Log.LogRecordSequence.Dispose*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)
  id: EndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Kończy się asynchroniczne Dołącz operacji. Ta metoda nie może być dziedziczona."
  remarks: "Ta metoda umożliwia blokowanie dopiero po ukończeniu operacji We/Wy. Błędów występujących podczas żądania asynchronicznego zapisu, takiej jak awaria dysku podczas wykonywania żądania We/Wy stają się widoczne, gdy jest wywoływana EndAppend.       Ta metoda musi zostać wywołana tylko raz w każdej <xref:System.IAsyncResult>zwrócony przez <xref:System.IO.Log.LogRecordSequence.BeginAppend%2A>metody.</xref:System.IO.Log.LogRecordSequence.BeginAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Odwołanie do oczekujących żądania asynchroniczne We/Wy."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji rekordu dziennika dołączany."
  overload: System.IO.Log.LogRecordSequence.EndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>jest nieprawidłowy."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.       - lub - nie można wykonać żądania z powodu błędu urządzenia We/Wy."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End &quot; name=&quot;End &quot; href=&quot;&quot;></xref>została już wywołana dla tej operacji asynchronicznej."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)
  id: EndFlush(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndFlush(IAsyncResult)
  nameWithType: LogRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndFlush(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Kończy operację asynchroniczną opróżniania. Ta metoda nie może być dziedziczona."
  remarks: "Ta metoda umożliwia blokowanie dopiero po ukończeniu operacji We/Wy. Błędów występujących podczas opróżniania żądania asynchronicznego, takiej jak awaria dysku podczas wykonywania żądania We/Wy stają się widoczne, gdy jest wywoływana EndFlush.       Ta metoda musi zostać wywołana tylko raz w każdej <xref:System.IAsyncResult>zwrócony przez <xref:System.IO.Log.LogRecordSequence.BeginFlush%2A>metody.</xref:System.IO.Log.LogRecordSequence.BeginFlush%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Odwołanie do oczekujących żądania asynchroniczne We/Wy."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji ostatni rekord zapisywane."
  overload: System.IO.Log.LogRecordSequence.EndFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>jest nieprawidłowy."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>została już wywołana dla tej operacji asynchronicznej."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  id: EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndReserveAndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Kończy się asynchroniczne rezerwowa i Dołącz operacji. Ta metoda nie może być dziedziczona."
  remarks: "Ta metoda umożliwia blokowanie dopiero po ukończeniu operacji We/Wy. Błędów występujących podczas żądania asynchronicznego zapisu, takiej jak awaria dysku podczas wykonywania żądania We/Wy stają się widoczne, gdy jest wywoływana EndReserveAndAppend.       Ta metoda musi zostać wywołana tylko raz w każdej <xref:System.IAsyncResult>zwrócony przez <xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A>metody.</xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Odwołanie do oczekujących żądania asynchroniczne We/Wy."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji rekordu dziennika dołączany."
  overload: System.IO.Log.LogRecordSequence.EndReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>jest nieprawidłowy."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.       - lub - nie można wykonać żądania z powodu błędu urządzenia We/Wy."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>została już wywołana dla tej operacji asynchronicznej."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  id: EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: LogRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndWriteRestartArea(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Kończy operację zapisu obszaru asynchroniczne ponownego uruchomienia. Ta metoda nie może być dziedziczona."
  remarks: "Ta metoda umożliwia blokowanie dopiero po ukończeniu operacji We/Wy. Błędów występujących podczas żądania asynchronicznego zapisu, takiej jak awaria dysku podczas wykonywania żądania We/Wy stają się widoczne, gdy jest wywoływana EndWriteRestartArea.       Ta metoda musi zostać wywołana tylko raz w każdej <xref:System.IAsyncResult>zwrócony przez <xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A>metody.</xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Odwołanie do oczekujących żądania asynchroniczne We/Wy."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji rekordu dziennika napisane."
  overload: System.IO.Log.LogRecordSequence.EndWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>nie jest prawidłowy."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Nowy lub istniejący element archiwum albo podstawa aktywnego dziennika jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>została już wywołana dla tej operacji asynchronicznej."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Flush
  id: Flush
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Flush()
  nameWithType: LogRecordSequence.Flush()
  fullName: System.IO.Log.LogRecordSequence.Flush()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Zapewnia zapisano wszystkich dołączonych rekordów. Ta metoda nie może być dziedziczona."
  remarks: "Wywołanie tej metody gwarantuje, że wszystkie rekordy, które zostały dołączone do <xref:System.IO.Log.LogRecordSequence>trwale zapisano.</xref:System.IO.Log.LogRecordSequence>"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush ();
    parameters: []
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji ostatni rekord zapisywane."
  overload: System.IO.Log.LogRecordSequence.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas opróżniania danych."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Ta operacja nie jest obsługiwana."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów nie można utworzyć wystarczającej ilości wolnego miejsca, aby zawierają nowy obszar ponownego uruchomienia."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Określony dziennik nie zawiera żadnych zakresów. Przed użyciem sekwencja rekordów, należy utworzyć jeden lub więcej zakresów."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)
  id: Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Flush(SequenceNumber)
  nameWithType: LogRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.Flush(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Zapewnia, że dołączane rekordy, w tym rekord z określony numer sekwencji został trwale zapisany. Ta metoda nie może być dziedziczona."
  remarks: "Wywołanie tej metody powoduje do liczby wszystkich rekordów z sekwencją i określony numer sekwencji, w tym trwale zapisano."
  syntax:
    content: public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji najnowsze rekordu, który musi być napisana. Jeśli <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> jest nieprawidłowy, a następnie wszystkie rekordy muszą być zapisane."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji ostatni rekord zapisywane."
  overload: System.IO.Log.LogRecordSequence.Flush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>jest nieprawidłowy dla tej sekwencji."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>sequenceNumber</code>nie jest od podstawowego do ostatniego numeru sekwencji."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Określony dziennik nie zawiera żadnych zakresów. Przed użyciem sekwencja rekordów, należy utworzyć jeden lub więcej zakresów."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.LastSequenceNumber
  id: LastSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LastSequenceNumber
  nameWithType: LogRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.LastSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Pobiera numer sekwencji jest ona większa niż ostatni rekord dołączone"
  remarks: "Ta właściwość zawiera numer sekwencji, który może być większa niż liczba sekwencji ostatniej dołączany rekordu. Prawidłowych numerów sekwencji są większe niż lub równe <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A>i mniejsza niż LastSequenceNumber.</xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> Wszystkie inne liczby sekwencji jest nieprawidłowy."
  syntax:
    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji jest ona większa niż ostatni rekord dołączane."
  overload: System.IO.Log.LogRecordSequence.LastSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Właściwość uzyskano po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.LogStore
  id: LogStore
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogStore
  nameWithType: LogRecordSequence.LogStore
  fullName: System.IO.Log.LogRecordSequence.LogStore
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Pobiera <xref href=&quot;System.IO.Log.LogStore&quot;> </xref> zawierający dane dla tej sekwencji rekordu. Ta metoda nie może być dziedziczona."
  remarks: ''
  example:
  - "This example shows how to use the LogStore member to add extents.  \n  \n [!code-cs[S_UELogRecordSequence#11](~/add/codesnippet/csharp/p-system.io.log.logrecor_1_1.cs)]\n [!code-vb[S_UELogRecordSequence#11](~/add/codesnippet/visualbasic/p-system.io.log.logrecor_1_1.vb)]"
  syntax:
    content: public System.IO.Log.LogStore LogStore { get; }
    return:
      type: System.IO.Log.LogStore
      description: "<xref href=&quot;System.IO.Log.LogStore&quot;> </xref> Zawierający dane dla tej sekwencji rekordu."
  overload: System.IO.Log.LogRecordSequence.LogStore*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.MaximumRecordLength
  id: MaximumRecordLength
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: MaximumRecordLength
  nameWithType: LogRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.LogRecordSequence.MaximumRecordLength
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Pobiera maksymalny rozmiar rekordu, który można dodać do tej sekwencji rekordu."
  syntax:
    content: public long MaximumRecordLength { get; }
    return:
      type: System.Int64
      description: "Maksymalny rozmiar rekordu, który można dodać do tej sekwencji rekordu."
  overload: System.IO.Log.LogRecordSequence.MaximumRecordLength*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  id: ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Zwraca wyliczalny kolekcji rekordów w sekwencji. Ta metoda nie może być dziedziczona."
  remarks: "Ta metoda zwraca wyliczalny kolekcji rekordów w sekwencji. Kolejność wyliczany rekordów zależy od wartości `logRecordEnum` parametru."
  example:
  - "This example shows how to use ReadLogRecords in a loop.  \n  \n [!code-cs[S_UELogRecordSequence#10](~/add/codesnippet/csharp/65162f37-dafe-4315-8e44-_1.cs)]\n [!code-vb[S_UELogRecordSequence#10](~/add/codesnippet/visualbasic/65162f37-dafe-4315-8e44-_1.vb)]"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);
    parameters:
    - id: start
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji pierwszy rekord, gdy rozpoczyna się odczyt."
    - id: logRecordEnum
      type: System.IO.Log.LogRecordEnumeratorType
      description: "Prawidłowy <xref href=&quot;System.IO.Log.LogRecordEnumeratorType&quot;> </xref> wartość, która określa sposób (to znaczy, do przodu lub wstecz), w którym rejestrowane są odczytywane z <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>."
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "Ustalony zbiór rekordów w sekwencji."
  overload: System.IO.Log.LogRecordSequence.ReadLogRecords*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>start</code>jest nieprawidłowy dla tej sekwencji.       - lub - <code>logRecordEnum</code> jest nieprawidłowy.       - lub - nie można odnaleźć określonego elementu w kolekcji."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>start</code>nie jest od podstawowego do ostatniego numeru sekwencji."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.       - lub - nie można wykonać żądania z powodu błędu urządzenia We/Wy.       - lub rozmiar buforu używany do zapisu rekordu dziennika jest większy niż rozmiar buforu używany do jego odczytu.       - lub - sekwencja rekordów jest uszkodzona.       - lub - format pliku dziennika określonego lub wersja jest nieprawidłowa.       - lub - rekord został zapisany za pomocą niezgodnej wersji sekwencja rekordów."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Operacja jest nieprawidłowa, ponieważ wyliczanie nie został uruchomiony. Wywołanie <xref:System.Collections.IEnumerator.MoveNext*>muszą być wprowadzane.</xref:System.Collections.IEnumerator.MoveNext*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReadRestartAreas
  id: ReadRestartAreas
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReadRestartAreas()
  nameWithType: LogRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.LogRecordSequence.ReadRestartAreas()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Zwraca wyliczalny kolekcji obszarów ponownego uruchomienia w sekwencji. Ta metoda nie może być dziedziczona."
  remarks: "Obszarów ponownego uruchomienia są wymienione w kolejności odwrotnej kolejności, oznacza to, z najwyższym numerem najniższy numer sekwencyjny. Tylko ponownie obszarów z numerami sekwencji między ostatni numer sekwencji i numer sekwencyjny podstawowej są wyliczone."
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadRestartAreas ();
    parameters: []
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "Wyliczalny kolekcja obszarów ponownego uruchomienia w sekwencji."
  overload: System.IO.Log.LogRecordSequence.ReadRestartAreas*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>start</code>nie jest od podstawowego do ostatniego numeru sekwencji."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.       - lub - nie można wykonać żądania z powodu błędu urządzenia We/Wy.       - lub rozmiar buforu używany do zapisu rekordu dziennika jest większy niż rozmiar buforu używany do jego odczytu.       - lub - sekwencja rekordów jest uszkodzona.       - lub - format pliku dziennika określonego lub wersja jest nieprawidłowa.       - lub - rekord został zapisany za pomocą niezgodnej wersji sekwencja rekordów."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Operacja jest nieprawidłowa, ponieważ wyliczanie nie został uruchomiony. Wywołanie <xref:System.Collections.IEnumerator.MoveNext*>muszą być wprowadzane.</xref:System.Collections.IEnumerator.MoveNext*>       - lub wyliczanie zostało zakończone."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Automatycznie sprawia, że pojedynczy rezerwacji i dołącza do sekwencji rekordu. Ta metoda nie może być dziedziczona."
  remarks: "Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Określony rezerwacji są dodawane podana rezerwacji operację dołączania kolekcji w niepodzielną operację z rekordu. W przypadku niepowodzenia Dołącz miejsce nie jest zarezerwowana.       Zwykle ta metoda może zakończyć się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A>metody.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  example:
  - "The following example shows how to use this method to make reservations. Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.  \n  \n```  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nlong[] lengthOfUndoRecords = new long[] { 1000 };  \nrecordSequence.ReserveAndAppend(recordData,  \n                                                     userSqn,  \n                                                     previousSqn,  \n                                                     RecordSequenceAppendOptions.None,  \n                                                     reservations,  \n                                                     lengthOfUndoRecords);  \nrecordSequence.Append(undoRecordData,    // If necessary …  \n                                    userSqn,  \n                                    previousSqn,  \n                                    RecordSequenceAppendOptions.ForceFlush,  \n                                    reservations);  \n```"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> zawierający dokonanie rezerwacji w kolekcji."
    - id: reservations
      type: System.Int64[]
      description: "Zastrzeżenia dokonanie w bajtach."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji rekordu dziennika dołączany."
  overload: System.IO.Log.LogRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>nextUndoRecord</code>lub <code>previousRecord</code> jest nieprawidłowy dla tej sekwencji.       - lub - <code>data</code> nie można dołączyć, ponieważ ma on większy niż maksymalna wielkość rekordu.       - lub - <code>reservations</code> nie został utworzony przez tę sekwencję rekordu."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>nextUndoRecord</code>lub <code>previousRecord</code> nie jest od podstawowego do ostatniego numeru sekwencji."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.       - lub - nie można wykonać żądania z powodu błędu urządzenia We/Wy."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Rezerwacja nie jest wystarczająco duży, aby zmieścić <code> data </code> znajdują się w <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Automatycznie sprawia, że pojedynczy rezerwacji i dołącza do sekwencji rekordu. Ta metoda nie może być dziedziczona."
  remarks: "Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Określony rezerwacji są dodawane podana rezerwacji operację dołączania kolekcji w niepodzielną operację z rekordu. W przypadku niepowodzenia Dołącz miejsce nie jest zarezerwowana.       Zwykle ta metoda może zakończyć się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.LogRecordSequence.Flush%2A>metody.</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "Kolekcja rezerwacji dokonanie rezerwacji w."
    - id: reservations
      type: System.Int64[]
      description: "Zastrzeżenia dokonanie w bajtach."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji rekordu dziennika dołączany."
  overload: System.IO.Log.LogRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas dołączania rekordu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów nie można utworzyć wystarczającej ilości wolnego miejsca na zawierają nowy rekord lub aby wprowadzić zastrzeżenie."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>lub <code>previousRecord</code> nie jest od podstawowego do ostatniego numeru sekwencji."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Nie można wykonać operacji, ponieważ sekwencja rekordów została otwarta z dostępem tylko do odczytu."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "Rezerwacja nie jest wystarczająco duży, aby zmieścić <code> data </code> znajdują się w <code> reservations </code>."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReservedBytes
  id: ReservedBytes
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReservedBytes
  nameWithType: LogRecordSequence.ReservedBytes
  fullName: System.IO.Log.LogRecordSequence.ReservedBytes
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Pobiera całkowitą liczbę bajtów, które zostały zarezerwowane."
  syntax:
    content: public long ReservedBytes { get; }
    return:
      type: System.Int64
      description: "Całkowity rozmiar wszystkich rezerwacji dokonanych w tej sekwencji rekordu."
  overload: System.IO.Log.LogRecordSequence.ReservedBytes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Właściwość uzyskano po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.RestartSequenceNumber
  id: RestartSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: RestartSequenceNumber
  nameWithType: LogRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.RestartSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Pobiera najbardziej zbliżony do końca dziennika numer sekwencyjny obszaru ponownego uruchomienia."
  remarks: "Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Typowe dziennika File System (CLFS) obsługuje dwa obszary, aby zagwarantować, że co najmniej jeden nieprawidłowy obszar jest zawsze dostępna po ponownym uruchomieniu. Podczas odzyskiwania jest niezbędne, CLFS odczytuje obszaru jego ponownego uruchomienia i wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania.       Przy użyciu <xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A>metody, można usunąć najbardziej ostatnio zapisany ponownie uruchomić obszaru.</xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny najbardziej zbliżony do końca dziennika obszaru ponownego uruchomienia."
  overload: System.IO.Log.LogRecordSequence.RestartSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Właściwość uzyskano po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.RetryAppend
  id: RetryAppend
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: RetryAppend
  nameWithType: LogRecordSequence.RetryAppend
  fullName: System.IO.Log.LogRecordSequence.RetryAppend
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Pobiera lub ustawia wartość wskazującą, czy dołącza są automatycznie podjęta, jeśli dziennik jest zapełniony."
  remarks: "Jeśli wartość tej właściwości jest `true`i <xref:System.IO.Log.LogRecordSequence.Append%2A>Wywołanie zakończy się niepowodzeniem, ponieważ nie ma wystarczającej ilości miejsca w sekwencji, sekwencja rekordów spróbuje wolnego miejsca, a następnie spróbuj ponownie Dołącz.</xref:System.IO.Log.LogRecordSequence.Append%2A>"
  example:
  - "This example shows how to use the RetryAppend property.  \n  \n [!code-cs[S_UELogRecordSequence#3](~/add/codesnippet/csharp/p-system.io.log.logrecor_0_1.cs)]\n [!code-vb[S_UELogRecordSequence#3](~/add/codesnippet/visualbasic/p-system.io.log.logrecor_0_1.vb)]"
  syntax:
    content: public bool RetryAppend { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli dołącza są automatycznie podjęta, jeśli dziennik jest zapełniony; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Wartość domyślna to <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.Log.LogRecordSequence.RetryAppend*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Właściwość uzyskano po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)
  id: SetLastRecord(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: SetLastRecord(SequenceNumber)
  nameWithType: LogRecordSequence.SetLastRecord(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.SetLastRecord(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Ustawia ostatni rekord w <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>."
  remarks: "Określony numer sekwencji musi być większy od numeru sekwencji podstawowej.       Po zakończeniu wykonywania tej metody wszystkie rekordy, które wcześniej były został dołączony numerów sekwencji jest większy niż określony numer sekwencji są niedostępne."
  syntax:
    content: public void SetLastRecord (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Liczba nowych ostatniej sekwencji w <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>.       Ten powinien dotyczyć bieżącego rekordu prawidłowy obecnie w dzienniku."
  overload: System.IO.Log.LogRecordSequence.SetLastRecord*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>jest nieprawidłowy dla tej sekwencji."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Nowy lub istniejący element archiwum albo podstawa aktywnego dziennika jest nieprawidłowa.       - lub - <code> sequenceNumber </code> nie jest od podstawowego do ostatniego numeru sekwencji."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.       - lub - osiągnięto koniec dziennika.       - lub - format pliku dziennika określonego lub wersja jest nieprawidłowa."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.TailPinned
  id: TailPinned
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: TailPinned
  nameWithType: LogRecordSequence.TailPinned
  fullName: System.IO.Log.LogRecordSequence.TailPinned
  type: Event
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Sygnalizuje konieczność przeniesienia tail sekwencji."
  remarks: "Mogą wyzwalać to zdarzenie, gdy sekwencja rekordów zabrakło miejsca. To zdarzenie jest wywoływane, tail sekwencji (to znaczy numer sekwencji podstawowej) jest przenoszony do przodu w celu zwolnienia miejsca.       Zdarzenie może być uruchamiane w dowolnym momencie, gdy sekwencja rekordów decyduje o tym, że musi on zwolnienia miejsca, jakiegokolwiek powodu. Na przykład aparat zasad CLFS może zdecydować o zdarzenia podczas określania ślady dwóch klientów dziennika udostępnianie tego samego pliku dziennika są zbyt daleko od siebie. Zwalnianie miejsca może odbywać się przez zapisywanie obszarów ponownego uruchomienia lub obcinanie dziennika i przy użyciu <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>metody w celu zwolnienia miejsca.</xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> Przykładowy kod w sekcji przykładzie pokazano drugiej metody.       Możesz także wywołać <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A>metody poza zdarzenia TailPinned wolnego miejsca.</xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> Obszar ponowne uruchomienie jest podobny do punktu kontrolnego w dzienniku, innych systemów przetwarzania. Wywołanie tej metody wskazuje, że aplikacji uwzględnia wszystkie wcześniejsze rekordy przed ponownym uruchomieniu jako w pełni ukończone i dołącza dla przyszłych rekordu. Podobnie jak inne rekordy, rzeczywiste wolne miejsce w dzienniku funkcji wymaga rekordu napisane przez tę metodę."
  example:
  - "This example shows how to use the TailPinned event.  \n  \n```  \nrecordSequence.RetryAppend = true;  \nrecordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  \n  \nvoid HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  \n{  \n   // tailPinnedEventArgs.TargetSequenceNumber is the target   \n   // sequence number to free up space to.    \n   // However, this sequence number is not necessarily valid.  We have  \n   // to use this sequence number as a starting point for finding a  \n   // valid point within the log to advance toward. You need to  \n   // identify a record with a sequence number equal to, or greater  \n   // than TargetSequenceNumber; let's call this   \n   // realTargetSequenceNumber. Once found, move the base  \n  \n   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  \n  \n}  \n```"
  syntax:
    content: public event EventHandler<System.IO.Log.TailPinnedEventArgs> TailPinned;
    return:
      type: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  id: WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Zapisuje obszar ponownego uruchomienia <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>. Ta metoda nie może być dziedziczona."
  remarks: "Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Typowe dziennika File System (CLFS) obsługuje dwa obszary, aby zagwarantować, że co najmniej jeden nieprawidłowy obszar jest zawsze dostępna po ponownym uruchomieniu. Podczas odzyskiwania jest niezbędne, CLFS odczytuje obszaru jego ponownego uruchomienia i wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania.       Obszar ponowne uruchomienie może zostać odczytany przy użyciu <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>metody.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       Dane w segmentach tablicy bajtów zostaną połączone tablicy bajtów pojedynczego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów przeczytaniu obszaru ponownego uruchamiania."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Tablica segmentu, który będzie połączony i dołączone jako rekord."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji zapisany ponownie obszar."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas zapisu obszaru ponownego uruchamiania."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów nie można utworzyć wystarczającej ilości wolnego miejsca, aby zawierają nowy obszar ponownego uruchomienia."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Zapisuje obszar ponownego uruchomienia <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>. Ta metoda nie może być dziedziczona."
  remarks: "Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Typowe dziennika File System (CLFS) obsługuje dwa obszary, aby zagwarantować, że co najmniej jeden nieprawidłowy obszar jest zawsze dostępna po ponownym uruchomieniu. Podczas odzyskiwania jest niezbędne, CLFS odczytuje obszaru jego ponownego uruchomienia i wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania.       Obszar ponowne uruchomienie może zostać odczytany przy użyciu <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>metody.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       Dane w segmentach tablicy bajtów zostaną połączone tablicy bajtów pojedynczego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów przeczytaniu obszaru ponownego uruchamiania."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji zapisany ponownie obszar."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas zapisu obszaru ponownego uruchamiania."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów nie można utworzyć wystarczającej ilości wolnego miejsca, aby zawierają nowy obszar ponownego uruchomienia."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z argumentów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Zapisuje obszar ponownego uruchomienia <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> i aktualizuje numer sekwencyjny podstawowej. Ta metoda nie może być dziedziczona."
  remarks: "Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Typowe dziennika File System (CLFS) obsługuje dwa obszary, aby zagwarantować, że co najmniej jeden nieprawidłowy obszar jest zawsze dostępna po ponownym uruchomieniu. Podczas odzyskiwania jest niezbędne, CLFS odczytuje obszaru jego ponownego uruchomienia i wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania.       Obszar ponowne uruchomienie może zostać odczytany przy użyciu <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>metody.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       Gdy obszar ponownego uruchomienia zostanie zapisany, dane w segmentach tablicy typu byte są łączone tablicy bajtów pojedynczego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów przeczytaniu obszaru ponownego uruchamiania.       Po pomyślnym zakończeniu tej metody, numer sekwencyjny podstawowy został zaktualizowany. Rejestrowania wszystkich rekordów z numerami sekwencji mniej niż nowy numer sekwencji podstawowej są niedostępne.       Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>Metoda jest wywoływana.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa bieżący numer sekwencyjny podstawowej."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji zapisany ponownie obszar."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas zapisu obszaru ponownego uruchamiania."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów nie można utworzyć wystarczającej ilości wolnego miejsca, aby zawierają nowy obszar ponownego uruchomienia."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Zapisuje obszar ponownego uruchomienia <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> i aktualizuje numer sekwencyjny podstawowej. Ta metoda nie może być dziedziczona."
  remarks: "Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Typowe dziennika File System (CLFS) obsługuje dwa obszary, aby zagwarantować, że co najmniej jeden nieprawidłowy obszar jest zawsze dostępna po ponownym uruchomieniu. Podczas odzyskiwania jest niezbędne, CLFS odczytuje obszaru jego ponownego uruchomienia i wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania.       Obszar ponowne uruchomienie może zostać odczytany przy użyciu <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>metody.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       Gdy obszar ponownego uruchomienia zostanie zapisany, dane w segmentach tablicy typu byte są łączone tablicy bajtów pojedynczego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów przeczytaniu obszaru ponownego uruchamiania.       Po pomyślnym zakończeniu tej metody, numer sekwencyjny podstawowy został zaktualizowany. Rejestrowania wszystkich rekordów z numerami sekwencji mniej niż nowy numer sekwencji podstawowej są niedostępne.       Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>Metoda jest wywoływana.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa bieżący numer sekwencyjny podstawowej."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji zapisany ponownie obszar."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas zapisu obszaru ponownego uruchamiania."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów nie można utworzyć wystarczającej ilości wolnego miejsca, aby zawierają nowy obszar ponownego uruchomienia."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Zapisuje obszar ponownego uruchomienia <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> za pomocą rezerwacji i aktualizuje numer sekwencyjny podstawowej. Ta metoda nie może być dziedziczona."
  remarks: "Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Typowe dziennika File System (CLFS) obsługuje dwa obszary, aby zagwarantować, że co najmniej jeden nieprawidłowy obszar jest zawsze dostępna po ponownym uruchomieniu. Podczas odzyskiwania jest niezbędne, CLFS odczytuje obszaru jego ponownego uruchomienia i wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania.       Obszar ponowne uruchomienie może zostać odczytany przy użyciu <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>metody.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       Gdy obszar ponownego uruchomienia zostanie zapisany, dane w segmentach tablicy typu byte są łączone tablicy bajtów pojedynczego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów przeczytaniu obszaru ponownego uruchamiania.       Jeśli określono zastrzeżenie, obszar napisane ponownego uruchamiania będą korzystać z miejsca wcześniej zarezerwowanych, za pomocą rezerwacji zawartych w kolekcji. Jeśli metoda zakończy się powodzeniem, zużyje najmniejszą rezerwacji zawierające dane, a rezerwacji zostanie usunięty z kolekcji.       Po pomyślnym zakończeniu tej metody, numer sekwencyjny podstawowy został zaktualizowany. Rejestrowania wszystkich rekordów z numerami sekwencji mniej niż nowy numer sekwencji podstawowej są niedostępne.       Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>Metoda jest wywoływana.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa bieżący numer sekwencyjny podstawowej."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> zawierający rezerwacji, które mają być używane dla tego obszaru ponownego uruchomienia."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji zapisany ponownie obszar."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas zapisu obszaru ponownego uruchamiania."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów nie można utworzyć wystarczającej ilości wolnego miejsca, aby zawierają nowy obszar ponownego uruchomienia."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Zapisuje obszar ponownego uruchomienia <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref> za pomocą rezerwacji i aktualizuje numer sekwencyjny podstawowej. Ta metoda nie może być dziedziczona."
  remarks: "Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Typowe dziennika File System (CLFS) obsługuje dwa obszary, aby zagwarantować, że co najmniej jeden nieprawidłowy obszar jest zawsze dostępna po ponownym uruchomieniu. Podczas odzyskiwania jest niezbędne, CLFS odczytuje obszaru jego ponownego uruchomienia i wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania.       Obszar ponowne uruchomienie może zostać odczytany przy użyciu <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>metody.</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       Gdy obszar ponownego uruchomienia zostanie zapisany, dane w segmentach tablicy typu byte są łączone tablicy bajtów pojedynczego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów przeczytaniu obszaru ponownego uruchamiania.       Jeśli określono zastrzeżenie, obszar napisane ponownego uruchamiania będą korzystać z miejsca wcześniej zarezerwowanych, za pomocą rezerwacji zawartych w kolekcji. Jeśli metoda zakończy się powodzeniem, zużyje najmniejszą rezerwacji zawierające dane, a rezerwacji zostanie usunięty z kolekcji.       Po pomyślnym zakończeniu tej metody, numer sekwencyjny podstawowy został zaktualizowany. Rejestrowania wszystkich rekordów z numerami sekwencji mniej niż nowy numer sekwencji podstawowej są niedostępne.       Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>Metoda jest wywoływana.</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa bieżący numer sekwencyjny podstawowej."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> zawierający rezerwacji, które mają być używane dla tego obszaru ponownego uruchomienia."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji zapisany ponownie obszar."
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>jest nieprawidłowy dla tej sekwencji.       - lub - numer sekwencji rozpoczęcia rejestracji dziennika określona jest nieprawidłowa.       - lub - <code>data</code> nie można dołączyć, ponieważ ma on większy niż maksymalna wielkość rekordu.       - lub - <code>reservationCollection</code> nie został utworzony przez tę sekwencję rekordu."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Co najmniej jeden z parametrów jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Nowy lub istniejący element archiwum albo podstawa aktywnego dziennika jest nieprawidłowa.       - lub - <code> newBaseSeqNum </code> nie jest od podstawowego do ostatniego numeru sekwencji."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.       - lub - nie można wykonać żądania z powodu błędu urządzenia We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Nie ma wystarczającej ilości pamięci, aby kontynuować wykonywanie programu."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Odmowa dostępu dla sekwencji określony dziennik przez system operacyjny."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.IO.Log.ReservationNotFoundException
  parent: System.IO.Log
  isExternal: false
  name: ReservationNotFoundException
  nameWithType: ReservationNotFoundException
  fullName: System.IO.Log.ReservationNotFoundException
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(LogStore)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore)
- uid: System.IO.Log.LogStore
  parent: System.IO.Log
  isExternal: false
  name: LogStore
  nameWithType: LogStore
  fullName: System.IO.Log.LogStore
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(LogStore,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
- uid: System.Security.AccessControl.FileSecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSecurity
  nameWithType: FileSecurity
  fullName: System.Security.AccessControl.FileSecurity
- uid: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
- uid: System.IO.Log.SequenceNumber
  parent: System.IO.Log
  isExternal: false
  name: SequenceNumber
  nameWithType: SequenceNumber
  fullName: System.IO.Log.SequenceNumber
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.ArraySegment{System.Byte}
  parent: System
  isExternal: true
  name: ArraySegment<Byte>
  nameWithType: ArraySegment<Byte>
  fullName: System.ArraySegment<System.Byte>
  spec.csharp:
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.RecordAppendOptions
  parent: System.IO.Log
  isExternal: false
  name: RecordAppendOptions
  nameWithType: RecordAppendOptions
  fullName: System.IO.Log.RecordAppendOptions
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
  parent: System.Collections.Generic
  isExternal: true
  name: IList<ArraySegment<Byte>>
  nameWithType: IList<ArraySegment<Byte>>
  fullName: System.Collections.Generic.IList<System.ArraySegment<System.Byte>>
  spec.csharp:
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: IList<System.ArraySegment<System.Byte>>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.ReservationCollection
  parent: System.IO.Log
  isExternal: false
  name: ReservationCollection
  nameWithType: ReservationCollection
  fullName: System.IO.Log.ReservationCollection
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.LogRecordSequence.BaseSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.Int64[]
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64[]
  spec.csharp:
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: Int64[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.CreateReservationCollection
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: CreateReservationCollection()
  nameWithType: LogRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.LogRecordSequence.CreateReservationCollection()
- uid: System.IO.Log.LogRecordSequence.Dispose
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Dispose()
  nameWithType: LogRecordSequence.Dispose()
  fullName: System.IO.Log.LogRecordSequence.Dispose()
- uid: System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndAppend(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndFlush(IAsyncResult)
  nameWithType: LogRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndFlush(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndReserveAndAppend(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: LogRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndWriteRestartArea(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.Flush
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Flush()
  nameWithType: LogRecordSequence.Flush()
  fullName: System.IO.Log.LogRecordSequence.Flush()
- uid: System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Flush(SequenceNumber)
  nameWithType: LogRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.Flush(SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.LastSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.LastSequenceNumber
- uid: System.IO.Log.LogRecordSequence.LogStore
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogStore
  nameWithType: LogRecordSequence.LogStore
  fullName: System.IO.Log.LogRecordSequence.LogStore
- uid: System.IO.Log.LogRecordSequence.MaximumRecordLength
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: LogRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.LogRecordSequence.MaximumRecordLength
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
- uid: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<LogRecord>
  nameWithType: IEnumerable<LogRecord>
  fullName: System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.IO.Log.LogRecord>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.LogRecord
    name: LogRecord
    nameWithType: LogRecord
    fullName: LogRecord
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordEnumeratorType
  parent: System.IO.Log
  isExternal: false
  name: LogRecordEnumeratorType
  nameWithType: LogRecordEnumeratorType
  fullName: System.IO.Log.LogRecordEnumeratorType
- uid: System.IO.Log.LogRecordSequence.ReadRestartAreas
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadRestartAreas()
  nameWithType: LogRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.LogRecordSequence.ReadRestartAreas()
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.LogRecordSequence.ReservedBytes
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: LogRecordSequence.ReservedBytes
  fullName: System.IO.Log.LogRecordSequence.ReservedBytes
- uid: System.IO.Log.LogRecordSequence.RestartSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: LogRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.LogRecordSequence.RetryAppend
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: LogRecordSequence.RetryAppend
  fullName: System.IO.Log.LogRecordSequence.RetryAppend
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: SetLastRecord(SequenceNumber)
  nameWithType: LogRecordSequence.SetLastRecord(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.SetLastRecord(SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.TailPinned
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: TailPinned
  nameWithType: LogRecordSequence.TailPinned
  fullName: System.IO.Log.LogRecordSequence.TailPinned
- uid: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<TailPinnedEventArgs>
  nameWithType: EventHandler<TailPinnedEventArgs>
  fullName: System.EventHandler<System.IO.Log.TailPinnedEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.IO.Log.TailPinnedEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.TailPinnedEventArgs
    name: TailPinnedEventArgs
    nameWithType: TailPinnedEventArgs
    fullName: TailPinnedEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.LogRecordSequence.#ctor*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence
  nameWithType: LogRecordSequence.LogRecordSequence
- uid: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber
  nameWithType: LogRecordSequence.AdvanceBaseSequenceNumber
- uid: System.IO.Log.LogRecordSequence.Append*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append
  nameWithType: LogRecordSequence.Append
- uid: System.IO.Log.LogRecordSequence.BaseSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.LogRecordSequence.BeginAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend
  nameWithType: LogRecordSequence.BeginAppend
- uid: System.IO.Log.LogRecordSequence.BeginFlush*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginFlush
  nameWithType: LogRecordSequence.BeginFlush
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginReserveAndAppend
  nameWithType: LogRecordSequence.BeginReserveAndAppend
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginWriteRestartArea
  nameWithType: LogRecordSequence.BeginWriteRestartArea
- uid: System.IO.Log.LogRecordSequence.CreateReservationCollection*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: CreateReservationCollection
  nameWithType: LogRecordSequence.CreateReservationCollection
- uid: System.IO.Log.LogRecordSequence.Dispose*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Dispose
  nameWithType: LogRecordSequence.Dispose
- uid: System.IO.Log.LogRecordSequence.EndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndAppend
  nameWithType: LogRecordSequence.EndAppend
- uid: System.IO.Log.LogRecordSequence.EndFlush*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndFlush
  nameWithType: LogRecordSequence.EndFlush
- uid: System.IO.Log.LogRecordSequence.EndReserveAndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndReserveAndAppend
  nameWithType: LogRecordSequence.EndReserveAndAppend
- uid: System.IO.Log.LogRecordSequence.EndWriteRestartArea*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndWriteRestartArea
  nameWithType: LogRecordSequence.EndWriteRestartArea
- uid: System.IO.Log.LogRecordSequence.Flush*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Flush
  nameWithType: LogRecordSequence.Flush
- uid: System.IO.Log.LogRecordSequence.LastSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogRecordSequence.LastSequenceNumber
- uid: System.IO.Log.LogRecordSequence.LogStore*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogStore
  nameWithType: LogRecordSequence.LogStore
- uid: System.IO.Log.LogRecordSequence.MaximumRecordLength*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: LogRecordSequence.MaximumRecordLength
- uid: System.IO.Log.LogRecordSequence.ReadLogRecords*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadLogRecords
  nameWithType: LogRecordSequence.ReadLogRecords
- uid: System.IO.Log.LogRecordSequence.ReadRestartAreas*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadRestartAreas
  nameWithType: LogRecordSequence.ReadRestartAreas
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReserveAndAppend
  nameWithType: LogRecordSequence.ReserveAndAppend
- uid: System.IO.Log.LogRecordSequence.ReservedBytes*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: LogRecordSequence.ReservedBytes
- uid: System.IO.Log.LogRecordSequence.RestartSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: LogRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.LogRecordSequence.RetryAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: LogRecordSequence.RetryAppend
- uid: System.IO.Log.LogRecordSequence.SetLastRecord*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: SetLastRecord
  nameWithType: LogRecordSequence.SetLastRecord
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea
  nameWithType: LogRecordSequence.WriteRestartArea
