### YamlMime:ManagedReference
items:
- uid: System.Net.HttpListener
  id: HttpListener
  children:
  - System.Net.HttpListener.#ctor
  - System.Net.HttpListener.Abort
  - System.Net.HttpListener.AuthenticationSchemes
  - System.Net.HttpListener.AuthenticationSchemeSelectorDelegate
  - System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)
  - System.Net.HttpListener.Close
  - System.Net.HttpListener.DefaultServiceNames
  - System.Net.HttpListener.EndGetContext(System.IAsyncResult)
  - System.Net.HttpListener.ExtendedProtectionPolicy
  - System.Net.HttpListener.ExtendedProtectionSelectorDelegate
  - System.Net.HttpListener.GetContext
  - System.Net.HttpListener.GetContextAsync
  - System.Net.HttpListener.IgnoreWriteExceptions
  - System.Net.HttpListener.IsListening
  - System.Net.HttpListener.IsSupported
  - System.Net.HttpListener.Prefixes
  - System.Net.HttpListener.Realm
  - System.Net.HttpListener.Start
  - System.Net.HttpListener.Stop
  - System.Net.HttpListener.System#IDisposable#Dispose
  - System.Net.HttpListener.TimeoutManager
  - System.Net.HttpListener.UnsafeConnectionNtlmAuthentication
  langs:
  - csharp
  name: HttpListener
  nameWithType: HttpListener
  fullName: System.Net.HttpListener
  type: Class
  summary: "Udostępnia prostą, programowo kontrolowane odbiornika protokołu HTTP. Ta klasa nie może być dziedziczona."
  remarks: "Using the HttpListener class, you can create a simple HTTP protocol listener that responds to HTTP requests. The listener is active for the lifetime of the HttpListener object and runs within your application with its permissions.  \n  \n> [!NOTE]\n>  This class is available only on computers running the Windows XP SP2 or Windows Server 2003 operating systems. If you attempt to create an HttpListener object on a computer that is running an earlier operating system, the constructor throws a <xref:System.PlatformNotSupportedException> exception.  \n  \n To use HttpListener, create a new instance of the class using the HttpListener constructor and use the <xref:System.Net.HttpListener.Prefixes%2A> property to gain access to the collection that holds the strings that specify which Uniform Resource Identifier (URI) prefixes the HttpListener should process.  \n  \n A URI prefix string is composed of a scheme (http or https), a host, an optional port, and an optional path. An example of a complete prefix string is \"`http://www.contoso.com:8080/customerData``/`\". Prefixes must end in a forward slash (\"/\"). The HttpListener object with the prefix that most closely matches a requested URI responds to the request. Multiple HttpListener objects cannot add the same prefix; a <xref:System.ComponentModel.Win32Exception> exception is thrown if a HttpListener adds a prefix that is already in use.  \n  \n When a port is specified, the host element can be replaced with \"*\" to indicate that the HttpListener accepts requests sent to the port if the requested URI does not match any other prefix. For example, to receive all requests sent to port 8080 when the requested URI is not handled by any HttpListener, the prefix is \"`http://*:8080``/`\". Similarly, to specify that the HttpListener accepts all requests sent to a port, replace the host element with the \"+\" character, \"`https://+:8080`\". The \"\\*\" and \"+\" characters can be present in prefixes that include paths.  \n  \n Starting with .NET 4.5.3 and Windows 10, wildcard subdomains are supported in URI prefixes that are managed by an HttpListener object. To specify a wildcard subdomain, use the \"*\" character as part of the hostname in a URI prefix: for example, `http://*.foo.com/`, and pass this as the argument to the HttpListenerPrefixCollection.Add method. This will work on .NET 4.5.3 and Windows 10; in earlier versions, this would generate an <xref:System.Net.HttpListenerException>  \n  \n To begin listening for requests from clients, add the URI prefixes to the collection and call the <xref:System.Net.HttpListener.Start%2A> method. HttpListener offers both synchronous and asynchronous models for processing client requests. Requests and their associated responses are accessed using the <xref:System.Net.HttpListenerContext> object returned by the <xref:System.Net.HttpListener.GetContext%2A> method or its asynchronous counterparts, the <xref:System.Net.HttpListener.BeginGetContext%2A> and <xref:System.Net.HttpListener.EndGetContext%2A> methods.  \n  \n The synchronous model is appropriate if your application should block while waiting for a client request and if you want to process only one request at a time. Using the synchronous model, call the <xref:System.Net.HttpListener.GetContext%2A> method, which waits for a client to send a request. The method returns an <xref:System.Net.HttpListenerContext> object to you for processing when one occurs.  \n  \n In the more complex asynchronous model, your application does not block while waiting for requests and each request is processed in its own execution thread. Use the <xref:System.Net.HttpListener.BeginGetContext%2A> method to specify an application-defined method to be called for each incoming request. Within that method, call the <xref:System.Net.HttpListener.EndGetContext%2A> method to obtain the request, process it, and respond.  \n  \n In either model, incoming requests are accessed using the <xref:System.Net.HttpListenerContext.Request%2A?displayProperty=fullName> property and are represented by <xref:System.Net.HttpListenerRequest> objects. Similarly, responses are accessed using the <xref:System.Net.HttpListenerContext.Response%2A?displayProperty=fullName> property and are represented by <xref:System.Net.HttpListenerResponse> objects. These objects share some functionality with the <xref:System.Net.HttpWebRequest> and <xref:System.Net.HttpWebResponse> objects, but the latter objects cannot be used in conjunction with HttpListener because they implement client, not server, behaviors.  \n  \n An HttpListener can require client authentication. You can either specify a particular scheme to use for authentication, or you can specify a delegate that determines the scheme to use. You must require some form of authentication to obtain information about the client's identity. For additional information, see the <xref:System.Net.HttpListenerContext.User%2A>, <xref:System.Net.HttpListener.AuthenticationSchemes%2A>, and <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A> properties.  \n  \n> [!NOTE]\n>  If you create an HttpListener using https, you must select a Server Certificate for that listener. Otherwise, an <xref:System.Net.HttpWebRequest> query of this HttpListener will fail with an unexpected close of the connection.  \n  \n> [!NOTE]\n>  You can configure Server Certificates and other listener options by using HttpCfg.exe. See [http://msdn.microsoft.com/library/default.asp?url=/library/en-us/http/http/httpcfg_exe.asp](http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp) for more details. The executable is shipped with Windows Server 2003, or can be built from source code available in the Platform SDK.  \n  \n> [!NOTE]\n>  If you specify multiple authentication schemes for the HttpListener, the listener will challenge clients in the following order: `Negotiate`, `NTLM`, `Digest`, and then `Basic`."
  example:
  - "The following code example demonstrates using a HttpListener.  \n  \n [!code-cs[Net_Listener_Basic#2](~/add/codesnippet/csharp/t-system.net.httplistener_1.cs)]"
  syntax:
    content: 'public sealed class HttpListener : IDisposable'
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Net.HttpListener.#ctor
  id: '#ctor'
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: HttpListener()
  nameWithType: HttpListener.HttpListener()
  fullName: System.Net.HttpListener.HttpListener()
  type: Constructor
  assemblies:
  - System
  namespace: System.Net
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Net.HttpListener&quot;> </xref> klasy."
  remarks: "Przed rozpoczęciem korzystania z wystąpienia zwróconych przez ten konstruktor, należy wywołać jej <xref:System.Net.HttpListener.Start%2A>metody.</xref:System.Net.HttpListener.Start%2A>"
  example:
  - "The following code example demonstrates using the <xref:System.Net.HttpListener> constructor to create a new <xref:System.Net.HttpListener> object. For the complete example, see the <xref:System.Net.HttpListener> class topic.  \n  \n [!code-cs[Net_listener_Basic#9](~/add/codesnippet/csharp/m-system.net.httplistene_20_1.cs)]"
  syntax:
    content: public HttpListener ();
    parameters: []
  overload: System.Net.HttpListener.#ctor*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Ta klasa nie można używać w bieżącym systemie operacyjnym. Windows Server 2003 lub Windows XP z dodatkiem SP2 jest wymagany, aby użyć wystąpienia tej klasy."
  platform:
  - net462
- uid: System.Net.HttpListener.Abort
  id: Abort
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Abort()
  nameWithType: HttpListener.Abort()
  fullName: System.Net.HttpListener.Abort()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Zamyka <xref href=&quot;System.Net.HttpListener&quot;> </xref> obiekt natychmiast, odrzucenie wszystkich aktualnie w kolejce żądań."
  remarks: "Ta metoda usuwa wszystkie zasoby zajmowane przez tego odbiornika. Nie można ukończyć są wszystkie oczekujące żądania.       Po wywołaniu tej metody, zostanie wyświetlony <xref:System.ObjectDisposedException>, jeśli próba użycia tego <xref:System.Net.HttpListener>.</xref:System.Net.HttpListener> </xref:System.ObjectDisposedException>"
  example:
  - "The following code example demonstrates calling this method.  \n  \n [!code-cs[Net_Listener_Basic#11](~/add/codesnippet/csharp/m-system.net.httplistene_4_1.cs)]"
  syntax:
    content: public void Abort ();
    parameters: []
  overload: System.Net.HttpListener.Abort*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.AuthenticationSchemes
  id: AuthenticationSchemes
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: AuthenticationSchemes
  nameWithType: HttpListener.AuthenticationSchemes
  fullName: System.Net.HttpListener.AuthenticationSchemes
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Pobiera lub ustawia Schemat używany do uwierzytelniania klientów."
  remarks: "<xref:System.Net.HttpListener>Używa określony schemat uwierzytelniania wszystkich żądań przychodzących.</xref:System.Net.HttpListener> <xref:System.Net.HttpListener.GetContext%2A>i <xref:System.Net.HttpListener.EndGetContext%2A>metody zwracają przychodzącego żądania klienta tylko wtedy, gdy <xref:System.Net.HttpListener>pomyślnie uwierzytelnia żądanie.</xref:System.Net.HttpListener> </xref:System.Net.HttpListener.EndGetContext%2A> </xref:System.Net.HttpListener.GetContext%2A>       Można przejrzeć tożsamości pomyślnie uwierzytelnionego klienta przy użyciu <xref:System.Net.HttpListenerContext.User%2A?displayProperty=fullName>Właściwości.</xref:System.Net.HttpListenerContext.User%2A?displayProperty=fullName>       Jeśli chcesz <xref:System.Net.HttpListener>obiektem można używać różnych mechanizmów uwierzytelniania na podstawie charakterystyk żądań odbierze (na przykład żądania <xref:System.Net.HttpListenerRequest.Url%2A>lub <xref:System.Net.HttpListenerRequest.UserHostName%2A>Właściwości), musi implementować metodę, która wybiera schematu uwierzytelniania.</xref:System.Net.HttpListenerRequest.UserHostName%2A> </xref:System.Net.HttpListenerRequest.Url%2A> </xref:System.Net.HttpListener> Aby dowiedzieć się, jak to zrobić, zobacz <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A>dokumentacji właściwości.</xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A>      > [!NOTE] > Aby ustawić tę właściwość, aby włączyć Digest, NTLM lub Negotiate wymaga <xref:System.Security.Permissions.SecurityPermission> <xref:System.Security.Permissions.SecurityPermissionFlag>.</xref:System.Security.Permissions.SecurityPermissionFlag> </xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "The following code example demonstrates using the AuthenticationSchemes property to specify an authentication scheme.  \n  \n [!code-cs[Net_listener_Basic#14](~/add/codesnippet/csharp/p-system.net.httplistene_0_1.cs)]"
  syntax:
    content: public System.Net.AuthenticationSchemes AuthenticationSchemes { get; set; }
    return:
      type: System.Net.AuthenticationSchemes
      description: "Bitowe połączenie <xref:System.Net.AuthenticationSchemes>wartości wyliczenia wskazujących na to, jak klienci mają być uwierzytelniani.</xref:System.Net.AuthenticationSchemes> Wartość domyślna to <xref:System.Net.AuthenticationSchemes>.</xref:System.Net.AuthenticationSchemes>"
  overload: System.Net.HttpListener.AuthenticationSchemes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ten obiekt został zamknięty."
  platform:
  - net462
- uid: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate
  id: AuthenticationSchemeSelectorDelegate
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: AuthenticationSchemeSelectorDelegate
  nameWithType: HttpListener.AuthenticationSchemeSelectorDelegate
  fullName: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Pobiera lub ustawia delegat wywoływany w celu określenia protokół używany do uwierzytelniania klientów."
  remarks: "> [!NOTE]> Jeśli chcesz, aby ten sam protokół uwierzytelniania do użycia dla wszystkich żądań obsługiwanych przez konkretne wystąpienie <xref:System.Net.HttpListener>, nie trzeba ustawić tę właściwość.</xref:System.Net.HttpListener> Aby określić protokołu używanego do wszystkich żądań klientów, należy użyć <xref:System.Net.HttpListener.AuthenticationSchemes%2A>Właściwości.</xref:System.Net.HttpListener.AuthenticationSchemes%2A>       Jeśli klient nie określił informacji o uwierzytelnianiu w jego nagłówki <xref:System.Net.HttpListener>wywołuje określony obiekt delegowany dla każdego nieuwierzytelnione żądania przychodzącego określić, ile, protokołu używanego na potrzeby uwierzytelniania klienta.</xref:System.Net.HttpListener> <xref:System.Net.HttpListener.GetContext%2A>i <xref:System.Net.HttpListener.EndGetContext%2A>metody zwracają przychodzącego żądania tylko wtedy, gdy <xref:System.Net.HttpListener>pomyślnie uwierzytelnić żądania.</xref:System.Net.HttpListener> </xref:System.Net.HttpListener.EndGetContext%2A> </xref:System.Net.HttpListener.GetContext%2A> Jeśli nie można uwierzytelnić żądania, <xref:System.Net.HttpListener>automatycznie wyśle z powrotem odpowiedzi 401.</xref:System.Net.HttpListener> Można uzyskać tożsamości z pomyślnie uwierzytelnionego klienta przy użyciu <xref:System.Web.HttpRequest.LogonUserIdentity%2A?displayProperty=fullName>Właściwości.</xref:System.Web.HttpRequest.LogonUserIdentity%2A?displayProperty=fullName>       Możliwość delegowania wybór protokół uwierzytelniania do metody specyficzne dla aplikacji jest przydatne w przypadku wystąpienia <xref:System.Net.HttpListener>do używania różnych protokołów uwierzytelniania w zależności od właściwości żądania otrzymania (na przykład żądania <xref:System.Net.HttpListenerRequest.Url%2A>lub <xref:System.Net.HttpListenerRequest.UserHostAddress%2A>Właściwości).</xref:System.Net.HttpListenerRequest.UserHostAddress%2A> </xref:System.Net.HttpListenerRequest.Url%2A> </xref:System.Net.HttpListener>      > [!NOTE] > Aby ustawić tę właściwość, aby włączyć Digest, NTLM lub Negotiate wymaga <xref:System.Security.Permissions.SecurityPermission> <xref:System.Security.Permissions.SecurityPermissionFlag>.</xref:System.Security.Permissions.SecurityPermissionFlag> </xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "The following code example sets the value of this property.  \n  \n [!code-vb[NclListener#2](~/add/codesnippet/visualbasic/p-system.net.httplistene_2_1.vb)]\n [!code-cs[NclListener#2](~/add/codesnippet/csharp/p-system.net.httplistene_2_1.cs)]  \n  \n The following code example provides an implementation of a method invoked by an <xref:System.Net.AuthenticationSchemeSelector> delegate.  \n  \n [!code-vb[NclListener#1](~/add/codesnippet/visualbasic/p-system.net.httplistene_2_2.vb)]\n [!code-cs[NclListener#1](~/add/codesnippet/csharp/p-system.net.httplistene_2_2.cs)]"
  syntax:
    content: public System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate { get; set; }
    return:
      type: System.Net.AuthenticationSchemeSelector
      description: "<xref href=&quot;System.Net.AuthenticationSchemeSelector&quot;> </xref> Delegata, który wywołuje metodę, aby wybrać protokół uwierzytelniania. Wartość domyślna to <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ten obiekt został zamknięty."
  platform:
  - net462
- uid: System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)
  id: BeginGetContext(System.AsyncCallback,System.Object)
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: BeginGetContext(AsyncCallback,Object)
  nameWithType: HttpListener.BeginGetContext(AsyncCallback,Object)
  fullName: System.Net.HttpListener.BeginGetContext(AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Rozpoczyna asynchronicznie pobierania przychodzącego żądania."
  remarks: "Metoda BeginGetContext rozpoczyna (bez blokowania) wywołanie asynchroniczne do odbierania przychodzących żądań klientów. Przed wywołaniem tej metody, należy wywołać <xref:System.Net.HttpListener.Start%2A>— Metoda i Dodaj co najmniej jeden identyfikator URI (Uniform Resource) prefiksu do nasłuchiwania przez dodanie ciągi identyfikatora URI, aby <xref:System.Net.HttpListenerPrefixCollection>zwrócony przez <xref:System.Net.HttpListener.Prefixes%2A>Właściwości.</xref:System.Net.HttpListener.Prefixes%2A> </xref:System.Net.HttpListenerPrefixCollection> </xref:System.Net.HttpListener.Start%2A>       Należy ukończyć operację asynchroniczną przez wywołanie metody <xref:System.Net.HttpListener.EndGetContext%2A>metody.</xref:System.Net.HttpListener.EndGetContext%2A> Zazwyczaj metoda jest wywoływana przez `callback` delegowanie.       Ta metoda nie są blokowane podczas operacji. Aby uzyskać przychodzące żądanie i blok przed zakończeniem operacji, należy wywołać <xref:System.Net.HttpListener.GetContext%2A>metody.</xref:System.Net.HttpListener.GetContext%2A>       Aby uzyskać szczegółowe informacje o korzystaniu z modelem programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/add/includes/ajax-current-ext-md.md)"
  example:
  - "The following code example demonstrates using the BeginGetContext method to specify a callback method that will handle incoming client requests.  \n  \n [!code-cs[Net_Listener_Basic#12](~/add/codesnippet/csharp/m-system.net.httplistene_13_1.cs)]  \n  \n The following code example implements a callback method.  \n  \n [!code-cs[Net_Listener_Basic#13](~/add/codesnippet/csharp/m-system.net.httplistene_13_2.cs)]"
  syntax:
    content: public IAsyncResult BeginGetContext (AsyncCallback callback, object state);
    parameters:
    - id: callback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>Delegata, który odwołuje się do metody do wywołania, gdy żądanie klienta nie jest dostępny.</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "Obiekt użytkownika, który zawiera informacje na temat operacji. Ten obiekt jest przekazywany do `callback` delegować po zakończeniu operacji."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Obiekt, który wskazuje stan operacji asynchronicznej.</xref:System.IAsyncResult>"
  overload: System.Net.HttpListener.BeginGetContext*
  exceptions:
  - type: System.Net.HttpListenerException
    commentId: T:System.Net.HttpListenerException
    description: "Nie można wywołać funkcji Win32. Sprawdź wyjątek <xref:System.Net.HttpListenerException.ErrorCode*>właściwość, aby ustalić przyczynę tego wyjątku.</xref:System.Net.HttpListenerException.ErrorCode*>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Ten obiekt nie został uruchomiony lub jest obecnie zatrzymana."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ten obiekt jest zamknięty."
  platform:
  - net462
- uid: System.Net.HttpListener.Close
  id: Close
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Close()
  nameWithType: HttpListener.Close()
  fullName: System.Net.HttpListener.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Zamyka <xref href=&quot;System.Net.HttpListener&quot;> </xref>."
  remarks: "Po wywołaniu tej metody, nie można korzystać <xref:System.Net.HttpListener>obiektu.</xref:System.Net.HttpListener> Aby tymczasowo wstrzymać <xref:System.Net.HttpListener>obiektów, użyj <xref:System.Net.HttpListener.Stop%2A>metody.</xref:System.Net.HttpListener.Stop%2A> </xref:System.Net.HttpListener>       Zamknij tę metodę szczegółu <xref:System.Net.HttpListener>obiektu bez przetwarzania żądań w kolejce.</xref:System.Net.HttpListener> Nie można ukończyć są wszystkie oczekujące żądania."
  example:
  - "The following code example demonstrates calling this method.  \n  \n [!code-cs[Net_Listener_Basic#2](~/add/codesnippet/csharp/m-system.net.httplistene_10_1.cs)]"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Net.HttpListener.Close*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.DefaultServiceNames
  id: DefaultServiceNames
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: DefaultServiceNames
  nameWithType: HttpListener.DefaultServiceNames
  fullName: System.Net.HttpListener.DefaultServiceNames
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Pobiera listę domyślnej nazwy dostawcy usługi (SPN), zgodnie z ustaleniami zarejestrowanych prefiksów."
  remarks: "The DefaultServiceNames property is used with integrated Windows authentication to provide extended protection. The list of SPNs is initialized from the <xref:System.Net.HttpListener.Prefixes%2A> property when accessed and cleared when new prefixes are added to the <xref:System.Net.HttpListener.Prefixes%2A> property.  \n  \n The DefaultServiceNames property is used if an application doesn't set the <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames%2A> property on its extended protection policy.  \n  \n The <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection> that is retrieved with the DefaultServiceNames property is built from the <xref:System.Net.HttpListener.Prefixes%2A> property according to the following rules:  \n  \n1.  If the hostname is \"+\", \"*\", or an IPv4 or IPv6 literal (equivalent to \"\\*\" but restricted to a specific local interface), the following SPN is added:  \n  \n `\"HTTP/\"` plus the fully qualified domain name of the computer.  \n  \n1.  If the hostname contains no dots (no domains or subdomains), an attempt is made to resolve the fully-qualified domain name using DNS (the same behavior used by <xref:System.Net.HttpWebRequest>). If the fully-qualified domain name can be resolved, the following SPNs are added:  \n  \n `\"HTTP/\"` plus the hostname (the short name).  \n  \n `\"HTTP/\"` plus the fully qualified domain name for the hostname.  \n  \n1.  If the hostname contains not dots (no domains or subdomains) and a fully-qualified domain name can't be resolved, the following SPN is added:  \n  \n `\"HTTP/\"` plus the hostname.  \n  \n1.  If the hostname contains dots (domains or subdomains), the following SPN is added:  \n  \n `\"HTTP/\"` plus the hostname.  \n  \n The DefaultServiceNames property can be used by an application to review the list of default SPNs which will be used for authentication if no custom list is supplied. If other SPNs are needed, an application can add them using one of the <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection.Merge%2A> methods.  \n  \n It is not safe when using extended protection to make policy decisions based on the requested URL, since this can be spoofed. Rather, applications should rely on the <xref:System.Net.HttpListenerRequest.LocalEndPoint%2A> or <xref:System.Net.HttpListenerRequest.RemoteEndPoint%2A> properties to make such policy decisions."
  syntax:
    content: public System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames { get; }
    return:
      type: System.Security.Authentication.ExtendedProtection.ServiceNameCollection
      description: "A <xref href=&quot;System.Security.Authentication.ExtendedProtection.ServiceNameCollection&quot;> </xref> zawierający listę nazw SPN."
  overload: System.Net.HttpListener.DefaultServiceNames*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.EndGetContext(System.IAsyncResult)
  id: EndGetContext(System.IAsyncResult)
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: EndGetContext(IAsyncResult)
  nameWithType: HttpListener.EndGetContext(IAsyncResult)
  fullName: System.Net.HttpListener.EndGetContext(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Kończy operację asynchroniczną można pobrać przychodzącego żądania klienta."
  remarks: "Wywoływana metoda EndGetContext, zwykle wewnątrz metody zdefiniowane przez aplikację wywołanie zwrotne wywoływane przez pełnomocnika, aby uzyskać <xref:System.Net.HttpListenerContext>obiekt, który zawiera przychodzącego żądania klienta i jego skojarzone odpowiedzi.</xref:System.Net.HttpListenerContext> Ta metoda wykona operację wcześniej uruchomione przez wywołanie metody <xref:System.Net.HttpListener.BeginGetContext%2A>metody.</xref:System.Net.HttpListener.BeginGetContext%2A> Jeśli działanie nie zostało ukończone, ta metoda blokuje, dopóki nie robi.       Ponieważ wywołanie metody EndGetContext wymaga <xref:System.Net.HttpListener>obiektu, ten obiekt jest zwykle przekazany do metody wywołania zwrotnego przez przy użyciu obiektu stanu przekazany <xref:System.Net.HttpListener.BeginGetContext%2A>metody.</xref:System.Net.HttpListener.BeginGetContext%2A> </xref:System.Net.HttpListener> Ten obiekt stanu można uzyskać za pomocą <xref:System.IAsyncResult.AsyncState%2A>Właściwość `asyncResult` obiektu.</xref:System.IAsyncResult.AsyncState%2A>       Aby uzyskać szczegółowe informacje o korzystaniu z modelem programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/add/includes/ajax-current-ext-md.md)"
  example:
  - "The following code example shows the implementation of a callback method that calls the EndGetContext method.  \n  \n [!code-cs[Net_Listener_Basic#13](~/add/codesnippet/csharp/m-system.net.httplistene_1_1.cs)]"
  syntax:
    content: public System.Net.HttpListenerContext EndGetContext (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Obiektu uzyskanego podczas uruchomienia operacji asynchronicznej.</xref:System.IAsyncResult>"
    return:
      type: System.Net.HttpListenerContext
      description: "<xref href=&quot;System.Net.HttpListenerContext&quot;> </xref> Obiekt, który reprezentuje żądania klienta."
  overload: System.Net.HttpListener.EndGetContext*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>asyncResult</code>nie uzyskano przez wywołanie metody <xref:System.Net.HttpListener.BeginGetContext*> metody."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Metoda EndGetContext została już wywołana dla określonego <code> asyncResult </code> obiektu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ten obiekt jest zamknięty."
  platform:
  - net462
- uid: System.Net.HttpListener.ExtendedProtectionPolicy
  id: ExtendedProtectionPolicy
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: ExtendedProtectionPolicy
  nameWithType: HttpListener.ExtendedProtectionPolicy
  fullName: System.Net.HttpListener.ExtendedProtectionPolicy
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "GET lub set <xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref> do użycia na potrzeby ochrona rozszerzona na potrzeby sesji."
  remarks: "Zasada ExtendedProtectionPolicy jest używana przy użyciu zintegrowanego uwierzytelniania systemu Windows w celu zapewnienia ochrony rozszerzonej. Właściwość zasady ExtendedProtectionPolicy umożliwia konfigurację zasad ochrony rozszerzonej dla całej <xref:System.Net.HttpListener>sesji.</xref:System.Net.HttpListener> <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A>Właściwość umożliwia konfigurację zasad ochrony rozszerzonej dla poszczególnych żądań.</xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A>       <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A>Właściwość musi być `null`.</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> <xref:System.Net.HttpListener>Wystąpienia pobiera kanału powiązanie Token (CBT) bezpośrednio z własnej sesji protokołu TLS, jeśli istnieje.</xref:System.Net.HttpListener>"
  syntax:
    content: public System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy { get; set; }
    return:
      type: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
      description: "A <xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref> , który określa zasady, które mają być używane do ochrony rozszerzonej."
  overload: System.Net.HttpListener.ExtendedProtectionPolicy*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Nastąpiła próba można ustawić właściwości zasady ExtendedProtectionPolicy, ale <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding*>nie odnaleziono <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>.</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding*>"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Podjęto próbę ustawienia właściwości zasady ExtendedProtectionPolicy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nastąpiła próba można ustawić właściwości zasady ExtendedProtectionPolicy po <xref:System.Net.HttpListener.Start*>Metoda została już wywołana.</xref:System.Net.HttpListener.Start*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ten obiekt jest zamknięty."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement*>Ustawiono właściwość <xref href=&quot;System.Security.Authentication.ExtendedProtection.PolicyEnforcement&quot;> </xref> na platformie, która nie obsługuje ochrony rozszerzonej.</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement*>"
  platform:
  - net462
- uid: System.Net.HttpListener.ExtendedProtectionSelectorDelegate
  id: ExtendedProtectionSelectorDelegate
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: ExtendedProtectionSelectorDelegate
  nameWithType: HttpListener.ExtendedProtectionSelectorDelegate
  fullName: System.Net.HttpListener.ExtendedProtectionSelectorDelegate
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "GET lub set delegat wywoływany w celu określenia <xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref> dla każdego żądania."
  remarks: "<xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A>Właściwość jest używana przy użyciu zintegrowanego uwierzytelniania systemu Windows w celu zapewnienia ochrony rozszerzonej.</xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A>Właściwość umożliwia konfigurację zasad ochrony rozszerzonej dla całej <xref:System.Net.HttpListener>sesji.</xref:System.Net.HttpListener> </xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> Właściwość ExtendedProtectionSelectorDelegate umożliwia konfigurację zasad ochrona rozszerzona na oddzielne żądanie.       <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A>Właściwość musi być `null`.</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> <xref:System.Net.HttpListener>Wystąpienia pobiera kanału powiązanie Token (CBT) bezpośrednio z własnej sesji protokołu TLS, jeśli istnieje.</xref:System.Net.HttpListener>       Dla każdego żądania delegata można wybrać ustawienia <xref:System.Net.HttpListener>wystąpienie będzie używać w celu zapewnienia ochrony rozszerzonej.</xref:System.Net.HttpListener>       Jeśli zwraca delegata `null` dla tej właściwości, ta pozycja reprezentuje <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy>którego <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A>właściwości ustawiono <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement>.</xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement> </xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> </xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy>"
  syntax:
    content: public System.Net.HttpListener.ExtendedProtectionSelector ExtendedProtectionSelectorDelegate { get; set; }
    return:
      type: System.Net.HttpListener.ExtendedProtectionSelector
      description: "A <xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref> , który określa zasady, które mają być używane do ochrony rozszerzonej."
  overload: System.Net.HttpListener.ExtendedProtectionSelectorDelegate*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Nastąpiła próba można ustawić właściwości ExtendedProtectionSelectorDelegate, ale <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding*>właściwość musi być <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>.</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding*>"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Podjęto próbę ustawienia właściwości ExtendedProtectionSelectorDelegate <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nastąpiła próba można ustawić właściwości ExtendedProtectionSelectorDelegate po <xref:System.Net.HttpListener.Start*>Metoda została już wywołana.</xref:System.Net.HttpListener.Start*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ten obiekt jest zamknięty."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Próbowano ustawić właściwość ExtendedProtectionSelectorDelegate na platformie, która nie obsługuje ochrony rozszerzonej."
  platform:
  - net462
- uid: System.Net.HttpListener.GetContext
  id: GetContext
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: GetContext()
  nameWithType: HttpListener.GetContext()
  fullName: System.Net.HttpListener.GetContext()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Czeka na przychodzące żądania i zwraca po odebraniu jeden."
  remarks: "Przed wywołaniem tej metody, należy wywołać <xref:System.Net.HttpListener.Start%2A>— Metoda i Dodaj co najmniej jeden prefiks URI do nasłuchiwania przez dodanie ciągi identyfikatora URI, aby <xref:System.Net.HttpListenerPrefixCollection>zwrócony przez <xref:System.Net.HttpListener.Prefixes%2A>Właściwości.</xref:System.Net.HttpListener.Prefixes%2A> </xref:System.Net.HttpListenerPrefixCollection> </xref:System.Net.HttpListener.Start%2A> Aby uzyskać szczegółowy opis prefiksy, zobacz <xref:System.Net.HttpListener>Przegląd klasy.</xref:System.Net.HttpListener>       Tej metody bloki podczas oczekiwania na żądanie przychodzące. Żądania przychodzące do przetwarzania asynchronicznego (w oddzielnych wątkach), które nie są blokowane przez aplikację, należy użyć <xref:System.Net.HttpListener.BeginGetContext%2A>metody.</xref:System.Net.HttpListener.BeginGetContext%2A>"
  example:
  - "The following code example demonstrates calling this method.  \n  \n [!code-cs[Net_Listener_Basic#2](~/add/codesnippet/csharp/m-system.net.httplistene_19_1.cs)]"
  syntax:
    content: public System.Net.HttpListenerContext GetContext ();
    parameters: []
    return:
      type: System.Net.HttpListenerContext
      description: "<xref href=&quot;System.Net.HttpListenerContext&quot;> </xref> Obiekt, który reprezentuje żądania klienta."
  overload: System.Net.HttpListener.GetContext*
  exceptions:
  - type: System.Net.HttpListenerException
    commentId: T:System.Net.HttpListenerException
    description: "Nie można wywołać funkcji Win32. Sprawdź wyjątek <xref:System.Net.HttpListenerException.ErrorCode*>właściwość, aby ustalić przyczynę tego wyjątku.</xref:System.Net.HttpListenerException.ErrorCode*>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Ten obiekt nie został uruchomiony lub jest obecnie zatrzymana.       - lub - <xref href=&quot;System.Net.HttpListener&quot;> </xref> nie ma żadnych prefiksów identyfikator URI (Uniform Resource) odpowiedzieć na. Zobacz uwagi."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ten obiekt jest zamknięty."
  platform:
  - net462
- uid: System.Net.HttpListener.GetContextAsync
  id: GetContextAsync
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: GetContextAsync()
  nameWithType: HttpListener.GetContextAsync()
  fullName: System.Net.HttpListener.GetContextAsync()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Czeka na przychodzące żądania jako operację asynchroniczną."
  remarks: "Ta operacja nie powoduje blokowania. Zwrócona <xref:System.Threading.Tasks.Task%601>obiektu ukończy po otrzymaniu żądania przychodzącego.</xref:System.Threading.Tasks.Task%601>       Przed wywołaniem tej metody, należy wywołać <xref:System.Net.HttpListener.Start%2A>— Metoda i Dodaj co najmniej jeden prefiks URI do nasłuchiwania przez dodanie ciągi identyfikatora URI, aby <xref:System.Net.HttpListenerPrefixCollection>zwrócony przez <xref:System.Net.HttpListener.Prefixes%2A>Właściwości.</xref:System.Net.HttpListener.Prefixes%2A> </xref:System.Net.HttpListenerPrefixCollection> </xref:System.Net.HttpListener.Start%2A> Aby uzyskać szczegółowy opis prefiksy, zobacz <xref:System.Net.HttpListener>Przegląd klasy.</xref:System.Net.HttpListener>"
  syntax:
    content: public System.Threading.Tasks.Task<System.Net.HttpListenerContext> GetContextAsync ();
    parameters: []
    return:
      type: System.Threading.Tasks.Task{System.Net.HttpListenerContext}
      description: "Zwraca &lt;xref:System.Threading.Tasks.Task%601&gt;.       Obiekt zadania reprezentujący operację asynchroniczną. &lt;Xref:System.Threading.Tasks.Task%601.Result%2A&gt; zwraca właściwości dla obiektu task <xref href=&quot;System.Net.HttpListenerContext&quot;> </xref> obiekt, który reprezentuje żądania klienta."
  overload: System.Net.HttpListener.GetContextAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.IgnoreWriteExceptions
  id: IgnoreWriteExceptions
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: IgnoreWriteExceptions
  nameWithType: HttpListener.IgnoreWriteExceptions
  fullName: System.Net.HttpListener.IgnoreWriteExceptions
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Pobiera lub ustawia <xref:System.Boolean>wartość, która określa, czy aplikacja odbiera wyjątków, które występują po <xref href=&quot;System.Net.HttpListener&quot;> </xref> wysyła odpowiedź do klienta.</xref:System.Boolean>"
  remarks: "Ta właściwość jest ustawiana `true` Jeśli aplikacja nie wymaga, czy odpowiedź jest pomyślnie wysłane do każdego klienta."
  example:
  - "The following code example demonstrates setting this property.  \n  \n [!code-cs[Net_Listener_Basic#14](~/add/codesnippet/csharp/p-system.net.httplistene_31_1.cs)]"
  syntax:
    content: public bool IgnoreWriteExceptions { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli <xref href=&quot;System.Net.HttpListener&quot;> </xref> nie może zwracać wyjątków występujących podczas wysyłania odpowiedzi do klienta; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Wartość domyślna to <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.HttpListener.IgnoreWriteExceptions*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ten obiekt został zamknięty."
  platform:
  - net462
- uid: System.Net.HttpListener.IsListening
  id: IsListening
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: IsListening
  nameWithType: HttpListener.IsListening
  fullName: System.Net.HttpListener.IsListening
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Pobiera wartość wskazującą, czy <xref href=&quot;System.Net.HttpListener&quot;> </xref> została uruchomiona."
  remarks: "Aby uruchomić <xref:System.Net.HttpListener>, wywołaj <xref:System.Net.HttpListener.Start%2A>metody.</xref:System.Net.HttpListener.Start%2A> </xref:System.Net.HttpListener>"
  example:
  - "The following code example demonstrates using this property to determine the listening state of an instance.  \n  \n [!code-cs[Net_Listener_Basic#1](~/add/codesnippet/csharp/p-system.net.httplistene_41_1.cs)]"
  syntax:
    content: public bool IsListening { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli <xref href=&quot;System.Net.HttpListener&quot;> </xref> została rozpoczęta, a w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.HttpListener.IsListening*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.IsSupported
  id: IsSupported
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: IsSupported
  nameWithType: HttpListener.IsSupported
  fullName: System.Net.HttpListener.IsSupported
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Pobiera wartość wskazującą, czy <xref href=&quot;System.Net.HttpListener&quot;> </xref> mogą być używane z bieżącym systemem operacyjnym."
  remarks: "Ta klasa jest dostępna tylko na komputerach z systemem operacyjnym Windows XP z dodatkiem SP2 lub Windows Server 2003."
  example:
  - "The following code example demonstrates the use of the IsSupported property to detect whether an <xref:System.Net.HttpListener> object can be used with the current operating system.  \n  \n [!code-cs[Net_Listener_Basic#2](~/add/codesnippet/csharp/p-system.net.httplistene_21_1.cs)]"
  syntax:
    content: public static bool IsSupported { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli <xref href=&quot;System.Net.HttpListener&quot;> </xref> jest obsługiwany; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.HttpListener.IsSupported*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.Prefixes
  id: Prefixes
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Prefixes
  nameWithType: HttpListener.Prefixes
  fullName: System.Net.HttpListener.Prefixes
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Pobiera prefiksy jednolity identyfikator zasobów (URI), obsługiwane przez to <xref href=&quot;System.Net.HttpListener&quot;> </xref> obiektu."
  remarks: "Prefiksy są w formie kanonicznej. Aby uzyskać szczegółowy opis prefiksy, zobacz <xref:System.Net.HttpListener>Przegląd klasy.</xref:System.Net.HttpListener>"
  example:
  - "The following code example demonstrates using the Prefixes property to obtain and print the URI prefixes that are handled.  \n  \n [!code-cs[Net_Listener_Basic#1](~/add/codesnippet/csharp/p-system.net.httplistene_24_1.cs)]"
  syntax:
    content: public System.Net.HttpListenerPrefixCollection Prefixes { get; }
    return:
      type: System.Net.HttpListenerPrefixCollection
      description: "<xref href=&quot;System.Net.HttpListenerPrefixCollection&quot;> </xref> Zawiera identyfikator URI tego prefiksy <xref href=&quot;System.Net.HttpListener&quot;> </xref> obiektu jest skonfigurowane do obsługi."
  overload: System.Net.HttpListener.Prefixes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ten obiekt został zamknięty."
  platform:
  - net462
- uid: System.Net.HttpListener.Realm
  id: Realm
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Realm
  nameWithType: HttpListener.Realm
  fullName: System.Net.HttpListener.Realm
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Pobiera lub ustawia obszar lub partycję zasobu, skojarzone z tym <xref href=&quot;System.Net.HttpListener&quot;> </xref> obiektu."
  remarks: "Serwery używają obszarów do partycjonowania chronionych zasobów; Każda partycja może mieć własną schematu i/lub autoryzacji bazy danych uwierzytelniania. Obszarów są używane tylko w przypadku basic i uwierzytelniania szyfrowanego. Po pomyślnym uwierzytelnieniu klient, uwierzytelnianie jest prawidłowa dla wszystkich zasobów w danym obszarze. Szczegółowy opis obszarów, zobacz dokument RFC 2617 na [http://www.ietf.org](http://www.ietf.org).       Wystąpienie <xref:System.Net.HttpListener>ma tylko jeden obszar skojarzone.</xref:System.Net.HttpListener>"
  example:
  - "The following code example demonstrates setting the Realm property.  \n  \n [!code-cs[Net_Listener_Basic#10](~/add/codesnippet/csharp/p-system.net.httplistene_26_1.cs)]"
  syntax:
    content: public string Realm { get; set; }
    return:
      type: System.String
      description: "A <xref:System.String>wartości, która zawiera nazwę obszaru skojarzone z <xref href=&quot;System.Net.HttpListener&quot;> </xref> obiektu.</xref:System.String>"
  overload: System.Net.HttpListener.Realm*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ten obiekt został zamknięty."
  platform:
  - net462
- uid: System.Net.HttpListener.Start
  id: Start
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Start()
  nameWithType: HttpListener.Start()
  fullName: System.Net.HttpListener.Start()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Umożliwia to wystąpienie do odbierania żądań przychodzących."
  remarks: "Ta metoda musi zostać wywołana przed wywołaniem <xref:System.Net.HttpListener.GetContext%2A>lub <xref:System.Net.HttpListener.BeginGetContext%2A>metody.</xref:System.Net.HttpListener.BeginGetContext%2A> </xref:System.Net.HttpListener.GetContext%2A>       Po wykonaniu uruchomiony <xref:System.Net.HttpListener>obiekt, można użyć <xref:System.Net.HttpListener.Stop%2A>metody, aby zatrzymać go.</xref:System.Net.HttpListener.Stop%2A> </xref:System.Net.HttpListener>      > [!NOTE] > Jeśli to wystąpienie odbiornika używa protokołu https, należy zainstalować i wybrać certyfikat serwera. W przeciwnym razie <xref:System.Net.HttpWebRequest>zapytania tego <xref:System.Net.HttpListener>zakończy się niepowodzeniem z nieoczekiwane zamknięcie połączenia.</xref:System.Net.HttpListener> </xref:System.Net.HttpWebRequest> Certyfikaty serwera oraz inne opcje odbiornika można skonfigurować przy użyciu HttpCfg.exe. Zobacz [http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp](http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp) więcej szczegółów."
  example:
  - "The following code example demonstrates using the Start method to begin processing incoming requests.  \n  \n [!code-cs[Net_Listener_Basic#12](~/add/codesnippet/csharp/m-system.net.httplistene_12_1.cs)]"
  syntax:
    content: public void Start ();
    parameters: []
  overload: System.Net.HttpListener.Start*
  exceptions:
  - type: System.Net.HttpListenerException
    commentId: T:System.Net.HttpListenerException
    description: "Nie można wywołać funkcji Win32. Sprawdź wyjątek <xref:System.Net.HttpListenerException.ErrorCode*>właściwość, aby ustalić przyczynę tego wyjątku.</xref:System.Net.HttpListenerException.ErrorCode*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ten obiekt jest zamknięty."
  platform:
  - net462
- uid: System.Net.HttpListener.Stop
  id: Stop
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Stop()
  nameWithType: HttpListener.Stop()
  fullName: System.Net.HttpListener.Stop()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Powoduje to wystąpienie zrezygnować z otrzymywania żądań przychodzących."
  remarks: "Jeśli to wystąpienie jest już zatrzymana, wywołanie tej metody nie ma znaczenia.       Po zatrzymaniu, <xref:System.Net.HttpListener>obiekt, można użyć <xref:System.Net.HttpListener.Start%2A>metody jej ponownego uruchamiania.</xref:System.Net.HttpListener.Start%2A> </xref:System.Net.HttpListener>"
  example:
  - "The following code example demonstrates using the Stop method to stop processing incoming requests.  \n  \n [!code-cs[Net_Listener_Basic#12](~/add/codesnippet/csharp/m-system.net.httplistene_5_1.cs)]"
  syntax:
    content: public void Stop ();
    parameters: []
  overload: System.Net.HttpListener.Stop*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ten obiekt został zamknięty."
  platform:
  - net462
- uid: System.Net.HttpListener.System#IDisposable#Dispose
  id: System#IDisposable#Dispose
  isEii: true
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: System.IDisposable.Dispose()
  nameWithType: HttpListener.System.IDisposable.Dispose()
  fullName: System.Net.HttpListener.System.IDisposable.Dispose()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Zwalnia zasoby posiadanych przez to <xref href=&quot;System.Net.HttpListener&quot;> </xref> obiektu."
  remarks: "Aplikacje powinny używać <xref:System.Net.HttpListener.Close%2A>metody zamiast wywołaniem tej metody.</xref:System.Net.HttpListener.Close%2A>"
  syntax:
    content: void IDisposable.Dispose ();
    parameters: []
  overload: System.Net.HttpListener.System#IDisposable#Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.TimeoutManager
  id: TimeoutManager
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: TimeoutManager
  nameWithType: HttpListener.TimeoutManager
  fullName: System.Net.HttpListener.TimeoutManager
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Menedżer limitu czasu dla tego <xref href=&quot;System.Net.HttpListener&quot;> </xref> wystąpienia."
  remarks: "Menedżer limitu czasu definiuje granicach limitu czasu połączenia dla tego <xref:System.Net.HttpListener>wystąpienia.</xref:System.Net.HttpListener>"
  syntax:
    content: public System.Net.HttpListenerTimeoutManager TimeoutManager { get; }
    return:
      type: System.Net.HttpListenerTimeoutManager
      description: "Returns <xref href=&quot;System.Net.HttpListenerTimeoutManager&quot;></xref>.       Menedżer limitu czasu dla tego <xref href=&quot;System.Net.HttpListener&quot;> </xref> wystąpienia."
  overload: System.Net.HttpListener.TimeoutManager*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication
  id: UnsafeConnectionNtlmAuthentication
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: UnsafeConnectionNtlmAuthentication
  nameWithType: HttpListener.UnsafeConnectionNtlmAuthentication
  fullName: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Pobiera lub ustawia <xref:System.Boolean>wartość, która kontroluje, czy, gdy jest używany protokół NTLM, dodatkowe żądania przy użyciu tego samego połączenia protokołu Transmission Control Protocol (TCP) są wymagane w celu uwierzytelnienia.</xref:System.Boolean>"
  remarks: "Jeśli ta właściwość jest skonfigurowana `true` i pierwsze żądanie przy użyciu określonego połączenia TCP jest uwierzytelniany przy użyciu protokołu NTLM, kolejne żądania za pośrednictwem tego samego połączenia TCP są przetwarzane przy użyciu informacji o uwierzytelnianiu (<xref:System.Security.Principal.IIdentity>) żądania początkowego.</xref:System.Security.Principal.IIdentity>       Ta właściwość nie ma znaczenia podczas uwierzytelniania NTLM nie jest protokołem uwierzytelniania. Gdy Negotiate jest określony jako protokół uwierzytelniania, ta właściwość ma wpływ tylko wtedy, gdy rzeczywista protokół używany do uwierzytelniania NTLM.      > [!NOTE] > Podczas ustawienie dla tej właściwości `true` zwiększa wydajność, ponieważ <xref:System.Net.HttpListener>nie nie wysyłaj dodatkowe NTLM wezwań do uwierzytelnienia, w niewymagające wszystkich żądań, aby podać informacje uwierzytelniania jest zagrożenie bezpieczeństwa.</xref:System.Net.HttpListener> Należy określić, czy zwiększenia wydajności warto to ryzyko."
  example:
  - "The following code example demonstrates setting this property.  \n  \n [!code-cs[Net_Listener_Basic#14](~/add/codesnippet/csharp/p-system.net.httplistene_34_1.cs)]"
  syntax:
    content: public bool UnsafeConnectionNtlmAuthentication { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli <xref:System.Security.Principal.IIdentity>pierwszego żądanie zostanie użyty dla kolejnych żądań w ramach tego samego połączenia; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Security.Principal.IIdentity> Wartość domyślna to <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Ten obiekt został zamknięty."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.Net.HttpListenerException
  parent: System.Net
  isExternal: false
  name: HttpListenerException
  nameWithType: HttpListenerException
  fullName: System.Net.HttpListenerException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.Net.HttpListener.#ctor
  parent: System.Net.HttpListener
  isExternal: false
  name: HttpListener()
  nameWithType: HttpListener.HttpListener()
  fullName: System.Net.HttpListener.HttpListener()
- uid: System.Net.HttpListener.Abort
  parent: System.Net.HttpListener
  isExternal: false
  name: Abort()
  nameWithType: HttpListener.Abort()
  fullName: System.Net.HttpListener.Abort()
- uid: System.Net.HttpListener.AuthenticationSchemes
  parent: System.Net.HttpListener
  isExternal: false
  name: AuthenticationSchemes
  nameWithType: HttpListener.AuthenticationSchemes
  fullName: System.Net.HttpListener.AuthenticationSchemes
- uid: System.Net.AuthenticationSchemes
  parent: System.Net
  isExternal: true
  name: AuthenticationSchemes
  nameWithType: AuthenticationSchemes
  fullName: System.Net.AuthenticationSchemes
- uid: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate
  parent: System.Net.HttpListener
  isExternal: false
  name: AuthenticationSchemeSelectorDelegate
  nameWithType: HttpListener.AuthenticationSchemeSelectorDelegate
  fullName: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate
- uid: System.Net.AuthenticationSchemeSelector
  parent: System.Net
  isExternal: false
  name: AuthenticationSchemeSelector
  nameWithType: AuthenticationSchemeSelector
  fullName: System.Net.AuthenticationSchemeSelector
- uid: System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)
  parent: System.Net.HttpListener
  isExternal: false
  name: BeginGetContext(AsyncCallback,Object)
  nameWithType: HttpListener.BeginGetContext(AsyncCallback,Object)
  fullName: System.Net.HttpListener.BeginGetContext(AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Net.HttpListener.Close
  parent: System.Net.HttpListener
  isExternal: false
  name: Close()
  nameWithType: HttpListener.Close()
  fullName: System.Net.HttpListener.Close()
- uid: System.Net.HttpListener.DefaultServiceNames
  parent: System.Net.HttpListener
  isExternal: false
  name: DefaultServiceNames
  nameWithType: HttpListener.DefaultServiceNames
  fullName: System.Net.HttpListener.DefaultServiceNames
- uid: System.Security.Authentication.ExtendedProtection.ServiceNameCollection
  parent: System.Security.Authentication.ExtendedProtection
  isExternal: false
  name: ServiceNameCollection
  nameWithType: ServiceNameCollection
  fullName: System.Security.Authentication.ExtendedProtection.ServiceNameCollection
- uid: System.Net.HttpListener.EndGetContext(System.IAsyncResult)
  parent: System.Net.HttpListener
  isExternal: false
  name: EndGetContext(IAsyncResult)
  nameWithType: HttpListener.EndGetContext(IAsyncResult)
  fullName: System.Net.HttpListener.EndGetContext(IAsyncResult)
- uid: System.Net.HttpListenerContext
  parent: System.Net
  isExternal: false
  name: HttpListenerContext
  nameWithType: HttpListenerContext
  fullName: System.Net.HttpListenerContext
- uid: System.Net.HttpListener.ExtendedProtectionPolicy
  parent: System.Net.HttpListener
  isExternal: false
  name: ExtendedProtectionPolicy
  nameWithType: HttpListener.ExtendedProtectionPolicy
  fullName: System.Net.HttpListener.ExtendedProtectionPolicy
- uid: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
  parent: System.Security.Authentication.ExtendedProtection
  isExternal: false
  name: ExtendedProtectionPolicy
  nameWithType: ExtendedProtectionPolicy
  fullName: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
- uid: System.Net.HttpListener.ExtendedProtectionSelectorDelegate
  parent: System.Net.HttpListener
  isExternal: false
  name: ExtendedProtectionSelectorDelegate
  nameWithType: HttpListener.ExtendedProtectionSelectorDelegate
  fullName: System.Net.HttpListener.ExtendedProtectionSelectorDelegate
- uid: System.Net.HttpListener.ExtendedProtectionSelector
  parent: System.Net
  isExternal: false
  name: HttpListener+ExtendedProtectionSelector
  nameWithType: HttpListener+ExtendedProtectionSelector
  fullName: System.Net.HttpListener+ExtendedProtectionSelector
- uid: System.Net.HttpListener.GetContext
  parent: System.Net.HttpListener
  isExternal: false
  name: GetContext()
  nameWithType: HttpListener.GetContext()
  fullName: System.Net.HttpListener.GetContext()
- uid: System.Net.HttpListener.GetContextAsync
  parent: System.Net.HttpListener
  isExternal: false
  name: GetContextAsync()
  nameWithType: HttpListener.GetContextAsync()
  fullName: System.Net.HttpListener.GetContextAsync()
- uid: System.Threading.Tasks.Task{System.Net.HttpListenerContext}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<HttpListenerContext>
  nameWithType: Task<HttpListenerContext>
  fullName: System.Threading.Tasks.Task<System.Net.HttpListenerContext>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Net.HttpListenerContext>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Net.HttpListenerContext
    name: HttpListenerContext
    nameWithType: HttpListenerContext
    fullName: HttpListenerContext
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Net.HttpListener.IgnoreWriteExceptions
  parent: System.Net.HttpListener
  isExternal: false
  name: IgnoreWriteExceptions
  nameWithType: HttpListener.IgnoreWriteExceptions
  fullName: System.Net.HttpListener.IgnoreWriteExceptions
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Net.HttpListener.IsListening
  parent: System.Net.HttpListener
  isExternal: false
  name: IsListening
  nameWithType: HttpListener.IsListening
  fullName: System.Net.HttpListener.IsListening
- uid: System.Net.HttpListener.IsSupported
  parent: System.Net.HttpListener
  isExternal: false
  name: IsSupported
  nameWithType: HttpListener.IsSupported
  fullName: System.Net.HttpListener.IsSupported
- uid: System.Net.HttpListener.Prefixes
  parent: System.Net.HttpListener
  isExternal: false
  name: Prefixes
  nameWithType: HttpListener.Prefixes
  fullName: System.Net.HttpListener.Prefixes
- uid: System.Net.HttpListenerPrefixCollection
  parent: System.Net
  isExternal: false
  name: HttpListenerPrefixCollection
  nameWithType: HttpListenerPrefixCollection
  fullName: System.Net.HttpListenerPrefixCollection
- uid: System.Net.HttpListener.Realm
  parent: System.Net.HttpListener
  isExternal: false
  name: Realm
  nameWithType: HttpListener.Realm
  fullName: System.Net.HttpListener.Realm
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Net.HttpListener.Start
  parent: System.Net.HttpListener
  isExternal: false
  name: Start()
  nameWithType: HttpListener.Start()
  fullName: System.Net.HttpListener.Start()
- uid: System.Net.HttpListener.Stop
  parent: System.Net.HttpListener
  isExternal: false
  name: Stop()
  nameWithType: HttpListener.Stop()
  fullName: System.Net.HttpListener.Stop()
- uid: System.Net.HttpListener.System#IDisposable#Dispose
  parent: System.Net.HttpListener
  isExternal: false
  name: System.IDisposable.Dispose()
  nameWithType: HttpListener.System.IDisposable.Dispose()
  fullName: System.Net.HttpListener.System.IDisposable.Dispose()
- uid: System.Net.HttpListener.TimeoutManager
  parent: System.Net.HttpListener
  isExternal: false
  name: TimeoutManager
  nameWithType: HttpListener.TimeoutManager
  fullName: System.Net.HttpListener.TimeoutManager
- uid: System.Net.HttpListenerTimeoutManager
  parent: System.Net
  isExternal: false
  name: HttpListenerTimeoutManager
  nameWithType: HttpListenerTimeoutManager
  fullName: System.Net.HttpListenerTimeoutManager
- uid: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication
  parent: System.Net.HttpListener
  isExternal: false
  name: UnsafeConnectionNtlmAuthentication
  nameWithType: HttpListener.UnsafeConnectionNtlmAuthentication
  fullName: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication
- uid: System.Net.HttpListener.#ctor*
  parent: System.Net.HttpListener
  isExternal: false
  name: HttpListener
  nameWithType: HttpListener.HttpListener
- uid: System.Net.HttpListener.Abort*
  parent: System.Net.HttpListener
  isExternal: false
  name: Abort
  nameWithType: HttpListener.Abort
- uid: System.Net.HttpListener.AuthenticationSchemes*
  parent: System.Net.HttpListener
  isExternal: false
  name: AuthenticationSchemes
  nameWithType: HttpListener.AuthenticationSchemes
- uid: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate*
  parent: System.Net.HttpListener
  isExternal: false
  name: AuthenticationSchemeSelectorDelegate
  nameWithType: HttpListener.AuthenticationSchemeSelectorDelegate
- uid: System.Net.HttpListener.BeginGetContext*
  parent: System.Net.HttpListener
  isExternal: false
  name: BeginGetContext
  nameWithType: HttpListener.BeginGetContext
- uid: System.Net.HttpListener.Close*
  parent: System.Net.HttpListener
  isExternal: false
  name: Close
  nameWithType: HttpListener.Close
- uid: System.Net.HttpListener.DefaultServiceNames*
  parent: System.Net.HttpListener
  isExternal: false
  name: DefaultServiceNames
  nameWithType: HttpListener.DefaultServiceNames
- uid: System.Net.HttpListener.EndGetContext*
  parent: System.Net.HttpListener
  isExternal: false
  name: EndGetContext
  nameWithType: HttpListener.EndGetContext
- uid: System.Net.HttpListener.ExtendedProtectionPolicy*
  parent: System.Net.HttpListener
  isExternal: false
  name: ExtendedProtectionPolicy
  nameWithType: HttpListener.ExtendedProtectionPolicy
- uid: System.Net.HttpListener.ExtendedProtectionSelectorDelegate*
  parent: System.Net.HttpListener
  isExternal: false
  name: ExtendedProtectionSelectorDelegate
  nameWithType: HttpListener.ExtendedProtectionSelectorDelegate
- uid: System.Net.HttpListener.GetContext*
  parent: System.Net.HttpListener
  isExternal: false
  name: GetContext
  nameWithType: HttpListener.GetContext
- uid: System.Net.HttpListener.GetContextAsync*
  parent: System.Net.HttpListener
  isExternal: false
  name: GetContextAsync
  nameWithType: HttpListener.GetContextAsync
- uid: System.Net.HttpListener.IgnoreWriteExceptions*
  parent: System.Net.HttpListener
  isExternal: false
  name: IgnoreWriteExceptions
  nameWithType: HttpListener.IgnoreWriteExceptions
- uid: System.Net.HttpListener.IsListening*
  parent: System.Net.HttpListener
  isExternal: false
  name: IsListening
  nameWithType: HttpListener.IsListening
- uid: System.Net.HttpListener.IsSupported*
  parent: System.Net.HttpListener
  isExternal: false
  name: IsSupported
  nameWithType: HttpListener.IsSupported
- uid: System.Net.HttpListener.Prefixes*
  parent: System.Net.HttpListener
  isExternal: false
  name: Prefixes
  nameWithType: HttpListener.Prefixes
- uid: System.Net.HttpListener.Realm*
  parent: System.Net.HttpListener
  isExternal: false
  name: Realm
  nameWithType: HttpListener.Realm
- uid: System.Net.HttpListener.Start*
  parent: System.Net.HttpListener
  isExternal: false
  name: Start
  nameWithType: HttpListener.Start
- uid: System.Net.HttpListener.Stop*
  parent: System.Net.HttpListener
  isExternal: false
  name: Stop
  nameWithType: HttpListener.Stop
- uid: System.Net.HttpListener.System#IDisposable#Dispose*
  parent: System.Net.HttpListener
  isExternal: false
  name: System.IDisposable.Dispose
  nameWithType: HttpListener.System.IDisposable.Dispose
- uid: System.Net.HttpListener.TimeoutManager*
  parent: System.Net.HttpListener
  isExternal: false
  name: TimeoutManager
  nameWithType: HttpListener.TimeoutManager
- uid: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication*
  parent: System.Net.HttpListener
  isExternal: false
  name: UnsafeConnectionNtlmAuthentication
  nameWithType: HttpListener.UnsafeConnectionNtlmAuthentication
