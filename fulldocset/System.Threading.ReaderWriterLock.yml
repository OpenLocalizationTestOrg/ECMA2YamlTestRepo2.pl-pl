### YamlMime:ManagedReference
items:
- uid: System.Threading.ReaderWriterLock
  id: ReaderWriterLock
  children:
  - System.Threading.ReaderWriterLock.#ctor
  - System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)
  - System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)
  - System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)
  - System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)
  - System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)
  - System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)
  - System.Threading.ReaderWriterLock.Finalize
  - System.Threading.ReaderWriterLock.IsReaderLockHeld
  - System.Threading.ReaderWriterLock.IsWriterLockHeld
  - System.Threading.ReaderWriterLock.ReleaseLock
  - System.Threading.ReaderWriterLock.ReleaseReaderLock
  - System.Threading.ReaderWriterLock.ReleaseWriterLock
  - System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)
  - System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)
  - System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)
  - System.Threading.ReaderWriterLock.WriterSeqNum
  langs:
  - csharp
  name: ReaderWriterLock
  nameWithType: ReaderWriterLock
  fullName: System.Threading.ReaderWriterLock
  type: Class
  summary: "Definiuje blokadę obsługuje autorzy jednego i wielu czytników."
  remarks: "> [!IMPORTANT]> [!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)] Ma dwa reader_writer_lock, <xref:System.Threading.ReaderWriterLockSlim>i ReaderWriterLock —.</xref:System.Threading.ReaderWriterLockSlim> <xref:System.Threading.ReaderWriterLockSlim>jest zalecana dla wszystkich nowych wdrożeń.</xref:System.Threading.ReaderWriterLockSlim> <xref:System.Threading.ReaderWriterLockSlim>przypomina ReaderWriterLock —, ale jest prostszy zasady rekursji oraz uaktualniania i zmiany na starszą wersję stan blokady.</xref:System.Threading.ReaderWriterLockSlim> <xref:System.Threading.ReaderWriterLockSlim>pozwala uniknąć wielu przypadkach potencjalnych zakleszczenia.</xref:System.Threading.ReaderWriterLockSlim> Ponadto wydajność <xref:System.Threading.ReaderWriterLockSlim>jest znacznie lepszą niż ReaderWriterLock —.</xref:System.Threading.ReaderWriterLockSlim>       ReaderWriterLock — służy do synchronizowania dostęp do zasobu. W dowolnym momencie umożliwia równoczesne dostęp do odczytu dla wielu wątków lub dostęp do zapisu dla jednego wątku. W sytuacji, gdy zasób jest rzadko, zmieniane `ReaderWriterLock` zapewnia większą przepustowość niż proste blokady jednego w czasie, takie jak <xref:System.Threading.Monitor>.</xref:System.Threading.Monitor>       `ReaderWriterLock`działa najlepiej, których uzyskuje dostęp do większości odczytów, gdy zapisy są rzadko i krótki czas trwania. Wielu czytników alternatywne z pojedynczego zapisywania, dzięki czemu czytników ani zapisywania są blokowane przez dłuższy czas.      > [!NOTE] > Akcji blokad czytnika lub blokad modułu zapisującego dla długim będzie blokować go, inne wątki. Aby uzyskać najlepszą wydajność należy wziąć pod uwagę restrukturyzacji aplikacji w taki sposób, aby zminimalizować czas trwania operacji zapisu.       Wątek może zawierać czytnik blokady lub blokadę zapisu, ale nie oba jednocześnie. Zamiast zwalnianie blokada czytnika. Aby uzyskać blokadę zapisu, można użyć <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>do <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> </xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>       Żądania lock cykliczne Zwiększ liczbę blokad na blokadę.       Czytniki i zapisywania są umieszczane w kolejce oddzielnie. Gdy wątek zwalnia blokadę zapisu, wszystkich wątków oczekujących w kolejce czytnika w tej chwili otrzymują blokad czytnika; gdy wszystkie te blokady czytnika zostały zwolnione, dalej oczekiwania wątku w moduł zapisujący kolejki, jeśli istnieje, uzyskuje blokadę zapisu i tak dalej. Innymi słowy `ReaderWriterLock` przełącza między kolekcją czytelników i jednego składnika zapisywania.       Podczas wątku w kolejce modułu zapisującego oczekuje na zwolnienie blokad aktywny czytnik, żądanie nowego czytnika blokad wątków gromadzone w kolejce czytnika. Ich żądania nie są przyznawane, mimo że można mają współbieżny dostęp z istniejących posiadaczy blokada czytnika; Pozwala to chronić autorów przed nieograniczonego zablokowaniu przez czytelników.       Uzyskiwanie blokad na większości metod `ReaderWriterLock` zaakceptować wartości limitu czasu. Użyj limitów czasu, aby uniknąć zakleszczenie w aplikacji. Na przykład wątek może uzyskać blokadę zapisu na jeden zasób, a następnie żądają blokadę na drugi zasobów; Tymczasem inny wątek może uzyskać blokadę zapisu na drugi oraz blokadę pierwszego żądania. Jeśli używane są limity czasu, zakleszczenie wątków.       Jeśli interwał limitu czasu wygaśnie, a nie udzielono żądanie blokady, metoda zwraca kontroli w wątku wywołującym przez zgłaszanie <xref:System.ApplicationException>.</xref:System.ApplicationException> Wątek można przechwycić tego wyjątku i ustalić, jakie działania należy podjąć.       Limity czasu są wyrażony w milisekundach. Jeśli używasz, <xref:System.TimeSpan?displayProperty=fullName>Aby określić limit czasu, wartość używana jest całkowita liczba pełnych milisekund reprezentowany przez <xref:System.TimeSpan>.</xref:System.TimeSpan> </xref:System.TimeSpan?displayProperty=fullName> W poniższej tabeli przedstawiono wartości prawidłowy limit czasu w milisekundach.      | Wartość | Opis elementu |   |-----------|-----------------|   | -1 | Wątek oczekuje, aż uzyskać blokady, niezależnie od tego, jak długo. Dla metod, które określić limity czasu liczba całkowita, użyciem stała <xref:System.Threading.Timeout.Infinite>. |   |&0; | Wątek nie oczekuje na przejęcie blokady.</xref:System.Threading.Timeout.Infinite> Jeśli nie można uzyskać blokady natychmiast, metoda zwraca. |   | >&0; | Wyrażony w milisekundach czas oczekiwania. |       Z wyjątkiem -1 wartości limitu czasu ujemne są niedozwolone. Jeśli określisz ujemną liczbą całkowitą od-1, zamiast niego jest używana wartość limitu czasu o wartości zero. (To znaczy, metoda zwraca bez oczekiwania, jeśli nie można natychmiast uzyskać blokady.) Jeśli określisz <xref:System.TimeSpan>reprezentujący ujemnej liczby milisekund od-1, <xref:System.ArgumentOutOfRangeException>jest generowany.</xref:System.ArgumentOutOfRangeException> </xref:System.TimeSpan>"
  example:
  - "The following example demonstrates how to use a ReaderWriterLock to protect a shared resource, an integer value named `resource`, that is read concurrently and written exclusively by multiple threads. Note that the ReaderWriterLock is declared at the class level so that it is visible to all threads.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#1](~/add/codesnippet/cpp/t-system.threading.reade_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#1](~/add/codesnippet/csharp/t-system.threading.reade_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#1](~/add/codesnippet/visualbasic/t-system.threading.reade_1.vb)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class ReaderWriterLock : System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  inheritance:
  - System.Object
  - System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.#ctor
  id: '#ctor'
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReaderWriterLock()
  nameWithType: ReaderWriterLock.ReaderWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReaderWriterLock()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Threading.ReaderWriterLock&quot;> </xref> klasy."
  remarks: ''
  example:
  - "The following code example demonstrates how to create a new instance of the <xref:System.Threading.ReaderWriterLock> class.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_0_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_0_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_0_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_0_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_0_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_0_2.vb)]"
  syntax:
    content: public ReaderWriterLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)
  id: AcquireReaderLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireReaderLock(Int32)
  nameWithType: ReaderWriterLock.AcquireReaderLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Uzyskuje czytnik zablokować, przy użyciu <xref:System.Int32>wartość limitu czasu.</xref:System.Int32>"
  remarks: "AcquireReaderLock blokuje, jeśli moduł zapisujący blokady ma inny wątek lub co najmniej jeden wątek oczekuje na blokadę zapisu.      > [!NOTE] > Jeśli bieżący wątek już moduł zapisujący blokady, blokada nie czytnik jest uzyskiwana. Zamiast tego jest zwiększany liczbę blokad na blokadę zapisu. Zapobiega to blokowania na jego własnej blokadę wątku. Wynik jest dokładnie taka sama, co wywołanie <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>oraz dodatkowe wywołanie <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>jest wymagana podczas zwalniania blokady modułu zapisującego.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> </xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>       `AcquireReaderLock`obsługuje żądania blokada czytnika cyklicznego. Oznacza to wątku mogą wywoływać AcquireReaderLock wielokrotnie, która zwiększa liczbę blokad zawsze. Należy wywołać <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A>raz przy każdym wywołaniu `AcquireReaderLock`.</xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> Alternatywnie możesz wywołać <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>Aby zmniejszyć liczbę blokad na zero, natychmiast.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       Cykliczne blokady są zawsze przydzielić natychmiast, bez wprowadzania wątku żądania w kolejce czytnika. Umożliwia cykliczne blokady z ostrożnością, unikania blokowania blokadę zapisu żądania przez dłuższy czas.       Dla limitu czasu prawidłowe wartości zobacz <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  example:
  - "The following code example shows how to acquire and release a reader lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_6_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_6_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_6_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#3](~/add/codesnippet/cpp/m-system.threading.reade_6_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#3](~/add/codesnippet/csharp/m-system.threading.reade_6_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#3](~/add/codesnippet/visualbasic/m-system.threading.reade_6_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_6_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_6_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_6_3.vb)]"
  syntax:
    content: public void AcquireReaderLock (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "Limit czasu w milisekundach."
  overload: System.Threading.ReaderWriterLock.AcquireReaderLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>millisecondsTimeout</code>wygasa przed udzieleniem żądanie blokady."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)
  id: AcquireReaderLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireReaderLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireReaderLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Uzyskuje czytnik zablokować, przy użyciu <xref:System.TimeSpan>wartość limitu czasu.</xref:System.TimeSpan>"
  remarks: "<xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A>blokuje, jeśli moduł zapisujący blokady ma inny wątek lub co najmniej jeden wątek oczekuje na blokadę zapisu.</xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A>      > [!NOTE] > Jeśli bieżący wątek już moduł zapisujący blokady, blokada nie czytnik jest uzyskiwana. Zamiast tego jest zwiększany liczbę blokad na blokadę zapisu. Zapobiega to blokowania na jego własnej blokadę wątku. Wynik jest dokładnie taka sama, co wywołanie <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>oraz dodatkowe wywołanie <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>jest wymagana podczas zwalniania blokady modułu zapisującego.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> </xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>       `AcquireReaderLock`obsługuje żądania blokada czytnika cyklicznego. Oznacza to wątku mogą wywoływać AcquireReaderLock wielokrotnie, która zwiększa liczbę blokad zawsze. Należy wywołać <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A>raz przy każdym wywołaniu `AcquireReaderLock`.</xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> Alternatywnie możesz wywołać <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>Aby zmniejszyć liczbę blokad na zero, natychmiast.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       Cykliczne blokady są zawsze przydzielić natychmiast, bez wprowadzania wątku żądania w kolejce czytnika. Umożliwia cykliczne blokady z ostrożnością, unikania blokowania blokadę zapisu żądania przez dłuższy czas.       Dla limitu czasu prawidłowe wartości zobacz <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  syntax:
    content: public void AcquireReaderLock (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "A <xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref> określający okres limitu czasu."
  overload: System.Threading.ReaderWriterLock.AcquireReaderLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>wygasa przed udzieleniem żądanie blokady."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>timeout</code>Określa wartość ujemną, innego niż-1 milisekund."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)
  id: AcquireWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireWriterLock(Int32)
  nameWithType: ReaderWriterLock.AcquireWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Pobiera moduł zapisujący zablokować, przy użyciu <xref:System.Int32>wartość limitu czasu.</xref:System.Int32>"
  remarks: "Ta metoda blokuje, jeśli ma inny wątek blokada czytnika lub moduł zapisujący blokady. Opis sposobu zastępcy moduł zapisujący blokady wyposażonych w kilka blokad czytnika jednoczesnych, zobacz <xref:System.Threading.ReaderWriterLock>klasy.</xref:System.Threading.ReaderWriterLock>       Wątek, który ma już blokadę może uzyskać blokadę zapisu w jeden z dwóch sposobów: przez zwolnienie blokady czytnika przed wywołaniem metody AcquireWriterLock lub poprzez wywołanie <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>      > [!CAUTION] > Wywołuje wątku `AcquireWriterLock` gdy nadal jest blokadę, blokuje na jego własnej blokada czytnika; Jeśli nieskończonego limitu czasu jest określony, będzie zakleszczenie wątku. Aby uniknąć takich zakleszczenia, użyj <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>ustalenie, czy bieżący wątek jest już blokadę.</xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>       `AcquireWriterLock`obsługuje żądania blokadę zapisu cyklicznego. Oznacza to, że wątek można wywołać `AcquireWriterLock` wielokrotnie, która zwiększa liczbę blokad zawsze. Należy wywołać <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>raz przy każdym wywołaniu `AcquireWriterLock`.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> Alternatywnie możesz wywołać <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>Aby zmniejszyć liczbę blokad na zero, natychmiast.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       Cykliczne blokady są zawsze przydzielić natychmiast, bez wprowadzania wątku żądania w kolejce modułu zapisującego.       Dla limitu czasu prawidłowe wartości zobacz <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  example:
  - "The following code example shows how to acquire and release a writer lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_4_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_4_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_4_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#4](~/add/codesnippet/cpp/m-system.threading.reade_4_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#4](~/add/codesnippet/csharp/m-system.threading.reade_4_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#4](~/add/codesnippet/visualbasic/m-system.threading.reade_4_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_4_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_4_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_4_3.vb)]"
  syntax:
    content: public void AcquireWriterLock (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "Limit czasu w milisekundach."
  overload: System.Threading.ReaderWriterLock.AcquireWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>wygasa przed udzieleniem żądanie blokady."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)
  id: AcquireWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AcquireWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Pobiera moduł zapisujący zablokować, przy użyciu <xref:System.TimeSpan>wartość limitu czasu.</xref:System.TimeSpan>"
  remarks: "Ta metoda blokuje, jeśli ma inny wątek blokada czytnika lub moduł zapisujący blokady. Opis sposobu zastępcy moduł zapisujący blokady wyposażonych w kilka blokad czytnika jednoczesnych, zobacz <xref:System.Threading.ReaderWriterLock>klasy.</xref:System.Threading.ReaderWriterLock>       Wątek, który ma już blokadę może uzyskać blokadę zapisu w jeden z dwóch sposobów: przez zwolnienie blokady czytnika przed wywołaniem <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, lub przez wywołanie metody <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> </xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>      > [!CAUTION] > Wywołuje wątku `AcquireWriterLock` gdy nadal jest blokadę, blokuje na jego własnej blokada czytnika; Jeśli nieskończonego limitu czasu jest określony, będzie zakleszczenie wątku. Aby uniknąć takich zakleszczenia, użyj <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>ustalenie, czy bieżący wątek jest już blokadę.</xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>       `AcquireWriterLock`obsługuje żądania blokadę zapisu cyklicznego. Oznacza to, że wątek można wywołać `AcquireWriterLock` wielokrotnie, która zwiększa liczbę blokad zawsze. Należy wywołać <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>raz przy każdym wywołaniu `AcquireWriterLock`.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> Alternatywnie możesz wywołać <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>Aby zmniejszyć liczbę blokad na zero, natychmiast.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       Cykliczne blokady są zawsze przydzielić natychmiast, bez wprowadzania wątku żądania w kolejce modułu zapisującego.       Dla limitu czasu prawidłowe wartości zobacz <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  syntax:
    content: public void AcquireWriterLock (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "<xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref> Określający okres limitu czasu."
  overload: System.Threading.ReaderWriterLock.AcquireWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>wygasa przed udzieleniem żądanie blokady."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>timeout</code>Określa wartość ujemną, innego niż-1 milisekund."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)
  id: AnyWritersSince(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: AnyWritersSince(Int32)
  nameWithType: ReaderWriterLock.AnyWritersSince(Int32)
  fullName: System.Threading.ReaderWriterLock.AnyWritersSince(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Wskazuje, czy moduł zapisujący blokady zostało przyznane którymkolwiek wątku ponieważ uzyskano numer sekwencji."
  remarks: "Można użyć <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A>i `AnyWritersSince` aby poprawić wydajność aplikacji.</xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> Na przykład wątku może buforować informacje, które uzyskuje podczas utrzymywania blokady czytnika. Po zwalniania i później reacquiring blokady, można użyć wątku `AnyWritersSince` ustalenie, czy inne wątki zostały zapisane do zasobu w międzyczasie; w przeciwnym razie można buforowanych informacji. Ta technika jest przydatna, gdy odczytu informacji o chronionych przez blokady jest kosztowne. na przykład uruchomienie kwerendy bazy danych.       Obiekt wywołujący musi zawierający blokadę lub blokadę zapisu w kolejności numeru sekwencji powinna być użyteczna."
  example:
  - "The following code example shows how to use the AnyWritersSince method and the <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> property to determine whether another thread acquired the writer lock on the protected resource since the current thread last held the writer lock.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_8_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_8_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_8_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/m-system.threading.reade_8_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/m-system.threading.reade_8_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/m-system.threading.reade_8_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_8_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_8_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_8_3.vb)]"
  syntax:
    content: public bool AnyWritersSince (int seqNum);
    parameters:
    - id: seqNum
      type: System.Int32
      description: "Numer sekwencji."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli moduł zapisujący blokady zostało przyznane którymkolwiek wątku ponieważ uzyskano numer sekwencyjny; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ReaderWriterLock.AnyWritersSince*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)
  id: DowngradeFromWriterLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: DowngradeFromWriterLock(LockCookie)
  nameWithType: ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Przywraca stan blokady wątku sprzed <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>została wywołana.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>"
  remarks: "DowngradeFromWriterLock zwalnia blokadę zapisu, niezależnie od tego, liczbę blokad cykliczne i przywraca blokada czytnika, która obowiązywała przez wątek przed uaktualnieniem do wersji blokadę zapisu. Po przywróceniu liczbę blokad na blokada czytnika.      > [!NOTE]  >   `DowngradeFromWriterLock` akceptuje <xref:System.Threading.LockCookie>można uzyskać przez wywołanie <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> </xref:System.Threading.LockCookie> Nie używaj `LockCookie` zwrócony przez <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>       Wątek nie blokuje przy przechodzeniu z blokadę zapisu nawet w przypadku innych wątków oczekuje na blokadę zapisu, ponieważ wszystkie żądania blokada czytnika są przyznawane po zwolnieniu blokadę zapisu."
  example:
  - "The following code example shows how to request a reader lock, upgrade the reader lock to a writer lock, and downgrade to a reader lock again.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/b2680c56-6b6f-4bd1-ba78-_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/b2680c56-6b6f-4bd1-ba78-_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/b2680c56-6b6f-4bd1-ba78-_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#5](~/add/codesnippet/cpp/b2680c56-6b6f-4bd1-ba78-_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#5](~/add/codesnippet/csharp/b2680c56-6b6f-4bd1-ba78-_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#5](~/add/codesnippet/visualbasic/b2680c56-6b6f-4bd1-ba78-_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/b2680c56-6b6f-4bd1-ba78-_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/b2680c56-6b6f-4bd1-ba78-_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/b2680c56-6b6f-4bd1-ba78-_3.vb)]"
  syntax:
    content: public void DowngradeFromWriterLock (ref System.Threading.LockCookie lockCookie);
    parameters:
    - id: lockCookie
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;> </xref> zwrócony przez <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock*>"
  overload: System.Threading.ReaderWriterLock.DowngradeFromWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "Wątek nie ma blokady modułu zapisującego."
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Adres <code> lockCookie </code> jest wskaźnika o wartości null."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.Finalize
  id: Finalize
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: Finalize()
  nameWithType: ReaderWriterLock.Finalize()
  fullName: System.Threading.ReaderWriterLock.Finalize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Gwarantuje, że zasoby są zwalniane i inne operacje oczyszczania są wykonywane, gdy moduł garbage collector zwraca <xref href=&quot;System.Threading.ReaderWriterLock&quot;> </xref> obiektu."
  remarks: "Moduł zbierający elementy bezużyteczne Finalize wywołania, gdy bieżący <xref:System.Threading.ReaderWriterLock>obiekt jest gotowy do przetwarzania.</xref:System.Threading.ReaderWriterLock>"
  syntax:
    content: ~ReaderWriterLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.IsReaderLockHeld
  id: IsReaderLockHeld
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: IsReaderLockHeld
  nameWithType: ReaderWriterLock.IsReaderLockHeld
  fullName: System.Threading.ReaderWriterLock.IsReaderLockHeld
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Pobiera wartość wskazującą, czy bieżący wątek utrzymuje blokadę."
  remarks: ''
  example:
  - "The following code example demonstrates how to use `IsReaderLockHeld` to avoid deadlocks.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/cpp/p-system.threading.reade_1_1.cpp)]\n [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/visualbasic/p-system.threading.reade_1_1.vb)]\n [!code-cs[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/csharp/p-system.threading.reade_1_1.cs)]"
  syntax:
    content: public bool IsReaderLockHeld { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli bieżący wątek utrzymuje blokadę; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ReaderWriterLock.IsReaderLockHeld*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.IsWriterLockHeld
  id: IsWriterLockHeld
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: IsWriterLockHeld
  nameWithType: ReaderWriterLock.IsWriterLockHeld
  fullName: System.Threading.ReaderWriterLock.IsWriterLockHeld
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Pobiera wartość wskazującą, czy bieżący wątek utrzymuje blokadę zapisu."
  remarks: ''
  example:
  - "The following code example demonstrates that when an attempt is made to acquire a reader lock on a thread that has a writer lock, `ReaderWriterLock` does not grant the reader lock but instead increments the lock count on the writer lock.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/cpp/p-system.threading.reade_0_1.cpp)]\n [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/visualbasic/p-system.threading.reade_0_1.vb)]\n [!code-cs[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/add/codesnippet/csharp/p-system.threading.reade_0_1.cs)]"
  syntax:
    content: public bool IsWriterLockHeld { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli bieżący wątek utrzymuje blokadę; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ReaderWriterLock.IsWriterLockHeld*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.ReleaseLock
  id: ReleaseLock
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReleaseLock()
  nameWithType: ReaderWriterLock.ReleaseLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseLock()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Zwalnia blokadę, niezależnie od tego, ile razy wątek uzyskać blokady."
  remarks: "Metody ReleaseLock zwalnia blokada czytnika lub blokadę zapisu, niezależnie od tego, liczbę blokad cyklicznego. Aby przywrócić stan blokady, w tym liczbę blokad przekazać <xref:System.Threading.LockCookie>do <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</xref:System.Threading.ReaderWriterLock.RestoreLock%2A> </xref:System.Threading.LockCookie>"
  example:
  - "The following code example shows how to use the ReleaseLock method to release the lock, regardless of how many times it has been acquired by the thread, and how to restore the state of the lock later.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_1_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_1_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_1_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/m-system.threading.reade_1_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/m-system.threading.reade_1_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/m-system.threading.reade_1_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_1_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_1_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_1_3.vb)]"
  syntax:
    content: public System.Threading.LockCookie ReleaseLock ();
    parameters: []
    return:
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;> </xref> wartość reprezentującą zwolnione blokady."
  overload: System.Threading.ReaderWriterLock.ReleaseLock*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.ReleaseReaderLock
  id: ReleaseReaderLock
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReleaseReaderLock()
  nameWithType: ReaderWriterLock.ReleaseReaderLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseReaderLock()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Zmniejsza liczbę blokad."
  remarks: "ReleaseReaderLock zmniejsza liczbę blokad. Jeśli licznik osiągnie wartość zero, blokada jest zwalniany.      > [!NOTE] > Jeśli wątek blokadę zapisu, wywoływania `ReleaseReaderLock` ma ten sam efekt co wywołanie <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> Jeśli wątku nie ma blokad, wywoływania `ReleaseReaderLock` zgłasza <xref:System.ApplicationException>.</xref:System.ApplicationException>"
  example:
  - "The following code example shows how to acquire and release a reader lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_5_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_5_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_5_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#3](~/add/codesnippet/cpp/m-system.threading.reade_5_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#3](~/add/codesnippet/csharp/m-system.threading.reade_5_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#3](~/add/codesnippet/visualbasic/m-system.threading.reade_5_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_5_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_5_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_5_3.vb)]"
  syntax:
    content: public void ReleaseReaderLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.ReleaseReaderLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "Wątek nie ma żadnych blokad odczytywania lub zapisywania."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.ReleaseWriterLock
  id: ReleaseWriterLock
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: ReleaseWriterLock()
  nameWithType: ReaderWriterLock.ReleaseWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseWriterLock()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Zmniejsza liczbę blokad na blokadę zapisu."
  remarks: "ReleaseWriterLock zmniejsza liczbę blokad modułu zapisującego. Jeśli licznik osiągnie wartość zero, moduł zapisujący blokady jest zwalniany.      > [!NOTE] > Jeśli wątek blokadę lub nie blokad, wywoływania `ReleaseWriterLock` zgłasza <xref:System.ApplicationException>.</xref:System.ApplicationException>"
  example:
  - "The following code example shows how to acquire and release a writer lock, and how to handle the exception thrown when a request times out.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_3_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_3_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_3_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#4](~/add/codesnippet/cpp/m-system.threading.reade_3_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#4](~/add/codesnippet/csharp/m-system.threading.reade_3_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#4](~/add/codesnippet/visualbasic/m-system.threading.reade_3_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_3_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_3_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_3_3.vb)]"
  syntax:
    content: public void ReleaseWriterLock ();
    parameters: []
  overload: System.Threading.ReaderWriterLock.ReleaseWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "Wątek nie ma blokady modułu zapisującego."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)
  id: RestoreLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: RestoreLock(LockCookie)
  nameWithType: ReaderWriterLock.RestoreLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.RestoreLock(LockCookie)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Przywraca stan blokady wątku jest przed wywołaniem <xref:System.Threading.ReaderWriterLock.ReleaseLock*>.</xref:System.Threading.ReaderWriterLock.ReleaseLock*>"
  remarks: "Stan przywrócone przez `RestoreLock` zawiera liczbę blokad cyklicznego.       Bloki wątku, jeśli próbuje przywrócić blokadę po inny wątek ustawił blokadę zapisu lub spróbuje przywrócić blokadę zapisu, po inny wątek ustawił blokada czytnika lub moduł zapisujący blokady. Ponieważ `RestoreLock` nie akceptuje limit czasu, można należy zwrócić uwagę, aby uniknąć możliwe zakleszczenie.      > [!CAUTION] > Przed wywołaniem `RestoreLock`, upewnij się, że zostały wydane wszystkich blokad ustawionych od czasu wywołania <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> Na przykład wątku zakleszczenie jeśli uzyskuje blokadę, a następnie podejmie próbę przywrócenia starszej blokadę zapisu. Użyj <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>i <xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A>do wykrywania takich dodatkowych blokad.</xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A> </xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>       Nie używaj <xref:System.Threading.LockCookie>zwrócony z <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> </xref:System.Threading.LockCookie>"
  example:
  - "The following code example shows how to use the <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> method to release the lock, regardless of how many times it has been acquired by the thread, and how to restore the state of the lock later.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_2_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_2_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_2_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/m-system.threading.reade_2_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/m-system.threading.reade_2_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/m-system.threading.reade_2_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_2_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_2_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_2_3.vb)]"
  syntax:
    content: public void RestoreLock (ref System.Threading.LockCookie lockCookie);
    parameters:
    - id: lockCookie
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;> </xref> zwrócony przez <xref:System.Threading.ReaderWriterLock.ReleaseLock*>.</xref:System.Threading.ReaderWriterLock.ReleaseLock*>"
  overload: System.Threading.ReaderWriterLock.RestoreLock*
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Adres <code> lockCookie </code> jest wskaźnika o wartości null."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)
  id: UpgradeToWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: UpgradeToWriterLock(Int32)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Blokowanie blokadę w składniku zapisywania uaktualnień, za pomocą <xref uid=&quot;langword_csharp_Int32&quot; name=&quot;Int32&quot; href=&quot;&quot;> </xref> wartość limitu czasu."
  remarks: "Gdy wywołuje wątku `UpgradeToWriterLock` blokada czytnika został wydany, niezależnie od tego, liczbę blokad i wątku przechodzi do końca moduł zapisujący blokady do kolejki. W związku z tym inne wątki może zapisać zasobów przed wątku, który zażądał uaktualnienia uzyskuje blokadę zapisu.      > [!IMPORTANT] > Nie jest zgłaszany wyjątek limitu czasu, aż do wątku, który wywołuje metodę UpgradeToWriterLock można ponownie uzyskać blokady czytnika. Jeśli nie ma żadnych innych wątków oczekujących na blokadę zapisu, dzieje się natychmiast. Jednak jeśli inny wątek jest w kolejce na blokadę zapisu, wątku, który wywołuje metodę UpgradeToWriterLock nie można ponownie pobrać blokada czytnika aż wszystkie bieżące czytników zostały wydane ich blokad, a jeden wątek stały i wydane blokadę zapisu. Dotyczy to nawet wtedy, gdy wątek, żądany moduł zapisujący blokady zażądał go po bieżącym wątku wywołano metodę UpgradeToWriterLock.       Aby przywrócić stan blokady, należy wywołać <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>przy użyciu <xref:System.Threading.LockCookie>zwrócony przez `UpgradeToWriterLock`.</xref:System.Threading.LockCookie> </xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> Nie używaj to `LockCookie` z <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</xref:System.Threading.ReaderWriterLock.RestoreLock%2A>       Jeśli wątek nie blokada czytnika, nie używaj `UpgradeToWriterLock`. Użyj <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>zamiast.</xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>       Dla limitu czasu prawidłowe wartości zobacz <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  example:
  - "The following code example shows how to request a reader lock, upgrade the reader lock to a writer lock, and downgrade to a reader lock again.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/m-system.threading.reade_7_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/m-system.threading.reade_7_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/m-system.threading.reade_7_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#5](~/add/codesnippet/cpp/m-system.threading.reade_7_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#5](~/add/codesnippet/csharp/m-system.threading.reade_7_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#5](~/add/codesnippet/visualbasic/m-system.threading.reade_7_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/m-system.threading.reade_7_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/m-system.threading.reade_7_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/m-system.threading.reade_7_3.vb)]"
  syntax:
    content: public System.Threading.LockCookie UpgradeToWriterLock (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "Limit czasu w milisekundach."
    return:
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;></xref> value."
  overload: System.Threading.ReaderWriterLock.UpgradeToWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>millisecondsTimeout</code>wygasa przed udzieleniem żądanie blokady."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)
  id: UpgradeToWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: UpgradeToWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Blokowanie blokadę w składniku zapisywania uaktualnień, za pomocą <xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref> wartość limitu czasu."
  remarks: "Gdy wywołuje wątku `UpgradeToWriterLock` blokada czytnika został wydany, niezależnie od tego, liczbę blokad i wątku przechodzi do końca moduł zapisujący blokady do kolejki. W związku z tym inne wątki może zapisać zasobów przed wątku, który zażądał uaktualnienia uzyskuje blokadę zapisu.      > [!IMPORTANT] > Limitu czasu nie wyjątku do wątku, który wywołuje <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>metody można ponownie uzyskać blokady czytnika.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> Jeśli nie ma żadnych innych wątków oczekujących na blokadę zapisu, dzieje się natychmiast. Jednak jeśli inny wątek jest w kolejce na blokadę zapisu, wątek który wywołuje <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>metody nie można ponownie uzyskać blokady czytnika, aż wszystkie bieżące czytników zostały wydane ich blokad, a jeden wątek stały i wydane moduł zapisujący blokady.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> Dotyczy to nawet wtedy, gdy wątek, żądany moduł zapisujący blokady zażądał go po wywołaniu metody bieżącego wątku <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>metody.</xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>       Aby przywrócić stan blokady, należy wywołać <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>przy użyciu <xref:System.Threading.LockCookie>zwrócony przez `UpgradeToWriterLock`.</xref:System.Threading.LockCookie> </xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> Nie używaj to `LockCookie` z <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</xref:System.Threading.ReaderWriterLock.RestoreLock%2A>       Jeśli wątek nie blokada czytnika, nie używaj `UpgradeToWriterLock`. Użyj <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>zamiast.</xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>       Dla limitu czasu prawidłowe wartości zobacz <xref:System.Threading.ReaderWriterLock>.</xref:System.Threading.ReaderWriterLock>"
  syntax:
    content: public System.Threading.LockCookie UpgradeToWriterLock (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "<xref uid=&quot;langword_csharp_TimeSpan&quot; name=&quot;TimeSpan&quot; href=&quot;&quot;> </xref> Określający okres limitu czasu."
    return:
      type: System.Threading.LockCookie
      description: "A <xref href=&quot;System.Threading.LockCookie&quot;></xref> value."
  overload: System.Threading.ReaderWriterLock.UpgradeToWriterLock*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "<code>timeout</code>wygasa przed udzieleniem żądanie blokady."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>timeout</code>Określa wartość ujemną, innego niż-1 milisekund."
  platform:
  - net462
- uid: System.Threading.ReaderWriterLock.WriterSeqNum
  id: WriterSeqNum
  parent: System.Threading.ReaderWriterLock
  langs:
  - csharp
  name: WriterSeqNum
  nameWithType: ReaderWriterLock.WriterSeqNum
  fullName: System.Threading.ReaderWriterLock.WriterSeqNum
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Pobiera bieżący numer sekwencji."
  remarks: "Sekwencja liczba zwiększa się zawsze, gdy wątek uzyskuje blokadę zapisu. Można zapisać numer sekwencji i przekaż go do <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A>w późniejszym czasie, jeśli chcesz określić, czy inne wątki zostały nabyte w międzyczasie moduł zapisujący blokady.</xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A>       Można użyć `WriterSeqNum` aby poprawić wydajność aplikacji. Na przykład wątku może buforować informacje, które uzyskuje podczas utrzymywania blokady czytnika. Po zwalniania i później reacquiring blokady, Wątek można określić, czy inne wątki zostały zapisane zasobu, wywołując `AnyWritersSince`; Jeśli nie, można użyć buforowanych informacji. Ta technika jest przydatna podczas odczytywania informacji o chronionych przez blokady jest kosztowne. na przykład uruchomienie kwerendy bazy danych.       Obiekt wywołujący musi zawierający blokadę lub blokadę zapisu w kolejności numeru sekwencji powinna być użyteczna."
  example:
  - "The following code example shows how to use the WriterSeqNum property and the <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> method to determine whether another thread acquired the writer lock on the protected resource since the current thread last held the writer lock.  \n  \n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.  \n  \n [!code-cpp[System.Threading.ReaderWriterLock#2](~/add/codesnippet/cpp/p-system.threading.reade_2_1.cpp)]\n [!code-cs[System.Threading.ReaderWriterLock#2](~/add/codesnippet/csharp/p-system.threading.reade_2_1.cs)]\n [!code-vb[System.Threading.ReaderWriterLock#2](~/add/codesnippet/visualbasic/p-system.threading.reade_2_1.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#6](~/add/codesnippet/cpp/p-system.threading.reade_2_2.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#6](~/add/codesnippet/csharp/p-system.threading.reade_2_2.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#6](~/add/codesnippet/visualbasic/p-system.threading.reade_2_2.vb)]  \n[!code-cpp[System.Threading.ReaderWriterLock#7](~/add/codesnippet/cpp/p-system.threading.reade_2_3.cpp)]\n[!code-cs[System.Threading.ReaderWriterLock#7](~/add/codesnippet/csharp/p-system.threading.reade_2_3.cs)]\n[!code-vb[System.Threading.ReaderWriterLock#7](~/add/codesnippet/visualbasic/p-system.threading.reade_2_3.vb)]"
  syntax:
    content: public int WriterSeqNum { get; }
    return:
      type: System.Int32
      description: "Bieżący numer sekwencji."
  overload: System.Threading.ReaderWriterLock.WriterSeqNum*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  isExternal: false
  name: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
- uid: System.ApplicationException
  parent: System
  isExternal: false
  name: ApplicationException
  nameWithType: ApplicationException
  fullName: System.ApplicationException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.Threading.ReaderWriterLock.#ctor
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReaderWriterLock()
  nameWithType: ReaderWriterLock.ReaderWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReaderWriterLock()
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireReaderLock(Int32)
  nameWithType: ReaderWriterLock.AcquireReaderLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireReaderLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireReaderLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireReaderLock(TimeSpan)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireWriterLock(Int32)
  nameWithType: ReaderWriterLock.AcquireWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(Int32)
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.AcquireWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.AcquireWriterLock(TimeSpan)
- uid: System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AnyWritersSince(Int32)
  nameWithType: ReaderWriterLock.AnyWritersSince(Int32)
  fullName: System.Threading.ReaderWriterLock.AnyWritersSince(Int32)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: DowngradeFromWriterLock(LockCookie)
  nameWithType: ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.DowngradeFromWriterLock(LockCookie)
- uid: System.Threading.LockCookie
  parent: System.Threading
  isExternal: false
  name: LockCookie
  nameWithType: LockCookie
  fullName: System.Threading.LockCookie
- uid: System.Threading.ReaderWriterLock.Finalize
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: Finalize()
  nameWithType: ReaderWriterLock.Finalize()
  fullName: System.Threading.ReaderWriterLock.Finalize()
- uid: System.Threading.ReaderWriterLock.IsReaderLockHeld
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsReaderLockHeld
  nameWithType: ReaderWriterLock.IsReaderLockHeld
  fullName: System.Threading.ReaderWriterLock.IsReaderLockHeld
- uid: System.Threading.ReaderWriterLock.IsWriterLockHeld
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsWriterLockHeld
  nameWithType: ReaderWriterLock.IsWriterLockHeld
  fullName: System.Threading.ReaderWriterLock.IsWriterLockHeld
- uid: System.Threading.ReaderWriterLock.ReleaseLock
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseLock()
  nameWithType: ReaderWriterLock.ReleaseLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseLock()
- uid: System.Threading.ReaderWriterLock.ReleaseReaderLock
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseReaderLock()
  nameWithType: ReaderWriterLock.ReleaseReaderLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseReaderLock()
- uid: System.Threading.ReaderWriterLock.ReleaseWriterLock
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseWriterLock()
  nameWithType: ReaderWriterLock.ReleaseWriterLock()
  fullName: System.Threading.ReaderWriterLock.ReleaseWriterLock()
- uid: System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: RestoreLock(LockCookie)
  nameWithType: ReaderWriterLock.RestoreLock(LockCookie)
  fullName: System.Threading.ReaderWriterLock.RestoreLock(LockCookie)
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: UpgradeToWriterLock(Int32)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(Int32)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(Int32)
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: UpgradeToWriterLock(TimeSpan)
  nameWithType: ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLock.UpgradeToWriterLock(TimeSpan)
- uid: System.Threading.ReaderWriterLock.WriterSeqNum
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: WriterSeqNum
  nameWithType: ReaderWriterLock.WriterSeqNum
  fullName: System.Threading.ReaderWriterLock.WriterSeqNum
- uid: System.Threading.ReaderWriterLock.#ctor*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReaderWriterLock
  nameWithType: ReaderWriterLock.ReaderWriterLock
- uid: System.Threading.ReaderWriterLock.AcquireReaderLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireReaderLock
  nameWithType: ReaderWriterLock.AcquireReaderLock
- uid: System.Threading.ReaderWriterLock.AcquireWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AcquireWriterLock
  nameWithType: ReaderWriterLock.AcquireWriterLock
- uid: System.Threading.ReaderWriterLock.AnyWritersSince*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: AnyWritersSince
  nameWithType: ReaderWriterLock.AnyWritersSince
- uid: System.Threading.ReaderWriterLock.DowngradeFromWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: DowngradeFromWriterLock
  nameWithType: ReaderWriterLock.DowngradeFromWriterLock
- uid: System.Threading.ReaderWriterLock.Finalize*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: Finalize
  nameWithType: ReaderWriterLock.Finalize
- uid: System.Threading.ReaderWriterLock.IsReaderLockHeld*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsReaderLockHeld
  nameWithType: ReaderWriterLock.IsReaderLockHeld
- uid: System.Threading.ReaderWriterLock.IsWriterLockHeld*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: IsWriterLockHeld
  nameWithType: ReaderWriterLock.IsWriterLockHeld
- uid: System.Threading.ReaderWriterLock.ReleaseLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseLock
  nameWithType: ReaderWriterLock.ReleaseLock
- uid: System.Threading.ReaderWriterLock.ReleaseReaderLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseReaderLock
  nameWithType: ReaderWriterLock.ReleaseReaderLock
- uid: System.Threading.ReaderWriterLock.ReleaseWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: ReleaseWriterLock
  nameWithType: ReaderWriterLock.ReleaseWriterLock
- uid: System.Threading.ReaderWriterLock.RestoreLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: RestoreLock
  nameWithType: ReaderWriterLock.RestoreLock
- uid: System.Threading.ReaderWriterLock.UpgradeToWriterLock*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: UpgradeToWriterLock
  nameWithType: ReaderWriterLock.UpgradeToWriterLock
- uid: System.Threading.ReaderWriterLock.WriterSeqNum*
  parent: System.Threading.ReaderWriterLock
  isExternal: false
  name: WriterSeqNum
  nameWithType: ReaderWriterLock.WriterSeqNum
