### YamlMime:ManagedReference
items:
- uid: System.Messaging.Message
  id: Message
  children:
  - System.Messaging.Message.#ctor
  - System.Messaging.Message.#ctor(System.Object)
  - System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)
  - System.Messaging.Message.AcknowledgeType
  - System.Messaging.Message.Acknowledgment
  - System.Messaging.Message.AdministrationQueue
  - System.Messaging.Message.AppSpecific
  - System.Messaging.Message.ArrivedTime
  - System.Messaging.Message.AttachSenderId
  - System.Messaging.Message.Authenticated
  - System.Messaging.Message.AuthenticationProviderName
  - System.Messaging.Message.AuthenticationProviderType
  - System.Messaging.Message.Body
  - System.Messaging.Message.BodyStream
  - System.Messaging.Message.BodyType
  - System.Messaging.Message.ConnectorType
  - System.Messaging.Message.CorrelationId
  - System.Messaging.Message.DestinationQueue
  - System.Messaging.Message.DestinationSymmetricKey
  - System.Messaging.Message.DigitalSignature
  - System.Messaging.Message.EncryptionAlgorithm
  - System.Messaging.Message.Extension
  - System.Messaging.Message.Formatter
  - System.Messaging.Message.HashAlgorithm
  - System.Messaging.Message.Id
  - System.Messaging.Message.InfiniteTimeout
  - System.Messaging.Message.IsFirstInTransaction
  - System.Messaging.Message.IsLastInTransaction
  - System.Messaging.Message.Label
  - System.Messaging.Message.LookupId
  - System.Messaging.Message.MessageType
  - System.Messaging.Message.Priority
  - System.Messaging.Message.Recoverable
  - System.Messaging.Message.ResponseQueue
  - System.Messaging.Message.SecurityContext
  - System.Messaging.Message.SenderCertificate
  - System.Messaging.Message.SenderId
  - System.Messaging.Message.SenderVersion
  - System.Messaging.Message.SentTime
  - System.Messaging.Message.SourceMachine
  - System.Messaging.Message.TimeToBeReceived
  - System.Messaging.Message.TimeToReachQueue
  - System.Messaging.Message.TransactionId
  - System.Messaging.Message.TransactionStatusQueue
  - System.Messaging.Message.UseAuthentication
  - System.Messaging.Message.UseDeadLetterQueue
  - System.Messaging.Message.UseEncryption
  - System.Messaging.Message.UseJournalQueue
  - System.Messaging.Message.UseTracing
  langs:
  - csharp
  name: Message
  nameWithType: Message
  fullName: System.Messaging.Message
  type: Class
  summary: "Zapewnia dostęp do właściwości, należy zdefiniować kolejkowania wiadomości."
  remarks: "Podgląd lub odbierać wiadomości z kolejki, lub szczegółową kontrolę właściwości komunikatu podczas wysyłania wiadomości do kolejki, należy użyć klasy wiadomości.       <xref:System.Messaging.MessageQueue>używa klasy wiadomości dokonuje lub odbiera komunikaty z kolejki, ponieważ zarówno <xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=fullName>i <xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=fullName>metody Utwórz nowe wystąpienie klasy wiadomości i ustaw właściwości wystąpienia.</xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=fullName> </xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=fullName></xref:System.Messaging.MessageQueue> Właściwości tylko do odczytu klasy wiadomości dotyczą pobieranie wiadomości z kolejki, podczas gdy właściwości odczytu/zapisu dotyczą wysyłanie i pobieranie wiadomości. Gdy <xref:System.Messaging.MessageQueue>dokonuje lub odbiera wiadomości z kolejki, jego <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>właściwość określa, które właściwości wiadomości są pobierane.</xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> </xref:System.Messaging.MessageQueue>       <xref:System.Messaging.MessageQueue>Klasy <xref:System.Messaging.MessageQueue.Send%2A>metody można określić typ obiektu dla wiadomości wysyłanych do tej kolejki.</xref:System.Messaging.MessageQueue.Send%2A> </xref:System.Messaging.MessageQueue> Można użyć <xref:System.Messaging.MessageQueue>wystąpienia <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>Właściwości w celu określenia ustawień ogólnych komunikatów wysłanych do kolejki.</xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> </xref:System.Messaging.MessageQueue> Typy ustawień obejmują program formatujący, etykiety, szyfrowania i uwierzytelniania. Można również określić wartości dla odpowiednich <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>elementów członkowskich, gdy koordynować komunikatów aplikacji odpowiedź na raport i potwierdzeń wiadomości.</xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Aby wysłać wiadomość do kolejki przy użyciu wystąpienia wiadomości zapewnia elastyczność wiele z tych właściwości modyfikacji i dostępu — pojedynczej wiadomości lub na podstawie komunikatów przez komunikat. Właściwości komunikatu mają pierwszeństwo przed <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>.</xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>       Komunikat dane są przechowywane w <xref:System.Messaging.Message.Body%2A>Właściwości i w mniejszym stopniu <xref:System.Messaging.Message.AppSpecific%2A>i <xref:System.Messaging.Message.Extension%2A>Właściwości.</xref:System.Messaging.Message.Extension%2A> </xref:System.Messaging.Message.AppSpecific%2A> </xref:System.Messaging.Message.Body%2A> Po dane wiadomości jest zaszyfrowany, serializacji lub deserializacji tylko zawartość <xref:System.Messaging.Message.Body%2A>dotyczy właściwości.</xref:System.Messaging.Message.Body%2A>       Zawartość <xref:System.Messaging.Message.Body%2A>Właściwości są serializowane, gdy komunikat jest wysyłany przy użyciu <xref:System.Messaging.Message.Formatter%2A>należy określić właściwość.</xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.Body%2A> Zserializowany zawartości znajdują się w <xref:System.Messaging.Message.BodyStream%2A>Właściwości.</xref:System.Messaging.Message.BodyStream%2A> Można również ustawić <xref:System.Messaging.Message.BodyStream%2A>właściwości bezpośrednio, na przykład można wysłać pliku jako zawartość danych komunikatu.</xref:System.Messaging.Message.BodyStream%2A> Można zmienić <xref:System.Messaging.Message.Body%2A>lub <xref:System.Messaging.Message.Formatter%2A>Właściwości w dowolnym momencie przed wysłaniem wiadomości i danych będzie wykonywana serializacja odpowiednio podczas wywoływania <xref:System.Messaging.MessageQueue.Send%2A>.</xref:System.Messaging.MessageQueue.Send%2A> </xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.Body%2A>       Właściwości zdefiniowane przez <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=fullName>właściwość dotyczy tylko wiadomości, które nie są typu Message.</xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=fullName> Jeśli określisz <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>Właściwość <xref:System.Messaging.MessageQueue>, te domyślne właściwości mają być ignorowane spowodować o identycznej nazwie właściwości wystąpienia wiadomości wysyłane do tej kolejki.</xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>       Aby uzyskać listę początkowe wartości właściwości dla wystąpienia wiadomości, zobacz <xref:System.Messaging.Message.%23ctor%2A>konstruktora.</xref:System.Messaging.Message.%23ctor%2A>"
  example:
  - "The following code example demonstrates formatting a message body using <xref:System.Messaging.BinaryMessageFormatter>.  \n  \n [!code-cpp[MessagingBinaryFormatter#1](~/add/codesnippet/cpp/t-system.messaging.message_1.cpp)]\n [!code-cs[MessagingBinaryFormatter#1](~/add/codesnippet/csharp/t-system.messaging.message_1.cs)]\n [!code-vb[MessagingBinaryFormatter#1](~/add/codesnippet/visualbasic/t-system.messaging.message_1.vb)]  \n  \n The following code example demonstrates formatting a message body using <xref:System.Messaging.XmlMessageFormatter>.  \n  \n [!code-cpp[Message.Body#1](~/add/codesnippet/cpp/t-system.messaging.message_2.cpp)]\n [!code-cs[Message.Body#1](~/add/codesnippet/csharp/t-system.messaging.message_2.cs)]\n [!code-vb[Message.Body#1](~/add/codesnippet/visualbasic/t-system.messaging.message_2.vb)]"
  syntax:
    content: >-
      [System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      public class Message : System.ComponentModel.Component
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements: []
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Dispose(System.Boolean)
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Messaging.Message.#ctor
  id: '#ctor'
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Message()
  nameWithType: Message.Message()
  fullName: System.Messaging.Message.Message()
  type: Constructor
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Messaging.Message&quot;> </xref> klasy o pustej treści."
  remarks: "Użyj tego przeciążenia, aby utworzyć nowe wystąpienie klasy <xref:System.Messaging.Message>klasy, która ma pustej treści.</xref:System.Messaging.Message>       Określ <xref:System.Messaging.Message.Body%2A>Właściwości lub <xref:System.Messaging.Message.BodyStream%2A>Właściwości przed wysłaniem <xref:System.Messaging.Message>obiektu.</xref:System.Messaging.Message> </xref:System.Messaging.Message.BodyStream%2A> </xref:System.Messaging.Message.Body%2A> <xref:System.Messaging.Message.Body%2A>Właściwość może być dowolny obiekt, który można serializować, takie jak ciąg tekstowy, obiekt struktury, wystąpienia klasy lub osadzonego obiektu.</xref:System.Messaging.Message.Body%2A>       O ile bezpośrednio do zapisu treści wiadomości <xref:System.Messaging.Message.BodyStream%2A>właściwość, ustaw <xref:System.Messaging.Message.Formatter%2A>Właściwości przed wysłaniem wiadomości.</xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.BodyStream%2A> Treść jest zserializowanym przy użyciu <xref:System.Messaging.Message.Formatter%2A>wartość właściwości w czasie <xref:System.Messaging.MessageQueue.Send%2A>wywoływana jest metoda <xref:System.Messaging.MessageQueue>wystąpienia.</xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue.Send%2A> </xref:System.Messaging.Message.Formatter%2A>       <xref:System.Messaging.XmlMessageFormatter>Jest luźno, więc nie ma tego samego obiektu typu na nadawcy i odbiorcy, korzystając z tego formatu.</xref:System.Messaging.XmlMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>i <xref:System.Messaging.BinaryMessageFormatter>serializuje dane na binarna reprezentacja.</xref:System.Messaging.BinaryMessageFormatter> </xref:System.Messaging.ActiveXMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>Jest używany przy wysyłaniu lub odbieraniu składniki COM.</xref:System.Messaging.ActiveXMessageFormatter>       W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Messaging.Message>.</xref:System.Messaging.Message>      | Właściwość | Nieprawidłowa wartość |   |--------------|-------------------|   | <xref:System.Messaging.Message.AcknowledgeType%2A>| `AcknowledgeType.None`|   | <xref:System.Messaging.Message.AdministrationQueue%2A>| `null`|   | <xref:System.Messaging.Message.AppSpecific%2A>|0|   | <xref:System.Messaging.Message.AttachSenderId%2A>| `true`|   | <xref:System.Messaging.Message.AuthenticationProviderName%2A>| Microsoft Base Cryptographic Provider 1.0 w wersji |   | <xref:System.Messaging.Message.AuthenticationProviderType%2A>| `CryptoProviderType.RSA_FULL`|   | <xref:System.Messaging.Message.Body%2A>| `null`|   | <xref:System.Messaging.Message.BodyStream%2A>| `Stream.null`|   | <xref:System.Messaging.Message.BodyType%2A>|0|   | <xref:System.Messaging.Message.ConnectorType%2A>| `Guid.Empty`|   | <xref:System.Messaging.Message.CorrelationId%2A>| Ciąg pusty (&quot;&quot;) |   | <xref:System.Messaging.Message.DestinationSymmetricKey%2A>| O zerowej długości tablicę bajtów |   | <xref:System.Messaging.Message.DigitalSignature%2A>| O zerowej długości tablicę bajtów |   | <xref:System.Messaging.Message.EncryptionAlgorithm%2A>| `EncryptionAlgorithm.RC2`|   | <xref:System.Messaging.Message.Extension%2A>| O zerowej długości tablicę bajtów |   | <xref:System.Messaging.Message.Formatter%2A>| `XmlMessageFormatter`|   | <xref:System.Messaging.Message.HashAlgorithm%2A>| `HashAlgorithm.MD5`|   | <xref:System.Messaging.Message.Label%2A>| Ciąg pusty (&quot;&quot;) |   | <xref:System.Messaging.Message.Priority%2A>| `MessagePriority.Normal`|   | <xref:System.Messaging.Message.Recoverable%2A>| `false`|   | <xref:System.Messaging.Message.ResponseQueue%2A>| `null`|   | <xref:System.Messaging.Message.SenderCertificate%2A>| O zerowej długości tablicę bajtów |   | <xref:System.Messaging.Message.TimeToBeReceived%2A>| `Message.InfiniteTimeout`|   | <xref:System.Messaging.Message.TimeToReachQueue%2A>| `Message.InfiniteTimeout`|   | <xref:System.Messaging.Message.TransactionStatusQueue%2A>| `null`|   | <xref:System.Messaging.Message.UseAuthentication%2A>| `false`|   | <xref:System.Messaging.Message.UseDeadLetterQueue%2A>| `false`|   | <xref:System.Messaging.Message.UseEncryption%2A>| `false`|   | <xref:System.Messaging.Message.UseJournalQueue%2A>| `false`|   | <xref:System.Messaging.Message.UseTracing%2A>| `false`|</xref:System.Messaging.Message.UseTracing%2A></xref:System.Messaging.Message.UseJournalQueue%2A></xref:System.Messaging.Message.UseEncryption%2A></xref:System.Messaging.Message.UseDeadLetterQueue%2A></xref:System.Messaging.Message.UseAuthentication%2A></xref:System.Messaging.Message.TransactionStatusQueue%2A></xref:System.Messaging.Message.TimeToReachQueue%2A></xref:System.Messaging.Message.TimeToBeReceived%2A></xref:System.Messaging.Message.SenderCertificate%2A></xref:System.Messaging.Message.ResponseQueue%2A></xref:System.Messaging.Message.Recoverable%2A></xref:System.Messaging.Message.Priority%2A></xref:System.Messaging.Message.Label%2A></xref:System.Messaging.Message.HashAlgorithm%2A></xref:System.Messaging.Message.Formatter%2A></xref:System.Messaging.Message.Extension%2A></xref:System.Messaging.Message.EncryptionAlgorithm%2A></xref:System.Messaging.Message.DigitalSignature%2A></xref:System.Messaging.Message.DestinationSymmetricKey%2A></xref:System.Messaging.Message.CorrelationId%2A></xref:System.Messaging.Message.ConnectorType%2A></xref:System.Messaging.Message.BodyType%2A></xref:System.Messaging.Message.BodyStream%2A></xref:System.Messaging.Message.Body%2A></xref:System.Messaging.Message.AuthenticationProviderType%2A></xref:System.Messaging.Message.AuthenticationProviderName%2A></xref:System.Messaging.Message.AttachSenderId%2A></xref:System.Messaging.Message.AppSpecific%2A></xref:System.Messaging.Message.AdministrationQueue%2A></xref:System.Messaging.Message.AcknowledgeType%2A>"
  example:
  - "The following code example sends two messages of different priorities to the queue, and retrieves them subsequently.  \n  \n [!code-cpp[Message.DefaultPropertiesToSend#1](~/add/codesnippet/cpp/m-system.messaging.messa_16_1.cpp)]\n [!code-vb[Message.DefaultPropertiesToSend#1](~/add/codesnippet/visualbasic/m-system.messaging.messa_16_1.vb)]\n [!code-cs[Message.DefaultPropertiesToSend#1](~/add/codesnippet/csharp/m-system.messaging.messa_16_1.cs)]"
  syntax:
    content: public Message ();
    parameters: []
  overload: System.Messaging.Message.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.Message.#ctor(System.Object)
  id: '#ctor(System.Object)'
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Message(Object)
  nameWithType: Message.Message(Object)
  fullName: System.Messaging.Message.Message(Object)
  type: Constructor
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Messaging.Message&quot;> </xref> przy użyciu <xref href=&quot;System.Messaging.XmlMessageFormatter&quot;> </xref> do serializacji określonego obiektu na treść komunikatu."
  remarks: "Użyj tego przeciążenia, aby utworzyć nowe wystąpienie klasy <xref:System.Messaging.Message>klasę, która zawiera <xref:System.Messaging.Message.Body%2A>określonego przez `body` parametru.</xref:System.Messaging.Message.Body%2A> </xref:System.Messaging.Message> `body` Parametr może być dowolny obiekt, który można serializować, takie jak ciąg tekstowy, obiekt struktury, wystąpienia klasy lub osadzonego obiektu. Treść jest zserializowanym przy użyciu <xref:System.Messaging.XmlMessageFormatter>chyba że zostanie zmienione <xref:System.Messaging.Message.Formatter%2A>Właściwości przed <xref:System.Messaging.Message>są wysyłane.</xref:System.Messaging.Message> </xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.XmlMessageFormatter> Jeśli zmienisz <xref:System.Messaging.Message.Body%2A>lub <xref:System.Messaging.Message.Formatter%2A>Właściwości w dowolnym momencie przed wywołaniem <xref:System.Messaging.MessageQueue.Send%2A>, wiadomości będą wykonywane szeregowo w zależności od nowa wartość właściwości.</xref:System.Messaging.MessageQueue.Send%2A> </xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.Body%2A>       <xref:System.Messaging.XmlMessageFormatter>Jest luźno, więc nie ma tego samego obiektu typu na nadawcy i odbiorcy, korzystając z tego formatu.</xref:System.Messaging.XmlMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>i <xref:System.Messaging.BinaryMessageFormatter>serializuje dane na binarna reprezentacja.</xref:System.Messaging.BinaryMessageFormatter> </xref:System.Messaging.ActiveXMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>Jest używany przy wysyłaniu lub odbieraniu składniki COM.</xref:System.Messaging.ActiveXMessageFormatter>       W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Messaging.Message>.</xref:System.Messaging.Message>      | Właściwość | Nieprawidłowa wartość |   |--------------|-------------------|   | <xref:System.Messaging.Message.AcknowledgeType%2A>| `AcknowledgeType.None`|   | <xref:System.Messaging.Message.AdministrationQueue%2A>| `null`|   | <xref:System.Messaging.Message.AppSpecific%2A>|0|   | <xref:System.Messaging.Message.AttachSenderId%2A>| `true`|   | <xref:System.Messaging.Message.AuthenticationProviderName%2A>| Microsoft Base Cryptographic Provider 1.0 w wersji |   | <xref:System.Messaging.Message.AuthenticationProviderType%2A>| `CryptoProviderType.RSA_FULL`|   | <xref:System.Messaging.Message.Body%2A>| `body` Parametru. |   | <xref:System.Messaging.Message.BodyStream%2A>| `Stream.null`|   | <xref:System.Messaging.Message.BodyType%2A>|0|   | <xref:System.Messaging.Message.ConnectorType%2A>| `Guid.Empty`|   | <xref:System.Messaging.Message.CorrelationId%2A>| Ciąg pusty (&quot;&quot;) |   | <xref:System.Messaging.Message.DestinationSymmetricKey%2A>| O zerowej długości tablicę bajtów |   | <xref:System.Messaging.Message.DigitalSignature%2A>| O zerowej długości tablicę bajtów |   | <xref:System.Messaging.Message.EncryptionAlgorithm%2A>| `EncryptionAlgorithm.RC2`|   | <xref:System.Messaging.Message.Extension%2A>| O zerowej długości tablicę bajtów |   | <xref:System.Messaging.Message.Formatter%2A>| `XmlMessageFormatter`|   | <xref:System.Messaging.Message.HashAlgorithm%2A>| `HashAlgorithm.MD5`|   | <xref:System.Messaging.Message.Label%2A>| Ciąg pusty (&quot;&quot;) |   | <xref:System.Messaging.Message.Priority%2A>| `MessagePriority.Normal`|   | <xref:System.Messaging.Message.Recoverable%2A>| `false`|   | <xref:System.Messaging.Message.ResponseQueue%2A>| `null`|   | <xref:System.Messaging.Message.SenderCertificate%2A>| O zerowej długości tablicę bajtów |   | <xref:System.Messaging.Message.TimeToBeReceived%2A>| `Message.InfiniteTimeout`|   | <xref:System.Messaging.Message.TimeToReachQueue%2A>| `Message.InfiniteTimeout`|   | <xref:System.Messaging.Message.TransactionStatusQueue%2A>| `null`|   | <xref:System.Messaging.Message.UseAuthentication%2A>| `false`|   | <xref:System.Messaging.Message.UseDeadLetterQueue%2A>| `false`|   | <xref:System.Messaging.Message.UseEncryption%2A>| `false`|   | <xref:System.Messaging.Message.UseJournalQueue%2A>| `false`|   | <xref:System.Messaging.Message.UseTracing%2A>| `false`|</xref:System.Messaging.Message.UseTracing%2A></xref:System.Messaging.Message.UseJournalQueue%2A></xref:System.Messaging.Message.UseEncryption%2A></xref:System.Messaging.Message.UseDeadLetterQueue%2A></xref:System.Messaging.Message.UseAuthentication%2A></xref:System.Messaging.Message.TransactionStatusQueue%2A></xref:System.Messaging.Message.TimeToReachQueue%2A></xref:System.Messaging.Message.TimeToBeReceived%2A></xref:System.Messaging.Message.SenderCertificate%2A></xref:System.Messaging.Message.ResponseQueue%2A></xref:System.Messaging.Message.Recoverable%2A></xref:System.Messaging.Message.Priority%2A></xref:System.Messaging.Message.Label%2A></xref:System.Messaging.Message.HashAlgorithm%2A></xref:System.Messaging.Message.Formatter%2A></xref:System.Messaging.Message.Extension%2A></xref:System.Messaging.Message.EncryptionAlgorithm%2A></xref:System.Messaging.Message.DigitalSignature%2A></xref:System.Messaging.Message.DestinationSymmetricKey%2A></xref:System.Messaging.Message.CorrelationId%2A></xref:System.Messaging.Message.ConnectorType%2A></xref:System.Messaging.Message.BodyType%2A></xref:System.Messaging.Message.BodyStream%2A></xref:System.Messaging.Message.Body%2A></xref:System.Messaging.Message.AuthenticationProviderType%2A></xref:System.Messaging.Message.AuthenticationProviderName%2A></xref:System.Messaging.Message.AttachSenderId%2A></xref:System.Messaging.Message.AppSpecific%2A></xref:System.Messaging.Message.AdministrationQueue%2A></xref:System.Messaging.Message.AcknowledgeType%2A>"
  example:
  - "The following code example creates a new queue, sends a message that contains an order to it, and then retrieves it.  \n  \n [!code-cpp[Message.Body#1](~/add/codesnippet/cpp/m-system.messaging.messa_33_1.cpp)]\n [!code-cs[Message.Body#1](~/add/codesnippet/csharp/m-system.messaging.messa_33_1.cs)]\n [!code-vb[Message.Body#1](~/add/codesnippet/visualbasic/m-system.messaging.messa_33_1.vb)]"
  syntax:
    content: public Message (object body);
    parameters:
    - id: body
      type: System.Object
      description: "Obiekt do serializacji w treści wiadomości."
  overload: System.Messaging.Message.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)
  id: '#ctor(System.Object,System.Messaging.IMessageFormatter)'
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Message(Object,IMessageFormatter)
  nameWithType: Message.Message(Object,IMessageFormatter)
  fullName: System.Messaging.Message.Message(Object,IMessageFormatter)
  type: Constructor
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Messaging.Message&quot;> </xref> przy użyciu określonego programu formatującego do serializacji określonego obiektu na treść komunikatu."
  remarks: "Użyj tego przeciążenia, aby utworzyć nowe wystąpienie klasy <xref:System.Messaging.Message>klasę, która zawiera <xref:System.Messaging.Message.Body%2A>określonego przez `body` parametr i korzysta z żadnych prawidłowy element formatujący do serializacji treści.</xref:System.Messaging.Message.Body%2A> </xref:System.Messaging.Message> `body` Parametr jest dowolny obiekt, który można serializować, takie jak ciąg tekstowy, obiekt struktury, wystąpienia klasy lub osadzonego obiektu. Jeśli zmienisz <xref:System.Messaging.Message.Body%2A>lub <xref:System.Messaging.Message.Formatter%2A>Właściwości w dowolnym momencie przed wywołaniem <xref:System.Messaging.MessageQueue.Send%2A>, wiadomości będą wykonywane szeregowo w zależności od nowa wartość właściwości.</xref:System.Messaging.MessageQueue.Send%2A> </xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.Body%2A>       <xref:System.Messaging.XmlMessageFormatter>Jest luźno, więc nie ma tego samego obiektu typu na nadawcy i odbiorcy, korzystając z tego formatu.</xref:System.Messaging.XmlMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>i <xref:System.Messaging.BinaryMessageFormatter>serializuje dane na binarna reprezentacja.</xref:System.Messaging.BinaryMessageFormatter> </xref:System.Messaging.ActiveXMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>Jest używany przy wysyłaniu lub odbieraniu składniki COM.</xref:System.Messaging.ActiveXMessageFormatter>       W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Messaging.Message>.</xref:System.Messaging.Message>      | Właściwość | Nieprawidłowa wartość |   |--------------|-------------------|   | <xref:System.Messaging.Message.AcknowledgeType%2A>| `AcknowledgeType.None`|   | <xref:System.Messaging.Message.AdministrationQueue%2A>| `null`|   | <xref:System.Messaging.Message.AppSpecific%2A>|0|   | <xref:System.Messaging.Message.AttachSenderId%2A>| `true`|   | <xref:System.Messaging.Message.AuthenticationProviderName%2A>| Microsoft Base Cryptographic Provider 1.0 w wersji |   | <xref:System.Messaging.Message.AuthenticationProviderType%2A>| `CryptoProviderType.RSA_FULL`|   | <xref:System.Messaging.Message.Body%2A>| `body` Parametru. |   | <xref:System.Messaging.Message.BodyStream%2A>| `Stream.null`|   | <xref:System.Messaging.Message.BodyType%2A>|0|   | <xref:System.Messaging.Message.ConnectorType%2A>| `Guid.Empty`|   | <xref:System.Messaging.Message.CorrelationId%2A>| Ciąg pusty (&quot;&quot;) |   | <xref:System.Messaging.Message.DestinationSymmetricKey%2A>| O zerowej długości tablicę bajtów |   | <xref:System.Messaging.Message.DigitalSignature%2A>| O zerowej długości tablicę bajtów |   | <xref:System.Messaging.Message.EncryptionAlgorithm%2A>| `EncryptionAlgorithm.RC2`|   | <xref:System.Messaging.Message.Extension%2A>| O zerowej długości tablicę bajtów |   | <xref:System.Messaging.Message.Formatter%2A>| `formatter` Parametru. |   | <xref:System.Messaging.Message.HashAlgorithm%2A>| `HashAlgorithm.MD5`|   | <xref:System.Messaging.Message.Label%2A>| Ciąg pusty (&quot;&quot;) |   | <xref:System.Messaging.Message.Priority%2A>| `MessagePriority.Normal`|   | <xref:System.Messaging.Message.Recoverable%2A>| `false`|   | <xref:System.Messaging.Message.ResponseQueue%2A>| `null`|   | <xref:System.Messaging.Message.SenderCertificate%2A>| O zerowej długości tablicę bajtów |   | <xref:System.Messaging.Message.TimeToBeReceived%2A>| `Message.InfiniteTimeout`|   | <xref:System.Messaging.Message.TimeToReachQueue%2A>| `Message.InfiniteTimeout`|   | <xref:System.Messaging.Message.TransactionStatusQueue%2A>| `null`|   | <xref:System.Messaging.Message.UseAuthentication%2A>| `false`|   | <xref:System.Messaging.Message.UseDeadLetterQueue%2A>| `false`|   | <xref:System.Messaging.Message.UseEncryption%2A>| `false`|   | <xref:System.Messaging.Message.UseJournalQueue%2A>| `false`|   | <xref:System.Messaging.Message.UseTracing%2A>| `false`|</xref:System.Messaging.Message.UseTracing%2A></xref:System.Messaging.Message.UseJournalQueue%2A></xref:System.Messaging.Message.UseEncryption%2A></xref:System.Messaging.Message.UseDeadLetterQueue%2A></xref:System.Messaging.Message.UseAuthentication%2A></xref:System.Messaging.Message.TransactionStatusQueue%2A></xref:System.Messaging.Message.TimeToReachQueue%2A></xref:System.Messaging.Message.TimeToBeReceived%2A></xref:System.Messaging.Message.SenderCertificate%2A></xref:System.Messaging.Message.ResponseQueue%2A></xref:System.Messaging.Message.Recoverable%2A></xref:System.Messaging.Message.Priority%2A></xref:System.Messaging.Message.Label%2A></xref:System.Messaging.Message.HashAlgorithm%2A></xref:System.Messaging.Message.Formatter%2A></xref:System.Messaging.Message.Extension%2A></xref:System.Messaging.Message.EncryptionAlgorithm%2A></xref:System.Messaging.Message.DigitalSignature%2A></xref:System.Messaging.Message.DestinationSymmetricKey%2A></xref:System.Messaging.Message.CorrelationId%2A></xref:System.Messaging.Message.ConnectorType%2A></xref:System.Messaging.Message.BodyType%2A></xref:System.Messaging.Message.BodyStream%2A></xref:System.Messaging.Message.Body%2A></xref:System.Messaging.Message.AuthenticationProviderType%2A></xref:System.Messaging.Message.AuthenticationProviderName%2A></xref:System.Messaging.Message.AttachSenderId%2A></xref:System.Messaging.Message.AppSpecific%2A></xref:System.Messaging.Message.AdministrationQueue%2A></xref:System.Messaging.Message.AcknowledgeType%2A>"
  example:
  - >-
    [!code-cpp[MessagingBinaryFormatter#1](~/add/codesnippet/cpp/6734a59e-0a86-49d1-96b9-_1.cpp)]
     [!code-cs[MessagingBinaryFormatter#1](~/add/codesnippet/csharp/6734a59e-0a86-49d1-96b9-_1.cs)]
     [!code-vb[MessagingBinaryFormatter#1](~/add/codesnippet/visualbasic/6734a59e-0a86-49d1-96b9-_1.vb)]
  syntax:
    content: public Message (object body, System.Messaging.IMessageFormatter formatter);
    parameters:
    - id: body
      type: System.Object
      description: "Obiekt do serializacji w treści wiadomości."
    - id: formatter
      type: System.Messaging.IMessageFormatter
      description: "A <xref href=&quot;System.Messaging.IMessageFormatter&quot;> </xref> , który określa formatujący serializacji treści komunikatu."
  overload: System.Messaging.Message.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.Message.AcknowledgeType
  id: AcknowledgeType
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AcknowledgeType
  nameWithType: Message.AcknowledgeType
  fullName: System.Messaging.Message.AcknowledgeType
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia typ komunikatu potwierdzenia do aplikację wysyłającą."
  remarks: "Właściwość AcknowledgeType Określa typ wiadomości potwierdzających żądany przez aplikację wysyłającą. Ustaw właściwość AcknowledgeType przed wysłaniem wiadomość, aby powiadomienia o niektórych wystąpień — na przykład komunikat dotarciem do kolejki docelowej, trwa pobieranie wiadomości lub limit czasu wiadomości uniemożliwia osiągnięcie bądź właśnie pobierane z kolejki docelowej.       Usługa kolejkowania komunikatów zwraca powiadomień przez wysłanie wiadomości potwierdzających do <xref:System.Messaging.Message.AdministrationQueue%2A>właściwości określone przez oryginalnej wiadomości.</xref:System.Messaging.Message.AdministrationQueue%2A> Wiadomości potwierdzającej <xref:System.Messaging.Message.Acknowledgment%2A>właściwość wskazuje typ potwierdzenia, który reprezentuje.</xref:System.Messaging.Message.Acknowledgment%2A> Na przykład, jeśli wiadomości potwierdzającej została wysłana, ponieważ wiadomość nie dotarła docelowym przed <xref:System.Messaging.Message.TimeToReachQueue%2A>Interwał uznawane za wygasłe, <xref:System.Messaging.Message.Acknowledgment%2A>zawiera wartość właściwości komunikatu potwierdzenia `ReachQueueTimeout`.</xref:System.Messaging.Message.Acknowledgment%2A> </xref:System.Messaging.Message.TimeToReachQueue%2A>"
  example:
  - "The following code example sends and receives a message containing an order to and from a queue. It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.  \n  \n [!code-cs[Message.Acknowledgment#1](~/add/codesnippet/csharp/p-system.messaging.messa_11_1.cs)]\n [!code-cpp[Message.Acknowledgment#1](~/add/codesnippet/cpp/p-system.messaging.messa_11_1.cpp)]\n [!code-vb[Message.Acknowledgment#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_11_1.vb)]"
  syntax:
    content: public System.Messaging.AcknowledgeTypes AcknowledgeType { get; set; }
    return:
      type: System.Messaging.AcknowledgeTypes
      description: "Jeden z <xref href=&quot;System.Messaging.AcknowledgeTypes&quot;> </xref> wartości, które reprezentują typy wiadomości potwierdzających system zapisuje na kolejkę administracyjną i warunków, w których są zwracane potwierdzenia wysyłania aplikacji. Wartość domyślna to <xref uid=&quot;langword_csharp_None&quot; name=&quot;None&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.AcknowledgeType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Wiadomość została odfiltrowana do ignorowania właściwości AcknowledgeType."
  platform:
  - net462
- uid: System.Messaging.Message.Acknowledgment
  id: Acknowledgment
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Acknowledgment
  nameWithType: Message.Acknowledgment
  fullName: System.Messaging.Message.Acknowledgment
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera klasyfikację potwierdzenia reprezentowanego przez tę wiadomość."
  remarks: "Gdy zostanie wyświetlony komunikat z kolejki administracyjnej, odczytać właściwość potwierdzenie, aby sprawdzić stan oryginalnej wiadomości.       Po wysłaniu wiadomości do kolejki docelowej usługi kolejkowania komunikatów może zażądać wiadomości potwierdzającej publikowania. Taki komunikat może wskazywać na przykład, czy wiadomość dotarła i czy został pobrany w ramach określonego limitu czasu lub może on wskazywać co poszło źle w przypadku niepowodzenia dostarczenia. Kolejka docelowa zwraca potwierdzeń wiadomości i przesyła je do kolejki administracyjnej określonej w oryginalnej wiadomości <xref:System.Messaging.Message.AdministrationQueue%2A>Właściwości.</xref:System.Messaging.Message.AdministrationQueue%2A> <xref:System.Messaging.Message.Id%2A>Właściwości wiadomości potwierdzającej identyfikuje komunikat potwierdzenia nie oryginalnej wiadomości.</xref:System.Messaging.Message.Id%2A> Identyfikator oryginalnej wiadomości można znaleźć w potwierdzenie <xref:System.Messaging.Message>wystąpienia <xref:System.Messaging.Message.CorrelationId%2A>Właściwości.</xref:System.Messaging.Message.CorrelationId%2A> </xref:System.Messaging.Message>       Jeśli ta <xref:System.Messaging.Message>wiadomości potwierdzającej reprezentuje wystąpienie, właściwość potwierdzenie określa typ potwierdzenia.</xref:System.Messaging.Message> W przeciwnym razie właściwość potwierdzenie zawiera wartość `Normal`.       Użyj <xref:System.Messaging.Message.AcknowledgeType%2A>właściwości oryginalnej wiadomości, aby określić okoliczności, w których będą zwracane potwierdzenia.</xref:System.Messaging.Message.AcknowledgeType%2A>"
  syntax:
    content: public System.Messaging.Acknowledgment Acknowledgment { get; }
    return:
      type: System.Messaging.Acknowledgment
      description: "Jeden z <xref href=&quot;System.Messaging.Acknowledgment&quot;> </xref> wartości wyliczenia."
  overload: System.Messaging.Message.Acknowledgment*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.       Kolejka komunikatów została odfiltrowana do ignorowania - lub - <xref:System.Messaging.MessagePropertyFilter.Acknowledgment*>Właściwości.</xref:System.Messaging.MessagePropertyFilter.Acknowledgment*>"
  platform:
  - net462
- uid: System.Messaging.Message.AdministrationQueue
  id: AdministrationQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AdministrationQueue
  nameWithType: Message.AdministrationQueue
  fullName: System.Messaging.Message.AdministrationQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia kolejki, który odbiera komunikaty potwierdzenia, które generuje usługi kolejkowania komunikatów."
  remarks: "Kolejki określony we właściwości AdministrationQueue można każdej kolejki nietransakcyjnej. Wiadomości potwierdzających wysłanych do kolejki administracyjnej można określić, czy oryginalnej wiadomości osiągnął kolejki docelowej i określa, czy została usunięta z kolejki.       Gdy <xref:System.Messaging.Message.AcknowledgeType%2A>właściwość ma żadnej wartości innych niż `None`, aplikacja wysyłająca musi określić kolejkę, która ma być używana jako kolejkę administracyjną.</xref:System.Messaging.Message.AcknowledgeType%2A>"
  example:
  - "The following code example sends and receives a message containing an order to and from a queue. It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.  \n  \n [!code-cs[Message.Acknowledgment#1](~/add/codesnippet/csharp/p-system.messaging.messa_47_1.cs)]\n [!code-cpp[Message.Acknowledgment#1](~/add/codesnippet/cpp/p-system.messaging.messa_47_1.cpp)]\n [!code-vb[Message.Acknowledgment#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_47_1.vb)]"
  syntax:
    content: public System.Messaging.MessageQueue AdministrationQueue { get; set; }
    return:
      type: System.Messaging.MessageQueue
      description: "<xref href=&quot;System.Messaging.MessageQueue&quot;> </xref> , Który określa kolejkę administracyjną dla potwierdzeń generowanych przez system komunikatów. Wartość domyślna to <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.AdministrationQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kolejka komunikatów została odfiltrowana do ignorowania właściwości AdministrationQueue."
  platform:
  - net462
- uid: System.Messaging.Message.AppSpecific
  id: AppSpecific
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AppSpecific
  nameWithType: Message.AppSpecific
  fullName: System.Messaging.Message.AppSpecific
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia informacje dodatkowe, specyficzne dla aplikacji."
  remarks: "Właściwość AppSpecific zawiera informacje specyficzne dla aplikacji, które umożliwia organizowanie różnych typów wiadomości. Na przykład można użyć indeksów specyficzne dla aplikacji. Jest odpowiedzialny za aplikacji interpretować AppSpecific informacje dotyczące właściwości.       Jeśli to możliwe, należy uwzględnić dane komunikatów w treści wiadomości, a nie właściwość AppSpecific.       Podczas pracy z kolejkami obcego, użyj <xref:System.Messaging.Message.Extension%2A>Właściwości, aby określić właściwości wiadomości, które nie istnieją w usługi kolejkowania komunikatów.</xref:System.Messaging.Message.Extension%2A> Zgodnie z właściwością AppSpecific jest odpowiedzialny za aplikacji, aby zrozumieć zawartość <xref:System.Messaging.Message.Extension%2A>Właściwości.</xref:System.Messaging.Message.Extension%2A>"
  syntax:
    content: public int AppSpecific { get; set; }
    return:
      type: System.Int32
      description: "Informacje dotyczące tej aplikacji. Wartość domyślna to zero."
  overload: System.Messaging.Message.AppSpecific*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kolejka komunikatów została odfiltrowana do ignorowania właściwości AppSpecific."
  platform:
  - net462
- uid: System.Messaging.Message.ArrivedTime
  id: ArrivedTime
  parent: System.Messaging.Message
  langs:
  - csharp
  name: ArrivedTime
  nameWithType: Message.ArrivedTime
  fullName: System.Messaging.Message.ArrivedTime
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera czas odebrania wiadomości w kolejce docelowej."
  remarks: "Komunikat <xref:System.Messaging.Message.TimeToBeReceived%2A>właściwość wskazuje, jak szybko można odebrać wiadomości z kolejki docelowej.</xref:System.Messaging.Message.TimeToBeReceived%2A> <xref:System.Messaging.Message.TimeToBeReceived%2A>Czasomierza właściwości rozpoczyna się, gdy komunikat jest wysyłany nie nadejściu wiadomości w kolejce.</xref:System.Messaging.Message.TimeToBeReceived%2A>"
  example:
  - "The following code example displays the value of a message's ArrivedTime property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public DateTime ArrivedTime { get; }
    return:
      type: System.DateTime
      description: "A <xref:System.DateTime>reprezentujący Godzina nadejścia wiadomości w kolejce docelowej.</xref:System.DateTime> Czas jest uwzględniany z GMT na czas lokalny komputera, na którym znajduje się kolejka docelowa."
  overload: System.Messaging.Message.ArrivedTime*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.       - lub - kolejki wiadomości jest filtrowana ignoruje parametr ArrivedTime właściwości."
  platform:
  - net462
- uid: System.Messaging.Message.AttachSenderId
  id: AttachSenderId
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AttachSenderId
  nameWithType: Message.AttachSenderId
  fullName: System.Messaging.Message.AttachSenderId
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia wartość wskazującą, czy identyfikator nadawcy powinien być dołączony do wiadomości."
  remarks: "<xref:System.Messaging.Message.SenderId%2A>Właściwość jest tablicą bajtów reprezentujący identyfikator użytkownika, wysyłania.</xref:System.Messaging.Message.SenderId%2A> Identyfikator nadawcy jest ustawiana przez usługę kolejkowania komunikatów i jest używany przez odbierającego menedżera kolejek, aby sprawdzić, czy nadawca ma prawa dostępu do kolejki.       Brak wskazanie przez aplikację wysyłającą, że usługi kolejkowania komunikatów należy zweryfikować nadawcy wiadomości nie Sprawdź dostęp do nadawcy to identyfikator nadawcy praw do odbierania kolejki. <xref:System.Messaging.Message.SenderId%2A>Jest zaufane, tylko wtedy, gdy wiadomość została uwierzytelniona, gdy jej dotarła do kolejki docelowej.</xref:System.Messaging.Message.SenderId%2A> Komunikat został odrzucony, gdy dotrze do kolejki docelowej, jeśli kolejka akceptuje tylko wiadomości uwierzytelnione, a następnie <xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>lub <xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>jest właściwość `false`.</xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A> </xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>      > [!CAUTION] > Jeśli komunikat zostanie odrzucony, jest albo wysłane do kolejki utraconych wiadomości (Jeśli <xref:System.Messaging.Message.UseDeadLetterQueue%2A>jest `true`), lub jest on ignorowany.</xref:System.Messaging.Message.UseDeadLetterQueue%2A> Można zażądać potwierdzenia nieudanej wiadomości do kolejki. W przeciwnym razie po wybraniu <xref:System.Messaging.Message.UseDeadLetterQueue%2A>jest `false` wiadomości mogą zostać utracone bez ostrzeżenia.</xref:System.Messaging.Message.UseDeadLetterQueue%2A>"
  example:
  - "The following code example gets and sets the value of a message's AttachSenderId property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool AttachSenderId { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli <xref:System.Messaging.Message.SenderId*>powinien być dołączony do wiadomości, a w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Messaging.Message.SenderId*> Wartość domyślna to <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.AttachSenderId*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kolejka komunikatów została odfiltrowana do ignorowania właściwości AttachSenderId."
  platform:
  - net462
- uid: System.Messaging.Message.Authenticated
  id: Authenticated
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Authenticated
  nameWithType: Message.Authenticated
  fullName: System.Messaging.Message.Authenticated
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera wartość wskazującą, czy wiadomość została uwierzytelniona."
  remarks: "Właściwość uwierzytelniany jest używana tylko przez aplikację, podczas próby określenia, czy żądano uwierzytelnienia i interakcji z komunikatem. W przypadku wiadomości w kolejce, wiadomość została uwierzytelniona. Z drugiej strony Jeśli właściwość uwierzytelniany jest `true`, odbierającego menedżera kolejek uwierzytelniony wiadomości, gdy ten komunikat.       Nie można ustalić, czy wiadomość niepowodzenie uwierzytelniania analizując jego właściwości. Usługa kolejkowania komunikatów odrzuca wiadomości, które niepowodzenia uwierzytelniania przed wysłaniem ich do kolejki. Można jednak żądanie wysłane wiadomości potwierdzającej Jeśli awaria dostarczania uniemożliwia wiadomości w kolejce."
  example:
  - "The following code example displays the value of a message's Authenticated property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool Authenticated { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli żądano uwierzytelnienia wiadomości wprowadzenie kolejki; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.Authenticated*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.       - lub - Ignoruj właściwość Uwierzytelniona kolejki wiadomości jest odfiltrowana."
  platform:
  - net462
- uid: System.Messaging.Message.AuthenticationProviderName
  id: AuthenticationProviderName
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AuthenticationProviderName
  nameWithType: Message.AuthenticationProviderName
  fullName: System.Messaging.Message.AuthenticationProviderName
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia nazwę dostawcy usług kryptograficznych używanego do generowania podpisu cyfrowego wiadomości."
  remarks: "Zazwyczaj jest używana AuthenticationProviderName podczas pracy z kolejkami obcego. Usługa kolejkowania komunikatów wymaga Nazwa dostawcy uwierzytelniania i dostawcy usług kryptograficznych (dostawcy uwierzytelniania), aby sprawdzić poprawność podpisów cyfrowych wiadomości wysłanych do kolejki obcego i przekazane do usługi kolejkowania komunikatów z kolejki obce komunikaty typu dostawcy uwierzytelniania.       Podczas wysyłania wiadomości, zawsze wartość AuthenticationProviderName i <xref:System.Messaging.Message.ConnectorType%2A>Właściwości razem.</xref:System.Messaging.Message.ConnectorType%2A> Po wysłaniu wiadomości usługi kolejkowania komunikatów ignoruje Nazwa dostawcy uwierzytelniania, jeśli typ łącznika nie jest również ustawiona.       Właściwość AuthenticationProviderName nie może być `null`, ale może być pustym ciągiem (&quot;&quot;)."
  syntax:
    content: public string AuthenticationProviderName { get; set; }
    return:
      type: System.String
      description: "Nazwa dostawcy usług kryptograficznych używanego do generowania podpisu cyfrowego wiadomości. Wartość domyślna to Microsoft Base Cryptographic Provider w wersji 1.0."
  overload: System.Messaging.Message.AuthenticationProviderName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nie można ustawić właściwości AuthenticationProviderName.       - lub - kolejki wiadomości jest filtrowana Ignorowanie właściwości AuthenticationProviderName."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Ustawiono AuthenticationProviderName <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Messaging.Message.AuthenticationProviderType
  id: AuthenticationProviderType
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AuthenticationProviderType
  nameWithType: Message.AuthenticationProviderType
  fullName: System.Messaging.Message.AuthenticationProviderType
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia typ dostawcy usług kryptograficznych używanego do generowania podpisu cyfrowego wiadomości."
  remarks: "Zwykle używasz właściwości AuthenticationProviderType podczas pracy z kolejkami obcego można określić, które usług kryptograficznych dostawcy jest skojarzony z komunikatem. Usługa kolejkowania komunikatów wymaga Nazwa dostawcy uwierzytelniania i dostawcy usług kryptograficznych (dostawcy uwierzytelniania), aby sprawdzić poprawność podpisów cyfrowych wiadomości wysłanych do kolejki obcego i przekazane do usługi kolejkowania komunikatów z kolejki obce komunikaty typu dostawcy uwierzytelniania.       Tylko `RsaFull` jest przeznaczony do użycia z obsługą wiadomości.       Podczas wysyłania wiadomości, zawsze wartość AuthenticationProviderType i <xref:System.Messaging.Message.ConnectorType%2A>Właściwości razem.</xref:System.Messaging.Message.ConnectorType%2A> Po wysłaniu wiadomości usługi kolejkowania komunikatów ignoruje typ dostawcy uwierzytelniania, jeśli typ łącznika nie jest również ustawiona."
  syntax:
    content: public System.Messaging.CryptographicProviderType AuthenticationProviderType { get; set; }
    return:
      type: System.Messaging.CryptographicProviderType
      description: "Jeden z <xref href=&quot;System.Messaging.CryptographicProviderType&quot;> </xref> wartości. Wartość domyślna to <xref uid=&quot;langword_csharp_RSA_FULL&quot; name=&quot;RSA_FULL&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.AuthenticationProviderType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nie można ustawić właściwości AuthenticationProviderType.       - lub - kolejki wiadomości jest filtrowana Ignorowanie właściwości AuthenticationProviderType."
  platform:
  - net462
- uid: System.Messaging.Message.Body
  id: Body
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Body
  nameWithType: Message.Body
  fullName: System.Messaging.Message.Body
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia zawartość komunikatu."
  remarks: "Właściwość treść wiadomości zawiera zwykle dane skojarzone z wiadomością. Mimo że można również wysyłać dane specyficzne dla aplikacji, <xref:System.Messaging.Message.AppSpecific%2A>i <xref:System.Messaging.Message.Extension%2A>Właściwości, powinny obejmować dane wiadomość w treści wiadomości, jeśli to możliwe.</xref:System.Messaging.Message.Extension%2A> </xref:System.Messaging.Message.AppSpecific%2A> Tylko zawartość treści właściwości są serializowane lub szyfrowane.       Właściwość treści może zawierać dowolny obiekt, którego rozmiar nie przekracza 4 MB. Jeśli używane <xref:System.Messaging.MessageQueue.Send%2A?displayProperty=fullName>do wysyłania dowolnego obiektu, to nie pochodzi z typu <xref:System.Messaging.Message> <xref:System.Messaging.MessageQueue>który obiekt będą znajdować się we właściwości treści <xref:System.Messaging.Message>wystąpień zwrócona przez <xref:System.Messaging.MessageQueue.Peek%2A>lub <xref:System.Messaging.MessageQueue.Receive%2A>.</xref:System.Messaging.MessageQueue.Receive%2A> </xref:System.Messaging.MessageQueue.Peek%2A> </xref:System.Messaging.Message> </xref:System.Messaging.MessageQueue> </xref:System.Messaging.Message> </xref:System.Messaging.MessageQueue.Send%2A?displayProperty=fullName>       Argument ciągu w `MessageQueue.Send(&quot;hello.&quot;)` przykładem obiekt generyczny.       <xref:System.Messaging.Message.BodyType%2A>Właściwość wskazuje typ informacji przechowywanych w treści wiadomości.</xref:System.Messaging.Message.BodyType%2A> Usługa kolejkowania komunikatów używa tych informacji do identyfikacji typu zawartości treści właściwości.       Określ właściwość Body lub <xref:System.Messaging.Message.BodyStream%2A>Właściwości przed wysłaniem <xref:System.Messaging.Message>obiektu.</xref:System.Messaging.Message> </xref:System.Messaging.Message.BodyStream%2A> Dla właściwości Body można możliwy do serializacji obiektu, na przykład ciąg tekstowy, obiekt struktury, wystąpienia klasy lub osadzonego obiektu.       O ile bezpośrednio do zapisu treści wiadomości <xref:System.Messaging.Message.BodyStream%2A>właściwość, ustaw <xref:System.Messaging.Message.Formatter%2A>Właściwości przed wysłaniem wiadomości.</xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.BodyStream%2A> Gdy <xref:System.Messaging.MessageQueue.Send%2A>wywoływana jest metoda <xref:System.Messaging.MessageQueue>wystąpienia, treść jest serializowany przy użyciu elementu formatującego, zawartych w <xref:System.Messaging.Message.Formatter%2A>Właściwości.</xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue.Send%2A> Jeśli zostanie wysłana wiadomość bez określenia wartości dla <xref:System.Messaging.Message.Formatter%2A>Właściwości, ustawienia domyślne programu formatującego <xref:System.Messaging.XmlMessageFormatter>.</xref:System.Messaging.XmlMessageFormatter> </xref:System.Messaging.Message.Formatter%2A>      > [!NOTE] > Treści wiadomości do ustawiania <xref:System.Decimal.MaxValue>spowoduje, że <xref:System.OverflowException>podczas `Send` metody <xref:System.Messaging.MessageQueue>nosi nazwę klasy i <xref:System.Messaging.ActiveXMessageFormatter>jest używany.</xref:System.Messaging.ActiveXMessageFormatter> </xref:System.Messaging.MessageQueue> </xref:System.OverflowException> </xref:System.Decimal.MaxValue>"
  example:
  - "The following code example sends two messages of different priorities to the queue, and retrieves them subsequently.  \n  \n [!code-cpp[Message.DefaultPropertiesToSend#1](~/add/codesnippet/cpp/p-system.messaging.messa_13_1.cpp)]\n [!code-vb[Message.DefaultPropertiesToSend#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_13_1.vb)]\n [!code-cs[Message.DefaultPropertiesToSend#1](~/add/codesnippet/csharp/p-system.messaging.messa_13_1.cs)]"
  syntax:
    content: public object Body { get; set; }
    return:
      type: System.Object
      description: "Obiekt, który określa treść komunikatu. Obiekt może być ciągiem, datę, waluty, liczbę, tablicę bajtów lub dowolny obiekt zarządzany."
  overload: System.Messaging.Message.Body*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref:System.Messaging.Message.Formatter*>Właściwość jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>.</xref:System.Messaging.Message.Formatter*>       - lub - kolejki wiadomości jest filtrowana Ignorowanie właściwości Body."
  platform:
  - net462
- uid: System.Messaging.Message.BodyStream
  id: BodyStream
  parent: System.Messaging.Message
  langs:
  - csharp
  name: BodyStream
  nameWithType: Message.BodyStream
  fullName: System.Messaging.Message.BodyStream
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia informacje w treści wiadomości."
  remarks: "Treść komunikatu może składać się z dowolnego typu informacji — na przykład ciąg, datę, waluty, liczbę, tablicę bajtów lub dowolny obiekt zarządzany. Te informacje jest serializowany w <xref:System.IO.Stream>do przekazania do kolejki.</xref:System.IO.Stream>       Określ <xref:System.Messaging.Message.Body%2A>Właściwość lub BodyStream przed wysłaniem <xref:System.Messaging.Message>obiektu.</xref:System.Messaging.Message> </xref:System.Messaging.Message.Body%2A> Jeśli ustawisz <xref:System.Messaging.Message.Body%2A>Właściwości, zawartość są serializowane do właściwości BodyStream.</xref:System.Messaging.Message.Body%2A> Jednak można zapisać właściwości BodyStream bezpośrednio. Jest to przydatne, na przykład, jeśli chcesz nawiązać połączenie z pliku i przesyłania strumieniowego jego zawartość jako treść komunikatu.       Jeśli piszesz treści wiadomości bezpośrednio do właściwości BodyStream ustalonych <xref:System.Messaging.Message.Formatter%2A>Właściwości przed wysłaniem wiadomości.</xref:System.Messaging.Message.Formatter%2A> Gdy <xref:System.Messaging.MessageQueue.Send%2A>wywoływana jest metoda <xref:System.Messaging.MessageQueue>wystąpienia, treść jest serializowany przy użyciu elementu formatującego, zawartych w <xref:System.Messaging.Message.Formatter%2A>Właściwości.</xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue.Send%2A> Jeśli zostanie wysłana wiadomość bez określenia wartości dla <xref:System.Messaging.Message.Formatter%2A>Właściwości, ustawienia domyślne programu formatującego <xref:System.Messaging.XmlMessageFormatter>.</xref:System.Messaging.XmlMessageFormatter> </xref:System.Messaging.Message.Formatter%2A>       Jeśli ustawisz <xref:System.Messaging.Message.UseEncryption%2A>właściwości `true` komunikat dla treści wiadomości, będą szyfrowane podczas wysyłania, nie po ustawieniu <xref:System.Messaging.Message.Body%2A>Właściwości.</xref:System.Messaging.Message.Body%2A> </xref:System.Messaging.Message.UseEncryption%2A> W związku z tym właściwość BodyStream nigdy nie są szyfrowane."
  syntax:
    content: public System.IO.Stream BodyStream { get; set; }
    return:
      type: System.IO.Stream
      description: "A <xref:System.IO.Stream>zawiera seryjnych informacje zawarte w <xref:System.Messaging.Message.Body*>wiadomości.</xref:System.Messaging.Message.Body*> </xref:System.IO.Stream>"
  overload: System.Messaging.Message.BodyStream*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kolejka komunikatów została odfiltrowana do ignorowania <xref:System.Messaging.Message.Body*>Właściwości.</xref:System.Messaging.Message.Body*>"
  platform:
  - net462
- uid: System.Messaging.Message.BodyType
  id: BodyType
  parent: System.Messaging.Message
  langs:
  - csharp
  name: BodyType
  nameWithType: Message.BodyType
  fullName: System.Messaging.Message.BodyType
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia typ danych, który zawiera treść komunikatu."
  remarks: "Usługa kolejkowania komunikatów rozpoznaje zawartość treści jako obiekt lub strumieniu serializowanym. Właściwość BodyType wskazuje typ obiektu, w ramach <xref:System.Messaging.Message.Body%2A>Właściwości komunikatu.</xref:System.Messaging.Message.Body%2A>       <xref:System.Messaging.XmlMessageFormatter>Wykonuje powiązanie między natywnych typów i obiektu w treści wiadomości.</xref:System.Messaging.XmlMessageFormatter> Jeśli używasz <xref:System.Messaging.XmlMessageFormatter>, element formatujący ustawia właściwość BodyType.</xref:System.Messaging.XmlMessageFormatter>       Inne elementy formatujące udostępniają funkcje powiązanie również, jak pokazano w poniższym kodzie C#.      ```   message.Formatter = new ActiveXMessageFormatter();   object myObject message.Body;   if (myObject is string) {   }   if (myObject is int) {   }   if (myObject is float) {   }   ```"
  example:
  - "The following code example displays the value of a message's BodyType property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public int BodyType { get; set; }
    return:
      type: System.Int32
      description: "Treść komunikatu true typu, na przykład ciąg, datę, waluty lub liczbą."
  overload: System.Messaging.Message.BodyType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kolejka komunikatów została odfiltrowana do ignorowania <xref:System.Messaging.Message.Body*>Właściwości.</xref:System.Messaging.Message.Body*>"
  platform:
  - net462
- uid: System.Messaging.Message.ConnectorType
  id: ConnectorType
  parent: System.Messaging.Message
  langs:
  - csharp
  name: ConnectorType
  nameWithType: Message.ConnectorType
  fullName: System.Messaging.Message.ConnectorType
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia wartość wskazującą, że niektóre właściwości komunikatów, na ogół ustawiane przez usługę MSMQ zostały określone przez aplikację wysyłającą."
  remarks: "Usługa kolejkowania komunikatów wymaga można ustawić właściwości elementu ConnectorType, gdy aplikacja ustawia właściwości wiadomości, która zwykle jest ustawiana przez usługę kolejkowania komunikatów. Aplikacja używa zwykle ConnectorType w dwóch następujących przypadków: - zawsze, gdy aplikacja łącznika przekazuje komunikat. ConnectorType informuje aplikacje wysyłające i odbierające jak interpretować właściwości zabezpieczeń i potwierdzeń wiadomości.      -Zawsze, gdy aplikacja wysyłająca, a nie usługi kolejkowania komunikatów, szyfruje wiadomości. ConnectorType informuje, aby użyć usługi kolejkowania komunikatów <xref:System.Messaging.Message.DestinationSymmetricKey%2A>wartości właściwości do odszyfrowywania wiadomości.</xref:System.Messaging.Message.DestinationSymmetricKey%2A>       Należy ustawić właściwość ConnectorType przypadku ustawienia dowolnej z następujących właściwości (w przeciwnym razie kolejki ignoruje te właściwości, gdy komunikat jest wysyłany):- <xref:System.Messaging.Message.AuthenticationProviderName%2A>- <xref:System.Messaging.Message.AuthenticationProviderType%2A>- <xref:System.Messaging.Message.DestinationSymmetricKey%2A>- <xref:System.Messaging.Message.DigitalSignature%2A>- <xref:System.Messaging.Message.MessageType%2A>— <xref:System.Messaging.Message.SenderId%2A></xref:System.Messaging.Message.SenderId%2A> </xref:System.Messaging.Message.MessageType%2A> </xref:System.Messaging.Message.DigitalSignature%2A> </xref:System.Messaging.Message.DestinationSymmetricKey%2A> </xref:System.Messaging.Message.AuthenticationProviderType%2A> </xref:System.Messaging.Message.AuthenticationProviderName%2A>"
  syntax:
    content: public Guid ConnectorType { get; set; }
    return:
      type: System.Guid
      description: "A <xref:System.Guid>zdefiniowane przez aplikację i używane w połączeniu z aplikacjami łącznik lub szyfrowania wiadomości.</xref:System.Guid> To <xref:System.Guid>umożliwia aplikacji odbierającej interpretować właściwości wiadomości, które zostały określone przez aplikację wysyłającą, ale zazwyczaj ustawionych przez usługę kolejkowania komunikatów.</xref:System.Guid>"
  overload: System.Messaging.Message.ConnectorType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kolejka komunikatów została odfiltrowana do ignorowania Właściwość ConnectorType."
  platform:
  - net462
- uid: System.Messaging.Message.CorrelationId
  id: CorrelationId
  parent: System.Messaging.Message
  langs:
  - csharp
  name: CorrelationId
  nameWithType: Message.CorrelationId
  fullName: System.Messaging.Message.CorrelationId
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia identyfikator komunikatu używany przez potwierdzenie, raportów i komunikatów odpowiedzi w celu oryginalnej wiadomości."
  remarks: "Podczas kolejkowania generuje komunikat potwierdzenia lub raport, używa właściwości identyfikator korelacji Aby określić identyfikator wiadomości oryginalnej wiadomości. W ten sposób identyfikator korelacji wiąże raportu lub potwierdzeń wiadomości do oryginalnej wiadomości.       Aplikacja wysyłająca może następnie być zgodne z potwierdzeń lub raport z oryginalnej wiadomości przy użyciu właściwości CorrelationId do identyfikacji oryginalnej wiadomości <xref:System.Messaging.Message.Id%2A>Właściwości.</xref:System.Messaging.Message.Id%2A>       Aplikacje łącznika również ustawić właściwości CorrelationId komunikatów potwierdzenia i raportu identyfikator wiadomości oryginalnej wiadomości.       Gdy aplikacja wysyła komunikat odpowiedzi do wysyłania aplikacji, można ustawić właściwości CorrelationId komunikat odpowiedzi do identyfikatora wiadomości oryginalnej wiadomości. Aplikacja wysyłająca można następnie powiązać komunikatu odpowiedzi na komunikat, który został wysłany."
  example:
  - "The following code example sends and receives a message that contains an order to and from a queue. It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.  \n  \n [!code-cs[Message.Acknowledgment#1](~/add/codesnippet/csharp/p-system.messaging.messa_95_1.cs)]\n [!code-cpp[Message.Acknowledgment#1](~/add/codesnippet/cpp/p-system.messaging.messa_95_1.cpp)]\n [!code-vb[Message.Acknowledgment#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_95_1.vb)]"
  syntax:
    content: public string CorrelationId { get; set; }
    return:
      type: System.String
      description: "Określony przez identyfikator wiadomości <xref:System.Messaging.Message.Id*>właściwości oryginalnej wiadomości.</xref:System.Messaging.Message.Id*> Identyfikator korelacji jest używany przez MSMQ podczas generowania wiadomości potwierdzającej lub raportu i przez aplikację, generując komunikat odpowiedzi."
  overload: System.Messaging.Message.CorrelationId*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kolejka komunikatów została odfiltrowana do właściwości CorrelationId zignorować."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Jest CorrelationId <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Messaging.Message.DestinationQueue
  id: DestinationQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: DestinationQueue
  nameWithType: Message.DestinationQueue
  fullName: System.Messaging.Message.DestinationQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera przeznaczenia kolejki wiadomości."
  remarks: "Właściwość DestinationQueue jest najczęściej używane do określenia początkowego miejsca docelowego wiadomości, które dotarły w dzienniku lub kolejki utraconych wiadomości. Zwykle nie trzeba sprawdzić tę właściwość, ponieważ zwykle pobierają wiadomości z kolejki docelowej."
  example:
  - "The following code example displays the value of a message's DestinationQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public System.Messaging.MessageQueue DestinationQueue { get; }
    return:
      type: System.Messaging.MessageQueue
      description: "A <xref href=&quot;System.Messaging.MessageQueue&quot;> </xref> , który określa przeznaczenia kolejki wiadomości."
  overload: System.Messaging.Message.DestinationQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.       - lub - kolejki wiadomości jest filtrowana Ignorowanie właściwości DestinationQueue."
  platform:
  - net462
- uid: System.Messaging.Message.DestinationSymmetricKey
  id: DestinationSymmetricKey
  parent: System.Messaging.Message
  langs:
  - csharp
  name: DestinationSymmetricKey
  nameWithType: Message.DestinationSymmetricKey
  fullName: System.Messaging.Message.DestinationSymmetricKey
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia klucz symetryczny stosowany do szyfrowania wiadomości zaszyfrowanych przez aplikację lub wiadomości wysyłanych do kolejki obcego."
  remarks: "Dwa scenariusze wymagają użycia właściwości DestinationSymmetricKey. Pierwsza to gdy z aplikacji, a nie usługi kolejkowania komunikatów, szyfruje wiadomości. Drugim jest podczas wysyłania wiadomości zaszyfrowanych do system kolejkowania wiadomości innego niż usługi kolejkowania komunikatów.       Przed skonfigurowaniem tej właściwości, należy zaszyfrować klucza symetrycznego z klucza publicznego odbierającego menedżera kolejek. Podczas wysyłania wiadomości zaszyfrowanych przez aplikację odbierającego menedżera kolejek używa klucza symetrycznego do odszyfrowywania wiadomości przed wysłaniem ich do swojej kolejki docelowej.       Po wysłaniu wiadomości do kolejki obcego komunikat jest najpierw odbierany przez aplikację odpowiedni łącznik, który przesyła dalej zaszyfrowanego komunikatu z klucza symetrycznego dołączona do aplikacji odbierającej. Następnie jest odpowiedzialny za aplikację do odszyfrowywania wiadomości za pomocą klucza symetrycznego.       Po ustawieniu właściwości DestinationSymmetricKey, należy także ustawić <xref:System.Messaging.Message.ConnectorType%2A>Właściwości.</xref:System.Messaging.Message.ConnectorType%2A> Po wysłaniu wiadomości MSMQ ignoruje właściwości DestinationSymmetricKey, jeśli <xref:System.Messaging.Message.ConnectorType%2A>właściwość nie jest również ustawiona.</xref:System.Messaging.Message.ConnectorType%2A>       Właściwość DestinationSymmetricKey ma rozmiar tablicy maksymalną 256."
  syntax:
    content: public byte[] DestinationSymmetricKey { get; set; }
    return:
      type: System.Byte[]
      description: "Tablica wartości bajtów określający docelowy klucz symetryczny stosowany do szyfrowania wiadomości. Wartość domyślna jest tablicą o zerowej długości."
  overload: System.Messaging.Message.DestinationSymmetricKey*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kolejka komunikatów została odfiltrowana do ignorowania właściwości DestinationSymmetricKey."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Jest DestinationSymmetricKey <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Messaging.Message.DigitalSignature
  id: DigitalSignature
  parent: System.Messaging.Message
  langs:
  - csharp
  name: DigitalSignature
  nameWithType: Message.DigitalSignature
  fullName: System.Messaging.Message.DigitalSignature
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia podpis cyfrowy, którego używa Usługa Kolejkowanie komunikatów do uwierzytelniania wiadomości."
  remarks: "Usługa kolejkowania komunikatów używa podpis cyfrowy do uwierzytelniania komunikatów wysłanych przez usługę kolejkowania komunikatów w wersji 1.0. W większości przypadków kolejkowania generuje i ustawia właściwość DigitalSignature, gdy aplikacja wysyłająca żąda uwierzytelnienia. Aplikacja używa tej właściwości można pobrać podpisu cyfrowego dołączanego do wiadomości.       Właściwość DigitalSignature można używać tylko podczas uruchamiania usługi kolejkowania komunikatów w wersji 2.0. Aplikacja wysyłająca musi określić usługi kolejkowania komunikatów w wersji 1.0 podpisów podczas żądania uwierzytelniania. Jeśli aplikacja wysyłająca wysyła podpis MSMQ w wersji 2.0, ta właściwość zawiera buforu czterech bajtów, każdy zawierający zero.       Właściwość DigitalSignature, wraz z <xref:System.Messaging.Message.SenderCertificate%2A>, jest również używana przez łącznik aplikacji podczas wysyłania wiadomości.</xref:System.Messaging.Message.SenderCertificate%2A> W tym scenariuszu aplikacja łącznika — zamiast usługi kolejkowania komunikatów — generuje podpisu cyfrowego opiera się on na certyfikat użytkownika, wysyłając ten komunikat.       Właściwość DigitalSignature ma rozmiar tablicy maksymalną 256.       Po ustawieniu właściwości DigitalSignature, należy także ustawić <xref:System.Messaging.Message.ConnectorType%2A>Właściwości.</xref:System.Messaging.Message.ConnectorType%2A> Po wysłaniu wiadomości MSMQ ignoruje właściwości DigitalSignature, jeśli <xref:System.Messaging.Message.ConnectorType%2A>właściwość nie jest również ustawiona.</xref:System.Messaging.Message.ConnectorType%2A>"
  syntax:
    content: public byte[] DigitalSignature { get; set; }
    return:
      type: System.Byte[]
      description: "Tablica wartości bajtów określający 1.0 usługi kolejkowania komunikatów podpis cyfrowy używany do uwierzytelniania wiadomości. Wartość domyślna jest tablicą o zerowej długości."
  overload: System.Messaging.Message.DigitalSignature*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kolejka komunikatów została odfiltrowana do ignorowania właściwości DigitalSignature."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Właściwość DigitalSignature jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Messaging.Message.EncryptionAlgorithm
  id: EncryptionAlgorithm
  parent: System.Messaging.Message
  langs:
  - csharp
  name: EncryptionAlgorithm
  nameWithType: Message.EncryptionAlgorithm
  fullName: System.Messaging.Message.EncryptionAlgorithm
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia algorytm szyfrowania używany do szyfrowania treści wiadomości prywatnej."
  remarks: "Jeśli komunikat jest prywatny (zaszyfrowane), są szyfrowane przed wysyłanych i odszyfrować po otrzymaniu. Właściwość EncryptionAlgorithm Określa algorytm używany do szyfrowania treści wiadomości prywatnej.       Kolejki mogą wymagać tego przychodzące można zaszyfrować wiadomości. Jeśli aplikacja wysyła wiadomość (z systemem innym niż prywatny) niezaszyfrowane do kolejki, która akceptuje tylko wiadomości prywatne lub jeśli wysyła wiadomości prywatne do kolejki, która akceptuje tylko wiadomości nieprywatne, kolejki odrzuca komunikat. Aplikacja wysyłająca mogą żądać, że w takim przypadku jest zwracany komunikat o potwierdzenie negatywne."
  syntax:
    content: public System.Messaging.EncryptionAlgorithm EncryptionAlgorithm { get; set; }
    return:
      type: System.Messaging.EncryptionAlgorithm
      description: "Jeden z <xref href=&quot;System.Messaging.EncryptionAlgorithm&quot;> </xref> wartości wyliczenia. Wartość domyślna to <xref uid=&quot;langword_csharp_RC2&quot; name=&quot;RC2&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.EncryptionAlgorithm*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kolejka komunikatów została odfiltrowana do Ignoruj właściwości algorytm szyfrowania."
  platform:
  - net462
- uid: System.Messaging.Message.Extension
  id: Extension
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Extension
  nameWithType: Message.Extension
  fullName: System.Messaging.Message.Extension
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia dodatkowe, zdefiniowane przez aplikację informacje skojarzone z wiadomością."
  remarks: "Właściwość rozszerzenia zawiera zdefiniowane przez aplikację informacje, takie jak dużego obiektu binarnego, który jest skojarzony z komunikatem. Jest odpowiedzialny za aplikacja odbierająca zinterpretować zawartości właściwość rozszerzenia.       Jeśli to możliwe, powinny obejmować dane komunikatów w <xref:System.Messaging.Message.Body%2A>Właściwości wiadomości, a nie wartość właściwości rozszerzenia.</xref:System.Messaging.Message.Body%2A>       Podczas pracy z kolejkami obcego, użyj właściwości rozszerzenia do określania właściwości wiadomości, które nie istnieją w usługi kolejkowania komunikatów.       Obcy kolejka istnieje w systemie kolejkowania innego niż usługi kolejkowania wiadomości firmy Microsoft. Usługa kolejkowania komunikatów komunikuje się z takich kolejek za pomocą łącznika aplikacji."
  syntax:
    content: public byte[] Extension { get; set; }
    return:
      type: System.Byte[]
      description: "Tablica wartości bajtów zawiera zdefiniowane przez aplikację informacje skojarzone z wiadomością. Wartość domyślna jest tablicą o zerowej długości."
  overload: System.Messaging.Message.Extension*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kolejka komunikatów została odfiltrowana do ignorowania właściwość rozszerzenia."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Właściwość rozszerzenia jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Messaging.Message.Formatter
  id: Formatter
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Formatter
  nameWithType: Message.Formatter
  fullName: System.Messaging.Message.Formatter
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia element formatujący używany do serializacji obiektu do lub deserializacji obiektu z treści wiadomości."
  remarks: "Użyj programu formatującego właściwości podczas odczytywania i zapisywania wiadomości. Po wysłaniu wiadomości do kolejki program formatujący serializuje <xref:System.Messaging.Message.Body%2A>właściwości do strumienia, który można wysłać do kolejki wiadomości.</xref:System.Messaging.Message.Body%2A> Podczas czytania z kolejki, element formatujący deserializuje dane wiadomości do <xref:System.Messaging.Message.Body%2A>Właściwości.</xref:System.Messaging.Message.Body%2A>       O ile bezpośrednio do zapisu treści wiadomości <xref:System.Messaging.Message.BodyStream%2A>właściwość, ustaw właściwość elementu formatującego przed wysłaniem wiadomości.</xref:System.Messaging.Message.BodyStream%2A> Gdy <xref:System.Messaging.MessageQueue.Send%2A>wywoływana jest metoda <xref:System.Messaging.MessageQueue>wystąpienia, treść jest serializowany przy użyciu elementu formatującego, znajdujących się we właściwości elementu formatującego.</xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue.Send%2A> Jeśli zostanie wysłana wiadomość bez określenia wartości dla właściwości elementu formatującego, element formatujący domyślnie <xref:System.Messaging.XmlMessageFormatter>.</xref:System.Messaging.XmlMessageFormatter>       <xref:System.Messaging.XmlMessageFormatter>Jest luźno, więc nie ma tego samego obiektu typu na nadawcy i odbiorcy, korzystając z tego formatu.</xref:System.Messaging.XmlMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>i <xref:System.Messaging.BinaryMessageFormatter>serializuje dane na binarna reprezentacja.</xref:System.Messaging.BinaryMessageFormatter> </xref:System.Messaging.ActiveXMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>Jest używany przy wysyłaniu lub odbieraniu składniki COM.</xref:System.Messaging.ActiveXMessageFormatter>"
  example:
  - "The following code example demonstrates formatting a message body using <xref:System.Messaging.BinaryMessageFormatter>.  \n  \n [!code-cpp[MessagingBinaryFormatter#1](~/add/codesnippet/cpp/p-system.messaging.messa_5_1.cpp)]\n [!code-cs[MessagingBinaryFormatter#1](~/add/codesnippet/csharp/p-system.messaging.messa_5_1.cs)]\n [!code-vb[MessagingBinaryFormatter#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_5_1.vb)]  \n  \n The following code example demonstrates formatting a message body using <xref:System.Messaging.XmlMessageFormatter>.  \n  \n [!code-cpp[Message.Body#1](~/add/codesnippet/cpp/p-system.messaging.messa_5_2.cpp)]\n [!code-cs[Message.Body#1](~/add/codesnippet/csharp/p-system.messaging.messa_5_2.cs)]\n [!code-vb[Message.Body#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_5_2.vb)]"
  syntax:
    content: public System.Messaging.IMessageFormatter Formatter { get; set; }
    return:
      type: System.Messaging.IMessageFormatter
      description: "<xref href=&quot;System.Messaging.IMessageFormatter&quot;> </xref> Daje strumienia zapisywane lub odczytywać treść komunikatu. Wartość domyślna to <xref href=&quot;System.Messaging.XmlMessageFormatter&quot;> </xref>."
  overload: System.Messaging.Message.Formatter*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Właściwość elementu formatującego jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Messaging.Message.HashAlgorithm
  id: HashAlgorithm
  parent: System.Messaging.Message
  langs:
  - csharp
  name: HashAlgorithm
  nameWithType: Message.HashAlgorithm
  fullName: System.Messaging.Message.HashAlgorithm
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia algorytmu, który używa Usługa Kolejkowanie komunikatów uwierzytelniania wiadomości mieszania lub tworzenia podpisu cyfrowego wiadomości."
  remarks: "Na komputerze źródłowym usługi kolejkowania komunikatów używa algorytmu wyznaczania wartości skrótu do utworzenia podpisu cyfrowego wiadomości. Element docelowy menedżera kolejek następnie używa tego samego algorytmu wyznaczania wartości skrótu do uwierzytelniania wiadomości, po odebraniu."
  syntax:
    content: public System.Messaging.HashAlgorithm HashAlgorithm { get; set; }
    return:
      type: System.Messaging.HashAlgorithm
      description: "Jeden z <xref href=&quot;System.Messaging.HashAlgorithm&quot;> </xref> wartości wyliczenia. Windows XP, wartością domyślną jest <xref uid=&quot;langword_csharp_SHA&quot; name=&quot;SHA&quot; href=&quot;&quot;> </xref>. W przeciwnym razie wartość domyślna to <xref uid=&quot;langword_csharp_MD5&quot; name=&quot;MD5&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.HashAlgorithm*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kolejka komunikatów została odfiltrowana do Ignoruj właściwości algorytm skrótu."
  platform:
  - net462
- uid: System.Messaging.Message.Id
  id: Id
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Id
  nameWithType: Message.Id
  fullName: System.Messaging.Message.Id
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera identyfikator komunikatu."
  remarks: "Usługa kolejkowania komunikatów generuje identyfikator komunikatu, gdy komunikat jest wysyłany. Identyfikator składa się z 20 bajtów i zawiera dwie pozycje: maszynie <xref:System.Guid>komputera wysyłającego i unikatowy identyfikator wiadomości na komputerze.</xref:System.Guid> Kombinacja dwóch elementów tworzy identyfikator wiadomości, która jest unikatowa w sieci.       Komunikatów usługi kolejkowania wiadomości generuje komunikat identyfikatorów dla wszystkich wiadomości — tym raport i potwierdzeń wiadomości. Wiadomości potwierdzającej zwykle wysyłane przez usługę kolejkowania wiadomości przyjęcia lub błąd oryginalny komunikat wysłany. Znajduje się wartość właściwości identyfikator oryginalnej wiadomości w <xref:System.Messaging.Message.CorrelationId%2A>Właściwości wiadomością potwierdzającą.</xref:System.Messaging.Message.CorrelationId%2A>       Umożliwia także właściwości Id podczas wysyłania komunikatu odpowiedzi do kolejki odpowiedzi. Aby dołączyć identyfikator oryginalnej wiadomości komunikat odpowiedzi, ustaw <xref:System.Messaging.Message.CorrelationId%2A>Właściwości komunikatu odpowiedzi z właściwością Id oryginalnej wiadomości.</xref:System.Messaging.Message.CorrelationId%2A> Aplikacja czytania wiadomości odpowiedzi służą następnie identyfikator korelacji wiadomości odpowiedzi do identyfikacji oryginalnej wiadomości."
  example:
  - "The following code example sends and receives a message containing an order to and from a queue. It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.  \n  \n [!code-cs[Message.Acknowledgment#1](~/add/codesnippet/csharp/p-system.messaging.messa_19_1.cs)]\n [!code-cpp[Message.Acknowledgment#1](~/add/codesnippet/cpp/p-system.messaging.messa_19_1.cpp)]\n [!code-vb[Message.Acknowledgment#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_19_1.vb)]"
  syntax:
    content: public string Id { get; }
    return:
      type: System.String
      description: "Komunikat Unikatowy identyfikator, który jest generowany przez usługę kolejkowania komunikatów."
  overload: System.Messaging.Message.Id*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.       - lub - kolejki wiadomości jest filtrowana Ignorowanie właściwości identyfikatora."
  platform:
  - net462
- uid: System.Messaging.Message.InfiniteTimeout
  id: InfiniteTimeout
  parent: System.Messaging.Message
  langs:
  - csharp
  name: InfiniteTimeout
  nameWithType: Message.InfiniteTimeout
  fullName: System.Messaging.Message.InfiniteTimeout
  type: Field
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Określa, czy limit czasu nie istnieje."
  remarks: "<xref:System.Messaging.Message.TimeToBeReceived%2A>i <xref:System.Messaging.Message.TimeToReachQueue%2A>wymagają wartość, która określa limit czasu.</xref:System.Messaging.Message.TimeToReachQueue%2A></xref:System.Messaging.Message.TimeToBeReceived%2A> Pierwsze, limit czasu jest maksymalny dozwolony czas realizacji wiadomości z kolejki. W przypadku drugiego nagłówka limit czasu jest czas przeznaczony na dotarcia wiadomości do kolejki. W obu przypadkach można określić jako liczbę sekund limitu czasu lub użyj InfiniteTimeout aby wskazać, że limit czasu nie istnieje."
  example:
  - "The following code example demonstrates the use of the InfiniteTimeout field.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public static readonly TimeSpan InfiniteTimeout;
    return:
      type: System.TimeSpan
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.Message.IsFirstInTransaction
  id: IsFirstInTransaction
  parent: System.Messaging.Message
  langs:
  - csharp
  name: IsFirstInTransaction
  nameWithType: Message.IsFirstInTransaction
  fullName: System.Messaging.Message.IsFirstInTransaction
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera wartość wskazującą, czy wiadomość była pierwszą wiadomością wysłaną w transakcji."
  remarks: "Aplikacje odbierające Użyj właściwości IsFirstInTransaction, aby sprawdzić, czy wiadomość była pierwszą wiadomością wysłaną w ramach pojedynczej transakcji do pojedynczej kolejki.       Ta właściwość jest dostępna tylko w przypadku usługi kolejkowania komunikatów w wersji 2.0 lub nowszy.       Aby sprawdzić granice transakcji, można użyć właściwości IsFirstInTransaction wraz z dwóch innych właściwości: <xref:System.Messaging.Message.IsLastInTransaction%2A>i <xref:System.Messaging.Message.TransactionId%2A>.</xref:System.Messaging.Message.TransactionId%2A> </xref:System.Messaging.Message.IsLastInTransaction%2A> Używa pierwszej do sprawdzenia, czy wiadomość była ostatnią wiadomością wysłaną w transakcji i drugie można pobrać identyfikatora transakcji.       Jeśli tylko jeden komunikat jest wysyłany w transakcji, IsFirstInTransaction i <xref:System.Messaging.Message.IsLastInTransaction%2A>Właściwości są ustawione na `true`.</xref:System.Messaging.Message.IsLastInTransaction%2A>"
  example:
  - "The following code example displays the value of a message's IsFirstInTransaction property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool IsFirstInTransaction { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli wiadomość była pierwszą wiadomością wysłaną w transakcji; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.IsFirstInTransaction*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.       - lub - kolejki wiadomości jest filtrowana Ignorowanie właściwości IsFirstInTransaction."
  platform:
  - net462
- uid: System.Messaging.Message.IsLastInTransaction
  id: IsLastInTransaction
  parent: System.Messaging.Message
  langs:
  - csharp
  name: IsLastInTransaction
  nameWithType: Message.IsLastInTransaction
  fullName: System.Messaging.Message.IsLastInTransaction
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera wartość wskazującą, czy wiadomość była ostatnią wiadomością wysłaną w transakcji."
  remarks: "Aplikacje odbierające Użyj właściwości IsLastInTransaction, aby sprawdzić, czy wiadomość była ostatnią wiadomością wysłaną w ramach pojedynczej transakcji do pojedynczej kolejki.       Ta właściwość jest dostępna tylko w przypadku usługi kolejkowania komunikatów w wersji 2.0 lub nowszy.       Aby sprawdzić granice transakcji, można użyć właściwości IsLastInTransaction wraz z dwóch innych właściwości: <xref:System.Messaging.Message.IsFirstInTransaction%2A>i <xref:System.Messaging.Message.TransactionId%2A>.</xref:System.Messaging.Message.TransactionId%2A> </xref:System.Messaging.Message.IsFirstInTransaction%2A> Używa pierwszej do sprawdzenia, czy wiadomość była pierwszą wiadomością wysłaną w transakcji i drugie można pobrać identyfikatora transakcji.       Jeśli tylko jeden komunikat jest wysyłany w transakcji, <xref:System.Messaging.Message.IsFirstInTransaction%2A>i IsLastInTransaction właściwości są ustawione na `true`.</xref:System.Messaging.Message.IsFirstInTransaction%2A>"
  example:
  - "The following code example displays the value of a message's IsLastInTransaction property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool IsLastInTransaction { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli wiadomość była ostatnią wiadomością wysłaną w ramach jednej transakcji; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.IsLastInTransaction*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.       - lub - kolejki wiadomości jest filtrowana Ignorowanie właściwości IsLastInTransaction."
  platform:
  - net462
- uid: System.Messaging.Message.Label
  id: Label
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Label
  nameWithType: Message.Label
  fullName: System.Messaging.Message.Label
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia zdefiniowanym przez aplikację ciągu Unicode, który opisuje wiadomości."
  remarks: "Etykieta wiadomości służy do kilku celów. Na przykład służy ona do wyświetlania lub w celu przetworzenia selektywnie na podstawie wartości etykietę wiadomości. Etykieta nie musi być unikatowa w wiadomości.       Kolejki komunikatów i komunikat etykiety reprezentować zdefiniowanym przez aplikację wartości, które mogą ułatwić identyfikację kolejki lub wiadomości w kategoriach zrozumiałą dla użytkownika. Jest odpowiedzialny za aplikacji interpretować zawartość etykiety, która ma wewnętrznej znaczenia dla usługi kolejkowania komunikatów aplikacji."
  example:
  - "The following code example gets and sets the value of a message's Label property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public string Label { get; set; }
    return:
      type: System.String
      description: "Etykieta wiadomości. Wartość domyślna to ciąg pusty (&quot;&quot;)."
  overload: System.Messaging.Message.Label*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kolejka komunikatów została odfiltrowana do ignorowania właściwości etykiety."
  platform:
  - net462
- uid: System.Messaging.Message.LookupId
  id: LookupId
  parent: System.Messaging.Message
  langs:
  - csharp
  name: LookupId
  nameWithType: Message.LookupId
  fullName: System.Messaging.Message.LookupId
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Wprowadzono w usłudze MSMQ 3.0. Pobiera identyfikator wyszukiwania wiadomości."
  remarks: "Właściwość Lookupld umożliwia dostęp tylko do odczytu do identyfikator wyszukiwania wiadomości. Identyfikator wyszukiwania, wprowadzone w 3.0 usługi MSMQ jest identyfikator 64-bitowym, który jest generowany przez usługę kolejkowania komunikatów i przypisane do każdego komunikatu, gdy wiadomość jest umieszczana w kolejce. Identyfikator wyszukiwania nie jest taki sam jak identyfikator wiadomości generowany, gdy komunikat jest wysyłany.       Usługa kolejkowania komunikatów generuje identyfikator wyszukiwania dla wszystkich wiadomości, które są umieszczane w kolejkach, tym wygenerowane w aplikacji docelowej, Administracja i kolejki raportu, a także generowanych przez system dziennika utraconych wiadomości, łącznik i kolejek wychodzących. Innymi słowy w tym komunikaty o błędach wysyłane przez wysyłanie aplikacje i usługi kolejkowania komunikatów. Identyfikator wyszukiwania jest unikatowy w kolejce i nie ma znaczenia poza kolejki.       Jeśli wiadomość jest wysyłana do kilku kolejek docelowych lub kopia wiadomości jest przechowywana w dzienniku komputera lub kolejki dziennika, każda kopia wiadomości będą mieli identyfikatora wyszukiwania, gdy znajduje się w jej w odpowiedniej kolejce.       Właściwość Lookupld mogą być odczytywane tylko na wiadomości pobierane z kolejki.       Identyfikator wyszukiwania jest używany do odczytu określonego komunikatu w kolejce. Gdy jest znany identyfikator wyszukiwania wiadomości, aplikacja odbierająca może wywołać <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>lub <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A>Funkcja przejść bezpośrednio do tej wiadomości i wgląd lub pobrać ją z kolejki, w odróżnieniu od kursorów, które należy uruchomić z przodu kolejki i przejdź pod koniec kolejki, uzyskiwania identyfikatorów wyszukiwania wiadomości w kolejce jest odpowiedzialny za aplikacji.</xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> </xref:System.Messaging.MessageQueue.PeekByLookupId%2A> Jest możliwe sposobem uzyskania identyfikatorów wyszukiwania można utworzyć wyzwalacza dla kolejki docelowej, która wywołuje składnik, który buforuje identyfikatory każdego komunikatu, ponieważ zostały one umieszczone w kolejce."
  syntax:
    content: public long LookupId { get; }
    return:
      type: System.Int64
      description: "Identyfikator wyszukiwania wiadomości, który został wygenerowany przez MSMQ i jest unikatowa dla kolejki, gdzie znajduje się komunikat."
  overload: System.Messaging.Message.LookupId*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Usługa MSMQ 3.0 nie jest zainstalowany."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.       - lub - kolejki wiadomości jest filtrowana Ignorowanie właściwości Lookupld."
  platform:
  - net462
- uid: System.Messaging.Message.MessageType
  id: MessageType
  parent: System.Messaging.Message
  langs:
  - csharp
  name: MessageType
  nameWithType: Message.MessageType
  fullName: System.Messaging.Message.MessageType
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: 'Gets the message type: <xref uid=&quot;langword_csharp_Normal&quot; name=&quot;Normal&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Acknowledgment&quot; name=&quot;Acknowledgment&quot; href=&quot;&quot;></xref>, or <xref uid=&quot;langword_csharp_Report&quot; name=&quot;Report&quot; href=&quot;&quot;></xref>.'
  remarks: "Usługa kolejkowania komunikatów zwykle ustawia tę właściwość podczas wysyłania wiadomości. Kolejkowania wiadomości nie może być jedną z następujących typów:- `Normal`, który jest typowy wiadomość wysłana z aplikacji do kolejki lub komunikat odpowiedzi zwracany do wysyłania aplikacji.      - `Acknowledgement`, usługi kolejkowania wiadomości generowany zawsze, gdy aplikacja wysyłająca zażądają. Na przykład usługi kolejkowania komunikatów mogą generować komunikaty dodatnie lub ujemne, aby wskazywać, że oryginalnej wiadomości dotarły lub została odczytana. Usługa kolejkowania komunikatów zwraca komunikat potwierdzenia odpowiednie do kolejki administracyjnej określonej przez aplikację wysyłającą.      - `Report`, usługi kolejkowania wiadomości generowany zawsze, gdy nie jest zdefiniowany kolejki raportu źródłowego menedżera kolejek. Gdy śledzenie jest włączone, usługi kolejkowania komunikatów wysyła raport komunikat do kolejki raportu usługi kolejkowania komunikatów za każdym razem oryginalnej wiadomości wprowadza lub pozostawia serwer usługi kolejkowania komunikatów."
  example:
  - "The following code example displays the value of a message's MessageType property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public System.Messaging.MessageType MessageType { get; }
    return:
      type: System.Messaging.MessageType
      description: "Jedna z wartości MessageType."
  overload: System.Messaging.Message.MessageType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.       - lub - kolejki wiadomości jest filtrowana Ignorowanie właściwości MessageType."
  platform:
  - net462
- uid: System.Messaging.Message.Priority
  id: Priority
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Priority
  nameWithType: Message.Priority
  fullName: System.Messaging.Message.Priority
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia priorytet wiadomości, która określa, gdzie w kolejce wiadomość jest umieszczana."
  remarks: "Właściwość priorytetu ma wpływ na sposób usługi kolejkowania komunikatów obsługi wiadomości, zarówno jest on drodze i po dotarciu serwerów do miejsca docelowego. Komunikaty o wyższym priorytecie są preferowane podczas routingu i dodaje do przodu kolejki docelowej. Wiadomości o takim samym priorytecie są umieszczane w kolejce zgodnie z ich Godzina nadejścia.       Można ustawić priorytet znaczący tylko dla wiadomości nietransakcyjnej. Usługa MSMQ automatycznie ustawia priorytet wiadomości transakcyjne do `Lowest`, co powoduje, że priorytet wiadomości transakcyjnych mają być ignorowane."
  example:
  - "The following code example sends two messages of different priorities to the queue, and retrieves them subsequently.  \n  \n [!code-cpp[Message.DefaultPropertiesToSend#1](~/add/codesnippet/cpp/p-system.messaging.messa_87_1.cpp)]\n [!code-vb[Message.DefaultPropertiesToSend#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_87_1.vb)]\n [!code-cs[Message.DefaultPropertiesToSend#1](~/add/codesnippet/csharp/p-system.messaging.messa_87_1.cs)]"
  syntax:
    content: public System.Messaging.MessagePriority Priority { get; set; }
    return:
      type: System.Messaging.MessagePriority
      description: "Jeden z <xref href=&quot;System.Messaging.MessagePriority&quot;> </xref> wartości, które reprezentują poziomy priorytetu wiadomości nietransakcyjnej. Wartość domyślna to <xref uid=&quot;langword_csharp_Normal&quot; name=&quot;Normal&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.Priority*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kolejka komunikatów została odfiltrowana do ignorowania właściwość priorytetu."
  platform:
  - net462
- uid: System.Messaging.Message.Recoverable
  id: Recoverable
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Recoverable
  nameWithType: Message.Recoverable
  fullName: System.Messaging.Message.Recoverable
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia wartość wskazującą, czy wiadomość jest gwarantowana dostarczanych w przypadku problemu awarii lub sieci komputera."
  remarks: "Możliwe do odzyskania właściwość wskazuje, czy jest gwarantowane dostarczanie komunikatów, nawet jeśli komputer ulegnie awarii, gdy wiadomość jest na drodze do kolejki docelowej.       Jeśli jest gwarantowane dostarczanie komunikatów, wiadomości są przechowywane lokalnie na każdym etapie wzdłuż trasy, aż pomyślnie przekazano komunikat do następnego komputera. Ustawienie właściwości możliwych do odzyskania `true` mogą wpłynąć na wydajność.       Jeśli komunikat jest transakcyjna, automatycznie usługi kolejkowania komunikatów traktuje komunikatu jako możliwe do odzyskania, niezależnie od wartości właściwości możliwych do odzyskania."
  example:
  - "The following code example gets and sets the value of a message's Recoverable property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool Recoverable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli dostarczania wiadomości jest gwarantowana (za pośrednictwem zapisywania wiadomości na dysku podczas dostarczania); <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> , jeśli nie jest zapewnione dostarczania. Wartość domyślna to <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.Recoverable*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kolejka komunikatów została odfiltrowana do Ignoruj właściwości możliwych do odzyskania."
  platform:
  - net462
- uid: System.Messaging.Message.ResponseQueue
  id: ResponseQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: ResponseQueue
  nameWithType: Message.ResponseQueue
  fullName: System.Messaging.Message.ResponseQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia kolejkę, która odbiera wiadomości odpowiedzi generowane przez aplikację."
  remarks: "Właściwość ResponseQueue identyfikuje kolejkę, która odbiera wiadomości odpowiedzi generowane przez aplikacje, które aplikacja zwraca do aplikacji wysyłania. Aplikacja wysyłająca określa kolejki odpowiedzi, gdy aplikacja wysyła swoje wiadomości. Wszystkie dostępne kolejki można określić jako kolejkę odpowiedzi.       Komunikaty zwracane kolejki odpowiedzi są specyficzne dla aplikacji. Aplikacja musi definiować zawartość wiadomości, a także akcję do wykonania po otrzymaniu komunikatu."
  example:
  - "The following code example gets and sets the value of a message's ResponseQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public System.Messaging.MessageQueue ResponseQueue { get; set; }
    return:
      type: System.Messaging.MessageQueue
      description: "<xref href=&quot;System.Messaging.MessageQueue&quot;> </xref> Na które odpowiedzi generowane przez aplikacje są zwracane wiadomości. Wartość domyślna to <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.ResponseQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kolejka komunikatów została odfiltrowana do ignorowania właściwości ResponseQueue."
  platform:
  - net462
- uid: System.Messaging.Message.SecurityContext
  id: SecurityContext
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SecurityContext
  nameWithType: Message.SecurityContext
  fullName: System.Messaging.Message.SecurityContext
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia kontekst zabezpieczeń dla wiadomości."
  syntax:
    content: public System.Messaging.SecurityContext SecurityContext { get; set; }
    return:
      type: System.Messaging.SecurityContext
      description: "A <xref href=&quot;System.Messaging.SecurityContext&quot;> </xref> obiekt, który zawiera kontekstu zabezpieczeń wiadomości, jeśli wcześniej została ustawiona właściwość; w przeciwnym razie wartość NULL."
  overload: System.Messaging.Message.SecurityContext*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.Message.SenderCertificate
  id: SenderCertificate
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SenderCertificate
  nameWithType: Message.SenderCertificate
  fullName: System.Messaging.Message.SenderCertificate
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia certyfikat zabezpieczeń używany do uwierzytelniania wiadomości."
  remarks: "Aplikacja używa właściwości SenderCertificate, gdy komunikat zawiera certyfikat zabezpieczeń zewnętrznych.       Usługa kolejkowania komunikatów może uwierzytelniać wiadomości przy użyciu certyfikatu zabezpieczeń wewnętrznych lub zewnętrznych. Usługa kolejkowania komunikatów zapewnia certyfikaty wewnętrzne, które są używane w celu sprawdzenia integralności komunikatu. Urząd certyfikacji zawiera certyfikatu zewnętrznego, które jest dostępne za pośrednictwem właściwości SenderCertificate wiadomości. Oprócz umożliwienia usługi kolejkowania komunikatów do uwierzytelniania wiadomości, certyfikat zewnętrzny umożliwia aplikacji odbierającej dodatkową weryfikację nadawcy. Wewnętrzny certyfikat nie ma używać wartości do aplikacji odbierającej.       Certyfikat zewnętrzny musi zarejestrować w usłudze usługa katalogowa usługi kolejkowania komunikatów systemu. Certyfikat zewnętrzny zawiera informacje dotyczące urzędu certyfikacji, certyfikat użytkownika, okres ważności certyfikatu, klucza publicznego certyfikatu użytkownika i podpisu urzędu certyfikacji."
  syntax:
    content: public byte[] SenderCertificate { get; set; }
    return:
      type: System.Byte[]
      description: "Tablica wartości bajtów reprezentujący certyfikatu zabezpieczeń, którego używa Usługa Kolejkowanie komunikatów, aby sprawdzić nadawcy wiadomości. Wartość domyślna jest tablicą o zerowej długości."
  overload: System.Messaging.Message.SenderCertificate*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kolejka komunikatów została odfiltrowana do ignorowania właściwości SenderCertificate."
  platform:
  - net462
- uid: System.Messaging.Message.SenderId
  id: SenderId
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SenderId
  nameWithType: Message.SenderId
  fullName: System.Messaging.Message.SenderId
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera identyfikator użytkownika, wysyłania."
  remarks: "Jeśli <xref:System.Messaging.Message.AttachSenderId%2A>jest właściwość `false`, określony we właściwości SenderId identyfikator nadawcy nie jest dołączony do wiadomości przed przesłaniem.</xref:System.Messaging.Message.AttachSenderId%2A> Wskazuje usługi kolejkowania komunikatów że nadawca nie powinny być weryfikowane podczas wysyłania wiadomości do kolejki docelowej. Jeśli <xref:System.Messaging.Message.AttachSenderId%2A>jest właściwość `true`, wartość właściwości SenderId jest godne zaufania tylko wtedy, gdy wiadomość została uwierzytelniona.</xref:System.Messaging.Message.AttachSenderId%2A> Użyj <xref:System.Messaging.Message.Authenticated%2A>właściwość w połączeniu z właściwością SenderId, aby sprawdzić prawa dostępu przez nadawcę.</xref:System.Messaging.Message.Authenticated%2A>       Aplikacja łącznika jest aplikacji korzystającej z serwera łącznika w celu zapewnienia komunikacji między usługi kolejkowania komunikatów i innymi systemami kolejkowania. Usługa kolejkowania komunikatów wymaga łącznik aplikacje dostarczające identyfikator nadawcy. Należy ustawić <xref:System.Messaging.Message.ConnectorType%2A>właściwości podczas wysyłania wiadomości za pomocą łącznika aplikacji.</xref:System.Messaging.Message.ConnectorType%2A>"
  syntax:
    content: public byte[] SenderId { get; }
    return:
      type: System.Byte[]
      description: "Tablica wartości bajtu identyfikuje nadawcę. Odbierającego menedżera kolejek używa identyfikatora podczas uwierzytelniania wiadomości zweryfikować nadawcy wiadomości i nadawcy prawa dostępu do kolejki."
  overload: System.Messaging.Message.SenderId*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.       - lub - kolejki wiadomości jest filtrowana Ignorowanie właściwości SenderId."
  platform:
  - net462
- uid: System.Messaging.Message.SenderVersion
  id: SenderVersion
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SenderVersion
  nameWithType: Message.SenderVersion
  fullName: System.Messaging.Message.SenderVersion
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera wersję usługi kolejkowania komunikatów używany do wysyłania wiadomości."
  remarks: "Właściwość SenderVersion jest ważne w przypadku niektórych funkcji. Na przykład przetwarzanie transakcji jest obsługiwana tylko przez komunikatów usługi kolejkowania wiadomości 2.0 lub nowszy i podpisy cyfrowe są używane do uwierzytelniania wiadomości wysyłanych przez usługi MSMQ 1.0.       Wysyłanie menedżera kolejek ustawia właściwość SenderVersion, gdy komunikat jest wysyłany."
  example:
  - "The following code example displays the value of a message's SenderVersion property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public long SenderVersion { get; }
    return:
      type: System.Int64
      description: "Wersja usługi kolejkowania komunikatów używany do wysyłania wiadomości."
  overload: System.Messaging.Message.SenderVersion*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.       - lub - kolejki wiadomości jest filtrowana Ignorowanie właściwości SenderVersion."
  platform:
  - net462
- uid: System.Messaging.Message.SentTime
  id: SentTime
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SentTime
  nameWithType: Message.SentTime
  fullName: System.Messaging.Message.SentTime
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera datę i godzinę wysłania wiadomości przez źródłowego menedżera kolejek komputera wysyłającego."
  remarks: "Właściwość parametr SentTime zostanie przesunięty na czas lokalny komputera, na którym znajduje się ten wystąpienia <xref:System.Messaging.Message>klasy został utworzony.</xref:System.Messaging.Message> Ta strefa czasowa może różnić się od wartości kolejek źródłowym i docelowym."
  example:
  - "The following code example displays the value of a message's SentTime property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public DateTime SentTime { get; }
    return:
      type: System.DateTime
      description: "A <xref:System.DateTime>reprezentujący godzinę wysłania wiadomości.</xref:System.DateTime>"
  overload: System.Messaging.Message.SentTime*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.       - lub - kolejki wiadomości jest filtrowana ignoruje parametr SentTime właściwości."
  platform:
  - net462
- uid: System.Messaging.Message.SourceMachine
  id: SourceMachine
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SourceMachine
  nameWithType: Message.SourceMachine
  fullName: System.Messaging.Message.SourceMachine
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera komputera, z którego wiadomość pochodzi."
  remarks: "Format właściwości SourceMachine nie zawiera poprzedzające dwa ukośniki (\\\\\\\\). Na przykład `myServer` jest prawidłowy SourceMachine."
  example:
  - "The following code example displays the value of a message's SourceMachine property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public string SourceMachine { get; }
    return:
      type: System.String
      description: "Nazwa komputera, z którego wiadomość została wysłana."
  overload: System.Messaging.Message.SourceMachine*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.       - lub - kolejki wiadomości jest filtrowana Ignorowanie właściwości SourceMachine."
  - type: System.Messaging.MessageQueueException
    commentId: T:System.Messaging.MessageQueueException
    description: "Nie można uzyskać dostępu do usługi informacji lub katalogu komputera."
  platform:
  - net462
- uid: System.Messaging.Message.TimeToBeReceived
  id: TimeToBeReceived
  parent: System.Messaging.Message
  langs:
  - csharp
  name: TimeToBeReceived
  nameWithType: Message.TimeToBeReceived
  fullName: System.Messaging.Message.TimeToBeReceived
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia maksymalną ilość czasu wiadomości z kolejki docelowej."
  remarks: "Właściwość TimeToBeReceived określa całkowity czas wiadomość z kolejki docelowej. Limit czasu obejmuje czas pobierania do kolejki docelowej, a czas oczekiwania w kolejce, zanim odebrać wiadomości.      > [!CAUTION] > Podczas korzystania z zależnych komputerów klienckich, należy w zegarze na komputerze klienckim jest zsynchronizowany z zegarem na serwerze jest uruchomiona usługa kolejkowania komunikatów. W przeciwnym razie może spowodować nieprzewidywalne zachowanie, podczas wysyłania wiadomości, których właściwość TimeToBeReceived nie jest <xref:System.Messaging.Message.InfiniteTimeout>.</xref:System.Messaging.Message.InfiniteTimeout>       Jeśli interwał określony we właściwości TimeToBeReceived wygasa przed usunięciem wiadomości z kolejki, usługi kolejkowania komunikatów odrzuca wiadomości w jeden z dwóch sposobów. Jeśli komunikat <xref:System.Messaging.Message.UseDeadLetterQueue%2A>właściwość jest `true`, komunikat jest wysyłany do kolejki utraconych wiadomości.</xref:System.Messaging.Message.UseDeadLetterQueue%2A> Jeśli <xref:System.Messaging.Message.UseDeadLetterQueue%2A>jest `false`, komunikat zostanie zignorowany.</xref:System.Messaging.Message.UseDeadLetterQueue%2A>       Można ustawić komunikatu <xref:System.Messaging.Message.AcknowledgeType%2A>żądania, że usługa kolejkowania komunikatów wysłać wiadomość negatywnego potwierdzenia dla właściwości z powrotem do aplikacja wysyłająca Jeśli wiadomość nie została pobrana przed wygaśnięciem czasomierza.</xref:System.Messaging.Message.AcknowledgeType%2A>       Jeśli wartość określoną przez właściwość TimeToBeReceived jest mniejsza niż wartość określoną przez <xref:System.Messaging.Message.TimeToReachQueue%2A>Właściwości, pierwszeństwo ma TimeToBeReceived.</xref:System.Messaging.Message.TimeToReachQueue%2A>       Gdy komunikaty są wysyłane w ramach jednej transakcji, usługi kolejkowania komunikatów używa właściwości TimeToBeReceived pierwszego komunikatu."
  example:
  - "The following code example gets and sets the value of a message's TimeToBeReceived property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public TimeSpan TimeToBeReceived { get; set; }
    return:
      type: System.TimeSpan
      description: "Łączny czas wiadomość z kolejki docelowej. Wartość domyślna to <xref href=&quot;System.Messaging.Message.InfiniteTimeout&quot;> </xref>."
  overload: System.Messaging.Message.TimeToBeReceived*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kolejka komunikatów została odfiltrowana do ignorowania właściwości TimeToBeReceived."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Wartość określona dla TimeToBeReceived jest nieprawidłowy."
  platform:
  - net462
- uid: System.Messaging.Message.TimeToReachQueue
  id: TimeToReachQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: TimeToReachQueue
  nameWithType: Message.TimeToReachQueue
  fullName: System.Messaging.Message.TimeToReachQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia maksymalną ilość czasu dotarcia wiadomości do kolejki."
  remarks: "Jeśli interwał określony we właściwości TimeToReachQueue wygasa przed komunikat dociera do miejsca docelowego, usługi kolejkowania komunikatów odrzuca wiadomości w jeden z dwóch sposobów. Jeśli komunikat <xref:System.Messaging.Message.UseDeadLetterQueue%2A>właściwość jest `true`, komunikat jest wysyłany do kolejki utraconych wiadomości.</xref:System.Messaging.Message.UseDeadLetterQueue%2A> Jeśli <xref:System.Messaging.Message.UseDeadLetterQueue%2A>jest `false`, komunikat zostanie zignorowany można ustawić komunikat he <xref:System.Messaging.Message.AcknowledgeType%2A>żądania, że usługa kolejkowania komunikatów wysłać wiadomość negatywnego potwierdzenia dla właściwości z powrotem do aplikacji wysyłającej Jeśli komunikat został odebrany przed wygaśnięciem.</xref:System.Messaging.Message.AcknowledgeType%2A> </xref:System.Messaging.Message.UseDeadLetterQueue%2A>       Jeśli właściwość TimeToReachQueue jest ustawiona na 0 sekund, usługi kolejkowania komunikatów próbuje raz do wysłania tej wiadomości do miejsca docelowego, jeśli kolejka oczekuje na komunikat. Jeśli kolejka jest lokalny, wiadomości zawsze osiągnie on.       Jeśli wartość określoną przez właściwość TimeToReachQueue jest większa niż wartość określoną przez <xref:System.Messaging.Message.TimeToBeReceived%2A>Właściwość <xref:System.Messaging.Message.TimeToBeReceived%2A>ma pierwszeństwo przed.</xref:System.Messaging.Message.TimeToBeReceived%2A> </xref:System.Messaging.Message.TimeToBeReceived%2A>       Gdy komunikaty są wysyłane w ramach jednej transakcji, usługi kolejkowania komunikatów używa właściwości TimeToReachQueue pierwszego komunikatu."
  example:
  - "The following code example gets and sets the value of a message's TimeToReachQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public TimeSpan TimeToReachQueue { get; set; }
    return:
      type: System.TimeSpan
      description: "Limit czasu dotarcia wiadomości do kolejki docelowej, rozpoczynający się od czasu wiadomość zostanie wysłana. Wartość domyślna to <xref href=&quot;System.Messaging.Message.InfiniteTimeout&quot;> </xref>."
  overload: System.Messaging.Message.TimeToReachQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kolejka komunikatów została odfiltrowana do ignorowania właściwości TimeToReachQueue."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Wartość określona dla TimeToReachQueue jest nieprawidłowy. Ten element reprezentuje może być liczbą ujemną."
  platform:
  - net462
- uid: System.Messaging.Message.TransactionId
  id: TransactionId
  parent: System.Messaging.Message
  langs:
  - csharp
  name: TransactionId
  nameWithType: Message.TransactionId
  fullName: System.Messaging.Message.TransactionId
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera identyfikator transakcji, których wiadomość została części."
  remarks: "Aplikacje odbierające Użyj właściwości identyfikator transakcji, aby sprawdzić, czy wiadomość została wysłana jako część określonej transakcji. Identyfikator transakcji zawiera identyfikator komputera wysyłającego (pierwszych 16 bitów) z numerem sekwencji 4-bajtowych transakcji.       Ta właściwość jest dostępna tylko w przypadku usługi kolejkowania komunikatów w wersji 2.0 lub nowszy.       Identyfikatory transakcji nie ma gwarancji być unikatowa, ponieważ numerów sekwencyjnych transakcji nie są trwałe i ich przerwanie 2 <sup>20</sup>. Usługa kolejkowania komunikatów gwarantuje tylko, że kolejnych transakcji numerów sekwencyjnych innej transakcji.       Można użyć właściwości identyfikator transakcji wraz z <xref:System.Messaging.Message.IsFirstInTransaction%2A>i <xref:System.Messaging.Message.IsLastInTransaction%2A>Właściwości, aby sprawdzić granice transakcji.</xref:System.Messaging.Message.IsLastInTransaction%2A> </xref:System.Messaging.Message.IsFirstInTransaction%2A>"
  example:
  - "The following code example displays the value of a message's TransactionId property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public string TransactionId { get; }
    return:
      type: System.String
      description: "Identyfikator transakcji skojarzonych z wiadomością."
  overload: System.Messaging.Message.TransactionId*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.       - lub - kolejki wiadomości jest filtrowana Ignorowanie właściwości identyfikator transakcji."
  platform:
  - net462
- uid: System.Messaging.Message.TransactionStatusQueue
  id: TransactionStatusQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: TransactionStatusQueue
  nameWithType: Message.TransactionStatusQueue
  fullName: System.Messaging.Message.TransactionStatusQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera kolejkę stanu transakcji na komputerze źródłowym."
  remarks: "Właściwość TransactionStatusQueue identyfikuje transakcyjne kolejki na komputer źródłowy, który odbiera potwierdzenia potwierdzeń przeczytania z aplikacji łącznika. Usługa kolejkowania komunikatów ustawia właściwość i aplikacje łącznika, użyj właściwości podczas pobierania wiadomości transakcyjnych wysłanych do kolejki obcego.       Obcy kolejka istnieje w systemie kolejkowania innego niż usługi kolejkowania wiadomości firmy Microsoft. Usługa kolejkowania komunikatów komunikuje się z takich kolejek za pomocą łącznika aplikacji.       Aplikacja łącznika można użyć kolejkę stanu transakcji do wysyłania wiadomości potwierdzającej do wysyłania aplikacji. Nawet wtedy, gdy aplikacja wysyłająca żądanie nie innych potwierdzenia kolejkę stanu transakcji powinien zostać wyświetlony te potwierdzenia."
  example:
  - "The following code example displays the value of a message's TransactionStatusQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public System.Messaging.MessageQueue TransactionStatusQueue { get; set; }
    return:
      type: System.Messaging.MessageQueue
      description: "Kolejkę stanu transakcji na komputerze źródłowym, który służy do wysyłania komunikatów potwierdzenia do aplikację wysyłającą. Wartość domyślna to <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.TransactionStatusQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.       - lub - kolejki wiadomości jest filtrowana Ignorowanie właściwości TransactionStatusQueue."
  platform:
  - net462
- uid: System.Messaging.Message.UseAuthentication
  id: UseAuthentication
  parent: System.Messaging.Message
  langs:
  - csharp
  name: UseAuthentication
  nameWithType: Message.UseAuthentication
  fullName: System.Messaging.Message.UseAuthentication
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia wartość wskazującą, czy wiadomość została (lub musi być) uwierzytelnionego przed wysyłane."
  remarks: "Właściwość UseAuthentication Określa, czy wiadomość wymaga uwierzytelniania. Jeśli aplikacja wysyłająca żąda uwierzytelniania, usługi kolejkowania komunikatów tworzy podpis cyfrowy i używa go do podpisania wiadomości, podczas wysyłania i uwierzytelniania wiadomości po odebraniu.       Jeśli jest UseAuthentication `false` i jest wysyłany komunikat do kolejki, która akceptuje tylko wiadomości uwierzytelnione, komunikat zostanie odrzucony, po osiągnięciu kolejki.       Nie można ustalić, czy wiadomość niepowodzenie uwierzytelniania analizując jego właściwości. Usługa kolejkowania komunikatów spowoduje odrzucenie tych wiadomości przed wysłaniem ich do kolejki. Można jednak żądanie wysłane wiadomości potwierdzającej Jeśli awarii dostarczania uniemożliwia wiadomości w kolejce."
  syntax:
    content: public bool UseAuthentication { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli aplikacja wysyłająca żądanie uwierzytelniania dla message; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.UseAuthentication*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kolejka komunikatów została odfiltrowana do ignorowania właściwości UseAuthentication."
  platform:
  - net462
- uid: System.Messaging.Message.UseDeadLetterQueue
  id: UseDeadLetterQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: UseDeadLetterQueue
  nameWithType: Message.UseDeadLetterQueue
  fullName: System.Messaging.Message.UseDeadLetterQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia wartość wskazującą, czy kopia wiadomości, którego nie można dostarczyć mają być wysyłane do kolejki utraconych wiadomości."
  remarks: "<xref:System.Messaging.Message.UseJournalQueue%2A>i właściwości UseDeadLetterQueue określają, jak kolejkowania wiadomości śledzi.</xref:System.Messaging.Message.UseJournalQueue%2A> Jeśli jest UseDeadLetterQueue `true`, dostarczania awarii (nietransakcyjnej komunikat), powoduje, że komunikat do wysłania do nietransakcyjnej kolejki utraconych wiadomości na komputerze, który nie może dostarczyć komunikatu. Błąd dostarczania może być spowodowana przez czasomierz komunikat wygasa, np.       W przypadku niepowodzenia dostarczania dla wiadomości transakcyjnych usługi kolejkowania komunikatów wysyła wiadomość do transakcyjnej kolejki utraconych wiadomości na komputerze źródłowym, we wszystkich przypadkach ujemna i wątpliwych.       Gdy wiadomości są przechowywane w kolejce wiadomości utraconych, należy wyczyścić kolejki, aby usunąć wiadomości, które nie są już potrzebne. Przechowywane w liczbę przydział rozmiaru dla komputera, na którym znajduje się kolejka utraconych wiadomości. Przydział komputera jest ustawiany przez administratora i odwołuje się do rozmiar przydzielony do przechowywania wiadomości na całego komputera, a nie tylko w pojedynczej kolejki.       Nie należy tworzyć dziennika lub kolejki utraconych wiadomości. Są to zarówno kolejki systemowe, generowane przez usługę kolejkowania komunikatów."
  example:
  - "The following code example gets and sets the value of a message's UseDeadLetterQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool UseDeadLetterQueue { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli kopia wiadomości wysyłanych do kolejki utraconych wiadomości; powinno spowodować niepowodzenie dostarczanie komunikatów w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Wartość domyślna to <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.UseDeadLetterQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kolejka komunikatów została odfiltrowana do ignorowania właściwości UseDeadLetterQueue."
  platform:
  - net462
- uid: System.Messaging.Message.UseEncryption
  id: UseEncryption
  parent: System.Messaging.Message
  langs:
  - csharp
  name: UseEncryption
  nameWithType: Message.UseEncryption
  fullName: System.Messaging.Message.UseEncryption
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia wartość wskazującą, czy wiadomości prywatnej."
  remarks: "Jeśli komunikat jest prywatny, przed wysyłanych i odszyfrować po odebraniu jego treść jest szyfrowane. Aby wysłać wiadomość prywatne, aplikacja wysyłająca musi określić, że szyfrowanie można użyć i, opcjonalnie, algorytm szyfrowania.       Podczas wysyłania wiadomości prywatne, aplikacja nie trzeba wykonywać szyfrowania wiadomości. Usługa kolejkowania komunikatów można zaszyfrować treść komunikatu dla Ciebie, jeśli aplikacja jest wysyłanie wiadomości w obrębie przedsiębiorstwa systemu Microsoft Windows 2000, który ma dostęp do usługi katalogowej. Podczas odbierania wiadomości, odbierającego menedżera kolejek zawsze Odszyfrowuje treść komunikatu."
  example:
  - "The following code example gets and sets the value of a message's UseEncryption property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool UseEncryption { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby wymagać usługi kolejkowania komunikatów do szyfrowania wiadomości; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Wartość domyślna to <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.UseEncryption*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kolejka komunikatów została odfiltrowana do ignorowania właściwości UseEncryption."
  platform:
  - net462
- uid: System.Messaging.Message.UseJournalQueue
  id: UseJournalQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: UseJournalQueue
  nameWithType: Message.UseJournalQueue
  fullName: System.Messaging.Message.UseJournalQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia wartość wskazującą, czy kopia wiadomości powinna być przechowywana w dzienniku komputera na komputerze źródłowym."
  remarks: "UseJournalQueue i <xref:System.Messaging.Message.UseDeadLetterQueue%2A>Właściwości określają sposób kolejkowania wiadomości śledzi.</xref:System.Messaging.Message.UseDeadLetterQueue%2A> Jeśli jest UseJournalQueue `true`, a następnie kopia jest przechowywana w dzienniku komputera, z którego pochodzi wiadomość w każdym kroku wiadomości przesyłane.       Wysłany komunikat jest kopiowany do kolejki dziennika tylko, jeśli kolejka docelowa znajduje się na komputerze zdalnym. Jeśli elementem docelowym jest na komputerze lokalnym, komunikat jest wysyłany bezpośrednio do kolejki; Brak pośrednich sposobów wymagają rejestrowania.       Gdy wiadomości są przechowywane w kolejce dziennika, należy wyczyścić kolejki, aby usunąć wiadomości, które nie są już potrzebne. Wiadomości przechowywanych w liczby kolejek dziennika względem limitu przydziału dla komputera, na którym znajduje się kolejka. (Przydział komputera jest ustawiany przez administratora).       Nie należy tworzyć dziennika lub kolejki utraconych wiadomości. Są to zarówno kolejki systemowe, generowane przez usługę kolejkowania komunikatów."
  example:
  - "The following code example gets and sets the value of a message's UseJournalQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool UseJournalQueue { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>wymaganie zachowane kopia wiadomości w dzienniku komputera źródłowego komputera po wiadomości została pomyślnie przesłana (z komputera źródłowego do następnego serwera); w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Wartość domyślna to <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.UseJournalQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kolejka komunikatów została odfiltrowana do ignorowania właściwości UseJournalQueue."
  platform:
  - net462
- uid: System.Messaging.Message.UseTracing
  id: UseTracing
  parent: System.Messaging.Message
  langs:
  - csharp
  name: UseTracing
  nameWithType: Message.UseTracing
  fullName: System.Messaging.Message.UseTracing
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera lub ustawia wartość wskazującą, czy śledzenie wiadomości przesyłane do swojej kolejki docelowej."
  remarks: "Właściwość UseTracing Określa, czy śledzenie trasy wiadomości przesyłane do swojej kolejki docelowej. Jeśli `true`, raportu (generowane przez usługę kolejkowania wiadomości) jest wysyłany komunikat do kolejki raportu zawsze wiadomości przechodzi przez serwer routingu usługi kolejkowania komunikatów. Kolejka raportu jest określana przez źródłowego menedżera kolejek. Kolejki raportu nie są ograniczone do raportu komunikaty generowane przez usługę kolejkowania komunikatów; wiadomości generowany przez aplikację mogą być również wysyłane do kolejki raportu.       Korzystanie z funkcji śledzenia obejmuje skonfigurowanie usługi Active Directory i określenie kolejki raportu dla przedsiębiorstw usługi kolejkowania komunikatów. Administrator konfiguruje te ustawienia."
  example:
  - "The following code example gets and sets the value of a message's UseTracing property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool UseTracing { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli każdego kroku pośredniego wprowadzone przez trasie oryginalnej wiadomości do kolejki docelowej generuje raport do wysłania do kolejki raportu systemu; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Wartość domyślna to <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.UseTracing*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Kolejka komunikatów została odfiltrowana do ignorowania właściwości UseTracing."
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.Messaging.MessageQueueException
  parent: System.Messaging
  isExternal: false
  name: MessageQueueException
  nameWithType: MessageQueueException
  fullName: System.Messaging.MessageQueueException
- uid: System.Messaging.Message.#ctor
  parent: System.Messaging.Message
  isExternal: false
  name: Message()
  nameWithType: Message.Message()
  fullName: System.Messaging.Message.Message()
- uid: System.Messaging.Message.#ctor(System.Object)
  parent: System.Messaging.Message
  isExternal: false
  name: Message(Object)
  nameWithType: Message.Message(Object)
  fullName: System.Messaging.Message.Message(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)
  parent: System.Messaging.Message
  isExternal: false
  name: Message(Object,IMessageFormatter)
  nameWithType: Message.Message(Object,IMessageFormatter)
  fullName: System.Messaging.Message.Message(Object,IMessageFormatter)
- uid: System.Messaging.IMessageFormatter
  parent: System.Messaging
  isExternal: false
  name: IMessageFormatter
  nameWithType: IMessageFormatter
  fullName: System.Messaging.IMessageFormatter
- uid: System.Messaging.Message.AcknowledgeType
  parent: System.Messaging.Message
  isExternal: false
  name: AcknowledgeType
  nameWithType: Message.AcknowledgeType
  fullName: System.Messaging.Message.AcknowledgeType
- uid: System.Messaging.AcknowledgeTypes
  parent: System.Messaging
  isExternal: false
  name: AcknowledgeTypes
  nameWithType: AcknowledgeTypes
  fullName: System.Messaging.AcknowledgeTypes
- uid: System.Messaging.Message.Acknowledgment
  parent: System.Messaging.Message
  isExternal: false
  name: Acknowledgment
  nameWithType: Message.Acknowledgment
  fullName: System.Messaging.Message.Acknowledgment
- uid: System.Messaging.Acknowledgment
  parent: System.Messaging
  isExternal: false
  name: Acknowledgment
  nameWithType: Acknowledgment
  fullName: System.Messaging.Acknowledgment
- uid: System.Messaging.Message.AdministrationQueue
  parent: System.Messaging.Message
  isExternal: false
  name: AdministrationQueue
  nameWithType: Message.AdministrationQueue
  fullName: System.Messaging.Message.AdministrationQueue
- uid: System.Messaging.MessageQueue
  parent: System.Messaging
  isExternal: false
  name: MessageQueue
  nameWithType: MessageQueue
  fullName: System.Messaging.MessageQueue
- uid: System.Messaging.Message.AppSpecific
  parent: System.Messaging.Message
  isExternal: false
  name: AppSpecific
  nameWithType: Message.AppSpecific
  fullName: System.Messaging.Message.AppSpecific
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Messaging.Message.ArrivedTime
  parent: System.Messaging.Message
  isExternal: false
  name: ArrivedTime
  nameWithType: Message.ArrivedTime
  fullName: System.Messaging.Message.ArrivedTime
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: System.Messaging.Message.AttachSenderId
  parent: System.Messaging.Message
  isExternal: false
  name: AttachSenderId
  nameWithType: Message.AttachSenderId
  fullName: System.Messaging.Message.AttachSenderId
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Messaging.Message.Authenticated
  parent: System.Messaging.Message
  isExternal: false
  name: Authenticated
  nameWithType: Message.Authenticated
  fullName: System.Messaging.Message.Authenticated
- uid: System.Messaging.Message.AuthenticationProviderName
  parent: System.Messaging.Message
  isExternal: false
  name: AuthenticationProviderName
  nameWithType: Message.AuthenticationProviderName
  fullName: System.Messaging.Message.AuthenticationProviderName
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Messaging.Message.AuthenticationProviderType
  parent: System.Messaging.Message
  isExternal: false
  name: AuthenticationProviderType
  nameWithType: Message.AuthenticationProviderType
  fullName: System.Messaging.Message.AuthenticationProviderType
- uid: System.Messaging.CryptographicProviderType
  parent: System.Messaging
  isExternal: false
  name: CryptographicProviderType
  nameWithType: CryptographicProviderType
  fullName: System.Messaging.CryptographicProviderType
- uid: System.Messaging.Message.Body
  parent: System.Messaging.Message
  isExternal: false
  name: Body
  nameWithType: Message.Body
  fullName: System.Messaging.Message.Body
- uid: System.Messaging.Message.BodyStream
  parent: System.Messaging.Message
  isExternal: false
  name: BodyStream
  nameWithType: Message.BodyStream
  fullName: System.Messaging.Message.BodyStream
- uid: System.IO.Stream
  parent: System.IO
  isExternal: true
  name: Stream
  nameWithType: Stream
  fullName: System.IO.Stream
- uid: System.Messaging.Message.BodyType
  parent: System.Messaging.Message
  isExternal: false
  name: BodyType
  nameWithType: Message.BodyType
  fullName: System.Messaging.Message.BodyType
- uid: System.Messaging.Message.ConnectorType
  parent: System.Messaging.Message
  isExternal: false
  name: ConnectorType
  nameWithType: Message.ConnectorType
  fullName: System.Messaging.Message.ConnectorType
- uid: System.Guid
  parent: System
  isExternal: true
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.Messaging.Message.CorrelationId
  parent: System.Messaging.Message
  isExternal: false
  name: CorrelationId
  nameWithType: Message.CorrelationId
  fullName: System.Messaging.Message.CorrelationId
- uid: System.Messaging.Message.DestinationQueue
  parent: System.Messaging.Message
  isExternal: false
  name: DestinationQueue
  nameWithType: Message.DestinationQueue
  fullName: System.Messaging.Message.DestinationQueue
- uid: System.Messaging.Message.DestinationSymmetricKey
  parent: System.Messaging.Message
  isExternal: false
  name: DestinationSymmetricKey
  nameWithType: Message.DestinationSymmetricKey
  fullName: System.Messaging.Message.DestinationSymmetricKey
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Messaging.Message.DigitalSignature
  parent: System.Messaging.Message
  isExternal: false
  name: DigitalSignature
  nameWithType: Message.DigitalSignature
  fullName: System.Messaging.Message.DigitalSignature
- uid: System.Messaging.Message.EncryptionAlgorithm
  parent: System.Messaging.Message
  isExternal: false
  name: EncryptionAlgorithm
  nameWithType: Message.EncryptionAlgorithm
  fullName: System.Messaging.Message.EncryptionAlgorithm
- uid: System.Messaging.EncryptionAlgorithm
  parent: System.Messaging
  isExternal: false
  name: EncryptionAlgorithm
  nameWithType: EncryptionAlgorithm
  fullName: System.Messaging.EncryptionAlgorithm
- uid: System.Messaging.Message.Extension
  parent: System.Messaging.Message
  isExternal: false
  name: Extension
  nameWithType: Message.Extension
  fullName: System.Messaging.Message.Extension
- uid: System.Messaging.Message.Formatter
  parent: System.Messaging.Message
  isExternal: false
  name: Formatter
  nameWithType: Message.Formatter
  fullName: System.Messaging.Message.Formatter
- uid: System.Messaging.Message.HashAlgorithm
  parent: System.Messaging.Message
  isExternal: false
  name: HashAlgorithm
  nameWithType: Message.HashAlgorithm
  fullName: System.Messaging.Message.HashAlgorithm
- uid: System.Messaging.HashAlgorithm
  parent: System.Messaging
  isExternal: false
  name: HashAlgorithm
  nameWithType: HashAlgorithm
  fullName: System.Messaging.HashAlgorithm
- uid: System.Messaging.Message.Id
  parent: System.Messaging.Message
  isExternal: false
  name: Id
  nameWithType: Message.Id
  fullName: System.Messaging.Message.Id
- uid: System.Messaging.Message.InfiniteTimeout
  parent: System.Messaging.Message
  isExternal: false
  name: InfiniteTimeout
  nameWithType: Message.InfiniteTimeout
  fullName: System.Messaging.Message.InfiniteTimeout
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Messaging.Message.IsFirstInTransaction
  parent: System.Messaging.Message
  isExternal: false
  name: IsFirstInTransaction
  nameWithType: Message.IsFirstInTransaction
  fullName: System.Messaging.Message.IsFirstInTransaction
- uid: System.Messaging.Message.IsLastInTransaction
  parent: System.Messaging.Message
  isExternal: false
  name: IsLastInTransaction
  nameWithType: Message.IsLastInTransaction
  fullName: System.Messaging.Message.IsLastInTransaction
- uid: System.Messaging.Message.Label
  parent: System.Messaging.Message
  isExternal: false
  name: Label
  nameWithType: Message.Label
  fullName: System.Messaging.Message.Label
- uid: System.Messaging.Message.LookupId
  parent: System.Messaging.Message
  isExternal: false
  name: LookupId
  nameWithType: Message.LookupId
  fullName: System.Messaging.Message.LookupId
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Messaging.Message.MessageType
  parent: System.Messaging.Message
  isExternal: false
  name: MessageType
  nameWithType: Message.MessageType
  fullName: System.Messaging.Message.MessageType
- uid: System.Messaging.MessageType
  parent: System.Messaging
  isExternal: false
  name: MessageType
  nameWithType: MessageType
  fullName: System.Messaging.MessageType
- uid: System.Messaging.Message.Priority
  parent: System.Messaging.Message
  isExternal: false
  name: Priority
  nameWithType: Message.Priority
  fullName: System.Messaging.Message.Priority
- uid: System.Messaging.MessagePriority
  parent: System.Messaging
  isExternal: false
  name: MessagePriority
  nameWithType: MessagePriority
  fullName: System.Messaging.MessagePriority
- uid: System.Messaging.Message.Recoverable
  parent: System.Messaging.Message
  isExternal: false
  name: Recoverable
  nameWithType: Message.Recoverable
  fullName: System.Messaging.Message.Recoverable
- uid: System.Messaging.Message.ResponseQueue
  parent: System.Messaging.Message
  isExternal: false
  name: ResponseQueue
  nameWithType: Message.ResponseQueue
  fullName: System.Messaging.Message.ResponseQueue
- uid: System.Messaging.Message.SecurityContext
  parent: System.Messaging.Message
  isExternal: false
  name: SecurityContext
  nameWithType: Message.SecurityContext
  fullName: System.Messaging.Message.SecurityContext
- uid: System.Messaging.SecurityContext
  parent: System.Messaging
  isExternal: false
  name: SecurityContext
  nameWithType: SecurityContext
  fullName: System.Messaging.SecurityContext
- uid: System.Messaging.Message.SenderCertificate
  parent: System.Messaging.Message
  isExternal: false
  name: SenderCertificate
  nameWithType: Message.SenderCertificate
  fullName: System.Messaging.Message.SenderCertificate
- uid: System.Messaging.Message.SenderId
  parent: System.Messaging.Message
  isExternal: false
  name: SenderId
  nameWithType: Message.SenderId
  fullName: System.Messaging.Message.SenderId
- uid: System.Messaging.Message.SenderVersion
  parent: System.Messaging.Message
  isExternal: false
  name: SenderVersion
  nameWithType: Message.SenderVersion
  fullName: System.Messaging.Message.SenderVersion
- uid: System.Messaging.Message.SentTime
  parent: System.Messaging.Message
  isExternal: false
  name: SentTime
  nameWithType: Message.SentTime
  fullName: System.Messaging.Message.SentTime
- uid: System.Messaging.Message.SourceMachine
  parent: System.Messaging.Message
  isExternal: false
  name: SourceMachine
  nameWithType: Message.SourceMachine
  fullName: System.Messaging.Message.SourceMachine
- uid: System.Messaging.Message.TimeToBeReceived
  parent: System.Messaging.Message
  isExternal: false
  name: TimeToBeReceived
  nameWithType: Message.TimeToBeReceived
  fullName: System.Messaging.Message.TimeToBeReceived
- uid: System.Messaging.Message.TimeToReachQueue
  parent: System.Messaging.Message
  isExternal: false
  name: TimeToReachQueue
  nameWithType: Message.TimeToReachQueue
  fullName: System.Messaging.Message.TimeToReachQueue
- uid: System.Messaging.Message.TransactionId
  parent: System.Messaging.Message
  isExternal: false
  name: TransactionId
  nameWithType: Message.TransactionId
  fullName: System.Messaging.Message.TransactionId
- uid: System.Messaging.Message.TransactionStatusQueue
  parent: System.Messaging.Message
  isExternal: false
  name: TransactionStatusQueue
  nameWithType: Message.TransactionStatusQueue
  fullName: System.Messaging.Message.TransactionStatusQueue
- uid: System.Messaging.Message.UseAuthentication
  parent: System.Messaging.Message
  isExternal: false
  name: UseAuthentication
  nameWithType: Message.UseAuthentication
  fullName: System.Messaging.Message.UseAuthentication
- uid: System.Messaging.Message.UseDeadLetterQueue
  parent: System.Messaging.Message
  isExternal: false
  name: UseDeadLetterQueue
  nameWithType: Message.UseDeadLetterQueue
  fullName: System.Messaging.Message.UseDeadLetterQueue
- uid: System.Messaging.Message.UseEncryption
  parent: System.Messaging.Message
  isExternal: false
  name: UseEncryption
  nameWithType: Message.UseEncryption
  fullName: System.Messaging.Message.UseEncryption
- uid: System.Messaging.Message.UseJournalQueue
  parent: System.Messaging.Message
  isExternal: false
  name: UseJournalQueue
  nameWithType: Message.UseJournalQueue
  fullName: System.Messaging.Message.UseJournalQueue
- uid: System.Messaging.Message.UseTracing
  parent: System.Messaging.Message
  isExternal: false
  name: UseTracing
  nameWithType: Message.UseTracing
  fullName: System.Messaging.Message.UseTracing
- uid: System.Messaging.Message.#ctor*
  parent: System.Messaging.Message
  isExternal: false
  name: Message
  nameWithType: Message.Message
- uid: System.Messaging.Message.AcknowledgeType*
  parent: System.Messaging.Message
  isExternal: false
  name: AcknowledgeType
  nameWithType: Message.AcknowledgeType
- uid: System.Messaging.Message.Acknowledgment*
  parent: System.Messaging.Message
  isExternal: false
  name: Acknowledgment
  nameWithType: Message.Acknowledgment
- uid: System.Messaging.Message.AdministrationQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: AdministrationQueue
  nameWithType: Message.AdministrationQueue
- uid: System.Messaging.Message.AppSpecific*
  parent: System.Messaging.Message
  isExternal: false
  name: AppSpecific
  nameWithType: Message.AppSpecific
- uid: System.Messaging.Message.ArrivedTime*
  parent: System.Messaging.Message
  isExternal: false
  name: ArrivedTime
  nameWithType: Message.ArrivedTime
- uid: System.Messaging.Message.AttachSenderId*
  parent: System.Messaging.Message
  isExternal: false
  name: AttachSenderId
  nameWithType: Message.AttachSenderId
- uid: System.Messaging.Message.Authenticated*
  parent: System.Messaging.Message
  isExternal: false
  name: Authenticated
  nameWithType: Message.Authenticated
- uid: System.Messaging.Message.AuthenticationProviderName*
  parent: System.Messaging.Message
  isExternal: false
  name: AuthenticationProviderName
  nameWithType: Message.AuthenticationProviderName
- uid: System.Messaging.Message.AuthenticationProviderType*
  parent: System.Messaging.Message
  isExternal: false
  name: AuthenticationProviderType
  nameWithType: Message.AuthenticationProviderType
- uid: System.Messaging.Message.Body*
  parent: System.Messaging.Message
  isExternal: false
  name: Body
  nameWithType: Message.Body
- uid: System.Messaging.Message.BodyStream*
  parent: System.Messaging.Message
  isExternal: false
  name: BodyStream
  nameWithType: Message.BodyStream
- uid: System.Messaging.Message.BodyType*
  parent: System.Messaging.Message
  isExternal: false
  name: BodyType
  nameWithType: Message.BodyType
- uid: System.Messaging.Message.ConnectorType*
  parent: System.Messaging.Message
  isExternal: false
  name: ConnectorType
  nameWithType: Message.ConnectorType
- uid: System.Messaging.Message.CorrelationId*
  parent: System.Messaging.Message
  isExternal: false
  name: CorrelationId
  nameWithType: Message.CorrelationId
- uid: System.Messaging.Message.DestinationQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: DestinationQueue
  nameWithType: Message.DestinationQueue
- uid: System.Messaging.Message.DestinationSymmetricKey*
  parent: System.Messaging.Message
  isExternal: false
  name: DestinationSymmetricKey
  nameWithType: Message.DestinationSymmetricKey
- uid: System.Messaging.Message.DigitalSignature*
  parent: System.Messaging.Message
  isExternal: false
  name: DigitalSignature
  nameWithType: Message.DigitalSignature
- uid: System.Messaging.Message.EncryptionAlgorithm*
  parent: System.Messaging.Message
  isExternal: false
  name: EncryptionAlgorithm
  nameWithType: Message.EncryptionAlgorithm
- uid: System.Messaging.Message.Extension*
  parent: System.Messaging.Message
  isExternal: false
  name: Extension
  nameWithType: Message.Extension
- uid: System.Messaging.Message.Formatter*
  parent: System.Messaging.Message
  isExternal: false
  name: Formatter
  nameWithType: Message.Formatter
- uid: System.Messaging.Message.HashAlgorithm*
  parent: System.Messaging.Message
  isExternal: false
  name: HashAlgorithm
  nameWithType: Message.HashAlgorithm
- uid: System.Messaging.Message.Id*
  parent: System.Messaging.Message
  isExternal: false
  name: Id
  nameWithType: Message.Id
- uid: System.Messaging.Message.IsFirstInTransaction*
  parent: System.Messaging.Message
  isExternal: false
  name: IsFirstInTransaction
  nameWithType: Message.IsFirstInTransaction
- uid: System.Messaging.Message.IsLastInTransaction*
  parent: System.Messaging.Message
  isExternal: false
  name: IsLastInTransaction
  nameWithType: Message.IsLastInTransaction
- uid: System.Messaging.Message.Label*
  parent: System.Messaging.Message
  isExternal: false
  name: Label
  nameWithType: Message.Label
- uid: System.Messaging.Message.LookupId*
  parent: System.Messaging.Message
  isExternal: false
  name: LookupId
  nameWithType: Message.LookupId
- uid: System.Messaging.Message.MessageType*
  parent: System.Messaging.Message
  isExternal: false
  name: MessageType
  nameWithType: Message.MessageType
- uid: System.Messaging.Message.Priority*
  parent: System.Messaging.Message
  isExternal: false
  name: Priority
  nameWithType: Message.Priority
- uid: System.Messaging.Message.Recoverable*
  parent: System.Messaging.Message
  isExternal: false
  name: Recoverable
  nameWithType: Message.Recoverable
- uid: System.Messaging.Message.ResponseQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: ResponseQueue
  nameWithType: Message.ResponseQueue
- uid: System.Messaging.Message.SecurityContext*
  parent: System.Messaging.Message
  isExternal: false
  name: SecurityContext
  nameWithType: Message.SecurityContext
- uid: System.Messaging.Message.SenderCertificate*
  parent: System.Messaging.Message
  isExternal: false
  name: SenderCertificate
  nameWithType: Message.SenderCertificate
- uid: System.Messaging.Message.SenderId*
  parent: System.Messaging.Message
  isExternal: false
  name: SenderId
  nameWithType: Message.SenderId
- uid: System.Messaging.Message.SenderVersion*
  parent: System.Messaging.Message
  isExternal: false
  name: SenderVersion
  nameWithType: Message.SenderVersion
- uid: System.Messaging.Message.SentTime*
  parent: System.Messaging.Message
  isExternal: false
  name: SentTime
  nameWithType: Message.SentTime
- uid: System.Messaging.Message.SourceMachine*
  parent: System.Messaging.Message
  isExternal: false
  name: SourceMachine
  nameWithType: Message.SourceMachine
- uid: System.Messaging.Message.TimeToBeReceived*
  parent: System.Messaging.Message
  isExternal: false
  name: TimeToBeReceived
  nameWithType: Message.TimeToBeReceived
- uid: System.Messaging.Message.TimeToReachQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: TimeToReachQueue
  nameWithType: Message.TimeToReachQueue
- uid: System.Messaging.Message.TransactionId*
  parent: System.Messaging.Message
  isExternal: false
  name: TransactionId
  nameWithType: Message.TransactionId
- uid: System.Messaging.Message.TransactionStatusQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: TransactionStatusQueue
  nameWithType: Message.TransactionStatusQueue
- uid: System.Messaging.Message.UseAuthentication*
  parent: System.Messaging.Message
  isExternal: false
  name: UseAuthentication
  nameWithType: Message.UseAuthentication
- uid: System.Messaging.Message.UseDeadLetterQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: UseDeadLetterQueue
  nameWithType: Message.UseDeadLetterQueue
- uid: System.Messaging.Message.UseEncryption*
  parent: System.Messaging.Message
  isExternal: false
  name: UseEncryption
  nameWithType: Message.UseEncryption
- uid: System.Messaging.Message.UseJournalQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: UseJournalQueue
  nameWithType: Message.UseJournalQueue
- uid: System.Messaging.Message.UseTracing*
  parent: System.Messaging.Message
  isExternal: false
  name: UseTracing
  nameWithType: Message.UseTracing
