### YamlMime:ManagedReference
items:
- uid: System.IO.BufferedStream
  id: BufferedStream
  children:
  - System.IO.BufferedStream.#ctor(System.IO.Stream)
  - System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)
  - System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.BufferedStream.CanRead
  - System.IO.BufferedStream.CanSeek
  - System.IO.BufferedStream.CanWrite
  - System.IO.BufferedStream.Dispose(System.Boolean)
  - System.IO.BufferedStream.EndRead(System.IAsyncResult)
  - System.IO.BufferedStream.EndWrite(System.IAsyncResult)
  - System.IO.BufferedStream.Flush
  - System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)
  - System.IO.BufferedStream.Length
  - System.IO.BufferedStream.Position
  - System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.BufferedStream.ReadByte
  - System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.IO.BufferedStream.SetLength(System.Int64)
  - System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.BufferedStream.WriteByte(System.Byte)
  langs:
  - csharp
  name: BufferedStream
  nameWithType: BufferedStream
  fullName: System.IO.BufferedStream
  type: Class
  summary: "Dodaje buforowania warstwy do odczytu i zapisu dla innego strumienia. Ta klasa nie może być dziedziczona."
  remarks: "A buffer is a block of bytes in memory used to cache data, thereby reducing the number of calls to the operating system. Buffers improve read and write performance. A buffer can be used for either reading or writing, but never both simultaneously. The [Read(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True) and [Write(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True) methods of `BufferedStream` automatically maintain the buffer.  \n  \n> [!IMPORTANT]\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n `BufferedStream` can be composed around certain types of streams. It provides implementations for reading and writing bytes to an underlying data source or repository. Use <xref:System.IO.BinaryReader> and <xref:System.IO.BinaryWriter> for reading and writing other data types. `BufferedStream` is designed to prevent the buffer from slowing down input and output when the buffer is not needed. If you always read and write for sizes greater than the internal buffer size, then `BufferedStream` might not even allocate the internal buffer. `BufferedStream` also buffers reads and writes in a shared buffer. It is assumed that you will almost always be doing a series of reads or writes, but rarely alternate between the two of them."
  example:
  - "The following code examples show how to use the `BufferedStream` class over the `NetworkStream` class to increase the performance of certain I/O operations. Start the server on a remote computer before starting the client. Specify the remote computer name as a command-line argument when starting the client. Vary the `dataArraySize` and `streamBufferSize` constants to view their effect on performance.  \n  \n The first example shows the code that runs on the client, and the second example shows the code that runs on the server.  \n  \n **Example 1: Code that runs on the client**  \n  \n [!code-cs[System.IO.BufferedStream1#1](~/add/codesnippet/csharp/t-system.io.bufferedstream_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#1](~/add/codesnippet/cpp/t-system.io.bufferedstream_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#1](~/add/codesnippet/visualbasic/t-system.io.bufferedstream_1.vb)]  \n  \n **Example 2: Code that runs on the server**  \n  \n [!code-vb[System.IO.BufferedStream2#1](~/add/codesnippet/visualbasic/t-system.io.bufferedstream_2.vb)]\n [!code-cs[System.IO.BufferedStream2#1](~/add/codesnippet/csharp/t-system.io.bufferedstream_2.cs)]\n [!code-cpp[System.IO.BufferedStream2#1](~/add/codesnippet/cpp/t-system.io.bufferedstream_2.cpp)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class BufferedStream : System.IO.Stream
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream)
  id: '#ctor(System.IO.Stream)'
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BufferedStream(Stream)
  nameWithType: BufferedStream.BufferedStream(Stream)
  fullName: System.IO.BufferedStream.BufferedStream(Stream)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.BufferedStream&quot;> </xref> klasy z domyślny rozmiar buforu 4096 bajtów."
  remarks: "Bufor odczytu/zapisu udostępnionego jest przydzielany przy pierwszym `BufferedStream` obiekt został zainicjowany przy użyciu tego konstruktora. Udostępniony bufor nie jest używany, jeśli wszystkie odczyty i zapisy są większe niż lub równe `bufferSize`."
  syntax:
    content: public BufferedStream (System.IO.Stream stream);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "Bieżący strumień."
  overload: System.IO.BufferedStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>stream</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)
  id: '#ctor(System.IO.Stream,System.Int32)'
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BufferedStream(Stream,Int32)
  nameWithType: BufferedStream.BufferedStream(Stream,Int32)
  fullName: System.IO.BufferedStream.BufferedStream(Stream,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.BufferedStream&quot;> </xref> klasy z określony rozmiar buforu."
  remarks: "Bufor odczytu/zapisu udostępnionego jest przydzielany przy pierwszym `BufferedStream` obiekt został zainicjowany przy użyciu tego konstruktora. Udostępniony bufor nie jest używany, jeśli wszystkie odczyty i zapisy są większe niż lub równe `bufferSize`."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#2](~/add/codesnippet/csharp/m-system.io.bufferedstre_2_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#2](~/add/codesnippet/cpp/m-system.io.bufferedstre_2_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#2](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_2_1.vb)]"
  syntax:
    content: public BufferedStream (System.IO.Stream stream, int bufferSize);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "Bieżący strumień."
    - id: bufferSize
      type: System.Int32
      description: "Rozmiar buforu w bajtach."
  overload: System.IO.BufferedStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>stream</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>jest ujemna."
  platform:
  - net462
- uid: System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Rozpoczyna operację asynchroniczną odczytu. (Rozważ użycie <xref:System.IO.BufferedStream.ReadAsync*>zamiast; sekcji uwag.)</xref:System.IO.BufferedStream.ReadAsync*>"
  remarks: "W programie .NET Framework 4 i wcześniejszych wersjach, należy użyć metody takie jak <xref:System.IO.Stream.BeginRead%2A>i <xref:System.IO.Stream.EndRead%2A>do wykonania operacji na plikach asynchronicznego.</xref:System.IO.Stream.EndRead%2A> </xref:System.IO.Stream.BeginRead%2A> Te metody są nadal dostępne w [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] do obsługi starszego kodu; jednak nowych metod asynchronicznych, takich jak <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, i <xref:System.IO.BufferedStream.FlushAsync%2A>, łatwiej implementuje operacji asynchronicznych pliku pomocy.</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       <xref:System.IO.BufferedStream.EndWrite%2A>musi zostać wywołana tylko raz dla każdego wywołania BeginRead.</xref:System.IO.BufferedStream.EndWrite%2A> Nie można zakończyć proces odczytu przed rozpoczęciem innego odczytu może spowodować niepożądane zachowanie, takie jak zakleszczenia.      > [!NOTE] > Użyj <xref:System.IO.BufferedStream.CanRead%2A>Właściwości w celu określenia, czy bieżące wystąpienie obsługuje odczytu.</xref:System.IO.BufferedStream.CanRead%2A>       <xref:System.IO.BufferedStream.EndRead%2A>musi zostać wywołany z tym <xref:System.IAsyncResult>Aby dowiedzieć się, odczytano liczbę bajtów.</xref:System.IAsyncResult></xref:System.IO.BufferedStream.EndRead%2A>"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Bufor do wczytania danych."
    - id: offset
      type: System.Int32
      description: "Przesunięcie bajtów w `buffer` jaką rozpocząć pisanie dane odczytane ze strumienia."
    - id: count
      type: System.Int32
      description: "Maksymalna liczba bajtów do odczytania."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu odczytu."
    - id: state
      type: System.Object
      description: "Obiekt dostarczane przez użytkownika, która odróżnia to asynchroniczne żądanie odczytu z innych żądań."
    return:
      type: System.IAsyncResult
      description: "Obiekt, który reprezentuje asynchroniczny odczyt, który może być oczekujące."
  overload: System.IO.BufferedStream.BeginRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>lub <code>count</code> jest ujemna."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nastąpiła próba asynchroniczny odczyt poza końcem strumienia."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Długość buforu pomniejszona o <code> offset </code> jest mniejsza niż <code> count </code>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Bieżący strumień nie obsługuje operacji odczytu."
  platform:
  - net462
- uid: System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Rozpoczyna operację asynchronicznego zapisu. (Rozważ użycie <xref:System.IO.BufferedStream.WriteAsync*>zamiast; sekcji uwag.)</xref:System.IO.BufferedStream.WriteAsync*>"
  remarks: "W programie .NET Framework 4 i wcześniejszych wersjach, należy użyć metody takie jak <xref:System.IO.Stream.BeginWrite%2A>i <xref:System.IO.Stream.EndWrite%2A>do wykonania operacji na plikach asynchronicznego.</xref:System.IO.Stream.EndWrite%2A> </xref:System.IO.Stream.BeginWrite%2A> Te metody są nadal dostępne w [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] do obsługi starszego kodu; jednak nowych metod asynchronicznych, takich jak <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, i <xref:System.IO.BufferedStream.FlushAsync%2A>, łatwiej implementuje operacji asynchronicznych pliku pomocy.</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       <xref:System.IO.BufferedStream.EndWrite%2A>musi zostać wywołana tylko raz w każdym <xref:System.IAsyncResult>z BeginWrite.</xref:System.IAsyncResult></xref:System.IO.BufferedStream.EndWrite%2A> <xref:System.IO.BufferedStream.EndWrite%2A>blokuje dopiero po ukończeniu operacji We/Wy.</xref:System.IO.BufferedStream.EndWrite%2A>"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Bufor zawierający dane do zapisania bieżącego strumienia."
    - id: offset
      type: System.Int32
      description: "Zerze przesunięcie w `buffer` jaką należy zacząć kopiowanie bajtów do bieżącego strumienia."
    - id: count
      type: System.Int32
      description: "Maksymalna liczba bajtów do zapisania."
    - id: callback
      type: System.AsyncCallback
      description: "Metoda wywoływana po zakończeniu operacji zapis asynchroniczny."
    - id: state
      type: System.Object
      description: "Obiekt dostarczane przez użytkownika, która odróżnia to żądanie określonego zapis asynchroniczny od innych żądań."
    return:
      type: System.IAsyncResult
      description: "Obiekt, który odwołuje się do asynchronicznego zapisu, która może być oczekujące."
  overload: System.IO.BufferedStream.BeginWrite*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>buffer</code>Długość minus <code>offset</code> jest mniejsza niż <code>count</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>lub <code>count</code> jest ujemna."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Strumień nie obsługuje zapisywania."
  platform:
  - net462
- uid: System.IO.BufferedStream.CanRead
  id: CanRead
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: CanRead
  nameWithType: BufferedStream.CanRead
  fullName: System.IO.BufferedStream.CanRead
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Pobiera wartość wskazującą, czy bieżący strumień obsługuje odczytu."
  remarks: "Jeśli klasą pochodną <xref:System.IO.Stream>nie obsługuje operacji odczytu, wywołań <xref:System.IO.BufferedStream.Read%2A>, <xref:System.IO.BufferedStream.ReadByte%2A>, <xref:System.IO.Stream.BeginRead%2A>, <xref:System.IO.Stream.EndRead%2A>i `Peek` metody <xref:System.IO.StreamReader>, <xref:System.IO.StringReader>i <xref:System.IO.TextReader>zgłosić <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.TextReader> </xref:System.IO.StringReader> </xref:System.IO.StreamReader> </xref:System.IO.Stream.EndRead%2A> </xref:System.IO.Stream.BeginRead%2A> </xref:System.IO.BufferedStream.ReadByte%2A> </xref:System.IO.BufferedStream.Read%2A> </xref:System.IO.Stream>       Jeśli strumień jest zamknięty, ta właściwość zwraca `false`."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#5](~/add/codesnippet/csharp/p-system.io.bufferedstre_2_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#5](~/add/codesnippet/cpp/p-system.io.bufferedstre_2_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#5](~/add/codesnippet/visualbasic/p-system.io.bufferedstre_2_1.vb)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli strumień nie udostępnia możliwości czytania; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> strumień jest zamknięty lub została otwarta z dostępem tylko do zapisu."
  overload: System.IO.BufferedStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.CanSeek
  id: CanSeek
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: BufferedStream.CanSeek
  fullName: System.IO.BufferedStream.CanSeek
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Pobiera wartość wskazującą, czy bieżący strumień obsługuje operacji wyszukiwania."
  remarks: "Jeśli klasą pochodną <xref:System.IO.Stream>nie obsługuje wyszukiwania, wywołań <xref:System.IO.BufferedStream.Length%2A>, <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Position%2A>i <xref:System.IO.BufferedStream.Seek%2A>zgłosić <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.BufferedStream.Seek%2A> </xref:System.IO.BufferedStream.Position%2A> </xref:System.IO.BufferedStream.SetLength%2A> </xref:System.IO.BufferedStream.Length%2A> </xref:System.IO.Stream>       Jeśli strumień jest zamknięty, ta właściwość zwraca `false`."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#3](~/add/codesnippet/csharp/p-system.io.bufferedstre_0_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#3](~/add/codesnippet/cpp/p-system.io.bufferedstre_0_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#3](~/add/codesnippet/visualbasic/p-system.io.bufferedstre_0_1.vb)]"
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>w przypadku strumienia obsługuje operacji wyszukiwania; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> czy strumień jest zamknięty, czy strumień został skonstruowany na podstawie dojścia systemu operacyjnego, takich jak potoku lub dane wyjściowe do konsoli."
  overload: System.IO.BufferedStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.CanWrite
  id: CanWrite
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: BufferedStream.CanWrite
  fullName: System.IO.BufferedStream.CanWrite
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Pobiera wartość wskazującą, czy bieżący strumień obsługuje zapisu."
  remarks: "Jeśli klasą pochodną <xref:System.IO.Stream>nie obsługuje zapisywania wywołanie <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Write%2A>, lub <xref:System.IO.BufferedStream.WriteByte%2A>zgłasza <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.BufferedStream.WriteByte%2A> </xref:System.IO.BufferedStream.Write%2A> </xref:System.IO.BufferedStream.SetLength%2A> </xref:System.IO.Stream>       Jeśli strumień jest zamknięty, ta właściwość zwraca `false`."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#4](~/add/codesnippet/csharp/p-system.io.bufferedstre_1_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#4](~/add/codesnippet/cpp/p-system.io.bufferedstre_1_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#4](~/add/codesnippet/visualbasic/p-system.io.bufferedstre_1_1.vb)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli strumienia obsługuje zapis; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> strumień jest zamknięty lub została otwarta z dostępem tylko do odczytu."
  overload: System.IO.BufferedStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: BufferedStream.Dispose(Boolean)
  fullName: System.IO.BufferedStream.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "Do dodania."
  overload: System.IO.BufferedStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: BufferedStream.EndRead(IAsyncResult)
  fullName: System.IO.BufferedStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Czeka na ukończenie oczekujących operacji odczytu asynchronicznego. (Rozważ użycie <xref:System.IO.BufferedStream.ReadAsync*>zamiast; sekcji uwag.)</xref:System.IO.BufferedStream.ReadAsync*>"
  remarks: "W programie .NET Framework 4 i wcześniejszych wersjach, należy użyć metody takie jak <xref:System.IO.Stream.BeginRead%2A>i <xref:System.IO.Stream.EndRead%2A>do wykonania operacji na plikach asynchronicznego.</xref:System.IO.Stream.EndRead%2A> </xref:System.IO.Stream.BeginRead%2A> Te metody są nadal dostępne w [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] do obsługi starszego kodu; jednak nowych metod asynchronicznych, takich jak <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, i <xref:System.IO.BufferedStream.FlushAsync%2A>, łatwiej implementuje operacji asynchronicznych pliku pomocy.</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       Funkcję EndRead musi zostać wywołany z tym <xref:System.IAsyncResult>Aby dowiedzieć się, odczytano liczbę bajtów.</xref:System.IAsyncResult>"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "Odwołanie do oczekujące żądania asynchronicznego oczekiwania."
    return:
      type: System.Int32
      description: "Liczba odczytanych bajtów ze strumienia, z zakresu od 0 (zero) oraz liczbę bajtów, żądana. Strumienie zwracać tylko 0 tylko na końcu strumienia, w przeciwnym razie należy zablokować, dopóki nie będzie dostępne co najmniej 1 bajt."
  overload: System.IO.BufferedStream.EndRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Ten <xref:System.IAsyncResult>obiekt nie został utworzony przez wywołanie metody <xref:System.IO.BufferedStream.BeginRead*>w tej klasie.</xref:System.IO.BufferedStream.BeginRead*> </xref:System.IAsyncResult>"
  platform:
  - net462
- uid: System.IO.BufferedStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: BufferedStream.EndWrite(IAsyncResult)
  fullName: System.IO.BufferedStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Kończy operację asynchronicznego zapisu i bloków, aż do zakończenia operacji We/Wy. (Rozważ użycie <xref:System.IO.BufferedStream.WriteAsync*>zamiast; sekcji uwag.)</xref:System.IO.BufferedStream.WriteAsync*>"
  remarks: "W programie .NET Framework 4 i wcześniejszych wersjach, należy użyć metody takie jak <xref:System.IO.Stream.BeginWrite%2A>i <xref:System.IO.Stream.EndWrite%2A>do wykonania operacji na plikach asynchronicznego.</xref:System.IO.Stream.EndWrite%2A> </xref:System.IO.Stream.BeginWrite%2A> Te metody są nadal dostępne w [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] do obsługi starszego kodu; jednak nowych metod asynchronicznych, takich jak <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, i <xref:System.IO.BufferedStream.FlushAsync%2A>, łatwiej implementuje operacji asynchronicznych pliku pomocy.</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       Metoda EndWrite musi zostać wywołana tylko raz dla każdego wywołania <xref:System.IO.BufferedStream.BeginRead%2A>.</xref:System.IO.BufferedStream.BeginRead%2A> Nie można zakończyć proces odczytu przed rozpoczęciem inna operacja odczytu może spowodować zakleszczenie lub inne niepożądane zachowanie."
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "Oczekujące żądania asynchronicznego."
  overload: System.IO.BufferedStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Ten <xref:System.IAsyncResult>obiekt nie został utworzony przez wywołanie metody <xref:System.IO.BufferedStream.BeginWrite*>w tej klasie.</xref:System.IO.BufferedStream.BeginWrite*> </xref:System.IAsyncResult>"
  platform:
  - net462
- uid: System.IO.BufferedStream.Flush
  id: Flush
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Flush()
  nameWithType: BufferedStream.Flush()
  fullName: System.IO.BufferedStream.Flush()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Czyści wszystkie bufory dla tego strumienia i powoduje, że wszystkie buforowane dane są zapisywane w podstawowej urządzenia."
  remarks: "Opróżnianie strumienia nie opróżnić jego podstawowym kodera, chyba że jawnie wywołać `Flush` lub <xref:System.IO.Stream.Close%2A>.</xref:System.IO.Stream.Close%2A>       Jeśli używasz <xref:System.IO.BufferedStream.%23ctor%2A>konstruktora, w związku z tym określania rozmiaru buforu podczas tworzenia `BufferedStream` obiektów i zawartości jest opróżniany, gdy osiągnie rozmiar buforu.</xref:System.IO.BufferedStream.%23ctor%2A> Na przykład kodu takich jak `BufferedStream bs = new BufferedStream(bs, 5)` opróżnić zawartość, gdy rozmiar buforu osiągnie 5 bajtów.       Wszystkie metody odczytu i zapisu z `BufferedStream` automatycznie Obsługa buforu, więc nie trzeba wywołać `Flush` podczas przełączania do i z powrotem między Odczyt i zapis."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#6](~/add/codesnippet/csharp/m-system.io.bufferedstre_0_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#6](~/add/codesnippet/cpp/m-system.io.bufferedstre_0_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#6](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_0_1.vb)]"
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.IO.BufferedStream.Flush*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Strumień został usunięty."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Źródło danych lub repozytorium nie jest otwarty."
  platform:
  - net462
- uid: System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: BufferedStream.FlushAsync(CancellationToken)
  fullName: System.IO.BufferedStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Asynchronicznie usuwa wszystkie bufory dla tego strumienia, powoduje, że wszystkie buforowane dane są zapisywane w podstawowej urządzenia i monitoruje żądania anulowania."
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Token do monitorowania żądań anulowania."
    return:
      type: System.Threading.Tasks.Task
      description: "Zadanie reprezentujące asynchroniczną operację opróżniania."
  overload: System.IO.BufferedStream.FlushAsync*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Strumień został usunięty."
  platform:
  - net462
- uid: System.IO.BufferedStream.Length
  id: Length
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Length
  nameWithType: BufferedStream.Length
  fullName: System.IO.BufferedStream.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Pobiera długość strumienia w bajtach."
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "Długość strumienia w bajtach."
  overload: System.IO.BufferedStream.Length*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Strumień podstawowy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> lub zamknięty."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Strumień nie obsługuje wyszukiwania."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metody wywołane po strumień został zamknięty."
  platform:
  - net462
- uid: System.IO.BufferedStream.Position
  id: Position
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Position
  nameWithType: BufferedStream.Position
  fullName: System.IO.BufferedStream.Position
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Pobiera położenie w obrębie bieżącego strumienia."
  remarks: "`get` Wywołuje metodę dostępu <xref:System.IO.BufferedStream.Seek%2A>uzyskać bieżącą pozycję w strumieniu podstawowym, a następnie można dostosować tę wartość, zgodnie z bieżącą pozycję w buforze.</xref:System.IO.BufferedStream.Seek%2A>       `set` Akcesor kopiuje wszystkie dane zapisane wcześniej w buforze do źródłowego strumienia, a następnie wywołuje <xref:System.IO.BufferedStream.Seek%2A>.</xref:System.IO.BufferedStream.Seek%2A>       Wyszukiwanie w dowolne miejsce powyżej długość strumienia jest obsługiwana."
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "Położenie w obrębie bieżącego strumienia."
  overload: System.IO.BufferedStream.Position*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Wartość przekazana do <xref:System.IO.BufferedStream.Seek*>jest ujemna.</xref:System.IO.BufferedStream.Seek*>"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Występuje błąd We/Wy, takich jak strumień jest zamknięty."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Strumień nie obsługuje wyszukiwania."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metody wywołane po strumień został zamknięty."
  platform:
  - net462
- uid: System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Kopie bajtów z bieżącym buforowanego strumienia do tablicy."
  remarks: "`Read` Metoda zwraca wartość 0 tylko wtedy, gdy zostanie osiągnięty koniec strumienia. We wszystkich innych przypadkach `Read` ma zawsze wartość co najmniej jednego bajtu ze strumienia przed zwróceniem. Zgodnie z definicją, jeśli dane są niedostępne ze strumienia po wywołaniu `Read`, `Read` metoda zwraca wartość 0 (Osiągnięto koniec strumienia jest automatycznie). Implementacja jest bezpłatna do zwrócenia mniej bajtów niż żądana, nawet jeżeli nie osiągnięto koniec strumienia.       Użyj <xref:System.IO.BinaryReader>do odczytywania danych pierwotnych typów.</xref:System.IO.BinaryReader>"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#7](~/add/codesnippet/csharp/m-system.io.bufferedstre_3_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#7](~/add/codesnippet/cpp/m-system.io.bufferedstre_3_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#7](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_3_1.vb)]"
  syntax:
    content: public override int Read (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "Bufor, do którego mają zostać skopiowane bajtów."
    - id: offset
      type: System.Int32
      description: "Przesunięcie bajtów w buforze, od którego ma zostać rozpoczęte odczytywanie bajtów."
    - id: count
      type: System.Int32
      description: "Liczba bajtów do odczytania."
    return:
      type: System.Int32
      description: "Całkowita liczba bajtów odczytanych na <code> array </code>. Może to być mniejsza niż żądana liczba bajtów, jeśli czy wiele bajtów nie są obecnie dostępne, lub 0, jeśli osiągnięto koniec strumienia przed żadnych danych można można odczytać."
  overload: System.IO.BufferedStream.Read*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Length of <code>array</code> minus <code>offset</code> is less than <code>count</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>lub <code>count</code> jest ujemna."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Strumień nie jest otwarty lub jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Strumień nie obsługuje odczytu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metody wywołane po strumień został zamknięty."
  platform:
  - net462
- uid: System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Asynchronicznie odczytuje sekwencję bajtów ze strumienia bieżącego zmienia pozycję w strumieniu przez liczbę bajtów odczytanych i monitoruje żądań anulowania."
  remarks: "Token anulowania można utworzyć przez utworzenie wystąpienia <xref:System.Threading.CancellationTokenSource>klasy i przekazywanie <xref:System.Threading.CancellationTokenSource.Token%2A>właściwość jako `cancellationToken` parametru.</xref:System.Threading.CancellationTokenSource.Token%2A> </xref:System.Threading.CancellationTokenSource>"
  syntax:
    content: public override System.Threading.Tasks.Task<int> ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Bufor zapisu danych do."
    - id: offset
      type: System.Int32
      description: "Przesunięcie bajtów w `buffer` jaką rozpocząć pisanie danych ze strumienia."
    - id: count
      type: System.Int32
      description: "Maksymalna liczba bajtów do odczytania."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Token do monitorowania żądań anulowania."
    return:
      type: System.Threading.Tasks.Task{System.Int32}
      description: "Zadanie reprezentujące asynchroniczną operacji odczytu. Wartość <code> TResult </code> parametr zawiera całkowitą liczbę bajtów odczytanych w buforze. Wartość wyniku może być mniejsza niż żądana liczba bajtów Liczba dostępnych bajtów jest mniejsza niż żądany numer, czy może być 0 (zero), jeśli osiągnięto koniec strumienia."
  overload: System.IO.BufferedStream.ReadAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>lub <code>count</code> jest ujemna."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Suma <code> offset </code> i <code> count </code> jest większa niż długość buforu."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Strumień nie obsługuje odczytu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Strumień został usunięty."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Strumień jest obecnie używany przez poprzednią operację odczytu."
  platform:
  - net462
- uid: System.IO.BufferedStream.ReadByte
  id: ReadByte
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: ReadByte()
  nameWithType: BufferedStream.ReadByte()
  fullName: System.IO.BufferedStream.ReadByte()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Odczytuje bajt zasadniczy strumień i zwraca bajt rzutować <xref uid=&quot;langword_csharp_int&quot; name=&quot;int&quot; href=&quot;&quot;> </xref>, lub zwraca wartość -1, jeśli odczytu z końcem strumienia."
  syntax:
    content: public override int ReadByte ();
    parameters: []
    return:
      type: System.Int32
      description: "Bajt rzutować <xref uid=&quot;langword_csharp_int&quot; name=&quot;int&quot; href=&quot;&quot;> </xref>, lub wartość -1, jeśli odczytu z końcem strumienia."
  overload: System.IO.BufferedStream.ReadByte*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Występuje błąd We/Wy, takich jak strumień jest zamknięty."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Strumień nie obsługuje odczytu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metody wywołane po strumień został zamknięty."
  platform:
  - net462
- uid: System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: BufferedStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.BufferedStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Ustawia położenie w bieżącym buforowanego strumienia."
  remarks: "Jeśli `offset` jest ujemna, Nowa pozycja jest poprzedzony pozycja określona przez `origin` przez liczbę bajtów określona przez `offset`. Jeśli `offset` ma wartość 0, nowe miejsce będzie pozycja określona przez `origin`. Jeśli `offset` jest dodatnia, nowe położenie zastosują się pozycja określona przez `origin` przez liczbę bajtów określona przez `offset`.       Gdy <xref:System.IO.BufferedStream>obiekt jest strumienia podstawowego dla <xref:System.IO.StreamReader>obiektu, wywołanie metody Seek może spowodować pozycji strumienia nie jest już odpowiadające pozycja buforu wewnętrznego w czytniku.</xref:System.IO.StreamReader> </xref:System.IO.BufferedStream> Aby zresetować wewnętrznego buforu, należy wywołać <xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=fullName>metody; jednak ta metoda spowalnia działanie i powinna być wywoływana tylko wtedy, gdy jest to bezwzględnie konieczne.</xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=fullName>       Wyszukiwanie w dowolne miejsce powyżej długość strumienia jest obsługiwana."
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "Przesunięcie bajtów, względem `origin`."
    - id: origin
      type: System.IO.SeekOrigin
      description: "Wartości typu <xref:System.IO.SeekOrigin>wskazujący punkt odniesienia, z którego ma pobrać nowe położenie.</xref:System.IO.SeekOrigin>"
    return:
      type: System.Int64
      description: "Nowa pozycja w bieżącym buforowanego strumienia."
  overload: System.IO.BufferedStream.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Strumień nie jest otwarty lub jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Strumień nie obsługuje wyszukiwania."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metody wywołane po strumień został zamknięty."
  platform:
  - net462
- uid: System.IO.BufferedStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: BufferedStream.SetLength(Int64)
  fullName: System.IO.BufferedStream.SetLength(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Ustawia długość buforowanego strumienia."
  remarks: "Bufor jest opróżniany przed ustawieniem długość źródła danych lub repozytorium. Jeśli określona wartość jest mniejsza niż bieżąca długość buforowanego strumienia, zostanie obcięta buforowanego strumienia. Jeśli określona wartość jest większa niż bieżąca długość buforowanego strumienia, jest rozwinięta buforowanego strumienia. Jeśli buforowany strumień jest rozwinięty, zawartość buforowanego strumienia między stary i nowy długości nie są zdefiniowane.       `SetLength`Czyści wszystkie buforowane zapisy w razie potrzeby.       Strumień musi obsługiwać zarówno zapisu i wyszukiwania dla `SetLength` do pracy."
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "Liczba całkowita wskazująca wymagana długość bieżącego buforowanego strumienia w bajtach."
  overload: System.IO.BufferedStream.SetLength*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>value</code>jest ujemna."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Strumień nie jest otwarty lub jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Strumień nie obsługuje zarówno zapisu i wyszukiwania."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metody wywołane po strumień został zamknięty."
  platform:
  - net462
- uid: System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Kopiuje bajtów do buforowanego strumienia i przechodzi przez liczba zapisanych bajtów bieżącą pozycję w buforowanego strumienia."
  remarks: ''
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#6](~/add/codesnippet/csharp/m-system.io.bufferedstre_1_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#6](~/add/codesnippet/cpp/m-system.io.bufferedstre_1_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#6](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_1_1.vb)]"
  syntax:
    content: public override void Write (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "Tablica bajtów do skopiowania `count` bajtów do bieżącego buforowanego strumienia."
    - id: offset
      type: System.Int32
      description: "Przesunięcie w buforze, od którego należy zacząć kopiowanie bajtów do bieżącego buforowanego strumienia."
    - id: count
      type: System.Int32
      description: "Liczba bajtów do zapisania w bieżącym buforowanego strumienia."
  overload: System.IO.BufferedStream.Write*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Length of <code>array</code> minus <code>offset</code> is less than <code>count</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>lub <code>count</code> jest ujemna."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Strumień jest zamknięty lub <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Strumień nie obsługuje zapisywania."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metody wywołane po strumień został zamknięty."
  platform:
  - net462
- uid: System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Asynchronicznie zapisuje sekwencję bajtów do strumienia bieżącego przesuwa bieżącą pozycję w tym strumieniu przez liczba zapisanych bajtów i monitoruje żądania anulowania."
  remarks: "Token anulowania można utworzyć przez utworzenie wystąpienia <xref:System.Threading.CancellationTokenSource>klasy i przekazywanie <xref:System.Threading.CancellationTokenSource.Token%2A>właściwość jako `cancellationToken` parametru.</xref:System.Threading.CancellationTokenSource.Token%2A> </xref:System.Threading.CancellationTokenSource>"
  syntax:
    content: public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Bufor zapisywania danych z."
    - id: offset
      type: System.Int32
      description: "Zerze przesunięcie w `buffer` z którego należy zacząć kopiowanie bajtów do strumienia."
    - id: count
      type: System.Int32
      description: "Maksymalna liczba bajtów do zapisania."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Token do monitorowania żądań anulowania."
    return:
      type: System.Threading.Tasks.Task
      description: "Zadanie reprezentujące operację asynchronicznego zapisu."
  overload: System.IO.BufferedStream.WriteAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>lub <code>count</code> jest ujemna."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Suma <code> offset </code> i <code> count </code> jest większa niż długość buforu."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Strumień nie obsługuje zapisywania."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Strumień został usunięty."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Strumień jest obecnie używany przez poprzednią operację zapisu."
  platform:
  - net462
- uid: System.IO.BufferedStream.WriteByte(System.Byte)
  id: WriteByte(System.Byte)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: WriteByte(Byte)
  nameWithType: BufferedStream.WriteByte(Byte)
  fullName: System.IO.BufferedStream.WriteByte(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Zapisuje bajt bieżącą pozycję w buforowanego strumienia."
  syntax:
    content: public override void WriteByte (byte value);
    parameters:
    - id: value
      type: System.Byte
      description: "Bajtów do zapisania w strumieniu."
  overload: System.IO.BufferedStream.WriteByte*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Strumień nie obsługuje zapisywania."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>value</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metody wywołane po strumień został zamknięty."
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BufferedStream(Stream)
  nameWithType: BufferedStream.BufferedStream(Stream)
  fullName: System.IO.BufferedStream.BufferedStream(Stream)
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BufferedStream(Stream,Int32)
  nameWithType: BufferedStream.BufferedStream(Stream,Int32)
  fullName: System.IO.BufferedStream.BufferedStream(Stream,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IO.BufferedStream.CanRead
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanRead
  nameWithType: BufferedStream.CanRead
  fullName: System.IO.BufferedStream.CanRead
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.BufferedStream.CanSeek
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanSeek
  nameWithType: BufferedStream.CanSeek
  fullName: System.IO.BufferedStream.CanSeek
- uid: System.IO.BufferedStream.CanWrite
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanWrite
  nameWithType: BufferedStream.CanWrite
  fullName: System.IO.BufferedStream.CanWrite
- uid: System.IO.BufferedStream.Dispose(System.Boolean)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: BufferedStream.Dispose(Boolean)
  fullName: System.IO.BufferedStream.Dispose(Boolean)
- uid: System.IO.BufferedStream.EndRead(System.IAsyncResult)
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: BufferedStream.EndRead(IAsyncResult)
  fullName: System.IO.BufferedStream.EndRead(IAsyncResult)
- uid: System.IO.BufferedStream.EndWrite(System.IAsyncResult)
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: BufferedStream.EndWrite(IAsyncResult)
  fullName: System.IO.BufferedStream.EndWrite(IAsyncResult)
- uid: System.IO.BufferedStream.Flush
  parent: System.IO.BufferedStream
  isExternal: false
  name: Flush()
  nameWithType: BufferedStream.Flush()
  fullName: System.IO.BufferedStream.Flush()
- uid: System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: BufferedStream.FlushAsync(CancellationToken)
  fullName: System.IO.BufferedStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.IO.BufferedStream.Length
  parent: System.IO.BufferedStream
  isExternal: false
  name: Length
  nameWithType: BufferedStream.Length
  fullName: System.IO.BufferedStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.BufferedStream.Position
  parent: System.IO.BufferedStream
  isExternal: false
  name: Position
  nameWithType: BufferedStream.Position
  fullName: System.IO.BufferedStream.Position
- uid: System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Read(Byte[],Int32,Int32)
- uid: System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.Threading.Tasks.Task{System.Int32}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<Int32>
  nameWithType: Task<Int32>
  fullName: System.Threading.Tasks.Task<System.Int32>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Int32>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.BufferedStream.ReadByte
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadByte()
  nameWithType: BufferedStream.ReadByte()
  fullName: System.IO.BufferedStream.ReadByte()
- uid: System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: BufferedStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.BufferedStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.IO.BufferedStream.SetLength(System.Int64)
  parent: System.IO.BufferedStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: BufferedStream.SetLength(Int64)
  fullName: System.IO.BufferedStream.SetLength(Int64)
- uid: System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Write(Byte[],Int32,Int32)
- uid: System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.IO.BufferedStream.WriteByte(System.Byte)
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteByte(Byte)
  nameWithType: BufferedStream.WriteByte(Byte)
  fullName: System.IO.BufferedStream.WriteByte(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.IO.BufferedStream.#ctor*
  parent: System.IO.BufferedStream
  isExternal: false
  name: BufferedStream
  nameWithType: BufferedStream.BufferedStream
- uid: System.IO.BufferedStream.BeginRead*
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginRead
  nameWithType: BufferedStream.BeginRead
- uid: System.IO.BufferedStream.BeginWrite*
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginWrite
  nameWithType: BufferedStream.BeginWrite
- uid: System.IO.BufferedStream.CanRead*
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanRead
  nameWithType: BufferedStream.CanRead
- uid: System.IO.BufferedStream.CanSeek*
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanSeek
  nameWithType: BufferedStream.CanSeek
- uid: System.IO.BufferedStream.CanWrite*
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanWrite
  nameWithType: BufferedStream.CanWrite
- uid: System.IO.BufferedStream.Dispose*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Dispose
  nameWithType: BufferedStream.Dispose
- uid: System.IO.BufferedStream.EndRead*
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndRead
  nameWithType: BufferedStream.EndRead
- uid: System.IO.BufferedStream.EndWrite*
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndWrite
  nameWithType: BufferedStream.EndWrite
- uid: System.IO.BufferedStream.Flush*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Flush
  nameWithType: BufferedStream.Flush
- uid: System.IO.BufferedStream.FlushAsync*
  parent: System.IO.BufferedStream
  isExternal: false
  name: FlushAsync
  nameWithType: BufferedStream.FlushAsync
- uid: System.IO.BufferedStream.Length*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Length
  nameWithType: BufferedStream.Length
- uid: System.IO.BufferedStream.Position*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Position
  nameWithType: BufferedStream.Position
- uid: System.IO.BufferedStream.Read*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Read
  nameWithType: BufferedStream.Read
- uid: System.IO.BufferedStream.ReadAsync*
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadAsync
  nameWithType: BufferedStream.ReadAsync
- uid: System.IO.BufferedStream.ReadByte*
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadByte
  nameWithType: BufferedStream.ReadByte
- uid: System.IO.BufferedStream.Seek*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Seek
  nameWithType: BufferedStream.Seek
- uid: System.IO.BufferedStream.SetLength*
  parent: System.IO.BufferedStream
  isExternal: false
  name: SetLength
  nameWithType: BufferedStream.SetLength
- uid: System.IO.BufferedStream.Write*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Write
  nameWithType: BufferedStream.Write
- uid: System.IO.BufferedStream.WriteAsync*
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteAsync
  nameWithType: BufferedStream.WriteAsync
- uid: System.IO.BufferedStream.WriteByte*
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteByte
  nameWithType: BufferedStream.WriteByte
