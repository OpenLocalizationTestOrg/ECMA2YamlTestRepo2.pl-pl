### YamlMime:ManagedReference
items:
- uid: System.Windows.DependencyProperty
  id: DependencyProperty
  children:
  - System.Windows.DependencyProperty.AddOwner(System.Type)
  - System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.DefaultMetadata
  - System.Windows.DependencyProperty.GetHashCode
  - System.Windows.DependencyProperty.GetMetadata(System.Type)
  - System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)
  - System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)
  - System.Windows.DependencyProperty.GlobalIndex
  - System.Windows.DependencyProperty.IsValidType(System.Object)
  - System.Windows.DependencyProperty.IsValidValue(System.Object)
  - System.Windows.DependencyProperty.Name
  - System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyProperty.OwnerType
  - System.Windows.DependencyProperty.PropertyType
  - System.Windows.DependencyProperty.ReadOnly
  - System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)
  - System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)
  - System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.ToString
  - System.Windows.DependencyProperty.UnsetValue
  - System.Windows.DependencyProperty.ValidateValueCallback
  langs:
  - csharp
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
  type: Class
  summary: "Reprezentuje właściwości, które można ustawić za pomocą metody takie jak, stylów, powiązań danych, animacji i dziedziczenia."
  remarks: "DependencyProperty obsługuje następujące funkcje w [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]:-właściwość można ustawić w stylu. Aby uzyskać więcej informacji, zobacz [stylami i tworzenia szablonów](~/add/includes/ajax-current-ext-md.md).      -Właściwość można ustawić za pomocą wiązania z danymi. Aby uzyskać więcej informacji na temat właściwości zależności wiązania danych, zobacz [porady: powiązanie właściwości formantów dwóch](~/add/includes/ajax-current-ext-md.md).      -Właściwość można ustawić z odwołaniem zasobu dynamicznego. Aby uzyskać więcej informacji, zobacz [zasobów XAML](~/add/includes/ajax-current-ext-md.md).      — Właściwości mogą dziedziczyć wartość automatycznie elementu nadrzędnego w drzewie elementu. Aby uzyskać więcej informacji, zobacz [dziedziczenie wartości właściwości](~/add/includes/ajax-current-ext-md.md).      -Właściwość można animować. Aby uzyskać więcej informacji, zobacz [omówienie animacja](~/add/includes/ajax-current-ext-md.md).      — Po zmianie poprzedniej wartości właściwości i wartości właściwości mogą zostać przekształcone zgłosić właściwość. Aby uzyskać więcej informacji, zobacz [wywołania zwrotne właściwości zależności i sprawdzania poprawności](~/add/includes/ajax-current-ext-md.md).      -Właściwość raportuje informacje do [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], takie jak czy zmiana wartości właściwości powinny wymagać systemu układu przeskładać elementy wizualne dla elementu.      -Właściwość otrzymuje wsparcie w [!INCLUDE[wpfdesigner_current_long](~/add/includes/wpfdesigner-current-long-md.md)].  Na przykład właściwość może być edytowany w **właściwości** okna.       Aby dowiedzieć się więcej na temat właściwości zależności, zobacz [Przegląd właściwości zależności](~/add/includes/ajax-current-ext-md.md). Jeśli chcesz właściwości z typów niestandardowych do obsługi funkcji z powyższej listy, należy utworzyć właściwości zależności.  Informacje na temat tworzenia właściwości zależności niestandardowych, zobacz [niestandardowe właściwości zależności](~/add/includes/ajax-current-ext-md.md).       Dołączona właściwość jest właściwością umożliwiającą dowolnego obiektu na typ, który definiuje dołączona właściwość informacji w raporcie. W [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], dowolnego typu, która dziedziczy <xref:System.Windows.DependencyObject>można użyć właściwości dołączonej niezależnie od tego, czy typ dziedziczy z typu, który definiuje właściwość.</xref:System.Windows.DependencyObject> Dołączona właściwość jest funkcją [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] języka.  Aby ustawić właściwości dołączonej w [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], użyj *ownerType*.* propertyName* składni. Na przykład dołączona właściwość <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName>Właściwości.</xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName> Jeśli chcesz utworzyć właściwość, która może być używana na wszystkich <xref:System.Windows.DependencyObject>typów, a następnie należy utworzyć dołączona właściwość.</xref:System.Windows.DependencyObject> Aby dowiedzieć się więcej na temat dołączone właściwości, oraz o sposobie ich tworzenia, zobacz [dołączony Przegląd właściwości](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;xamlAttributeUsage_DependencyProperty&quot;></a>## Użycie atrybutu XAML ```   <object property=&quot;dependencyPropertyName&quot;/>   - or -   <object property=&quot;ownerType.dependencyPropertyName&quot;/>   - or -   <object property=&quot;attachedPropertyOwnerType.attachedPropertyName&quot;/>   ``` <a name=&quot;xamlValues_DependencyProperty&quot;> </a> ## wartości XAML `dependencyPropertyName` ciąg, który określa <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>Właściwości zależności żądaną.</xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>       To może być poprzedzony przez prefiks przestrzeni nazw XML, jeśli właściwość nie ma domyślnej przestrzeni nazw XML (Aby uzyskać więcej informacji, zobacz [przestrzeń nazw XAML i Namespace mapowanie WPF XAML](~/add/includes/ajax-current-ext-md.md).)       `ownerType`.`dependencyPropertyName`    Ciąg określający typ właściciela właściwości zależności, kropkę (.), a następnie <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>.</xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName> `ownerType`może być poprzedzone prefiks przestrzeni nazw XML. Dla style późnym wiązaniem i szablony, w którym należy określić właściciela właściwości zależności do analizowania kontekstu, ponieważ jest to użycie `TargetType` nie jest jeszcze znany. Aby uzyskać więcej informacji, zobacz [stylami i tworzenia szablonów](../Topic/Styling%20and%20Templating.md).       `attachedPropertyOwnerType` *.* `attachedPropertyName`Ciąg, który określa właściciela dołączona właściwość, kropkę (.), a następnie dołączona właściwość name. `attachedPropertyOwnerType`może być poprzedzone prefiks przestrzeni nazw XML."
  syntax:
    content: >-
      [System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]

      [System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))]

      public sealed class DependencyProperty
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.AddOwner(System.Type)
  id: AddOwner(System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: AddOwner(Type)
  nameWithType: DependencyProperty.AddOwner(Type)
  fullName: System.Windows.DependencyProperty.AddOwner(Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Dodaje innego typu jako właściciela właściwości zależności, który został już zarejestrowany."
  remarks: "Ta metoda umożliwia systemowi właściwości rozpoznaje właściwości zależności na typ, który nie może zarejestrować danej właściwości zależności w szczególności początkowo.       Zazwyczaj AddOwner służy do dodawania właściwości zależności do klasy, które nie udostępniają już tą właściwością zależności za pomocą dziedziczenia klas zarządzanych (dziedziczenia klas spowodowałoby właściwości otoki być dziedziczone przez klasy pochodnej i w związku z tym będzie udostępniany ogólne tabeli elementów członkowskich właściwości zależności już). AddOwner umożliwia systemowi właściwości rozpoznaje właściwości zależności na typ, który nie zarejestrował początkowo danej właściwości zależności.       Ta sygnatura nie zezwala na określanie metadanych.  Korzystając z tej metody, metadanych jest generowane automatycznie dla nowego <xref:System.Windows.DependencyProperty>i wpisz jego właściciela.</xref:System.Windows.DependencyProperty> Metadane automatycznie generowanej powstaje na podstawie metadanych scalony ze wszystkich typów podstawowych, których tej właściwości zdefiniowane. Jeśli brak metadanych scalonych nie jest dostępny, używana jest domyślna metadane dla właściwości. Jeśli właściwość jest zarejestrowana przy użyciu <xref:System.Windows.DependencyProperty.RegisterAttached%2A>metody, a następnie metadane domyślny jest taka sama jak metadanych, które jest tworzone, gdy <xref:System.Windows.DependencyProperty.RegisterAttached%2A>została wywołana.</xref:System.Windows.DependencyProperty.RegisterAttached%2A> </xref:System.Windows.DependencyProperty.RegisterAttached%2A> W przeciwnym razie <xref:System.Windows.PropertyMetadata>obiekt jest tworzony z <xref:System.Windows.PropertyMetadata.DefaultValue%2A>Właściwość domyślny typ właściwości i wszystkie inne właściwości <xref:System.Windows.PropertyMetadata>ustawiono `null`.</xref:System.Windows.PropertyMetadata> </xref:System.Windows.PropertyMetadata.DefaultValue%2A> </xref:System.Windows.PropertyMetadata> Użyj <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>podpisu, aby zapewnić metadanych do wersji właściwości zależności, jak dodać do udostępnionego typu.</xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>       Zwracana wartość tej metody zwykle umożliwia deklarowanie i ujawnia właściwości zależności, przechowując identyfikatora właściwości zależności. Identyfikator zapewnia dostęp do właściwości zależności, aby wywołać właściwości systemu [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] względem właściwości zależności, szczególnie jako istnieje na dodawanie klasy właściciela. Tej samej nazwie właściwości pierwotnego właściciela i dodany właściciela powinny być służy do wskazania podobnych możliwościach. Należy używać <xref:System.Windows.DependencyProperty>zwrócić wartość metody AddOwner do definiowania identyfikatora właściwości zależności, a także aby zadeklarować [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] otoki właściwości, dla właściwości zależności, które są dodawane do typów za pomocą AddOwner.</xref:System.Windows.DependencyProperty>       Metodologia AddOwner zalecanych jest używany podczas tworzenia właściwości zależności, które są zadeklarowane w [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]. Na przykład zarówno <xref:System.Windows.Controls.Border>i <xref:System.Windows.Controls.Control>zdefiniować `BorderBrush` właściwości zależności, które mają podobną funkcjonalność.</xref:System.Windows.Controls.Control> </xref:System.Windows.Controls.Border> <xref:System.Windows.Controls.Control>Definiuje jego `BorderBrush` na pierwotny właściciel na podstawie właściwości w systemie właściwości przez wywołanie metody AddOwner <xref:System.Windows.Controls.Border>i jego zarejestrowanych <xref:System.Windows.Controls.Border.BorderBrushProperty>identyfikatora właściwości zależności.</xref:System.Windows.Controls.Border.BorderBrushProperty> </xref:System.Windows.Controls.Border></xref:System.Windows.Controls.Control> AddOwner zwrócić wartość jest następnie używany do ustanawiania nowego statycznego <xref:System.Windows.DependencyProperty>pola (<xref:System.Windows.Controls.Control.BorderBrushProperty>) dla tej właściwości na dodano właściciela i `BorderBrush` właściwości otoki jest również zadeklarowany.</xref:System.Windows.Controls.Control.BorderBrushProperty> </xref:System.Windows.DependencyProperty>"
  syntax:
    content: public System.Windows.DependencyProperty AddOwner (Type ownerType);
    parameters:
    - id: ownerType
      type: System.Type
      description: "Typ do dodania jako właściciela tej właściwości zależności."
    return:
      type: System.Windows.DependencyProperty
      description: "Odwołanie do oryginalnej <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> identyfikator, który identyfikuje właściwości zależności. Ten identyfikator powinny zostać ujawnione przez dodanie klasę jako <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> pola."
  overload: System.Windows.DependencyProperty.AddOwner*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)
  id: AddOwner(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: AddOwner(Type,PropertyMetadata)
  nameWithType: DependencyProperty.AddOwner(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.AddOwner(Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Dodaje innego typu jako właściciela właściwości zależności, który został już zarejestrowany, zapewniając metadane właściwości zależności dla właściwości zależności będą znajdować się na typ podanego właściciela."
  remarks: "Ta metoda umożliwia systemowi właściwości rozpoznaje właściwości zależności na typ, który nie może zarejestrować danej właściwości zależności w szczególności początkowo.       Zwracana wartość ta metoda służy do deklarowanie i ujawnia właściwości zależności szczególnie, ponieważ znajduje się ona na dodawanie klasy właściciela. Ogólnie rzecz biorąc tej samej nazwie właściwości pierwotnego właściciela i dodany właściciela powinny być służy do wskazania podobnych możliwościach. Dobrym rozwiązaniem do udostępnienia identyfikatorów, a także jako nowy jest [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] otoki właściwości, dla właściwości zależności, które są dodawane do typów za pomocą <xref:System.Windows.DependencyProperty.AddOwner%2A>.</xref:System.Windows.DependencyProperty.AddOwner%2A>       <xref:System.Windows.DependencyProperty.AddOwner%2A>Metodologii zalecanych jest używany podczas tworzenia [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] zadeklarowana wewnątrz [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)].</xref:System.Windows.DependencyProperty.AddOwner%2A> Na przykład zarówno <xref:System.Windows.Controls.Border>i <xref:System.Windows.Controls.Control>zdefiniować `BorderBrush` właściwości zależności, które mają podobną funkcjonalność.</xref:System.Windows.Controls.Control> </xref:System.Windows.Controls.Border> <xref:System.Windows.Controls.Control>Definiuje jego `BorderBrush` właściwości do właściwości systemu przez wywołanie metody <xref:System.Windows.DependencyProperty.AddOwner%2A>na pierwotny właściciel <xref:System.Windows.Controls.Border>i jego zarejestrowanych <xref:System.Windows.Controls.Border.BorderBrushProperty>identyfikatora właściwości zależności.</xref:System.Windows.Controls.Border.BorderBrushProperty> </xref:System.Windows.Controls.Border> </xref:System.Windows.DependencyProperty.AddOwner%2A></xref:System.Windows.Controls.Control> <xref:System.Windows.DependencyProperty.AddOwner%2A>Zwrócić wartość jest następnie używany do ustanawiania statycznego <xref:System.Windows.DependencyProperty>pola (<xref:System.Windows.Controls.Control.BorderBrushProperty>) dla tej właściwości na dodano właściciela i `BorderBrush` właściwości otoki jest również zadeklarowany.</xref:System.Windows.Controls.Control.BorderBrushProperty> </xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.AddOwner%2A>       Identyfikator właściwości zależności dodano właściciela ma być używane jako operacji, takich jak <xref:System.Windows.DependencyObject.GetValue%2A>.</xref:System.Windows.DependencyObject.GetValue%2A> Jednak określonego typu obejmującego typów lub wystąpienia klasy, która została dodana jako właściciela o metadanych, będzie nadal zwraca oczekiwanych rezultatów nawet wtedy, gdy oryginalne (nie dodano właściciela) określono identyfikator właściwości zależności w wywołaniach metody takie jak <xref:System.Windows.DependencyObject.GetValue%2A>lub <xref:System.Windows.DependencyProperty.GetMetadata%2A>.</xref:System.Windows.DependencyProperty.GetMetadata%2A> </xref:System.Windows.DependencyObject.GetValue%2A> Metadane dla właściciela dodany jest perpetuated przez AddOwner wywoływać samego siebie, niekoniecznie odwołuje się do wyłącznie przez dodanie pola Identyfikator klasy właściciela. Niemniej jednak jest dobrym rozwiązaniem, aby prezentować identyfikator, a także jako nowy [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] otoki właściwości, dla właściwości zależności, które są dodawane do typów przy użyciu AddOwner, ponieważ w przeciwnym razie tworzy rozbieżności między [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] i [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] reprezentacje właściwości.       Metadane podane jest scalany z metadane właściwości dla właściwości zależności, ponieważ znajduje się na podstawową właściciela. Wszystkie właściwości, które zostały określone w oryginalnych metadanych podstawowej będzie umieszczony. Tylko te właściwości, które w szczególności zostały zmienione w nowych metadanych spowoduje zastąpienie właściwości metadanych podstawowej. Niektóre właściwości, takie jak <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, zostały zastąpione, jeśli są one określone w nowymi metadanymi.</xref:System.Windows.PropertyMetadata.DefaultValue%2A> Inne, takie jak <xref:System.Windows.PropertyChangedCallback>, są połączone.</xref:System.Windows.PropertyChangedCallback> Ostatecznie, zachowanie scalania zależy od typu metadanych właściwości używany do zastąpienia, dlatego dla istniejącej klasy metadanych właściwości używane przez zachowanie opisane tutaj [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] właściwości zależności. Aby uzyskać więcej informacji, zobacz [metadanych właściwości zależności](~/add/includes/ajax-current-ext-md.md) i [metadanych właściwości Framework](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: ownerType
      type: System.Type
      description: "Typ do dodania jako właściciela tej właściwości zależności."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Metadane, które kwalifikują się właściwości zależności, ponieważ znajduje się na podanego typu."
    return:
      type: System.Windows.DependencyProperty
      description: "Odwołanie do oryginalnej <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> identyfikator, który identyfikuje właściwości zależności. Ten identyfikator powinny zostać ujawnione przez dodanie klasę jako <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> pola."
  overload: System.Windows.DependencyProperty.AddOwner*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.DefaultMetadata
  id: DefaultMetadata
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: DefaultMetadata
  nameWithType: DependencyProperty.DefaultMetadata
  fullName: System.Windows.DependencyProperty.DefaultMetadata
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Pobiera metadane domyślnej właściwości zależności."
  remarks: "Metadane domyślne są metadane właściwości, która jest dostępna dla tego konkretnego obiektu lub typu pochodnego obiektu gdzie metadanych alternatywną, nie został dostarczony przez jawne <xref:System.Windows.DependencyProperty.Register%2A>lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>wywołań.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.Register%2A>       Jeśli właściciel oryginalnego zastosowano metadanych do pierwszej <xref:System.Windows.DependencyProperty.Register%2A>wywołaniu, które ustanowić właściwości zależności, a następnie metadane są zwracane w postaci DefaultMetadata.</xref:System.Windows.DependencyProperty.Register%2A>       Jeśli metadanych nie została zastosowana w oryginalnym <xref:System.Windows.DependencyProperty.Register%2A>wywołań, a następnie metadanych domyślne są generowane na podstawie poziomu <xref:System.Windows.DependencyProperty.Register%2A>połączeń i ta wartość jest zwracana jako DefaultMetadata.</xref:System.Windows.DependencyProperty.Register%2A> </xref:System.Windows.DependencyProperty.Register%2A>       Głównym celem o domyślnej metadane skojarzone z <xref:System.Windows.DependencyProperty>jest umożliwiają określanie wartości domyślnej dla tej właściwości na dowolnym <xref:System.Windows.DependencyObject>lub typu pochodnego.</xref:System.Windows.DependencyObject> </xref:System.Windows.DependencyProperty>       Dla właściwości nie dołączony zwracane przez tę właściwość typu metadanych nie można rzutować na typy pochodne <xref:System.Windows.PropertyMetadata>Typ, nawet jeśli właściwość pierwotnie został zarejestrowany z typu pochodnego metadanych.</xref:System.Windows.PropertyMetadata> Jeśli pierwotnie zarejestrowanego metadanych, łącznie z jej oryginalnego typu pochodnego prawdopodobnie metadanych, należy wywołać <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29>przekazywanie oryginalnego rejestrowanie zamiast tego typu jako parametr.</xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29>       W przypadku dołączonych właściwości typ metadanych zwróconych przez tę właściwość zostanie pasuje do typu podane w oryginalnym <xref:System.Windows.DependencyProperty.RegisterAttached%2A>Metoda rejestracji.</xref:System.Windows.DependencyProperty.RegisterAttached%2A>"
  example:
  - "[!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#DPDefaultValue](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]\n[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]"
  syntax:
    content: public System.Windows.PropertyMetadata DefaultMetadata { get; }
    return:
      type: System.Windows.PropertyMetadata
      description: "Metadane domyślnej właściwości zależności."
  overload: System.Windows.DependencyProperty.DefaultMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetHashCode
  id: GetHashCode
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetHashCode()
  nameWithType: DependencyProperty.GetHashCode()
  fullName: System.Windows.DependencyProperty.GetHashCode()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Zwraca wartość skrótu dla tego <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>."
  remarks: "Właściwość system używa swojego unikatowego identyfikatora <xref:System.Windows.DependencyProperty.GlobalIndex%2A>, a wartość tej właściwości jest zwracany przez GetHashCode.</xref:System.Windows.DependencyProperty.GlobalIndex%2A>"
  syntax:
    content: public override int GetHashCode ();
    parameters: []
    return:
      type: System.Int32
      description: "Wartość skrótu dla tego <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>."
  overload: System.Windows.DependencyProperty.GetHashCode*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetMetadata(System.Type)
  id: GetMetadata(System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetMetadata(Type)
  nameWithType: DependencyProperty.GetMetadata(Type)
  fullName: System.Windows.DependencyProperty.GetMetadata(Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Zwraca metadane dla ta właściwość zależności, które znajdują się na określony typ istniejących."
  remarks: "Określanie typu lub odwołanie do obiektu, do użycia jako typ jest niezbędne, ponieważ metadane mogą się różnić od oryginalnej rejestracji ze względu na <xref:System.Windows.DependencyProperty.AddOwner%2A>lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>wywołań, które zmienić metadanych właściwości zależności, ponieważ istnieje w typie.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A>"
  example:
  - "The following example gets metadata for a dependency property based on its type. The type is obtained by using a `typeof` operator.  \n  \n [!code-cs[PropertySystemEsoterics#GetMetadataType](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/default.xaml.cs#getmetadatatype)]\n [!code-vb[PropertySystemEsoterics#GetMetadataType](~/add/codesnippet/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]"
  syntax:
    content: public System.Windows.PropertyMetadata GetMetadata (Type forType);
    parameters:
    - id: forType
      type: System.Type
      description: "Określony typ, z którego można pobrać metadanych właściwości zależności."
    return:
      type: System.Windows.PropertyMetadata
      description: "Właściwości obiektu metadanych."
  overload: System.Windows.DependencyProperty.GetMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)
  id: GetMetadata(System.Windows.DependencyObject)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetMetadata(DependencyObject)
  nameWithType: DependencyProperty.GetMetadata(DependencyObject)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObject)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Zwraca metadane dla tej właściwości zależności, ponieważ znajduje się na wystąpienie określonego obiektu."
  remarks: "Określanie typu lub odwołanie do obiektu jest konieczne, ponieważ metadane żadnych danej właściwości zależności mogą się różnić od oryginalnej rejestracji ze względu na <xref:System.Windows.DependencyProperty.AddOwner%2A>lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>wywołań, które można dostosować metadanych właściwości, ponieważ istnieje w typie.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A>       W przypadku żądania metadanych właściwość w wystąpieniu, są tak naprawdę przekazywanie wystąpienie tak, aby jej typ może przyjmować wewnętrznie. Metadane właściwości zależności nie zmienia się na każde wystąpienie; zawsze jest spójne dla dowolnej kombinacji właściwości danego typu."
  example:
  - "The following example gets metadata for a dependency property based on a specific <xref:System.Windows.DependencyObject> instance.  \n  \n [!code-cs[PropertySystemEsoterics#GetMetadataDOInstance](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]\n [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/add/codesnippet/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]"
  syntax:
    content: public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);
    parameters:
    - id: dependencyObject
      type: System.Windows.DependencyObject
      description: "Obiekt zależności, który jest sprawdzany pod kątem typu, w celu ustalenia, która wersja określonego typu właściwości zależności metadanych powinna pochodzić z."
    return:
      type: System.Windows.PropertyMetadata
      description: "Właściwości obiektu metadanych."
  overload: System.Windows.DependencyProperty.GetMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)
  id: GetMetadata(System.Windows.DependencyObjectType)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetMetadata(DependencyObjectType)
  nameWithType: DependencyProperty.GetMetadata(DependencyObjectType)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObjectType)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Zwraca metadane dla tej właściwości zależności, ponieważ znajduje się na określony typ."
  remarks: "Określanie typu lub odwołanie do obiektu jest konieczne, ponieważ metadane żadnych danej właściwości zależności mogą się różnić od oryginalnej rejestracji ze względu na <xref:System.Windows.DependencyProperty.AddOwner%2A>lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>wywołań, które można dostosować metadanych właściwości, ponieważ istnieje w typie.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A>"
  example:
  - "The following example gets metadata for a dependency property based on its <xref:System.Windows.DependencyObjectType>.  \n  \n [!code-cs[PropertySystemEsoterics#GetMetadataDOType](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/default.xaml.cs#getmetadatadotype)]\n [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/add/codesnippet/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]"
  syntax:
    content: public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);
    parameters:
    - id: dependencyObjectType
      type: System.Windows.DependencyObjectType
      description: "Określonego obiektu, który rejestruje typ obiektu zależności, z którego jest pożądany metadane właściwości zależności."
    return:
      type: System.Windows.PropertyMetadata
      description: "Właściwości obiektu metadanych."
  overload: System.Windows.DependencyProperty.GetMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GlobalIndex
  id: GlobalIndex
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GlobalIndex
  nameWithType: DependencyProperty.GlobalIndex
  fullName: System.Windows.DependencyProperty.GlobalIndex
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Pobiera wartość wewnętrznie generowane, który unikatowo identyfikuje właściwości zależności."
  remarks: "Ta wartość nie jest liczbą całkowitą [!INCLUDE[TLA#tla_guid](~/add/includes/ajax-current-ext-md.md)]. Ogólnie rzecz biorąc przy użyciu tej wartości indeksu nie jest wymagane i brak jest indeks dostępu do tabel wszystkich właściwości zależności. Właściwości zależności zamiast tego należy odwoływać się swoich pól identyfikator.       GlobalIndex jest używana wewnętrznie do szybszy dostęp do struktury danych, które używają GlobalIndex jako indeks tablicy liczony od zera. Podobne obciążenie może być aplikacje dla projektantów lub narzędzia."
  syntax:
    content: public int GlobalIndex { get; }
    return:
      type: System.Int32
      description: "Unikatowy identyfikator liczbowy."
  overload: System.Windows.DependencyProperty.GlobalIndex*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.IsValidType(System.Object)
  id: IsValidType(System.Object)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: IsValidType(Object)
  nameWithType: DependencyProperty.IsValidType(Object)
  fullName: System.Windows.DependencyProperty.IsValidType(Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Określa, czy określona wartość jest akceptowalne dla typu ta właściwość zależności, ponieważ sprawdza, czy typ właściwości zawarte w pierwotnej rejestracji właściwości zależności."
  remarks: "Wartość `null` jest prawidłowym typem dla właściwości zależności typu odwołania lub <xref:System.Nullable%601>Właściwości zależności i zwróci `true` dla tych przypadków.</xref:System.Nullable%601> W przypadkach, gdy właściwość zależności jest ani odwołaniem ani <xref:System.Nullable%601>typu, zwróci IsValidType `false` na wartość null zamiast Zgłoś wyjątek.</xref:System.Nullable%601>"
  example:
  - "The following example uses IsValidType as a check before calling <xref:System.Windows.DependencyObject.SetValue%2A> on the dependency property.  \n  \n [!code-cs[PropertySystemEsoterics#TrySetValue](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#trysetvalue)]\n [!code-vb[PropertySystemEsoterics#TrySetValue](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]"
  syntax:
    content: public bool IsValidType (object value);
    parameters:
    - id: value
      type: System.Object
      description: "Wartość do sprawdzenia."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli określona wartość jest typu zarejestrowanej właściwości lub dopuszczalne typu pochodnego; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.DependencyProperty.IsValidType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.IsValidValue(System.Object)
  id: IsValidValue(System.Object)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: IsValidValue(Object)
  nameWithType: DependencyProperty.IsValidValue(Object)
  fullName: System.Windows.DependencyProperty.IsValidValue(Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Określa, czy podana wartość jest akceptowany dla typu właściwości, wybierając typ podstawowy, a także potencjalnie jeśli znajduje się w dozwolonym zakresem wartości dla tego typu."
  remarks: "Dla właściwości zależności, można określić zakres dozwolonych wartości dla tego typu za pomocą <xref:System.Windows.ValidateValueCallback>dostarczanym rejestracji właściwości zależności.</xref:System.Windows.ValidateValueCallback>       Ta metoda wywołuje <xref:System.Windows.DependencyProperty.IsValidType%2A>wewnętrznie.</xref:System.Windows.DependencyProperty.IsValidType%2A> Jeśli w danym właściwość zależności nie ma żadnych <xref:System.Windows.ValidateValueCallback>następnie wywołaniem tej metody jest równoważne wywołanie <xref:System.Windows.DependencyProperty.IsValidType%2A>.</xref:System.Windows.DependencyProperty.IsValidType%2A> </xref:System.Windows.ValidateValueCallback> Jeśli właściwość zależności <xref:System.Windows.ValidateValueCallback>i w razie <xref:System.Windows.DependencyProperty.IsValidType%2A>będzie musiał zwrócić `true`, zwracana wartość zostanie wykonane podczas wywołania zwrotnego.</xref:System.Windows.DependencyProperty.IsValidType%2A> </xref:System.Windows.ValidateValueCallback>       Wartość null jest prawidłową wartością dla właściwości zależności typu odwołania lub <xref:System.Nullable%601>Właściwości zależności i zwróci `true` dla tych przypadków.</xref:System.Nullable%601> W przypadkach, gdy właściwość zależności jest ani odwołaniem ani <xref:System.Nullable%601>typu <xref:System.Windows.DependencyProperty.IsValidType%2A>zwróci `false` na wartość null zamiast Zgłoś wyjątek.</xref:System.Windows.DependencyProperty.IsValidType%2A> </xref:System.Nullable%601>"
  example:
  - "The following example uses IsValidValue as a check before calling <xref:System.Windows.DependencyObject.SetValue%2A> on the dependency property.  \n  \n [!code-cs[PropertySystemEsoterics#TrySetValueWithValidate](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]\n [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]"
  syntax:
    content: public bool IsValidValue (object value);
    parameters:
    - id: value
      type: System.Object
      description: "Wartość do sprawdzenia."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli wartość jest dopuszczalne i jest nieprawidłowego typu lub typu pochodnego; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.DependencyProperty.IsValidValue*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Name
  id: Name
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Name
  nameWithType: DependencyProperty.Name
  fullName: System.Windows.DependencyProperty.Name
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Pobiera nazwę właściwości zależności."
  remarks: "Ta właściwość uzyskuje nazwę odpowiednio `name` parametru podczas rejestracji właściwości zależności. Ta nazwa jest niemodyfikowalna i nie może być `null` lub ciąg pusty. Rejestracje zduplikowanej nazwy do tego samego typu właściciela nie są dozwolone i zgłosi wyjątek podczas próby zarejestrowania duplikatu.      > [!IMPORTANT] > Nazwa właściwości zależności musi być zgodna z Konwencją pasującego do nazwy identyfikatora właściwości zależności minus sufiks &quot;Property&quot;. Aby uzyskać więcej informacji, zobacz [właściwości zależności niestandardowe](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example queries various characteristics of a dependency property identifier, including the Name.  \n  \n [!code-cs[PropertySystemEsoterics#DPProps](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpprops)]\n [!code-vb[PropertySystemEsoterics#DPProps](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpprops)]"
  syntax:
    content: public string Name { get; }
    return:
      type: System.String
      description: "Nazwa właściwości."
  overload: System.Windows.DependencyProperty.Name*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  id: OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: OverrideMetadata(Type,PropertyMetadata)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Określa alternatywny metadanych dla tej właściwości zależności, gdy nie jest obecny w wystąpieniach o określonym typie, zastępowanie metadanych, które istniały dla właściwości zależności, ponieważ został on odziedziczony z typów podstawowych."
  remarks: "Powinna zostać zastąpiona metadanych właściwości zależności, zanim system właściwości używa właściwości zależności. To jest równa czas określone wystąpienia są tworzone przy użyciu klasy, która rejestruje właściwości zależności. Wywołania metody OverrideMetadata powinny zostać wykonane tylko w konstruktorów statycznych typu, który udostępnia siebie jako `forType` parametru tej metody lub za pomocą podobnego wystąpienia. Podjęto próbę zmiany metadanych po istnieje wystąpienie typu właściciela nie będą zgłaszać wyjątków, ale spowoduje niespójność zachowania w systemie właściwości.       Po ustanowieniu metadanych dla elementu override określonej klasy pochodnej z tą metodą, kolejne próby na zastępowanie metadanych na tej samej klasy pochodnej zgłosi wyjątek.       Metadane podane jest scalany z metadane właściwości dla właściwości zależności, ponieważ znajduje się na podstawową właściciela. Wszystkie właściwości, które zostały określone w oryginalnych metadanych podstawowej będzie trwać; tylko te właściwości, które w szczególności zostały zmienione w nowych metadanych spowoduje zastąpienie właściwości podstawowej metadanych. Niektóre właściwości, takie jak <xref:System.Windows.PropertyMetadata.DefaultValue%2A>zostały zastąpione, jeśli określony w metadanych nowy.</xref:System.Windows.PropertyMetadata.DefaultValue%2A> Inne, takie jak <xref:System.Windows.PropertyChangedCallback>, są połączone.</xref:System.Windows.PropertyChangedCallback> Ostatecznie, zachowanie scalania zależy od typu metadanych właściwości używany do zastąpienia, dlatego dla istniejącej klasy metadanych właściwości używane przez zachowanie opisane tutaj [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] właściwości zależności. Aby uzyskać więcej informacji, zobacz [metadanych właściwości zależności](~/add/includes/ajax-current-ext-md.md) i [metadanych właściwości Framework](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: forType
      type: System.Type
      description: "Typ, w którym ta właściwość zależności jest dziedziczona i gdzie zostaną zastosowane podane metadane alternatywny."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Metadane dla właściwości zależności na zastępowanie typu."
  overload: System.Windows.DependencyProperty.OverrideMetadata*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nastąpiła próba na zastępowanie metadanych właściwości tylko do odczytu zależności (nie można wykonać operacji przy użyciu tego podpisu)."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Metadane już zostało ustanowione dla właściwości zależności, ponieważ znajduje się na podanego typu."
  platform:
  - net462
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  id: OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Dostaw alternatywny metadane dla właściwości tylko do odczytu zależności, gdy nie jest obecny w wystąpieniach o określonym typie, zastępowanie metadanych, które podano w rejestracji właściwości zależności początkowej. Należy podać <xref href=&quot;System.Windows.DependencyPropertyKey&quot;> </xref> dla właściwości tylko do odczytu zależności uniknąć, który wywołał wyjątek."
  remarks: "Ta sygnatura zawiera implementacja dla identyfikatora właściwości zależności tylko do odczytu (<xref:System.Windows.DependencyPropertyKey>) metoda.</xref:System.Windows.DependencyPropertyKey> Jeśli Zastępowanie metadanych dla właściwości zależności odczytu i zapisu, użyj <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>.</xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>       Powinna zostać zastąpiona metadanych właściwości zależności, zanim system właściwości używa właściwości zależności. To jest równa czasu określone obiekty są tworzone dla klasy, która rejestruje właściwości zależności. Wywołuje się <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>powinno być wykonywane jedynie konstruktorów statycznych typu, który udostępnia siebie jako `forType` parametru tej metody lub za pomocą podobnego wystąpienia.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> Podjęto próbę zmiany metadanych po istnieje wystąpienie typu właściciela nie będą zgłaszać wyjątków, ale spowoduje niespójność zachowania w systemie właściwości.       Po ustanowieniu metadanych dla elementu override określonej klasy pochodnej z tą metodą, kolejne próby na zastępowanie metadanych na tej samej klasy pochodnej zgłosi wyjątek.       Metadane podane jest scalany z metadane właściwości dla właściwości zależności, ponieważ znajduje się na podstawową właściciela. Wszystkie właściwości, które zostały określone w oryginalnych metadanych podstawowej będzie trwać; tylko te właściwości, które w szczególności zostały zmienione w nowych metadanych spowoduje zastąpienie właściwości podstawowej metadanych. Niektóre właściwości, takie jak <xref:System.Windows.PropertyMetadata.DefaultValue%2A>zostały zastąpione, jeśli określony w metadanych nowy.</xref:System.Windows.PropertyMetadata.DefaultValue%2A> Inne, takie jak <xref:System.Windows.PropertyChangedCallback>, są połączone.</xref:System.Windows.PropertyChangedCallback> Zachowanie scalania zależy od typu metadanych właściwości używany do zastąpienia. Aby uzyskać więcej informacji, zobacz [metadanych właściwości zależności](~/add/includes/ajax-current-ext-md.md) i [metadanych właściwości Framework](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);
    parameters:
    - id: forType
      type: System.Type
      description: "Typ, w którym ta właściwość zależności jest dziedziczona i gdzie zostaną zastosowane podane metadane alternatywny."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Metadane dla właściwości zależności na zastępowanie typu."
    - id: key
      type: System.Windows.DependencyPropertyKey
      description: "Klucz dostępu dla właściwości zależności tylko do odczytu."
  overload: System.Windows.DependencyProperty.OverrideMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.OwnerType
  id: OwnerType
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: OwnerType
  nameWithType: DependencyProperty.OwnerType
  fullName: System.Windows.DependencyProperty.OwnerType
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Pobiera typ obiektu, który jest zarejestrowany w systemie właściwość właściwości zależności lub dodaje się jako właściciela właściwości."
  remarks: "Ta wartość zostało podane podczas rejestracji właściwości. Właściciel będzie albo oryginalnego rejestracji typu w odniesieniu <xref:System.Windows.DependencyProperty>generowane na podstawie identyfikatora <xref:System.Windows.DependencyProperty.Register%2A>wywołania lub typ, który dodaje się jako właściciel w przypadku <xref:System.Windows.DependencyProperty>generowane na podstawie identyfikatora <xref:System.Windows.DependencyProperty.AddOwner%2A>wywołań.</xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.Register%2A> </xref:System.Windows.DependencyProperty>       OwnerType na żadnej podanej <xref:System.Windows.DependencyProperty>jest niemodyfikowalna i nie może być `null` prawidłową <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty>"
  example:
  - "The following example gets the owner type based on a dependency property identifier `dp`, and then gets metadata on the owner type for that same identifier. This operation is actually equivalent to getting <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> on `dp`.  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]"
  syntax:
    content: public Type OwnerType { get; }
    return:
      type: System.Type
      description: "Typ obiektu, który zarejestrowany właściwość lub dodaje się jako właściciela właściwości."
  overload: System.Windows.DependencyProperty.OwnerType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.PropertyType
  id: PropertyType
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: PropertyType
  nameWithType: DependencyProperty.PropertyType
  fullName: System.Windows.DependencyProperty.PropertyType
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Pobiera typ, który używa właściwości zależności dla jej wartości."
  remarks: "Ta właściwość raportuje typ wartości właściwości w postaci zadeklarowanej przez pierwotnej rejestracji właściwości, za pomocą `propertyType` parametru. Podobnie jak <xref:System.Windows.DependencyProperty.Name%2A>, typ właściwości właściwości zależności nie można modyfikować po rejestracji.</xref:System.Windows.DependencyProperty.Name%2A>"
  example:
  - "The following example queries various characteristics of a dependency property identifier, including the PropertyType. The type name string of the PropertyType is obtained from the returned <xref:System.Type>.  \n  \n [!code-cs[PropertySystemEsoterics#DPProps](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpprops)]\n [!code-vb[PropertySystemEsoterics#DPProps](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpprops)]"
  syntax:
    content: public Type PropertyType { get; }
    return:
      type: System.Type
      description: "<xref:System.Type>Wartości właściwości.</xref:System.Type>"
  overload: System.Windows.DependencyProperty.PropertyType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.ReadOnly
  id: ReadOnly
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: ReadOnly
  nameWithType: DependencyProperty.ReadOnly
  fullName: System.Windows.DependencyProperty.ReadOnly
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Pobiera wartość wskazującą, czy właściwość zależności jest identyfikowane przez to <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> wystąpienie jest właściwością tylko do odczytu zależności."
  remarks: "Właściwości tylko do odczytu zależności są zarejestrowane w systemie właściwości przez wywołanie metody <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>metody, w przeciwieństwie do <xref:System.Windows.DependencyProperty.Register%2A>metody.</xref:System.Windows.DependencyProperty.Register%2A> </xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> Dołączone właściwości może być również zarejestrowany jako tylko do odczytu. zobacz <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.</xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>       Właściwości tylko do odczytu zależności wymagają <xref:System.Windows.DependencyPropertyKey>identyfikator zamiast <xref:System.Windows.DependencyProperty>identyfikator do wykonywania operacji na metadanych, takich jak zastępowanie metadanych lub ustawiania wartości.</xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyPropertyKey> Jeśli użytkownik uzyskał Kolekcja <xref:System.Windows.DependencyProperty>identyfikatory poprzez wywołanie <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A>lub innym [!INCLUDE[TLA2#tla_api](~/add/includes/tla2sharptla-api-md.md)] który uwidacznia identyfikatory, należy sprawdzić wartość tylko do odczytu, przed podjęciem ponownej próby wywołania <xref:System.Windows.DependencyObject.SetValue%2A>lub <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>przy użyciu tego identyfikatora właściwości zależności jako parametr wejściowy, aby sprawdzić, czy właściwości zależności, który reprezentuje identyfikator nie jest tylko do odczytu.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyObject.SetValue%2A> </xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> </xref:System.Windows.DependencyProperty> Jeśli wartość tylko do odczytu jest `true` we właściwości zależności nie istnieje sposób programowy uzyskać odwołania do <xref:System.Windows.DependencyPropertyKey>identyfikatora właściwości zależności, z metadanych lub <xref:System.Windows.DependencyProperty>identyfikator; identyfikator muszą być dostępne jako statyczne pole w celu wywołania <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>względem właściwości zależności tylko do odczytu.</xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> </xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyPropertyKey>       Podczas tworzenia właściwości zależności niestandardowe i zarejestruj go jako tylko do odczytu, należy zdefiniować tylko metody dostępu get dla [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] właściwości otoki. W przeciwnym razie klasy mają mylące model obiektów dla otoki właściwości w porównaniu do dostępu do właściwości zależności zapasowego. Aby uzyskać więcej informacji, zobacz [właściwości zależności niestandardowe](~/add/includes/ajax-current-ext-md.md) lub [tylko do odczytu właściwości zależności](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example obtains the default metadata and the dependency property identifier properties from various dependency property fields, and uses the information to populate a table to implement a \"metadata browser\".  \n  \n [!code-cs[PropertySystemEsoterics#DPProps](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpprops)]\n [!code-vb[PropertySystemEsoterics#DPProps](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpprops)]"
  syntax:
    content: public bool ReadOnly { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli właściwość zależności jest tylko do odczytu. w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.DependencyProperty.ReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)
  id: Register(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Register(String,Type,Type)
  nameWithType: DependencyProperty.Register(String,Type,Type)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Określona nazwa właściwości, typ właściwości i typ właściciela rejestruje właściwości zależności."
  remarks: "Aby uzyskać więcej informacji dotyczących rejestracji właściwości zależności zobacz <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  example:
  - >-
    [!code-cs[WPFAquariumSln#Register3Param](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#register3param)]
     [!code-vb[WPFAquariumSln#Register3Param](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#register3param)]
  syntax:
    content: public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);
    parameters:
    - id: name
      type: System.String
      description: "Nazwa właściwości zależności, aby zarejestrować. Nazwa musi być unikatowa w ramach rejestracji przestrzeni nazw typu właściciela."
    - id: propertyType
      type: System.Type
      description: "Typ właściwości."
    - id: ownerType
      type: System.Type
      description: "Typ właściciela, który rejestruje właściwości zależności."
    return:
      type: System.Windows.DependencyProperty
      description: "Identyfikator właściwości zależności, które mają być używane do ustawienia wartości <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> pole w klasie. Ten identyfikator jest następnie używany do później, odwołania właściwości zależności dla operacji, takich jak programowo ustawiania dla niego wartości i uzyskiwanie metadanych."
  overload: System.Windows.DependencyProperty.Register*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Register(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Rejestruje właściwości zależności określona nazwa właściwości, typ właściwości, typ właściciela i metadane właściwości."
  remarks: "Aby uzyskać więcej informacji dotyczących rejestracji właściwości zależności zobacz <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  syntax:
    content: public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: name
      type: System.String
      description: "Nazwa właściwości zależności, aby zarejestrować."
    - id: propertyType
      type: System.Type
      description: "Typ właściwości."
    - id: ownerType
      type: System.Type
      description: "Typ właściciela, który rejestruje właściwości zależności."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Metadane właściwości dla właściwości zależności."
    return:
      type: System.Windows.DependencyProperty
      description: "Identyfikator właściwości zależności, które mają być używane do ustawienia wartości <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> pole w klasie. Ten identyfikator jest następnie używany do później, odwołania właściwości zależności dla operacji, takich jak programowo ustawiania dla niego wartości i uzyskiwanie metadanych."
  overload: System.Windows.DependencyProperty.Register*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Określona nazwa właściwości, typ właściwości, typ właściciela, metadane właściwości i wywołanie zwrotne weryfikacji wartości dla właściwości rejestruje właściwości zależności."
  remarks: "Aby uzyskać więcej informacji dotyczących rejestracji właściwości zależności zobacz <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  example:
  - "The following example registers a dependency property, including a validation callback (the callback definition is not shown; for details on the callback definition, see <xref:System.Windows.ValidateValueCallback>).  \n  \n [!code-cs[DPCallbackOverride#CurrentDefinitionWithWrapper](~/add/codesnippet/csharp/DPCallbackOverride/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]\n [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/add/codesnippet/visualbasic/DPCallbackOverride.sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]"
  syntax:
    content: public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "Nazwa właściwości zależności, aby zarejestrować."
    - id: propertyType
      type: System.Type
      description: "Typ właściwości."
    - id: ownerType
      type: System.Type
      description: "Typ właściciela, który rejestruje właściwości zależności."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Metadane właściwości dla właściwości zależności."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "Odwołanie do wywołania zwrotnego, które należy wykonać wszelkie niestandardowego sprawdzania poprawności wartości właściwości zależności poza typowy Typ weryfikacji."
    return:
      type: System.Windows.DependencyProperty
      description: "Identyfikator właściwości zależności, które mają być używane do ustawienia wartości <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> pole w klasie. Ten identyfikator jest następnie używany do później, odwołania właściwości zależności dla operacji, takich jak programowo ustawiania dla niego wartości i uzyskiwanie metadanych."
  overload: System.Windows.DependencyProperty.Register*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)
  id: RegisterAttached(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttached(String,Type,Type)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Rejestruje dołączona właściwość o nazwie określonej właściwości, typ właściwości i typ właściciela."
  remarks: "Dołączona właściwość to pojęcie właściwości zdefiniowane przez [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]implementuje dołączone właściwości jako właściwości zależności. Ponieważ [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] właściwości zależności są dołączone właściwości, mogą oni mieć metadanych stosowane używaną przez system ogólne właściwości dla operacji, takich jak raportowanie właściwości układu. Aby uzyskać więcej informacji, zobacz [dołączony Przegląd właściwości](~/add/includes/ajax-current-ext-md.md).       Aby uzyskać więcej informacji dotyczących rejestracji właściwości zależności zobacz <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  example:
  - "The following example registers an attached property on an abstract class using this RegisterAttached signature.  \n  \n [!code-cs[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]\n [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]"
  syntax:
    content: public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);
    parameters:
    - id: name
      type: System.String
      description: "Nazwa właściwości zależności, aby zarejestrować."
    - id: propertyType
      type: System.Type
      description: "Typ właściwości."
    - id: ownerType
      type: System.Type
      description: "Typ właściciela, który rejestruje właściwości zależności."
    return:
      type: System.Windows.DependencyProperty
      description: "Identyfikator właściwości zależności, które mają być używane do ustawienia wartości <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> pole w klasie. Ten identyfikator jest następnie używany do później, odwołania właściwości zależności dla operacji, takich jak programowo ustawiania dla niego wartości i uzyskiwanie metadanych."
  overload: System.Windows.DependencyProperty.RegisterAttached*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttached(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Rejestruje dołączona właściwość określona nazwa właściwości, typ właściwości, typ właściciela i metadane właściwości."
  remarks: "An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] implements attached properties as dependency properties. Because the [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics. For more information, see [Attached Properties Overview](~/add/includes/ajax-current-ext-md.md).  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property with RegisterAttached instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance. You should register value-inheriting dependency properties with RegisterAttached even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use RegisterAttached to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);
    parameters:
    - id: name
      type: System.String
      description: "Nazwa właściwości zależności, aby zarejestrować."
    - id: propertyType
      type: System.Type
      description: "Typ właściwości."
    - id: ownerType
      type: System.Type
      description: "Typ właściciela, który rejestruje właściwości zależności."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "Metadane właściwości dla właściwości zależności. Mogą to wartość domyślna, a także inne właściwości."
    return:
      type: System.Windows.DependencyProperty
      description: "Identyfikator właściwości zależności, które mają być używane do ustawienia wartości <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> pole w klasie. Ten identyfikator jest następnie używany do później, odwołania właściwości zależności dla operacji, takich jak programowo ustawiania dla niego wartości i uzyskiwanie metadanych."
  overload: System.Windows.DependencyProperty.RegisterAttached*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Rejestruje dołączona właściwość z określonym typem właściwości, typ właściciela, metadane właściwości i wywołanie zwrotne weryfikacji wartości dla właściwości."
  remarks: "An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] implements attached properties as dependency properties. Because the [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics. For more information, see [Attached Properties Overview](~/add/includes/ajax-current-ext-md.md).  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance. You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example registers an attached property on an abstract class using this RegisterAttached signature. This attached property is an enumeration type property, and the registration adds a validation callback to verify that the provided value is a value of the enumeration.  \n  \n [!code-cs[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]\n [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]"
  syntax:
    content: public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "Nazwa właściwości zależności, aby zarejestrować."
    - id: propertyType
      type: System.Type
      description: "Typ właściwości."
    - id: ownerType
      type: System.Type
      description: "Typ właściciela, który rejestruje właściwości zależności."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "Metadane właściwości dla właściwości zależności. Mogą to wartość domyślna, a także inne właściwości."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "Odwołanie do wywołania zwrotnego, które należy wykonać wszelkie niestandardowego sprawdzania poprawności wartości właściwości zależności poza typowy Typ weryfikacji."
    return:
      type: System.Windows.DependencyProperty
      description: "Identyfikator właściwości zależności, które mają być używane do ustawienia wartości <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> pole w klasie. Ten identyfikator jest następnie używany do później, odwołania właściwości zależności dla operacji, takich jak programowo ustawiania dla niego wartości i uzyskiwanie metadanych."
  overload: System.Windows.DependencyProperty.RegisterAttached*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Rejestruje tylko do odczytu dołączona właściwość, z określonym typem właściwości, typ właściciela i metadane właściwości."
  remarks: "This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>. Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic. It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName> as a `public static readonly` field on your class.  \n  \n Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]. Without a public setter, an attached property cannot be set in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] syntax.  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property as attached is to support property value inheritance. You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);
    parameters:
    - id: name
      type: System.String
      description: "Nazwa właściwości zależności, aby zarejestrować."
    - id: propertyType
      type: System.Type
      description: "Typ właściwości."
    - id: ownerType
      type: System.Type
      description: "Typ właściciela, który rejestruje właściwości zależności."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "Metadane właściwości dla właściwości zależności."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "Klucz właściwości zależności, które mają być używane do wartości pola statycznego tylko do odczytu w klasie, która jest następnie używany do odwołania właściwości zależności później."
  overload: System.Windows.DependencyProperty.RegisterAttachedReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Rejestruje tylko do odczytu dołączona właściwość, z określonym typem właściwości, typ właściciela metadanych właściwości i wywołanie zwrotne weryfikacji."
  remarks: "This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>. Typically, the keys that represent the type <xref:System.Windows.DependencyProperty>. Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic. It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName> as a `public static readonly` field on your class.  \n  \n Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]. Without a public setter, an attached property cannot be set in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] syntax.  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property as attached instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance. You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "Nazwa właściwości zależności, aby zarejestrować."
    - id: propertyType
      type: System.Type
      description: "Typ właściwości."
    - id: ownerType
      type: System.Type
      description: "Typ właściciela, który rejestruje właściwości zależności."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "Metadane właściwości dla właściwości zależności."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "Odwołanie do utworzonych przez użytkownika wywołanie zwrotne, które należy wykonać wszelkie niestandardowego sprawdzania poprawności wartości właściwości zależności poza typowy Typ weryfikacji."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "Klucz właściwości zależności, które mają być używane do wartości pola statycznego tylko do odczytu w klasie, która jest następnie używany do odwołania właściwości zależności."
  overload: System.Windows.DependencyProperty.RegisterAttachedReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Rejestruje właściwości tylko do odczytu zależności, z określonym typem właściwości, typ właściciela i metadane właściwości."
  remarks: "Ta metoda zwraca typ <xref:System.Windows.DependencyPropertyKey>, podczas gdy <xref:System.Windows.DependencyProperty.RegisterAttached%2A>zwraca typ <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.RegisterAttached%2A> </xref:System.Windows.DependencyPropertyKey> Zazwyczaj nie zostaną wprowadzone publiczne, klucze, które reprezentują właściwości tylko do odczytu, ponieważ klucze można ustawić wartości właściwości zależności przez wywołanie metody <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> Projekt klasy będzie miało wpływ na wymagania dotyczące, ale ogólnie zaleca się ograniczyć dostęp i widoczności dowolnego <xref:System.Windows.DependencyPropertyKey>tylko te części kodu, które są niezbędne, można ustawić tej właściwości zależności w ramach klasy lub aplikacji logiki.</xref:System.Windows.DependencyPropertyKey> Zaleca się również ujawniać identyfikatora właściwości zależności dla właściwości tylko do odczytu zależności, w przypadku wystawianego wartość <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>jako `public static readonly` na Twojej klasy</xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>       Właściwości tylko do odczytu zależności są dość typowy scenariusz zarówno w istniejących [!INCLUDE[TLA2#tla_api](~/add/includes/tla2sharptla-api-md.md)] i dostosowania, ponieważ inne [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] funkcje mogą wymagać właściwości zależności, nawet jeśli tej właściwości nie może być można ustawić przez obiekty wywołujące. Możesz użyć wartości właściwości tylko do odczytu zależności na podstawie innych operacji system właściwości, które przyjmują właściwość zależności, takich jak utworzenie <xref:System.Windows.Trigger>we właściwości zależności w stylu.</xref:System.Windows.Trigger>       Aby uzyskać więcej informacji dotyczących rejestracji właściwości zależności zobacz <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  example:
  - "The following example registers an `AquariumSize` dependency property as read-only. The example defines `AquariumSizeKey` as an internal key (so that other classes in the assembly could override metadata) and exposes the dependency property identifier based on that key as `AquariumSizeProperty`. Also, a wrapper is created for `AquariumSize`, with only a get accessor.  \n  \n [!code-cs[WPFAquariumSln#RODP](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#rodp)]\n [!code-vb[WPFAquariumSln#RODP](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#rodp)]"
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: name
      type: System.String
      description: "Nazwa właściwości zależności, aby zarejestrować."
    - id: propertyType
      type: System.Type
      description: "Typ właściwości."
    - id: ownerType
      type: System.Type
      description: "Typ właściciela, który rejestruje właściwości zależności."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Metadane właściwości dla właściwości zależności."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "Klucz właściwości zależności, które mają być używane do wartości pola statycznego tylko do odczytu w klasie, która jest następnie używany do odwołania właściwości zależności."
  overload: System.Windows.DependencyProperty.RegisterReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Rejestruje właściwości tylko do odczytu zależności, z określonym typem właściwości, typ właściciela metadane właściwości i wywołanie zwrotne weryfikacji."
  remarks: "Ta metoda zwraca typ <xref:System.Windows.DependencyPropertyKey>, podczas gdy <xref:System.Windows.DependencyProperty.RegisterAttached%2A>zwraca typ <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.RegisterAttached%2A> </xref:System.Windows.DependencyPropertyKey> Zazwyczaj nie zostaną wprowadzone publiczne, klucze, które reprezentują właściwości tylko do odczytu, ponieważ klucze można ustawić wartości właściwości zależności przez wywołanie metody <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> Projekt klasy będzie miało wpływ na wymagania dotyczące, ale ogólnie zaleca się ograniczyć dostęp i widoczności dowolnego <xref:System.Windows.DependencyPropertyKey>tylko te części kodu, które są niezbędne, można ustawić tej właściwości zależności w ramach klasy lub aplikacji logiki.</xref:System.Windows.DependencyPropertyKey> Zaleca się również ujawniać identyfikatora właściwości zależności dla właściwości tylko do odczytu zależności, w przypadku wystawianego wartość <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>jako `public static readonly` na Twojej klasy</xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>       Właściwości tylko do odczytu zależności są dość typowy scenariusz. Możesz użyć wartości właściwości tylko do odczytu zależności na podstawie innych operacji system właściwości, które przyjmują właściwość zależności, takich jak utworzenie <xref:System.Windows.Trigger>we właściwości zależności w stylu.</xref:System.Windows.Trigger>       Aby uzyskać więcej informacji dotyczących rejestracji właściwości zależności zobacz <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>       Sprawdzanie poprawności właściwości tylko do odczytu zależności może być mniej ważne. Poziom dostępu niepubliczne, które określisz klucza zmniejsza prawdopodobieństwo dla dowolnego nieprawidłowe dane wejściowe."
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "Nazwa właściwości zależności, aby zarejestrować."
    - id: propertyType
      type: System.Type
      description: "Typ właściwości."
    - id: ownerType
      type: System.Type
      description: "Typ właściciela, który rejestruje właściwości zależności."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Metadane właściwości dla właściwości zależności."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "Odwołanie do utworzonych przez użytkownika wywołanie zwrotne, które należy wykonać wszelkie niestandardowego sprawdzania poprawności wartości właściwości zależności poza typowy Typ weryfikacji."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "Klucz właściwości zależności, które mają być używane do wartości pola statycznego tylko do odczytu w klasie, która jest następnie używany do odwołania właściwości zależności później."
  overload: System.Windows.DependencyProperty.RegisterReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.ToString
  id: ToString
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: ToString()
  nameWithType: DependencyProperty.ToString()
  fullName: System.Windows.DependencyProperty.ToString()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Zwraca reprezentację ciągu właściwości zależności."
  remarks: "Ta implementacja zwraca <xref:System.Windows.DependencyProperty.Name%2A>wartości właściwości.</xref:System.Windows.DependencyProperty.Name%2A>"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "Reprezentacja ciągu właściwości zależności."
  overload: System.Windows.DependencyProperty.ToString*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.UnsetValue
  id: UnsetValue
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: UnsetValue
  nameWithType: DependencyProperty.UnsetValue
  fullName: System.Windows.DependencyProperty.UnsetValue
  type: Field
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Określa wartość statyczną, który jest używany przez [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] właściwości systemu zamiast <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> aby wskazać, że właściwość istnieje, ale nie ma jej wartość właściwości systemu."
  remarks: "UnsetValue jest wartością wskaźnikowych, która jest używana w scenariuszach, gdzie [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] właściwości system nie mógł określić zażądano <xref:System.Windows.DependencyProperty>wartość.</xref:System.Windows.DependencyProperty> UnsetValue jest używany zamiast `null`, ponieważ `null` może mieć prawidłową wartość właściwości, a także prawidłowy (i często używane) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.</xref:System.Windows.PropertyMetadata.DefaultValue%2A>       UnsetValue nigdy nie jest zwracana poza <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName>.</xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName> Podczas wywoływania <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName>we właściwości zależności na <xref:System.Windows.DependencyObject>wystąpienia, jedno z następujących stosuje: - właściwości zależności ma wartość domyślną w metadanych i ta wartość jest zwracana.</xref:System.Windows.DependencyObject> </xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName> Ta wartość może pochodzić z <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.</xref:System.Windows.DependencyProperty.DefaultMetadata%2A>      -Wartość zostało ustanowione przez właściwości systemu, a wartość domyślna jest już nieaktualny. Aby uzyskać więcej informacji, zobacz [pierwszeństwo wartość właściwości zależności](~/add/includes/ajax-current-ext-md.md).       Ustawienie <xref:System.Windows.PropertyMetadata.DefaultValue%2A>z UnsetValue w szczególności jest niedozwolone.</xref:System.Windows.PropertyMetadata.DefaultValue%2A>       <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=fullName>Zwraca UnsetValue, gdy żądana właściwość nie została lokalnie ustawiona.</xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=fullName>       UnsetValue ma specjalne znaczenie, gdy jest używany jako wartość zwracaną <xref:System.Windows.CoerceValueCallback>.</xref:System.Windows.CoerceValueCallback> Aby uzyskać więcej informacji, zobacz [wywołania zwrotne właściwości zależności i sprawdzania poprawności](~/add/includes/ajax-current-ext-md.md).       Są wiązane z bazą danych, należy pamiętać, że UnsetValue nie jest odpowiednikiem <xref:System.DBNull.Value>, w podobny sposób jak <xref:System.DBNull.Value>nie jest równoważna wartości true wartość null.</xref:System.DBNull.Value> </xref:System.DBNull.Value>"
  syntax:
    content: public static readonly object UnsetValue;
    return:
      type: System.Object
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.ValidateValueCallback
  id: ValidateValueCallback
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: ValidateValueCallback
  nameWithType: DependencyProperty.ValidateValueCallback
  fullName: System.Windows.DependencyProperty.ValidateValueCallback
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Pobiera wywołanie zwrotne weryfikacji wartości dla właściwości zależności."
  remarks: "Ta właściwość będzie zawierać `null` dla każdej właściwości zależności, bez sprawdzania poprawności w zarejestrowany wywołania zwrotnego.       Zweryfikować wartości wywołania zwrotne musi działać w statycznej znaczeniu: Sprawdzanie poprawności stosowane przy użyciu <xref:System.Windows.ValidateValueCallback>nie może określić, czy podana wartość jest nieprawidłowa dla dowolne wystąpienie.</xref:System.Windows.ValidateValueCallback> Wywołanie zwrotne tylko można określić, czy wszystkie obiekty, które posiadają właściwości zależności powinien lub nie powinien akceptować podanej wartości jako prawidłowy. Jeśli potrzebujesz sprawdzania poprawności opartym na wiedzy o wartości innych właściwości zależności na konkretnym wystąpieniu, użyj <xref:System.Windows.CoerceValueCallback>zamiast.</xref:System.Windows.CoerceValueCallback> <xref:System.Windows.CoerceValueCallback>Jest zarejestrowany w ramach metadanych właściwości zależności, a nie bezpośrednio z poziomu identyfikatora właściwości zależności.</xref:System.Windows.CoerceValueCallback> Aby uzyskać więcej informacji, zobacz [wywołania zwrotne właściwości zależności i sprawdzania poprawności](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Windows.ValidateValueCallback ValidateValueCallback { get; }
    return:
      type: System.Windows.ValidateValueCallback
      description: "Wywołanie zwrotne weryfikacji wartość dla tej właściwości zależności, zgodnie z <code> validateValueCallback </code> parametru w pierwotnej rejestracji właściwości zależności."
  overload: System.Windows.DependencyProperty.ValidateValueCallback*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Windows.DependencyProperty.AddOwner(System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: AddOwner(Type)
  nameWithType: DependencyProperty.AddOwner(Type)
  fullName: System.Windows.DependencyProperty.AddOwner(Type)
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: AddOwner(Type,PropertyMetadata)
  nameWithType: DependencyProperty.AddOwner(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.AddOwner(Type,PropertyMetadata)
- uid: System.Windows.PropertyMetadata
  parent: System.Windows
  isExternal: false
  name: PropertyMetadata
  nameWithType: PropertyMetadata
  fullName: System.Windows.PropertyMetadata
- uid: System.Windows.DependencyProperty.DefaultMetadata
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: DefaultMetadata
  nameWithType: DependencyProperty.DefaultMetadata
  fullName: System.Windows.DependencyProperty.DefaultMetadata
- uid: System.Windows.DependencyProperty.GetHashCode
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetHashCode()
  nameWithType: DependencyProperty.GetHashCode()
  fullName: System.Windows.DependencyProperty.GetHashCode()
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.DependencyProperty.GetMetadata(System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata(Type)
  nameWithType: DependencyProperty.GetMetadata(Type)
  fullName: System.Windows.DependencyProperty.GetMetadata(Type)
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata(DependencyObject)
  nameWithType: DependencyProperty.GetMetadata(DependencyObject)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObject)
- uid: System.Windows.DependencyObject
  parent: System.Windows
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata(DependencyObjectType)
  nameWithType: DependencyProperty.GetMetadata(DependencyObjectType)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObjectType)
- uid: System.Windows.DependencyObjectType
  parent: System.Windows
  isExternal: false
  name: DependencyObjectType
  nameWithType: DependencyObjectType
  fullName: System.Windows.DependencyObjectType
- uid: System.Windows.DependencyProperty.GlobalIndex
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GlobalIndex
  nameWithType: DependencyProperty.GlobalIndex
  fullName: System.Windows.DependencyProperty.GlobalIndex
- uid: System.Windows.DependencyProperty.IsValidType(System.Object)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidType(Object)
  nameWithType: DependencyProperty.IsValidType(Object)
  fullName: System.Windows.DependencyProperty.IsValidType(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.DependencyProperty.IsValidValue(System.Object)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidValue(Object)
  nameWithType: DependencyProperty.IsValidValue(Object)
  fullName: System.Windows.DependencyProperty.IsValidValue(Object)
- uid: System.Windows.DependencyProperty.Name
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Name
  nameWithType: DependencyProperty.Name
  fullName: System.Windows.DependencyProperty.Name
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OverrideMetadata(Type,PropertyMetadata)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
- uid: System.Windows.DependencyPropertyKey
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyKey
  nameWithType: DependencyPropertyKey
  fullName: System.Windows.DependencyPropertyKey
- uid: System.Windows.DependencyProperty.OwnerType
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OwnerType
  nameWithType: DependencyProperty.OwnerType
  fullName: System.Windows.DependencyProperty.OwnerType
- uid: System.Windows.DependencyProperty.PropertyType
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: PropertyType
  nameWithType: DependencyProperty.PropertyType
  fullName: System.Windows.DependencyProperty.PropertyType
- uid: System.Windows.DependencyProperty.ReadOnly
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ReadOnly
  nameWithType: DependencyProperty.ReadOnly
  fullName: System.Windows.DependencyProperty.ReadOnly
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register(String,Type,Type)
  nameWithType: DependencyProperty.Register(String,Type,Type)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type)
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.ValidateValueCallback
  parent: System.Windows
  isExternal: false
  name: ValidateValueCallback
  nameWithType: ValidateValueCallback
  fullName: System.Windows.ValidateValueCallback
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached(String,Type,Type)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type)
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.DependencyProperty.ToString
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ToString()
  nameWithType: DependencyProperty.ToString()
  fullName: System.Windows.DependencyProperty.ToString()
- uid: System.Windows.DependencyProperty.UnsetValue
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: UnsetValue
  nameWithType: DependencyProperty.UnsetValue
  fullName: System.Windows.DependencyProperty.UnsetValue
- uid: System.Windows.DependencyProperty.ValidateValueCallback
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ValidateValueCallback
  nameWithType: DependencyProperty.ValidateValueCallback
  fullName: System.Windows.DependencyProperty.ValidateValueCallback
- uid: System.Windows.DependencyProperty.AddOwner*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: AddOwner
  nameWithType: DependencyProperty.AddOwner
- uid: System.Windows.DependencyProperty.DefaultMetadata*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: DefaultMetadata
  nameWithType: DependencyProperty.DefaultMetadata
- uid: System.Windows.DependencyProperty.GetHashCode*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetHashCode
  nameWithType: DependencyProperty.GetHashCode
- uid: System.Windows.DependencyProperty.GetMetadata*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata
  nameWithType: DependencyProperty.GetMetadata
- uid: System.Windows.DependencyProperty.GlobalIndex*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GlobalIndex
  nameWithType: DependencyProperty.GlobalIndex
- uid: System.Windows.DependencyProperty.IsValidType*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidType
  nameWithType: DependencyProperty.IsValidType
- uid: System.Windows.DependencyProperty.IsValidValue*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidValue
  nameWithType: DependencyProperty.IsValidValue
- uid: System.Windows.DependencyProperty.Name*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Name
  nameWithType: DependencyProperty.Name
- uid: System.Windows.DependencyProperty.OverrideMetadata*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OverrideMetadata
  nameWithType: DependencyProperty.OverrideMetadata
- uid: System.Windows.DependencyProperty.OwnerType*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OwnerType
  nameWithType: DependencyProperty.OwnerType
- uid: System.Windows.DependencyProperty.PropertyType*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: PropertyType
  nameWithType: DependencyProperty.PropertyType
- uid: System.Windows.DependencyProperty.ReadOnly*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ReadOnly
  nameWithType: DependencyProperty.ReadOnly
- uid: System.Windows.DependencyProperty.Register*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register
  nameWithType: DependencyProperty.Register
- uid: System.Windows.DependencyProperty.RegisterAttached*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached
  nameWithType: DependencyProperty.RegisterAttached
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttachedReadOnly
  nameWithType: DependencyProperty.RegisterAttachedReadOnly
- uid: System.Windows.DependencyProperty.RegisterReadOnly*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterReadOnly
  nameWithType: DependencyProperty.RegisterReadOnly
- uid: System.Windows.DependencyProperty.ToString*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ToString
  nameWithType: DependencyProperty.ToString
- uid: System.Windows.DependencyProperty.ValidateValueCallback*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ValidateValueCallback
  nameWithType: DependencyProperty.ValidateValueCallback
