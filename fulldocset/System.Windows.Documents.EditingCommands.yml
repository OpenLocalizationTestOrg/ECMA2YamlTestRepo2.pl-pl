### YamlMime:ManagedReference
items:
- uid: System.Windows.Documents.EditingCommands
  id: EditingCommands
  children:
  - System.Windows.Documents.EditingCommands.AlignCenter
  - System.Windows.Documents.EditingCommands.AlignJustify
  - System.Windows.Documents.EditingCommands.AlignLeft
  - System.Windows.Documents.EditingCommands.AlignRight
  - System.Windows.Documents.EditingCommands.Backspace
  - System.Windows.Documents.EditingCommands.CorrectSpellingError
  - System.Windows.Documents.EditingCommands.DecreaseFontSize
  - System.Windows.Documents.EditingCommands.DecreaseIndentation
  - System.Windows.Documents.EditingCommands.Delete
  - System.Windows.Documents.EditingCommands.DeleteNextWord
  - System.Windows.Documents.EditingCommands.DeletePreviousWord
  - System.Windows.Documents.EditingCommands.EnterLineBreak
  - System.Windows.Documents.EditingCommands.EnterParagraphBreak
  - System.Windows.Documents.EditingCommands.IgnoreSpellingError
  - System.Windows.Documents.EditingCommands.IncreaseFontSize
  - System.Windows.Documents.EditingCommands.IncreaseIndentation
  - System.Windows.Documents.EditingCommands.MoveDownByLine
  - System.Windows.Documents.EditingCommands.MoveDownByPage
  - System.Windows.Documents.EditingCommands.MoveDownByParagraph
  - System.Windows.Documents.EditingCommands.MoveLeftByCharacter
  - System.Windows.Documents.EditingCommands.MoveLeftByWord
  - System.Windows.Documents.EditingCommands.MoveRightByCharacter
  - System.Windows.Documents.EditingCommands.MoveRightByWord
  - System.Windows.Documents.EditingCommands.MoveToDocumentEnd
  - System.Windows.Documents.EditingCommands.MoveToDocumentStart
  - System.Windows.Documents.EditingCommands.MoveToLineEnd
  - System.Windows.Documents.EditingCommands.MoveToLineStart
  - System.Windows.Documents.EditingCommands.MoveUpByLine
  - System.Windows.Documents.EditingCommands.MoveUpByPage
  - System.Windows.Documents.EditingCommands.MoveUpByParagraph
  - System.Windows.Documents.EditingCommands.SelectDownByLine
  - System.Windows.Documents.EditingCommands.SelectDownByPage
  - System.Windows.Documents.EditingCommands.SelectDownByParagraph
  - System.Windows.Documents.EditingCommands.SelectLeftByCharacter
  - System.Windows.Documents.EditingCommands.SelectLeftByWord
  - System.Windows.Documents.EditingCommands.SelectRightByCharacter
  - System.Windows.Documents.EditingCommands.SelectRightByWord
  - System.Windows.Documents.EditingCommands.SelectToDocumentEnd
  - System.Windows.Documents.EditingCommands.SelectToDocumentStart
  - System.Windows.Documents.EditingCommands.SelectToLineEnd
  - System.Windows.Documents.EditingCommands.SelectToLineStart
  - System.Windows.Documents.EditingCommands.SelectUpByLine
  - System.Windows.Documents.EditingCommands.SelectUpByPage
  - System.Windows.Documents.EditingCommands.SelectUpByParagraph
  - System.Windows.Documents.EditingCommands.TabBackward
  - System.Windows.Documents.EditingCommands.TabForward
  - System.Windows.Documents.EditingCommands.ToggleBold
  - System.Windows.Documents.EditingCommands.ToggleBullets
  - System.Windows.Documents.EditingCommands.ToggleInsert
  - System.Windows.Documents.EditingCommands.ToggleItalic
  - System.Windows.Documents.EditingCommands.ToggleNumbering
  - System.Windows.Documents.EditingCommands.ToggleSubscript
  - System.Windows.Documents.EditingCommands.ToggleSuperscript
  - System.Windows.Documents.EditingCommands.ToggleUnderline
  langs:
  - csharp
  name: EditingCommands
  nameWithType: EditingCommands
  fullName: System.Windows.Documents.EditingCommands
  type: Class
  summary: "Zawiera standardowy zestaw pokrewne polecenia edycji."
  remarks: "W poniższej tabeli przedstawiono poleceń edycji i skojarzoną domyślną gestów klucza (z nazwami kluczy z <xref:System.Windows.Input.Key>i <xref:System.Windows.Input.ModifierKeys>wyliczenia).</xref:System.Windows.Input.ModifierKeys> </xref:System.Windows.Input.Key>      | Polecenie edytowania | Domyślna klucza gestu |   |---------------------|-------------------------|   | <xref:System.Windows.Documents.EditingCommands.AlignCenter%2A>| `Ctrl`+`E`|   | <xref:System.Windows.Documents.EditingCommands.AlignJustify%2A>| `Ctrl`+`J`|   | <xref:System.Windows.Documents.EditingCommands.AlignLeft%2A>| `Ctrl`+`L`|   | <xref:System.Windows.Documents.EditingCommands.AlignRight%2A>| `Ctrl`+`R`|   | <xref:System.Windows.Documents.EditingCommands.Backspace%2A>| `Backspace`|   | <xref:System.Windows.Documents.EditingCommands.CorrectSpellingError%2A>| gestu klucza nie domyślne |   | <xref:System.Windows.Documents.EditingCommands.DecreaseFontSize%2A>| `Ctrl`+`OemOpenBrackets`|   | <xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A>| `Ctrl`+`Shift`+`T`|   | <xref:System.Windows.Documents.EditingCommands.Delete%2A>| `Delete`|   | <xref:System.Windows.Documents.EditingCommands.DeleteNextWord%2A>| `Ctrl`+`Delete`|   | <xref:System.Windows.Documents.EditingCommands.DeletePreviousWord%2A>| `Ctrl`+`Backspace`|   | <xref:System.Windows.Documents.EditingCommands.EnterLineBreak%2A>| `Shift`+`Enter`|   | <xref:System.Windows.Documents.EditingCommands.EnterParagraphBreak%2A>| `Enter`|   | <xref:System.Windows.Documents.EditingCommands.IgnoreSpellingError%2A>| gestu klucza nie domyślne |   | <xref:System.Windows.Documents.EditingCommands.IncreaseFontSize%2A>| `Ctrl`+`OemCloseBrackets`|   | <xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A>| `Ctrl`+`T`|   | <xref:System.Windows.Documents.EditingCommands.MoveDownByLine%2A>| `Down`|   | <xref:System.Windows.Documents.EditingCommands.MoveDownByPage%2A>| `PageDown`|   | <xref:System.Windows.Documents.EditingCommands.MoveDownByParagraph%2A>| `Ctrl`+`Down`|   | <xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A>| `Left`|   | <xref:System.Windows.Documents.EditingCommands.MoveLeftByWord%2A>| `Ctrl`+`Left`|   | <xref:System.Windows.Documents.EditingCommands.MoveRightByCharacter%2A>| `Right`|   | <xref:System.Windows.Documents.EditingCommands.MoveRightByWord%2A>| `Ctrl`+`Right`|   | <xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A>| `Ctrl`+`End`|   | <xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A>| `Ctrl`+`Home`|   | <xref:System.Windows.Documents.EditingCommands.MoveToLineEnd%2A>| `End`|   | <xref:System.Windows.Documents.EditingCommands.MoveToLineStart%2A>| `Home`|   | <xref:System.Windows.Documents.EditingCommands.MoveUpByLine%2A>| `Up`|   | <xref:System.Windows.Documents.EditingCommands.MoveUpByPage%2A>| `PageUp`|   | <xref:System.Windows.Documents.EditingCommands.MoveUpByParagraph%2A>| `Ctrl`+`Up`|   | <xref:System.Windows.Documents.EditingCommands.SelectDownByLine%2A>| `Shift`+`Down`|   | <xref:System.Windows.Documents.EditingCommands.SelectDownByPage%2A>| `Shift`+`PageDown`|   | <xref:System.Windows.Documents.EditingCommands.SelectDownByParagraph%2A>| `Ctrl`+`Shift`+`Down`|   | <xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A>| `Shift`+`Left`|   | <xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A>| `Ctrl`+`Shift`+`Left`|   | <xref:System.Windows.Documents.EditingCommands.SelectRightByCharacter%2A>| `Shift`+`Right`|   | <xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>| `Ctrl`+`Shift`+`Right`|   | <xref:System.Windows.Documents.EditingCommands.SelectToDocumentEnd%2A>| `Ctrl`+`Shift`+`End`|   | <xref:System.Windows.Documents.EditingCommands.SelectToDocumentStart%2A>| `Ctrl`+`Shift`+`Home`|   | <xref:System.Windows.Documents.EditingCommands.SelectToLineEnd%2A>| `Shift`+`End`|   | <xref:System.Windows.Documents.EditingCommands.SelectToLineStart%2A>| `Shift`+`Home`|   | <xref:System.Windows.Documents.EditingCommands.SelectUpByLine%2A>| `Shift`+`Up`|   | <xref:System.Windows.Documents.EditingCommands.SelectUpByPage%2A>| `Shift`+`PageUp`|   | <xref:System.Windows.Documents.EditingCommands.SelectUpByParagraph%2A>| `Ctrl`+`Shift`+`Up`|   | <xref:System.Windows.Documents.EditingCommands.TabBackward%2A>| `Shift`+`Tab`|   | <xref:System.Windows.Documents.EditingCommands.TabForward%2A>| `Tab`|   | <xref:System.Windows.Documents.EditingCommands.ToggleBold%2A>| `Ctrl`+`B`|   | <xref:System.Windows.Documents.EditingCommands.ToggleBullets%2A>| `Ctrl`+`Shift`+`L`|   | <xref:System.Windows.Documents.EditingCommands.ToggleInsert%2A>| `Insert`|   | <xref:System.Windows.Documents.EditingCommands.ToggleItalic%2A>| `Ctrl`+`I`|   | <xref:System.Windows.Documents.EditingCommands.ToggleNumbering%2A>| `Ctrl`+`Shift`+`N`|   | <xref:System.Windows.Documents.EditingCommands.ToggleSubscript%2A>| `Ctrl`+`OemPlus`|   | <xref:System.Windows.Documents.EditingCommands.ToggleSuperscript%2A>| `Ctrl`+`Shift+OemPlus`|   | <xref:System.Windows.Documents.EditingCommands.ToggleUnderline%2A>| `Ctrl`+`U`|       Polecenia przepływu karetki i wybór rozwijanie polecenia korzystają ze wspólnego zestawu kluczy gestów domyślny, różnią się ogólne</xref:System.Windows.Documents.EditingCommands.ToggleUnderline%2A> </xref:System.Windows.Documents.EditingCommands.ToggleSuperscript%2A> </xref:System.Windows.Documents.EditingCommands.ToggleSubscript%2A> </xref:System.Windows.Documents.EditingCommands.ToggleNumbering%2A> </xref:System.Windows.Documents.EditingCommands.ToggleItalic%2A> </xref:System.Windows.Documents.EditingCommands.ToggleInsert%2A> </xref:System.Windows.Documents.EditingCommands.ToggleBullets%2A> </xref:System.Windows.Documents.EditingCommands.ToggleBold%2A> </xref:System.Windows.Documents.EditingCommands.TabForward%2A> </xref:System.Windows.Documents.EditingCommands.TabBackward%2A> </xref:System.Windows.Documents.EditingCommands.SelectUpByParagraph%2A> </xref:System.Windows.Documents.EditingCommands.SelectUpByPage%2A> </xref:System.Windows.Documents.EditingCommands.SelectUpByLine%2A> </xref:System.Windows.Documents.EditingCommands.SelectToLineStart%2A> </xref:System.Windows.Documents.EditingCommands.SelectToLineEnd%2A> </xref:System.Windows.Documents.EditingCommands.SelectToDocumentStart%2A> </xref:System.Windows.Documents.EditingCommands.SelectToDocumentEnd%2A> </xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A> </xref:System.Windows.Documents.EditingCommands.SelectRightByCharacter%2A> </xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A> </xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A> </xref:System.Windows.Documents.EditingCommands.SelectDownByParagraph%2A> </xref:System.Windows.Documents.EditingCommands.SelectDownByPage%2A> </xref:System.Windows.Documents.EditingCommands.SelectDownByLine%2A> </xref:System.Windows.Documents.EditingCommands.MoveUpByParagraph%2A> </xref:System.Windows.Documents.EditingCommands.MoveUpByPage%2A> </xref:System.Windows.Documents.EditingCommands.MoveUpByLine%2A> </xref:System.Windows.Documents.EditingCommands.MoveToLineStart%2A> </xref:System.Windows.Documents.EditingCommands.MoveToLineEnd%2A> </xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A> </xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A> </xref:System.Windows.Documents.EditingCommands.MoveRightByWord%2A> </xref:System.Windows.Documents.EditingCommands.MoveRightByCharacter%2A> </xref:System.Windows.Documents.EditingCommands.MoveLeftByWord%2A> </xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A> </xref:System.Windows.Documents.EditingCommands.MoveDownByParagraph%2A> </xref:System.Windows.Documents.EditingCommands.MoveDownByPage%2A> </xref:System.Windows.Documents.EditingCommands.MoveDownByLine%2A> </xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A> </xref:System.Windows.Documents.EditingCommands.IncreaseFontSize%2A> </xref:System.Windows.Documents.EditingCommands.IgnoreSpellingError%2A> </xref:System.Windows.Documents.EditingCommands.EnterParagraphBreak%2A> </xref:System.Windows.Documents.EditingCommands.EnterLineBreak%2A> </xref:System.Windows.Documents.EditingCommands.DeletePreviousWord%2A> </xref:System.Windows.Documents.EditingCommands.DeleteNextWord%2A> </xref:System.Windows.Documents.EditingCommands.Delete%2A> </xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A> </xref:System.Windows.Documents.EditingCommands.DecreaseFontSize%2A> </xref:System.Windows.Documents.EditingCommands.CorrectSpellingError%2A> </xref:System.Windows.Documents.EditingCommands.Backspace%2A> </xref:System.Windows.Documents.EditingCommands.AlignRight%2A> </xref:System.Windows.Documents.EditingCommands.AlignLeft%2A> </xref:System.Windows.Documents.EditingCommands.AlignJustify%2A> </xref:System.Windows.Documents.EditingCommands.AlignCenter%2A>  Na przykład <xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A>polecenie ma domyślne gestu klucza z <xref:System.Windows.Input.Key>, a odpowiednie <xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A>polecenie ma domyślne gestu klucza + <xref:System.Windows.Input.ModifierKeys><xref:System.Windows.Input.Key>.</xref:System.Windows.Input.Key> </xref:System.Windows.Input.ModifierKeys> </xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A> </xref:System.Windows.Input.Key> </xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A>       Ogólnie rzecz biorąc, nie należy wprowadzać definicje polecenia udostępnianym przez klasę EditingCommands korzystanie z parametrów polecenia ( `parameter` parametru oczekiwany przez <xref:System.Windows.Input.ICommand.Execute%2A>metody).</xref:System.Windows.Input.ICommand.Execute%2A>       Aby uzyskać więcej informacji na polecenia i steruje, zobacz [omówienie wprowadzania](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static class EditingCommands
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.AlignCenter
  id: AlignCenter
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: AlignCenter
  nameWithType: EditingCommands.AlignCenter
  fullName: System.Windows.Documents.EditingCommands.AlignCenter
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie AlignCenter, które żądania, że wyśrodkowany bieżącego akapitu lub akapitów zaznaczenia."
  remarks: "To polecenie działa w <xref:System.Windows.Documents.Paragraph>poziom.</xref:System.Windows.Documents.Paragraph>  Jeśli to polecenie jest wywoływana częściowy wybór zawartości akapitu (w tym zaznaczenie jest puste, gdzie karetka znajduje się w obrębie akapitu), żądany efekt jest stosowane do całego akapitu.  Jeśli to polecenie jest wywoływana, wybór, obejmującej wiele akapitów, efekt jest stosowane do całej zawartości każdego akapitu, który uczestniczy w zaznaczeniu.       Na poniższej ilustracji przedstawiono przykład wyśrodkowany zawartości.       ![Zrzut ekranu: Wartość właściwości TextAlign Centrum](~/add/media/flowdoc-textalign-center.png &quot;zrzut ekranu: wartość właściwości TextAlign Centrum&quot;) to polecenie jest obsługiwany natywnie przez <xref:System.Windows.Controls.RichTextBox>.</xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_AlignCenter&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;AlignCenter&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand AlignCenter { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_E&quot; name=&quot;E&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.AlignCenter*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.AlignJustify
  id: AlignJustify
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: AlignJustify
  nameWithType: EditingCommands.AlignJustify
  fullName: System.Windows.Documents.EditingCommands.AlignJustify
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie AlignJustify, która żąda być uzasadnione bieżącego akapitu lub akapitów zaznaczenia."
  remarks: "To polecenie działa w <xref:System.Windows.Documents.Paragraph>poziom.</xref:System.Windows.Documents.Paragraph>  Jeśli to polecenie jest wywoływana częściowy wybór zawartości akapitu (w tym zaznaczenie jest puste, gdzie karetka znajduje się w obrębie akapitu), żądany efekt jest stosowane do całego akapitu.  Jeśli to polecenie jest wywoływana, wybór, obejmującej wiele akapitów, efekt jest stosowany do wszystkich akapitów w zaznaczeniu.       Gdy zawartość jest uzasadnione, odstępy w poziomie w każdym wierszu zawartość zostanie zmieniona tak, aby uzasadnionych wiersze są takie same lub w pobliżu równy szerokości.  Zawartość jest uzasadnione zwykle utworzyć smooth krawędzi na strony zawartość.       Często jest krótszy niż pozostałe, w ostatnim wierszu akapitu mogą pozostać nieuzasadnione po wywołaniu tego polecenia.       Na poniższej ilustracji przedstawiono nieuzasadnione zawartości (wyrównanego do lewej).       ![Zrzut ekranu: Zawartość jest uzasadnione](~/add/media/content-unjustified.png &quot;zrzut ekranu: zawartość jest uzasadnione&quot;) na poniższej ilustracji przedstawiono tę samą zawartość po została uzasadniona.       ![Zrzut ekranu przedstawiający zawartości uzasadnione tekst](~/add/media/content-justified.png &quot;zrzut ekranu przedstawiający zawartości uzasadnione tekst&quot;) nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie przez <xref:System.Windows.Controls.RichTextBox>.</xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_AlignJustify&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;AlignJustify&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand AlignJustify { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_J&quot; name=&quot;J&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.AlignJustify*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.AlignLeft
  id: AlignLeft
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: AlignLeft
  nameWithType: EditingCommands.AlignLeft
  fullName: System.Windows.Documents.EditingCommands.AlignLeft
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie AlignLeft, która żąda zaznaczenia zawartości wyrównać po lewej."
  remarks: "To polecenie działa w <xref:System.Windows.Documents.Paragraph>poziom.</xref:System.Windows.Documents.Paragraph>  Jeśli to polecenie jest wywoływana częściowy wybór zawartości akapitu (w tym zaznaczenie jest puste, gdzie karetka znajduje się w obrębie akapitu), żądany efekt jest stosowane do całego akapitu.  Jeśli to polecenie jest wywoływana, wybór, obejmującej wiele akapitów, efekt jest stosowane do całej zawartości każdego akapitu, który uczestniczy w zaznaczeniu.       Na poniższej ilustracji przedstawiono przykład wyrównany zawartości.       ![Zrzut ekranu: Wartość właściwości TextAlign lewej](~/add/media/flowdoc-textalign-left.png &quot;zrzut ekranu: wartość właściwości TextAlign lewej&quot;) nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie przez <xref:System.Windows.Controls.RichTextBox>.</xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_AlignLeft&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;AlignLeft&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand AlignLeft { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_L&quot; name=&quot;L&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.AlignLeft*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.AlignRight
  id: AlignRight
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: AlignRight
  nameWithType: EditingCommands.AlignRight
  fullName: System.Windows.Documents.EditingCommands.AlignRight
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie AlignRight, która żąda zaznaczenia zawartości być wyrównane do prawej strony."
  remarks: "To polecenie działa w <xref:System.Windows.Documents.Paragraph>poziom.</xref:System.Windows.Documents.Paragraph>  Jeśli to polecenie jest wywoływana częściowy wybór zawartości akapitu (w tym zaznaczenie jest puste, gdzie karetka znajduje się w obrębie akapitu), żądany efekt jest stosowane do całego akapitu.  Jeśli to polecenie jest wywoływana, wybór, obejmującej wiele akapitów, efekt jest stosowane do całej zawartości każdego akapitu, który uczestniczy w zaznaczeniu.       Na poniższej ilustracji przedstawiono przykład wyrównany zawartości.       ![Zrzut ekranu: Wartość TextAlign prawa](~/add/media/flowdoc-textalign-right.png &quot;zrzut ekranu: wartość TextAlign prawa&quot;) nie jest zawsze rzeczywistej implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie przez <xref:System.Windows.Controls.RichTextBox>.</xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_AlignRight&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;AlignRight&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand AlignRight { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_R&quot; name=&quot;R&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.AlignRight*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.Backspace
  id: Backspace
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: Backspace
  nameWithType: EditingCommands.Backspace
  fullName: System.Windows.Documents.EditingCommands.Backspace
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie Backspace, która żąda wprowadzenia polecenie backspace w bieżącym położeniu lub za pośrednictwem bieżącego zaznaczenia."
  remarks: "Po wywołaniu na zaznaczenie jest puste, to polecenie usuwa separatora znaków lub bezpośrednio przed karetką. Po wywołaniu wyboru niepustym, to polecenie usuwa zaznaczenie.       To polecenie zachowuje formatowanie usunięto zaznaczenie zawartości natychmiast wstawione w tej samej lokalizacji, po wywołaniu tego polecenia.  Natomiast z <xref:System.Windows.Documents.EditingCommands.Delete%2A>polecenia, które nie zachowuje poprzednie formatowanie.</xref:System.Windows.Documents.EditingCommands.Delete%2A>       Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.</xref:System.Windows.Controls.PasswordBox> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_Backspace&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;Backspace&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand Backspace { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Backspace&quot; name=&quot;Backspace&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.Backspace*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.CorrectSpellingError
  id: CorrectSpellingError
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: CorrectSpellingError
  nameWithType: EditingCommands.CorrectSpellingError
  fullName: System.Windows.Documents.EditingCommands.CorrectSpellingError
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie CorrectSpellingError, która żąda korygowane żadnych wyraz w bieżącym położeniu."
  remarks: "Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.      <a name=&quot;xamlAttributeUsage_CorrectSpellingError&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;CorrectSpellingError&quot;/>   ```"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand CorrectSpellingError { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Nie domyślnego gestu klucza nie ma tego polecenia."
  overload: System.Windows.Documents.EditingCommands.CorrectSpellingError*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.DecreaseFontSize
  id: DecreaseFontSize
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: DecreaseFontSize
  nameWithType: EditingCommands.DecreaseFontSize
  fullName: System.Windows.Documents.EditingCommands.DecreaseFontSize
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie DecreaseFontSize, które żądań zmniejszyć rozmiar czcionki dla bieżącego zaznaczenia przez punkt 1."
  remarks: "Jeśli to polecenie jest wywoływana, zaznaczenie jest puste, gdzie karetka znajduje się wewnątrz słowa, zaznaczenie jest automatycznie dodawany do dotyczą polecenie całe wyrazy.       Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie przez <xref:System.Windows.Controls.RichTextBox>.</xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_DecreaseFontSize&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;DecreaseFontSize&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand DecreaseFontSize { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_OemOpenBrackets&quot; name=&quot;OemOpenBrackets&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.DecreaseFontSize*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.DecreaseIndentation
  id: DecreaseIndentation
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: DecreaseIndentation
  nameWithType: EditingCommands.DecreaseIndentation
  fullName: System.Windows.Documents.EditingCommands.DecreaseIndentation
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie DecreaseIndentation, która żąda zmniejszyć wcięcia akapitu bieżącego przez jedną pozycję tabulatora."
  remarks: "Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie przez <xref:System.Windows.Controls.RichTextBox>.</xref:System.Windows.Controls.RichTextBox>      > [!IMPORTANT] > To polecenie nie ma wpływu na element tekstowy chyba że <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A>ma ustawioną właściwość elementu tekst `true`.</xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A>      <a name=&quot;xamlAttributeUsage_DecreaseIndentation&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;DecreaseIndentation&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand DecreaseIndentation { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Shift&quot; name=&quot;Shift&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_T&quot; name=&quot;T&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.DecreaseIndentation*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.Delete
  id: Delete
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: Delete
  nameWithType: EditingCommands.Delete
  fullName: System.Windows.Documents.EditingCommands.Delete
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenia Delete, która żąda usunięte bieżącego zaznaczenia."
  remarks: "To polecenie spowoduje odrzucenie formatowanie usunięto zaznaczenie.  Natomiast z <xref:System.Windows.Documents.EditingCommands.Backspace%2A>polecenia, który zachowuje formatowanie usunięto zaznaczenie zawartości natychmiast wstawione w tej samej lokalizacji, po wywołaniu tego polecenia.</xref:System.Windows.Documents.EditingCommands.Backspace%2A>       Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.</xref:System.Windows.Controls.PasswordBox> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_Delete&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;Delete&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand Delete { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Delete&quot; name=&quot;Delete&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.Delete*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.DeleteNextWord
  id: DeleteNextWord
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: DeleteNextWord
  nameWithType: EditingCommands.DeleteNextWord
  fullName: System.Windows.Documents.EditingCommands.DeleteNextWord
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie DeleteNextWord, która żąda usunięte wyrazu (względem bieżącej pozycji)."
  remarks: "W przypadku karetka znajduje się wewnątrz słowa, zostaną usunięte w pozostałej części słowa między bieżącą pozycję i na końcu słowo.       Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.</xref:System.Windows.Controls.PasswordBox> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_DeleteNextWord&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;DeleteNextWord&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand DeleteNextWord { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Delete&quot; name=&quot;Delete&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.DeleteNextWord*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.DeletePreviousWord
  id: DeletePreviousWord
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: DeletePreviousWord
  nameWithType: EditingCommands.DeletePreviousWord
  fullName: System.Windows.Documents.EditingCommands.DeletePreviousWord
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie DeletePreviousWord, która żąda usunięte poprzedniego wyrazu (względem bieżącej pozycji)."
  remarks: "W przypadku karetka znajduje się wewnątrz słowa, zostaną usunięte w pozostałej części słowa między bieżącą pozycję i początek wyrazu.       Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.</xref:System.Windows.Controls.PasswordBox> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_DeletePreviousWord&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;DeletePreviousWord&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand DeletePreviousWord { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Backspace&quot; name=&quot;Backspace&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.DeletePreviousWord*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.EnterLineBreak
  id: EnterLineBreak
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: EnterLineBreak
  nameWithType: EditingCommands.EnterLineBreak
  fullName: System.Windows.Documents.EditingCommands.EnterLineBreak
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie EnterLineBreak, która żąda wstawić podział wiersza w bieżącym położeniu lub za pośrednictwem bieżącego zaznaczenia."
  remarks: "Dla edytory obsługujących zawartość przepływu, takich jak <xref:System.Windows.Controls.RichTextBox>, to polecenie powoduje, że <xref:System.Windows.Documents.LineBreak>element do wstawienia w bieżącym położeniu.</xref:System.Windows.Documents.LineBreak> </xref:System.Windows.Controls.RichTextBox>       Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>i <xref:System.Windows.Controls.TextBox>.</xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_EnterLineBreak&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;EnterLineBreak&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand EnterLineBreak { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Shift&quot; name=&quot;Shift&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Enter&quot; name=&quot;Enter&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.EnterLineBreak*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.EnterParagraphBreak
  id: EnterParagraphBreak
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: EnterParagraphBreak
  nameWithType: EditingCommands.EnterParagraphBreak
  fullName: System.Windows.Documents.EditingCommands.EnterParagraphBreak
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie EnterParagraphBreak, która żąda wstawić podział akapitu w bieżącym położeniu lub za pośrednictwem bieżącego zaznaczenia."
  remarks: "To polecenie jest odpowiednikiem użytkownika, naciskając klawisz ENTER.       Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>i <xref:System.Windows.Controls.TextBox>(gdy <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A>jest właściwość `true`).</xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      > [!IMPORTANT] > To polecenie nie ma wpływu na element tekstowy chyba że <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A>ma ustawioną właściwość elementu tekst `true`.</xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A>      <a name=&quot;xamlAttributeUsage_EnterParagraphBreak&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;EnterParagraphBreak&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand EnterParagraphBreak { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Enter&quot; name=&quot;Enter&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.EnterParagraphBreak*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.IgnoreSpellingError
  id: IgnoreSpellingError
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: IgnoreSpellingError
  nameWithType: EditingCommands.IgnoreSpellingError
  fullName: System.Windows.Documents.EditingCommands.IgnoreSpellingError
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie IgnoreSpellingError, która żąda zignorowane wystąpienia pisowni w bieżącym położeniu lub w bieżącym zaznaczeniu."
  remarks: "Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.      <a name=&quot;xamlAttributeUsage_IgnoreSpellingError&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;IgnoreSpellingError&quot;/>   ```"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand IgnoreSpellingError { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Nie domyślnego gestu klucza nie ma tego polecenia."
  overload: System.Windows.Documents.EditingCommands.IgnoreSpellingError*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.IncreaseFontSize
  id: IncreaseFontSize
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: IncreaseFontSize
  nameWithType: EditingCommands.IncreaseFontSize
  fullName: System.Windows.Documents.EditingCommands.IncreaseFontSize
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie IncreaseFontSize, które żądania, czy rozmiar czcionki dla bieżącego wyboru zwiększana o 1 punktu."
  remarks: "Jeśli to polecenie jest wywoływana, zaznaczenie jest puste, gdzie karetka znajduje się wewnątrz słowa, zaznaczenie jest rozwinięty, dotyczą polecenie całe wyrazy.       Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie przez <xref:System.Windows.Controls.RichTextBox>.</xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_IncreaseFontSize&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;IncreaseFontSize&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand IncreaseFontSize { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_OemCloseBrackets&quot; name=&quot;OemCloseBrackets&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.IncreaseFontSize*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.IncreaseIndentation
  id: IncreaseIndentation
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: IncreaseIndentation
  nameWithType: EditingCommands.IncreaseIndentation
  fullName: System.Windows.Documents.EditingCommands.IncreaseIndentation
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie IncreaseIndentation, która żąda czy zwiększyć wcięcia akapitu bieżącego o jedną pozycję tabulatora."
  remarks: "Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie przez <xref:System.Windows.Controls.RichTextBox>.</xref:System.Windows.Controls.RichTextBox>      > [!IMPORTANT] > To polecenie nie ma wpływu na element tekstowy chyba że <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A>ma ustawioną właściwość elementu tekst `true`.</xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A>      <a name=&quot;xamlAttributeUsage_IncreaseIndentation&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;IncreaseIndentation&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand IncreaseIndentation { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_T&quot; name=&quot;T&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.IncreaseIndentation*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.MoveDownByLine
  id: MoveDownByLine
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: MoveDownByLine
  nameWithType: EditingCommands.MoveDownByLine
  fullName: System.Windows.Documents.EditingCommands.MoveDownByLine
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie MoveDownByLine, która żąda Przenieś karetkę w dół o jeden wiersz."
  remarks: "Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>i <xref:System.Windows.Controls.TextBox>.</xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_MoveDownByLine&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;MoveDownByLine&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand MoveDownByLine { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Down&quot; name=&quot;Down&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.MoveDownByLine*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.MoveDownByPage
  id: MoveDownByPage
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: MoveDownByPage
  nameWithType: EditingCommands.MoveDownByPage
  fullName: System.Windows.Documents.EditingCommands.MoveDownByPage
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie MoveDownByPage, która żąda karetkę Przenieś o jedną stronę w dół."
  remarks: "Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>i <xref:System.Windows.Controls.TextBox>.</xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_MoveDownByPage&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;MoveDownByPage&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand MoveDownByPage { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_PageDown&quot; name=&quot;PageDown&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.MoveDownByPage*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.MoveDownByParagraph
  id: MoveDownByParagraph
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: MoveDownByParagraph
  nameWithType: EditingCommands.MoveDownByParagraph
  fullName: System.Windows.Documents.EditingCommands.MoveDownByParagraph
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie MoveDownByParagraph, która żąda Przenieś karetkę dół przez jeden akapit."
  remarks: "To polecenie ustawia położenie karetki na początku następnego akapitu.       To polecenie zachowuje się jak <xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A>po wywołaniu na <xref:System.Windows.Controls.TextBox>.</xref:System.Windows.Controls.TextBox> </xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A>       Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>i <xref:System.Windows.Controls.TextBox>.</xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_MoveDownByParagraph&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;MoveDownByParagraph&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand MoveDownByParagraph { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Down&quot; name=&quot;Down&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.MoveDownByParagraph*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.MoveLeftByCharacter
  id: MoveLeftByCharacter
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: MoveLeftByCharacter
  nameWithType: EditingCommands.MoveLeftByCharacter
  fullName: System.Windows.Documents.EditingCommands.MoveLeftByCharacter
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie MoveLeftByCharacter, która żąda karetkę lewej Przesuń o jeden znak."
  remarks: "Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.</xref:System.Windows.Controls.PasswordBox> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_MoveLeftByCharacter&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;MoveLeftByCharacter&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand MoveLeftByCharacter { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Left&quot; name=&quot;Left&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.MoveLeftByCharacter*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.MoveLeftByWord
  id: MoveLeftByWord
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: MoveLeftByWord
  nameWithType: EditingCommands.MoveLeftByWord
  fullName: System.Windows.Documents.EditingCommands.MoveLeftByWord
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie MoveLeftByWord, które żądania, że karetkę przenieść o jedno słowo w lewo."
  remarks: "W przypadku karetkę wyrazu, to polecenie spowoduje przeniesienie karetkę do początku wyrazie.  W przeciwnym razie to polecenie spowoduje przeniesienie karetkę na początek poprzedniego wyrazu.       Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.</xref:System.Windows.Controls.PasswordBox> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_MoveLeftByWord&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;MoveLeftByWord&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand MoveLeftByWord { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Left&quot; name=&quot;Left&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.MoveLeftByWord*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.MoveRightByCharacter
  id: MoveRightByCharacter
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: MoveRightByCharacter
  nameWithType: EditingCommands.MoveRightByCharacter
  fullName: System.Windows.Documents.EditingCommands.MoveRightByCharacter
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie MoveRightByCharacter, która żąda czy karetki w prawo o jeden znak."
  remarks: "Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.</xref:System.Windows.Controls.PasswordBox> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_MoveRightByCharacter&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;MoveRightByCharacter&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand MoveRightByCharacter { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Right&quot; name=&quot;Right&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.MoveRightByCharacter*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.MoveRightByWord
  id: MoveRightByWord
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: MoveRightByWord
  nameWithType: EditingCommands.MoveRightByWord
  fullName: System.Windows.Documents.EditingCommands.MoveRightByWord
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie MoveRightByWord, która żąda prawo Przesuń karetkę o jedno słowo."
  remarks: "W przypadku karetkę wyrazu, to polecenie spowoduje przeniesienie karetkę na końcu tego wyrazu.  W przeciwnym razie to polecenie spowoduje przeniesienie karetkę na początek następnego wyrazu.       Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.</xref:System.Windows.Controls.PasswordBox> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_MoveRightByWord&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;MoveRightByWord&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand MoveRightByWord { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Right&quot; name=&quot;Right&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.MoveRightByWord*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.MoveToDocumentEnd
  id: MoveToDocumentEnd
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: MoveToDocumentEnd
  nameWithType: EditingCommands.MoveToDocumentEnd
  fullName: System.Windows.Documents.EditingCommands.MoveToDocumentEnd
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie MoveToDocumentEnd, które żądania, że karetkę przenosić do bardzo koniec zawartości."
  remarks: "A *kontenera dopisków fonetycznych* jest elementem formularzy ultimate obramowania wykonywanego zawartości.  <xref:System.Windows.Controls.TextBlock>i <xref:System.Windows.Documents.FlowDocument>przedstawiono kontenery tekstu.</xref:System.Windows.Documents.FlowDocument></xref:System.Windows.Controls.TextBlock>  Zawartość zbiorczo zawartych w kontenerze tekstu jest określany jako *dokumentu*.       Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.</xref:System.Windows.Controls.PasswordBox> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_MoveToDocumentEnd&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;MoveToDocumentEnd&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand MoveToDocumentEnd { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.MoveToDocumentEnd*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.MoveToDocumentStart
  id: MoveToDocumentStart
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: MoveToDocumentStart
  nameWithType: EditingCommands.MoveToDocumentStart
  fullName: System.Windows.Documents.EditingCommands.MoveToDocumentStart
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie MoveToDocumentStart, które żądania, że karetkę przenosić do początku części zawartości."
  remarks: "A *kontenera dopisków fonetycznych* jest elementem formularzy ultimate obramowania wykonywanego zawartości.  <xref:System.Windows.Controls.TextBlock>i <xref:System.Windows.Documents.FlowDocument>przedstawiono kontenery tekstu.</xref:System.Windows.Documents.FlowDocument></xref:System.Windows.Controls.TextBlock>  Zawartość zbiorczo zawartych w kontenerze tekstu jest określany jako *dokumentu*.       Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.</xref:System.Windows.Controls.PasswordBox> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_MoveToDocumentStart&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;MoveToDocumentStart&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand MoveToDocumentStart { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Home&quot; name=&quot;Home&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.MoveToDocumentStart*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.MoveToLineEnd
  id: MoveToLineEnd
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: MoveToLineEnd
  nameWithType: EditingCommands.MoveToLineEnd
  fullName: System.Windows.Documents.EditingCommands.MoveToLineEnd
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie MoveToLineEnd, które żądania, że karetkę Przenieś na koniec bieżącego wiersza."
  remarks: "Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.</xref:System.Windows.Controls.PasswordBox> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_MoveToLineEnd&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;MoveToLineEnd&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand MoveToLineEnd { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.MoveToLineEnd*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.MoveToLineStart
  id: MoveToLineStart
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: MoveToLineStart
  nameWithType: EditingCommands.MoveToLineStart
  fullName: System.Windows.Documents.EditingCommands.MoveToLineStart
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie MoveToLineStart, które żądania, że karetkę Przenieś na początek bieżącego wiersza."
  remarks: "Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.</xref:System.Windows.Controls.PasswordBox> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_MoveToLineStart&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;MoveToLineStart&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand MoveToLineStart { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Home&quot; name=&quot;Home&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.MoveToLineStart*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.MoveUpByLine
  id: MoveUpByLine
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: MoveUpByLine
  nameWithType: EditingCommands.MoveUpByLine
  fullName: System.Windows.Documents.EditingCommands.MoveUpByLine
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie MoveUpByLine, które żądania, że karetkę Przenieś w górę o jeden wiersz."
  remarks: "Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>i <xref:System.Windows.Controls.TextBox>.</xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_MoveUpByLine&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;MoveUpByLine&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand MoveUpByLine { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Up&quot; name=&quot;Up&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.MoveUpByLine*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.MoveUpByPage
  id: MoveUpByPage
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: MoveUpByPage
  nameWithType: EditingCommands.MoveUpByPage
  fullName: System.Windows.Documents.EditingCommands.MoveUpByPage
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie MoveUpByPage, która żąda karetkę przesunięty o jedną stronę."
  remarks: "Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>i <xref:System.Windows.Controls.TextBox>.</xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_MoveUpByPage&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;MoveUpByPage&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand MoveUpByPage { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_PageUp&quot; name=&quot;PageUp&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.MoveUpByPage*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.MoveUpByParagraph
  id: MoveUpByParagraph
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: MoveUpByParagraph
  nameWithType: EditingCommands.MoveUpByParagraph
  fullName: System.Windows.Documents.EditingCommands.MoveUpByParagraph
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie MoveUpByParagraph, która żąda Przenieś karetkę górę przez jeden akapit."
  remarks: "To polecenie ustawia położenie karetki na początku następnego akapitu.       To polecenie zachowuje się jak <xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A>po wywołaniu na <xref:System.Windows.Controls.TextBox>.</xref:System.Windows.Controls.TextBox> </xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A>       Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>i <xref:System.Windows.Controls.TextBox>.</xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_MoveUpByParagraph&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;MoveUpByParagraph&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand MoveUpByParagraph { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Up&quot; name=&quot;Up&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.MoveUpByParagraph*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.SelectDownByLine
  id: SelectDownByLine
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: SelectDownByLine
  nameWithType: EditingCommands.SelectDownByLine
  fullName: System.Windows.Documents.EditingCommands.SelectDownByLine
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie SelectDownByLine, która żąda rozszerzona bieżące zaznaczenie w dół o jeden wiersz."
  remarks: "Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.</xref:System.Windows.Controls.PasswordBox> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_SelectDownByLine&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;SelectDownByLine&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand SelectDownByLine { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Shift&quot; name=&quot;Shift&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Down&quot; name=&quot;Down&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.SelectDownByLine*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.SelectDownByPage
  id: SelectDownByPage
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: SelectDownByPage
  nameWithType: EditingCommands.SelectDownByPage
  fullName: System.Windows.Documents.EditingCommands.SelectDownByPage
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie SelectDownByPage, która żąda rozszerzona bieżące zaznaczenie w dół o jedną stronę."
  remarks: "Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.</xref:System.Windows.Controls.PasswordBox> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_SelectDownByPage&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;SelectDownByPage&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand SelectDownByPage { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Shift&quot; name=&quot;Shift&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_PageDown&quot; name=&quot;PageDown&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.SelectDownByPage*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.SelectDownByParagraph
  id: SelectDownByParagraph
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: SelectDownByParagraph
  nameWithType: EditingCommands.SelectDownByParagraph
  fullName: System.Windows.Documents.EditingCommands.SelectDownByParagraph
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie SelectDownByParagraph, która żąda rozszerzona bieżące zaznaczenie w dół przez jeden akapit."
  remarks: "To polecenie rozszerza zaznaczenie na początek następnego akapitu.  W przeciwnym razie polecenie rozszerza zaznaczenie do końca bieżącego akapitu.  Rozszerzony wybór zawiera podział akapit, który oznacza koniec akapitu.       Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.</xref:System.Windows.Controls.PasswordBox> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_SelectDownByParagraph&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;SelectDownByParagraph&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand SelectDownByParagraph { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Shift&quot; name=&quot;Shift&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Down&quot; name=&quot;Down&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.SelectDownByParagraph*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.SelectLeftByCharacter
  id: SelectLeftByCharacter
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: SelectLeftByCharacter
  nameWithType: EditingCommands.SelectLeftByCharacter
  fullName: System.Windows.Documents.EditingCommands.SelectLeftByCharacter
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie SelectLeftByCharacter, które żądania, że bieżące zaznaczenie lewej rozszerzona o jeden znak."
  remarks: "Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.</xref:System.Windows.Controls.PasswordBox> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_SelectLeftByCharacter&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;SelectLeftByCharacter&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand SelectLeftByCharacter { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Shift&quot; name=&quot;Shift&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Left&quot; name=&quot;Left&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.SelectLeftByCharacter*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.SelectLeftByWord
  id: SelectLeftByWord
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: SelectLeftByWord
  nameWithType: EditingCommands.SelectLeftByWord
  fullName: System.Windows.Documents.EditingCommands.SelectLeftByWord
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie SelectLeftByWord, które żądania, że bieżące zaznaczenie lewej rozszerzona o jedno słowo."
  remarks: "W przypadku karetkę wyrazu, to polecenie rozszerza zaznaczenie na początku tego programu word.  W przeciwnym razie polecenie rozszerza zaznaczenie na początek poprzedniego wyrazu.       Rozszerzony wybór nie ma ogranicznika słowa.  Natomiast z <xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>, który ma ogranicznika słowa w zaznaczeniu rozwinięte.</xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>       Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.</xref:System.Windows.Controls.PasswordBox> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_SelectLeftByWord&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;SelectLeftByWord&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand SelectLeftByWord { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Shift&quot; name=&quot;Shift&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Left&quot; name=&quot;Left&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.SelectLeftByWord*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.SelectRightByCharacter
  id: SelectRightByCharacter
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: SelectRightByCharacter
  nameWithType: EditingCommands.SelectRightByCharacter
  fullName: System.Windows.Documents.EditingCommands.SelectRightByCharacter
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie SelectRightByCharacter, która żąda rozszerzona bieżące zaznaczenie w prawo o jeden znak."
  remarks: "Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.</xref:System.Windows.Controls.PasswordBox> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_SelectRightByCharacter&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;SelectRightByCharacter&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand SelectRightByCharacter { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Shift&quot; name=&quot;Shift&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Right&quot; name=&quot;Right&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.SelectRightByCharacter*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.SelectRightByWord
  id: SelectRightByWord
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: SelectRightByWord
  nameWithType: EditingCommands.SelectRightByWord
  fullName: System.Windows.Documents.EditingCommands.SelectRightByWord
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie SelectRightByWord, która żąda rozszerzona bieżące zaznaczenie w prawo o jedno słowo."
  remarks: "W przypadku karetkę wyrazu, to polecenie rozszerza zaznaczenie na końcu tego wyrazu.  W przeciwnym razie to polecenie rozszerza zaznaczenie na końcu następnego wyrazu.       Rozszerzony wybór obejmuje ogranicznika słowa.  Natomiast z <xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A>której nie ma ogranicznika słowa w zaznaczeniu rozwinięte.</xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A>       Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.</xref:System.Windows.Controls.PasswordBox> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_SelectRightByWord&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;SelectRightByWord&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand SelectRightByWord { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Shift&quot; name=&quot;Shift&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Right&quot; name=&quot;Right&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.SelectRightByWord*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.SelectToDocumentEnd
  id: SelectToDocumentEnd
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: SelectToDocumentEnd
  nameWithType: EditingCommands.SelectToDocumentEnd
  fullName: System.Windows.Documents.EditingCommands.SelectToDocumentEnd
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie SelectToDocumentEnd, która żąda rozszerzona bieżące zaznaczenie na końcu zawartości."
  remarks: "A *kontenera dopisków fonetycznych* jest elementem formularzy ultimate obramowania wykonywanego zawartości.  <xref:System.Windows.Controls.TextBlock>i <xref:System.Windows.Documents.FlowDocument>przedstawiono kontenery tekstu.</xref:System.Windows.Documents.FlowDocument></xref:System.Windows.Controls.TextBlock>  Zawartość zbiorczo zawartych w kontenerze tekstu jest określany jako *dokumentu*.       Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.</xref:System.Windows.Controls.PasswordBox> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_SelectToDocumentEnd&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;SelectToDocumentEnd&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand SelectToDocumentEnd { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Shift&quot; name=&quot;Shift&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.SelectToDocumentEnd*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.SelectToDocumentStart
  id: SelectToDocumentStart
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: SelectToDocumentStart
  nameWithType: EditingCommands.SelectToDocumentStart
  fullName: System.Windows.Documents.EditingCommands.SelectToDocumentStart
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie SelectToDocumentStart, która żąda rozszerzona bieżące zaznaczenie na samym początku zawartości."
  remarks: "A *kontenera dopisków fonetycznych* jest elementem formularzy ultimate obramowania wykonywanego zawartości.  <xref:System.Windows.Controls.TextBlock>i <xref:System.Windows.Documents.FlowDocument>przedstawiono kontenery tekstu.</xref:System.Windows.Documents.FlowDocument></xref:System.Windows.Controls.TextBlock>  Zawartość zbiorczo zawartych w kontenerze tekstu jest określany jako *dokumentu*.       Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.</xref:System.Windows.Controls.PasswordBox> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_SelectToDocumentStart&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;SelectToDocumentStart&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand SelectToDocumentStart { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Shift&quot; name=&quot;Shift&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Home&quot; name=&quot;Home&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.SelectToDocumentStart*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.SelectToLineEnd
  id: SelectToLineEnd
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: SelectToLineEnd
  nameWithType: EditingCommands.SelectToLineEnd
  fullName: System.Windows.Documents.EditingCommands.SelectToLineEnd
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie SelectToLineEnd, która żąda rozszerzona bieżące zaznaczenie do końca bieżącego wiersza."
  remarks: "Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.</xref:System.Windows.Controls.PasswordBox> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_SelectToLineEnd&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;SelectToLineEnd&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand SelectToLineEnd { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Shift&quot; name=&quot;Shift&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.SelectToLineEnd*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.SelectToLineStart
  id: SelectToLineStart
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: SelectToLineStart
  nameWithType: EditingCommands.SelectToLineStart
  fullName: System.Windows.Documents.EditingCommands.SelectToLineStart
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie SelectToLineStart, która żąda rozszerzona bieżący wybór do początku bieżącego wiersza."
  remarks: "Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.</xref:System.Windows.Controls.PasswordBox> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_SelectToLineStart&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;SelectToLineStart&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand SelectToLineStart { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Shift&quot; name=&quot;Shift&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Home&quot; name=&quot;Home&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.SelectToLineStart*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.SelectUpByLine
  id: SelectUpByLine
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: SelectUpByLine
  nameWithType: EditingCommands.SelectUpByLine
  fullName: System.Windows.Documents.EditingCommands.SelectUpByLine
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie SelectUpByLine, która żąda rozszerzona bieżące zaznaczenie górę o jeden wiersz."
  remarks: "Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.</xref:System.Windows.Controls.PasswordBox> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_SelectUpByLine&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;SelectUpByLine&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand SelectUpByLine { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Shift&quot; name=&quot;Shift&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Up&quot; name=&quot;Up&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.SelectUpByLine*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.SelectUpByPage
  id: SelectUpByPage
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: SelectUpByPage
  nameWithType: EditingCommands.SelectUpByPage
  fullName: System.Windows.Documents.EditingCommands.SelectUpByPage
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie SelectUpByPage, która żąda rozszerzona bieżące zaznaczenie się o jedną stronę."
  remarks: "Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.</xref:System.Windows.Controls.PasswordBox> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_SelectUpByPage&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;SelectUpByPage&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand SelectUpByPage { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Shift&quot; name=&quot;Shift&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_PageUp&quot; name=&quot;PageUp&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.SelectUpByPage*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.SelectUpByParagraph
  id: SelectUpByParagraph
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: SelectUpByParagraph
  nameWithType: EditingCommands.SelectUpByParagraph
  fullName: System.Windows.Documents.EditingCommands.SelectUpByParagraph
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie SelectUpByParagraph, która żąda rozszerzona bieżące zaznaczenie się przez jeden akapit."
  remarks: "Jeśli karetka znajduje się na początku akapitu, to polecenie rozszerza zaznaczenie na początek poprzedniego akapitu.  W przeciwnym razie polecenie rozszerza zaznaczenie do początku bieżącego akapitu.       Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.</xref:System.Windows.Controls.PasswordBox> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_SelectUpByParagraph&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;SelectUpByParagraph&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand SelectUpByParagraph { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Shift&quot; name=&quot;Shift&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Up&quot; name=&quot;Up&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.SelectUpByParagraph*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.TabBackward
  id: TabBackward
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: TabBackward
  nameWithType: EditingCommands.TabBackward
  fullName: System.Windows.Documents.EditingCommands.TabBackward
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie TabBackward."
  remarks: "Zachowanie dla tego polecenia jest zależny od bieżącego zaznaczenia. Jeśli zaznaczenie jest pusta, to polecenie jest odpowiednikiem <xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A>.</xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A> Jeśli karetka znajduje się w komórce tabeli (reprezentowane przez <xref:System.Windows.Documents.TableCell>element), to polecenie spowoduje przeniesienie karetkę do poprzedniej komórki.</xref:System.Windows.Documents.TableCell> W przeciwnym razie wstawiany jest znak tabulacji w bieżącym położeniu.       Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>i <xref:System.Windows.Controls.TextBox>(gdy <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A>jest właściwość `true`).</xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_TabBackward&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;TabBackward&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n```c#  \nRichTextBox rTB = new RichTextBox();  \n  \nEditingCommands.ToggleInsert.Execute(null, rTB);  \n  \n```  \n  \n```vb  \n			Dim rTB As New RichTextBox()  \n  \n			EditingCommands.ToggleInsert.Execute(Nothing, rTB)  \n```"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand TabBackward { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Shift&quot; name=&quot;Shift&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Tab&quot; name=&quot;Tab&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.TabBackward*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.TabForward
  id: TabForward
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: TabForward
  nameWithType: EditingCommands.TabForward
  fullName: System.Windows.Documents.EditingCommands.TabForward
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie TabForward."
  remarks: "Zachowanie dla tego polecenia jest zależny od bieżącego zaznaczenia. Jeśli zaznaczenie jest pusty lub jeśli zaznaczenie jest puste i jest bieżącym położeniu karetki na początku akapitu, to polecenie jest odpowiednikiem <xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A>.</xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A> Jeśli karetka znajduje się w komórce tabeli (reprezentowane przez <xref:System.Windows.Documents.TableCell>element), to polecenie spowoduje przeniesienie karetkę do następnej komórki.</xref:System.Windows.Documents.TableCell> Jeśli karetka znajduje się w ostatniej komórce tabeli, to polecenie powoduje, że nowy wiersz do dołączenia do tabeli z karetka znajduje się w pierwszej komórki nowego wiersza.  W przeciwnym razie wstawiany jest znak tabulacji w bieżącym położeniu.       Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>i <xref:System.Windows.Controls.TextBox>(gdy <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A>jest właściwość `true`).</xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_TabForward&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;TabForward&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n```c#  \nRichTextBox rTB = new RichTextBox();  \n  \nEditingCommands.ToggleInsert.Execute(null, rTB);  \n  \n```  \n  \n```vb  \n			Dim rTB As New RichTextBox()  \n  \n			EditingCommands.ToggleInsert.Execute(Nothing, rTB)  \n```"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand TabForward { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Tab&quot; name=&quot;Tab&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.TabForward*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.ToggleBold
  id: ToggleBold
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: ToggleBold
  nameWithType: EditingCommands.ToggleBold
  fullName: System.Windows.Documents.EditingCommands.ToggleBold
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie ToggleBold, które żądania wysyłane przez <xref href=&quot;System.Windows.Documents.Bold&quot;> </xref> formatowania zostać przełączona w bieżącym zaznaczeniu."
  remarks: "Jeśli <xref:System.Windows.FontWeight>bieżące zaznaczenie jest w zakresie od <xref:System.Windows.FontWeights.Thin%2A>do <xref:System.Windows.FontWeights.SemiBold%2A>, <xref:System.Windows.FontWeights.Bold%2A>jest stosowany do bieżącego zaznaczenia.</xref:System.Windows.FontWeights.Bold%2A> </xref:System.Windows.FontWeights.SemiBold%2A> </xref:System.Windows.FontWeights.Thin%2A> </xref:System.Windows.FontWeight>  W przeciwnym razie <xref:System.Windows.FontWeights.Normal%2A>jest stosowany.</xref:System.Windows.FontWeights.Normal%2A>  Porównawczych listę <xref:System.Windows.FontWeight>wartości, zobacz <xref:System.Windows.FontWeights>.</xref:System.Windows.FontWeights> </xref:System.Windows.FontWeight>       Jeśli zaznaczenie jest puste i karetka znajduje się wewnątrz słowa, zaznaczenie jest rozszerzona w celu uwzględnienia całe wyrazy.       Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie przez <xref:System.Windows.Controls.RichTextBox>.</xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_ToggleBold&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;ToggleBold&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand ToggleBold { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_B&quot; name=&quot;B&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.ToggleBold*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.ToggleBullets
  id: ToggleBullets
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: ToggleBullets
  nameWithType: EditingCommands.ToggleBullets
  fullName: System.Windows.Documents.EditingCommands.ToggleBullets
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie ToggleBullets, które żądania, że formatowanie nieuporządkowaną listę (określane również jako listy punktowane) zostać przełączona w bieżącym zaznaczeniu."
  remarks: "To polecenie działa w <xref:System.Windows.Documents.Paragraph>poziom.</xref:System.Windows.Documents.Paragraph>  Jeśli to polecenie jest wywoływana częściowy wybór zawartości akapitu (w tym zaznaczenie jest puste, gdzie karetka znajduje się w obrębie akapitu), żądany efekt jest stosowane do całego akapitu.  Jeśli to polecenie jest wywoływana, wybór, obejmującej wiele akapitów, efekt jest stosowane do całej zawartości każdego akapitu, który uczestniczy w zaznaczeniu.       Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie przez <xref:System.Windows.Controls.RichTextBox>.</xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_ToggleBullets&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;ToggleBullets&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand ToggleBullets { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Shift&quot; name=&quot;Shift&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_L&quot; name=&quot;L&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.ToggleBullets*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.ToggleInsert
  id: ToggleInsert
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: ToggleInsert
  nameWithType: EditingCommands.ToggleInsert
  fullName: System.Windows.Documents.EditingCommands.ToggleInsert
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie ToggleInsert, które Przełącza tryb pisania pomiędzy wstawianiem, a zastępowaniem."
  remarks: "Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie w <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.</xref:System.Windows.Controls.PasswordBox> </xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_ToggleInsert&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;ToggleInsert&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand ToggleInsert { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Insert&quot; name=&quot;Insert&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.ToggleInsert*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.ToggleItalic
  id: ToggleItalic
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: ToggleItalic
  nameWithType: EditingCommands.ToggleItalic
  fullName: System.Windows.Documents.EditingCommands.ToggleItalic
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie ToggleItalic, które żądania wysyłane przez <xref href=&quot;System.Windows.Documents.Italic&quot;> </xref> formatowania zostać przełączona w bieżącym zaznaczeniu."
  remarks: "Jeśli <xref:System.Windows.FontStyle>bieżące zaznaczenie jest <xref:System.Windows.FontStyles.Normal%2A>, <xref:System.Windows.FontStyles.Italic%2A>jest stosowany do bieżącego zaznaczenia.</xref:System.Windows.FontStyles.Italic%2A> </xref:System.Windows.FontStyles.Normal%2A> </xref:System.Windows.FontStyle>  W przeciwnym razie <xref:System.Windows.FontStyles.Normal%2A>jest stosowany.</xref:System.Windows.FontStyles.Normal%2A>       Jeśli zaznaczenie jest puste i karetka znajduje się wewnątrz słowa, zaznaczenie jest rozszerzona w celu uwzględnienia całe wyrazy.       Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie przez <xref:System.Windows.Controls.RichTextBox>.</xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_ToggleItalic&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;ToggleItalic&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand ToggleItalic { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_I&quot; name=&quot;I&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.ToggleItalic*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.ToggleNumbering
  id: ToggleNumbering
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: ToggleNumbering
  nameWithType: EditingCommands.ToggleNumbering
  fullName: System.Windows.Documents.EditingCommands.ToggleNumbering
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie ToggleNumbering, które żądania, że formatowanie listy uporządkowanej (nazywane również lista numerowana) zostać przełączona w bieżącym zaznaczeniu."
  remarks: "To polecenie działa w <xref:System.Windows.Documents.Paragraph>poziom.</xref:System.Windows.Documents.Paragraph>  Jeśli to polecenie jest wywoływana częściowy wybór zawartości akapitu (w tym zaznaczenie jest puste, gdzie karetka znajduje się w obrębie akapitu), żądany efekt jest stosowane do całego akapitu.  Jeśli to polecenie jest wywoływana, wybór, obejmującej wiele akapitów, efekt jest stosowane do całej zawartości każdego akapitu, który uczestniczy w zaznaczeniu.       Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie przez <xref:System.Windows.Controls.RichTextBox>.</xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_ToggleNumbering&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;ToggleNumbering&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand ToggleNumbering { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Shift&quot; name=&quot;Shift&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_N&quot; name=&quot;N&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.ToggleNumbering*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.ToggleSubscript
  id: ToggleSubscript
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: ToggleSubscript
  nameWithType: EditingCommands.ToggleSubscript
  fullName: System.Windows.Documents.EditingCommands.ToggleSubscript
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie ToggleSubscript, które żądania, że indeks dolny zostać przełączona w bieżącym zaznaczeniu."
  remarks: "Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.      <a name=&quot;xamlAttributeUsage_ToggleSubscript&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;ToggleSubscript&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand ToggleSubscript { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_OemPlus&quot; name=&quot;OemPlus&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.ToggleSubscript*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.ToggleSuperscript
  id: ToggleSuperscript
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: ToggleSuperscript
  nameWithType: EditingCommands.ToggleSuperscript
  fullName: System.Windows.Documents.EditingCommands.ToggleSuperscript
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie ToggleSuperscript, które żądania, czy górny zostać przełączona w bieżącym zaznaczeniu."
  remarks: "Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.      <a name=&quot;xamlAttributeUsage_ToggleSuperscript&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;ToggleSuperscript&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand ToggleSuperscript { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_Shift&quot; name=&quot;Shift&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_OemPlus&quot; name=&quot;OemPlus&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.ToggleSuperscript*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.EditingCommands.ToggleUnderline
  id: ToggleUnderline
  parent: System.Windows.Documents.EditingCommands
  langs:
  - csharp
  name: ToggleUnderline
  nameWithType: EditingCommands.ToggleUnderline
  fullName: System.Windows.Documents.EditingCommands.ToggleUnderline
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Reprezentuje polecenie ToggleUnderline, które żądania wysyłane przez <xref href=&quot;System.Windows.Documents.Underline&quot;> </xref> formatowania zostać przełączona w bieżącym zaznaczeniu."
  remarks: "Jeśli zaznaczenie jest puste i karetka znajduje się wewnątrz słowa, zaznaczenie jest rozszerzona w celu uwzględnienia całe wyrazy.       Nie jest zawsze rzeczywiste implementację, która odpowiada na polecenie w dowolnym danego obiektu; w wielu przypadkach implementację, która odpowiada na polecenie jest odpowiedzialny za moduł zapisujący aplikacji.       To polecenie jest obsługiwany natywnie przez <xref:System.Windows.Controls.RichTextBox>.</xref:System.Windows.Controls.RichTextBox>      <a name=&quot;xamlAttributeUsage_ToggleUnderline&quot;></a>## Użycie atrybutu XAML```   <object property=&quot;ToggleUnderline&quot;/>   ```"
  example:
  - "The following example demonstrates how to invoke an editing command on an object that supports the command.  \n  \n For this example, a <xref:System.Windows.Controls.RichTextBox> serves as the command target.  Note that <xref:System.Windows.Controls.RichTextBox> implements the <xref:System.Windows.IInputElement> interface (inherited from <xref:System.Windows.FrameworkElement>), and that it includes native support for many editing commands.  \n  \n The first argument for the <xref:System.Windows.Input.RoutedCommand.Execute%2A> method is a command parameter.  Most editing commands ignore the command parameter; in general, this parameter should be `null` for editing commands.  \n  \n The second argument specifies the object to which the command will be routed.  This object must implement the <xref:System.Windows.IInputElement> interface, and should include a handler for the specified command.  Generally, a command is ignored when invoked on an object that does not handle the command.  \n  \n [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/visualbasic/richtextboxsnippets/window1.xaml.vb#_editingcommands_invoke)]\n [!code-cs[RichTextBoxSnippets#_EditingCommands_Invoke](~/add/codesnippet/csharp/RichTextBoxSnippets/Window1.xaml.cs#_editingcommands_invoke)]"
  syntax:
    content: public static System.Windows.Input.RoutedUICommand ToggleUnderline { get; }
    return:
      type: System.Windows.Input.RoutedUICommand
      description: "Żądane polecenie.  Gest klucza domyślnego dla tego polecenia jest <xref uid=&quot;langword_csharp_Ctrl&quot; name=&quot;Ctrl&quot; href=&quot;&quot;> </xref> + <xref uid=&quot;langword_csharp_U&quot; name=&quot;U&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.EditingCommands.ToggleUnderline*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Windows.Documents.EditingCommands.AlignCenter
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: AlignCenter
  nameWithType: EditingCommands.AlignCenter
  fullName: System.Windows.Documents.EditingCommands.AlignCenter
- uid: System.Windows.Input.RoutedUICommand
  parent: System.Windows.Input
  isExternal: false
  name: RoutedUICommand
  nameWithType: RoutedUICommand
  fullName: System.Windows.Input.RoutedUICommand
- uid: System.Windows.Documents.EditingCommands.AlignJustify
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: AlignJustify
  nameWithType: EditingCommands.AlignJustify
  fullName: System.Windows.Documents.EditingCommands.AlignJustify
- uid: System.Windows.Documents.EditingCommands.AlignLeft
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: AlignLeft
  nameWithType: EditingCommands.AlignLeft
  fullName: System.Windows.Documents.EditingCommands.AlignLeft
- uid: System.Windows.Documents.EditingCommands.AlignRight
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: AlignRight
  nameWithType: EditingCommands.AlignRight
  fullName: System.Windows.Documents.EditingCommands.AlignRight
- uid: System.Windows.Documents.EditingCommands.Backspace
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: Backspace
  nameWithType: EditingCommands.Backspace
  fullName: System.Windows.Documents.EditingCommands.Backspace
- uid: System.Windows.Documents.EditingCommands.CorrectSpellingError
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: CorrectSpellingError
  nameWithType: EditingCommands.CorrectSpellingError
  fullName: System.Windows.Documents.EditingCommands.CorrectSpellingError
- uid: System.Windows.Documents.EditingCommands.DecreaseFontSize
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: DecreaseFontSize
  nameWithType: EditingCommands.DecreaseFontSize
  fullName: System.Windows.Documents.EditingCommands.DecreaseFontSize
- uid: System.Windows.Documents.EditingCommands.DecreaseIndentation
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: DecreaseIndentation
  nameWithType: EditingCommands.DecreaseIndentation
  fullName: System.Windows.Documents.EditingCommands.DecreaseIndentation
- uid: System.Windows.Documents.EditingCommands.Delete
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: Delete
  nameWithType: EditingCommands.Delete
  fullName: System.Windows.Documents.EditingCommands.Delete
- uid: System.Windows.Documents.EditingCommands.DeleteNextWord
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: DeleteNextWord
  nameWithType: EditingCommands.DeleteNextWord
  fullName: System.Windows.Documents.EditingCommands.DeleteNextWord
- uid: System.Windows.Documents.EditingCommands.DeletePreviousWord
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: DeletePreviousWord
  nameWithType: EditingCommands.DeletePreviousWord
  fullName: System.Windows.Documents.EditingCommands.DeletePreviousWord
- uid: System.Windows.Documents.EditingCommands.EnterLineBreak
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: EnterLineBreak
  nameWithType: EditingCommands.EnterLineBreak
  fullName: System.Windows.Documents.EditingCommands.EnterLineBreak
- uid: System.Windows.Documents.EditingCommands.EnterParagraphBreak
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: EnterParagraphBreak
  nameWithType: EditingCommands.EnterParagraphBreak
  fullName: System.Windows.Documents.EditingCommands.EnterParagraphBreak
- uid: System.Windows.Documents.EditingCommands.IgnoreSpellingError
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: IgnoreSpellingError
  nameWithType: EditingCommands.IgnoreSpellingError
  fullName: System.Windows.Documents.EditingCommands.IgnoreSpellingError
- uid: System.Windows.Documents.EditingCommands.IncreaseFontSize
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: IncreaseFontSize
  nameWithType: EditingCommands.IncreaseFontSize
  fullName: System.Windows.Documents.EditingCommands.IncreaseFontSize
- uid: System.Windows.Documents.EditingCommands.IncreaseIndentation
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: IncreaseIndentation
  nameWithType: EditingCommands.IncreaseIndentation
  fullName: System.Windows.Documents.EditingCommands.IncreaseIndentation
- uid: System.Windows.Documents.EditingCommands.MoveDownByLine
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveDownByLine
  nameWithType: EditingCommands.MoveDownByLine
  fullName: System.Windows.Documents.EditingCommands.MoveDownByLine
- uid: System.Windows.Documents.EditingCommands.MoveDownByPage
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveDownByPage
  nameWithType: EditingCommands.MoveDownByPage
  fullName: System.Windows.Documents.EditingCommands.MoveDownByPage
- uid: System.Windows.Documents.EditingCommands.MoveDownByParagraph
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveDownByParagraph
  nameWithType: EditingCommands.MoveDownByParagraph
  fullName: System.Windows.Documents.EditingCommands.MoveDownByParagraph
- uid: System.Windows.Documents.EditingCommands.MoveLeftByCharacter
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveLeftByCharacter
  nameWithType: EditingCommands.MoveLeftByCharacter
  fullName: System.Windows.Documents.EditingCommands.MoveLeftByCharacter
- uid: System.Windows.Documents.EditingCommands.MoveLeftByWord
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveLeftByWord
  nameWithType: EditingCommands.MoveLeftByWord
  fullName: System.Windows.Documents.EditingCommands.MoveLeftByWord
- uid: System.Windows.Documents.EditingCommands.MoveRightByCharacter
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveRightByCharacter
  nameWithType: EditingCommands.MoveRightByCharacter
  fullName: System.Windows.Documents.EditingCommands.MoveRightByCharacter
- uid: System.Windows.Documents.EditingCommands.MoveRightByWord
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveRightByWord
  nameWithType: EditingCommands.MoveRightByWord
  fullName: System.Windows.Documents.EditingCommands.MoveRightByWord
- uid: System.Windows.Documents.EditingCommands.MoveToDocumentEnd
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveToDocumentEnd
  nameWithType: EditingCommands.MoveToDocumentEnd
  fullName: System.Windows.Documents.EditingCommands.MoveToDocumentEnd
- uid: System.Windows.Documents.EditingCommands.MoveToDocumentStart
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveToDocumentStart
  nameWithType: EditingCommands.MoveToDocumentStart
  fullName: System.Windows.Documents.EditingCommands.MoveToDocumentStart
- uid: System.Windows.Documents.EditingCommands.MoveToLineEnd
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveToLineEnd
  nameWithType: EditingCommands.MoveToLineEnd
  fullName: System.Windows.Documents.EditingCommands.MoveToLineEnd
- uid: System.Windows.Documents.EditingCommands.MoveToLineStart
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveToLineStart
  nameWithType: EditingCommands.MoveToLineStart
  fullName: System.Windows.Documents.EditingCommands.MoveToLineStart
- uid: System.Windows.Documents.EditingCommands.MoveUpByLine
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveUpByLine
  nameWithType: EditingCommands.MoveUpByLine
  fullName: System.Windows.Documents.EditingCommands.MoveUpByLine
- uid: System.Windows.Documents.EditingCommands.MoveUpByPage
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveUpByPage
  nameWithType: EditingCommands.MoveUpByPage
  fullName: System.Windows.Documents.EditingCommands.MoveUpByPage
- uid: System.Windows.Documents.EditingCommands.MoveUpByParagraph
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveUpByParagraph
  nameWithType: EditingCommands.MoveUpByParagraph
  fullName: System.Windows.Documents.EditingCommands.MoveUpByParagraph
- uid: System.Windows.Documents.EditingCommands.SelectDownByLine
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectDownByLine
  nameWithType: EditingCommands.SelectDownByLine
  fullName: System.Windows.Documents.EditingCommands.SelectDownByLine
- uid: System.Windows.Documents.EditingCommands.SelectDownByPage
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectDownByPage
  nameWithType: EditingCommands.SelectDownByPage
  fullName: System.Windows.Documents.EditingCommands.SelectDownByPage
- uid: System.Windows.Documents.EditingCommands.SelectDownByParagraph
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectDownByParagraph
  nameWithType: EditingCommands.SelectDownByParagraph
  fullName: System.Windows.Documents.EditingCommands.SelectDownByParagraph
- uid: System.Windows.Documents.EditingCommands.SelectLeftByCharacter
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectLeftByCharacter
  nameWithType: EditingCommands.SelectLeftByCharacter
  fullName: System.Windows.Documents.EditingCommands.SelectLeftByCharacter
- uid: System.Windows.Documents.EditingCommands.SelectLeftByWord
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectLeftByWord
  nameWithType: EditingCommands.SelectLeftByWord
  fullName: System.Windows.Documents.EditingCommands.SelectLeftByWord
- uid: System.Windows.Documents.EditingCommands.SelectRightByCharacter
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectRightByCharacter
  nameWithType: EditingCommands.SelectRightByCharacter
  fullName: System.Windows.Documents.EditingCommands.SelectRightByCharacter
- uid: System.Windows.Documents.EditingCommands.SelectRightByWord
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectRightByWord
  nameWithType: EditingCommands.SelectRightByWord
  fullName: System.Windows.Documents.EditingCommands.SelectRightByWord
- uid: System.Windows.Documents.EditingCommands.SelectToDocumentEnd
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectToDocumentEnd
  nameWithType: EditingCommands.SelectToDocumentEnd
  fullName: System.Windows.Documents.EditingCommands.SelectToDocumentEnd
- uid: System.Windows.Documents.EditingCommands.SelectToDocumentStart
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectToDocumentStart
  nameWithType: EditingCommands.SelectToDocumentStart
  fullName: System.Windows.Documents.EditingCommands.SelectToDocumentStart
- uid: System.Windows.Documents.EditingCommands.SelectToLineEnd
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectToLineEnd
  nameWithType: EditingCommands.SelectToLineEnd
  fullName: System.Windows.Documents.EditingCommands.SelectToLineEnd
- uid: System.Windows.Documents.EditingCommands.SelectToLineStart
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectToLineStart
  nameWithType: EditingCommands.SelectToLineStart
  fullName: System.Windows.Documents.EditingCommands.SelectToLineStart
- uid: System.Windows.Documents.EditingCommands.SelectUpByLine
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectUpByLine
  nameWithType: EditingCommands.SelectUpByLine
  fullName: System.Windows.Documents.EditingCommands.SelectUpByLine
- uid: System.Windows.Documents.EditingCommands.SelectUpByPage
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectUpByPage
  nameWithType: EditingCommands.SelectUpByPage
  fullName: System.Windows.Documents.EditingCommands.SelectUpByPage
- uid: System.Windows.Documents.EditingCommands.SelectUpByParagraph
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectUpByParagraph
  nameWithType: EditingCommands.SelectUpByParagraph
  fullName: System.Windows.Documents.EditingCommands.SelectUpByParagraph
- uid: System.Windows.Documents.EditingCommands.TabBackward
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: TabBackward
  nameWithType: EditingCommands.TabBackward
  fullName: System.Windows.Documents.EditingCommands.TabBackward
- uid: System.Windows.Documents.EditingCommands.TabForward
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: TabForward
  nameWithType: EditingCommands.TabForward
  fullName: System.Windows.Documents.EditingCommands.TabForward
- uid: System.Windows.Documents.EditingCommands.ToggleBold
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: ToggleBold
  nameWithType: EditingCommands.ToggleBold
  fullName: System.Windows.Documents.EditingCommands.ToggleBold
- uid: System.Windows.Documents.EditingCommands.ToggleBullets
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: ToggleBullets
  nameWithType: EditingCommands.ToggleBullets
  fullName: System.Windows.Documents.EditingCommands.ToggleBullets
- uid: System.Windows.Documents.EditingCommands.ToggleInsert
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: ToggleInsert
  nameWithType: EditingCommands.ToggleInsert
  fullName: System.Windows.Documents.EditingCommands.ToggleInsert
- uid: System.Windows.Documents.EditingCommands.ToggleItalic
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: ToggleItalic
  nameWithType: EditingCommands.ToggleItalic
  fullName: System.Windows.Documents.EditingCommands.ToggleItalic
- uid: System.Windows.Documents.EditingCommands.ToggleNumbering
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: ToggleNumbering
  nameWithType: EditingCommands.ToggleNumbering
  fullName: System.Windows.Documents.EditingCommands.ToggleNumbering
- uid: System.Windows.Documents.EditingCommands.ToggleSubscript
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: ToggleSubscript
  nameWithType: EditingCommands.ToggleSubscript
  fullName: System.Windows.Documents.EditingCommands.ToggleSubscript
- uid: System.Windows.Documents.EditingCommands.ToggleSuperscript
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: ToggleSuperscript
  nameWithType: EditingCommands.ToggleSuperscript
  fullName: System.Windows.Documents.EditingCommands.ToggleSuperscript
- uid: System.Windows.Documents.EditingCommands.ToggleUnderline
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: ToggleUnderline
  nameWithType: EditingCommands.ToggleUnderline
  fullName: System.Windows.Documents.EditingCommands.ToggleUnderline
- uid: System.Windows.Documents.EditingCommands.AlignCenter*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: AlignCenter
  nameWithType: EditingCommands.AlignCenter
- uid: System.Windows.Documents.EditingCommands.AlignJustify*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: AlignJustify
  nameWithType: EditingCommands.AlignJustify
- uid: System.Windows.Documents.EditingCommands.AlignLeft*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: AlignLeft
  nameWithType: EditingCommands.AlignLeft
- uid: System.Windows.Documents.EditingCommands.AlignRight*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: AlignRight
  nameWithType: EditingCommands.AlignRight
- uid: System.Windows.Documents.EditingCommands.Backspace*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: Backspace
  nameWithType: EditingCommands.Backspace
- uid: System.Windows.Documents.EditingCommands.CorrectSpellingError*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: CorrectSpellingError
  nameWithType: EditingCommands.CorrectSpellingError
- uid: System.Windows.Documents.EditingCommands.DecreaseFontSize*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: DecreaseFontSize
  nameWithType: EditingCommands.DecreaseFontSize
- uid: System.Windows.Documents.EditingCommands.DecreaseIndentation*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: DecreaseIndentation
  nameWithType: EditingCommands.DecreaseIndentation
- uid: System.Windows.Documents.EditingCommands.Delete*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: Delete
  nameWithType: EditingCommands.Delete
- uid: System.Windows.Documents.EditingCommands.DeleteNextWord*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: DeleteNextWord
  nameWithType: EditingCommands.DeleteNextWord
- uid: System.Windows.Documents.EditingCommands.DeletePreviousWord*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: DeletePreviousWord
  nameWithType: EditingCommands.DeletePreviousWord
- uid: System.Windows.Documents.EditingCommands.EnterLineBreak*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: EnterLineBreak
  nameWithType: EditingCommands.EnterLineBreak
- uid: System.Windows.Documents.EditingCommands.EnterParagraphBreak*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: EnterParagraphBreak
  nameWithType: EditingCommands.EnterParagraphBreak
- uid: System.Windows.Documents.EditingCommands.IgnoreSpellingError*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: IgnoreSpellingError
  nameWithType: EditingCommands.IgnoreSpellingError
- uid: System.Windows.Documents.EditingCommands.IncreaseFontSize*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: IncreaseFontSize
  nameWithType: EditingCommands.IncreaseFontSize
- uid: System.Windows.Documents.EditingCommands.IncreaseIndentation*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: IncreaseIndentation
  nameWithType: EditingCommands.IncreaseIndentation
- uid: System.Windows.Documents.EditingCommands.MoveDownByLine*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveDownByLine
  nameWithType: EditingCommands.MoveDownByLine
- uid: System.Windows.Documents.EditingCommands.MoveDownByPage*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveDownByPage
  nameWithType: EditingCommands.MoveDownByPage
- uid: System.Windows.Documents.EditingCommands.MoveDownByParagraph*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveDownByParagraph
  nameWithType: EditingCommands.MoveDownByParagraph
- uid: System.Windows.Documents.EditingCommands.MoveLeftByCharacter*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveLeftByCharacter
  nameWithType: EditingCommands.MoveLeftByCharacter
- uid: System.Windows.Documents.EditingCommands.MoveLeftByWord*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveLeftByWord
  nameWithType: EditingCommands.MoveLeftByWord
- uid: System.Windows.Documents.EditingCommands.MoveRightByCharacter*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveRightByCharacter
  nameWithType: EditingCommands.MoveRightByCharacter
- uid: System.Windows.Documents.EditingCommands.MoveRightByWord*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveRightByWord
  nameWithType: EditingCommands.MoveRightByWord
- uid: System.Windows.Documents.EditingCommands.MoveToDocumentEnd*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveToDocumentEnd
  nameWithType: EditingCommands.MoveToDocumentEnd
- uid: System.Windows.Documents.EditingCommands.MoveToDocumentStart*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveToDocumentStart
  nameWithType: EditingCommands.MoveToDocumentStart
- uid: System.Windows.Documents.EditingCommands.MoveToLineEnd*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveToLineEnd
  nameWithType: EditingCommands.MoveToLineEnd
- uid: System.Windows.Documents.EditingCommands.MoveToLineStart*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveToLineStart
  nameWithType: EditingCommands.MoveToLineStart
- uid: System.Windows.Documents.EditingCommands.MoveUpByLine*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveUpByLine
  nameWithType: EditingCommands.MoveUpByLine
- uid: System.Windows.Documents.EditingCommands.MoveUpByPage*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveUpByPage
  nameWithType: EditingCommands.MoveUpByPage
- uid: System.Windows.Documents.EditingCommands.MoveUpByParagraph*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: MoveUpByParagraph
  nameWithType: EditingCommands.MoveUpByParagraph
- uid: System.Windows.Documents.EditingCommands.SelectDownByLine*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectDownByLine
  nameWithType: EditingCommands.SelectDownByLine
- uid: System.Windows.Documents.EditingCommands.SelectDownByPage*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectDownByPage
  nameWithType: EditingCommands.SelectDownByPage
- uid: System.Windows.Documents.EditingCommands.SelectDownByParagraph*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectDownByParagraph
  nameWithType: EditingCommands.SelectDownByParagraph
- uid: System.Windows.Documents.EditingCommands.SelectLeftByCharacter*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectLeftByCharacter
  nameWithType: EditingCommands.SelectLeftByCharacter
- uid: System.Windows.Documents.EditingCommands.SelectLeftByWord*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectLeftByWord
  nameWithType: EditingCommands.SelectLeftByWord
- uid: System.Windows.Documents.EditingCommands.SelectRightByCharacter*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectRightByCharacter
  nameWithType: EditingCommands.SelectRightByCharacter
- uid: System.Windows.Documents.EditingCommands.SelectRightByWord*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectRightByWord
  nameWithType: EditingCommands.SelectRightByWord
- uid: System.Windows.Documents.EditingCommands.SelectToDocumentEnd*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectToDocumentEnd
  nameWithType: EditingCommands.SelectToDocumentEnd
- uid: System.Windows.Documents.EditingCommands.SelectToDocumentStart*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectToDocumentStart
  nameWithType: EditingCommands.SelectToDocumentStart
- uid: System.Windows.Documents.EditingCommands.SelectToLineEnd*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectToLineEnd
  nameWithType: EditingCommands.SelectToLineEnd
- uid: System.Windows.Documents.EditingCommands.SelectToLineStart*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectToLineStart
  nameWithType: EditingCommands.SelectToLineStart
- uid: System.Windows.Documents.EditingCommands.SelectUpByLine*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectUpByLine
  nameWithType: EditingCommands.SelectUpByLine
- uid: System.Windows.Documents.EditingCommands.SelectUpByPage*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectUpByPage
  nameWithType: EditingCommands.SelectUpByPage
- uid: System.Windows.Documents.EditingCommands.SelectUpByParagraph*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: SelectUpByParagraph
  nameWithType: EditingCommands.SelectUpByParagraph
- uid: System.Windows.Documents.EditingCommands.TabBackward*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: TabBackward
  nameWithType: EditingCommands.TabBackward
- uid: System.Windows.Documents.EditingCommands.TabForward*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: TabForward
  nameWithType: EditingCommands.TabForward
- uid: System.Windows.Documents.EditingCommands.ToggleBold*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: ToggleBold
  nameWithType: EditingCommands.ToggleBold
- uid: System.Windows.Documents.EditingCommands.ToggleBullets*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: ToggleBullets
  nameWithType: EditingCommands.ToggleBullets
- uid: System.Windows.Documents.EditingCommands.ToggleInsert*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: ToggleInsert
  nameWithType: EditingCommands.ToggleInsert
- uid: System.Windows.Documents.EditingCommands.ToggleItalic*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: ToggleItalic
  nameWithType: EditingCommands.ToggleItalic
- uid: System.Windows.Documents.EditingCommands.ToggleNumbering*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: ToggleNumbering
  nameWithType: EditingCommands.ToggleNumbering
- uid: System.Windows.Documents.EditingCommands.ToggleSubscript*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: ToggleSubscript
  nameWithType: EditingCommands.ToggleSubscript
- uid: System.Windows.Documents.EditingCommands.ToggleSuperscript*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: ToggleSuperscript
  nameWithType: EditingCommands.ToggleSuperscript
- uid: System.Windows.Documents.EditingCommands.ToggleUnderline*
  parent: System.Windows.Documents.EditingCommands
  isExternal: false
  name: ToggleUnderline
  nameWithType: EditingCommands.ToggleUnderline
