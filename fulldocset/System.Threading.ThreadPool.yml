### YamlMime:ManagedReference
items:
- uid: System.Threading.ThreadPool
  id: ThreadPool
  children:
  - System.Threading.ThreadPool.BindHandle(System.IntPtr)
  - System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
  - System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
  - System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
  - System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
  - System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
  - System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  - System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
  - System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
  - System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  - System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  langs:
  - csharp
  name: ThreadPool
  nameWithType: ThreadPool
  fullName: System.Threading.ThreadPool
  type: Class
  summary: "Udostępnia puli wątków, które mogą służyć do wykonywania zadań, publikowania elementów roboczych, Przetwarzanie asynchroniczne We/Wy, Oczekiwanie w imieniu innych wątków i przetworzyć czasomierze."
  remarks: "Wiele aplikacji Tworzenie wątków, które spędzają na dużą ilość czasu w stanie uśpiony, oczekuje na wystąpienie zdarzenia. Inne wątki może przejść w stan uśpiony tylko do wznowione okresowo sondować zmiany lub zaktualizować informacje o stanie. Pula wątków umożliwia korzystanie wątków wydajniej, udostępniając aplikację z pulą wątków roboczych, które są zarządzane przez system. Operacje, które używają wątków z puli wątków są następujące: - podczas tworzenia <xref:System.Threading.Tasks.Task>lub <xref:System.Threading.Tasks.Task%601>obiektu w celu wykonania niektórych zadań asynchronicznie, domyślnie zadanie jest zaplanowane do uruchomienia w wątku puli wątków.</xref:System.Threading.Tasks.Task%601> </xref:System.Threading.Tasks.Task>      — Czasomierze asynchroniczne Użyj puli wątków. Wątków z puli wątków wykonywania wywołań zwrotnych z <xref:System.Threading.Timer?displayProperty=fullName>klasy i zgłoś zdarzenia z <xref:System.Timers.Timer?displayProperty=fullName>klasy.</xref:System.Timers.Timer?displayProperty=fullName> </xref:System.Threading.Timer?displayProperty=fullName>      — Jeśli używasz uchwyty oczekiwania zarejestrowanych wątku systemu monitoruje stan uchwyty oczekiwania. Po ukończeniu operacji oczekiwania wątku roboczego z puli wątków wykonuje odpowiednie funkcja wywołania zwrotnego.      -Podczas wywoływania <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>metody do kolejki metody do wykonania w wątku puli wątków.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> Można to zrobić przez przekazanie metody <xref:System.Threading.WaitCallback>delegować.</xref:System.Threading.WaitCallback>   Delegat ma sygnaturę <CodeContentPlaceHolder>0</CodeContentPlaceHolder><CodeContentPlaceHolder>1</CodeContentPlaceHolder> gdzie `state` jest obiekt, który zawiera dane, które mają być używane przez delegata.    Rzeczywiste dane mogą zostać przekazane do delegata, wywołując <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>metody.</xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>      > [!NOTE] > Wątków w puli wątków zarządzanych są wątki w tle. Oznacza to, że ich <xref:System.Threading.Thread.IsBackground%2A>Właściwości są `true`.</xref:System.Threading.Thread.IsBackground%2A> Oznacza to, że puli wątków nie zachowa aplikacji uruchomionej po zamknięciu wszystkie wątki pierwszego planu.      > [!IMPORTANT] > Gdy puli wątków ponownie używa wątku, nie czyści danych lokalny magazyn wątków lub pola, które są oznaczone ikoną z <xref:System.ThreadStaticAttribute>atrybutu.</xref:System.ThreadStaticAttribute> W związku z tym, gdy metoda sprawdza, czy lokalny magazyn wątków lub pola, które są oznaczone ikoną z <xref:System.ThreadStaticAttribute>Atrybut wartości znajdzie może pozostać za pośrednictwem z wcześniejszego użycia wątku puli wątków.</xref:System.ThreadStaticAttribute>       Można również kolejki elementów pracy, które nie są powiązane z operacją oczekiwania do puli wątków. Aby zażądać, że element pracy ma być obsługiwany przez wątek w puli wątków, należy wywołać <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>metody.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> Ta metoda przyjmuje jako parametr odwołania do metody lub delegata, która zostanie wywołana przez wątek z puli wątków. Nie istnieje sposób anulowania elementu roboczego po jego zostało umieszczone w kolejce.       Czasomierze kolejki czasomierza i zarejestrowanych oczekiwania operacji również używają puli wątków. Funkcje wywołania zwrotnego, ich są umieszczane w kolejce do puli wątków.       Brak jednej puli wątków na proces. Począwszy od [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], domyślny rozmiar puli wątków procesu zależy od wielu czynników, takich jak rozmiar wirtualnej przestrzeni adresowej. Proces może wywołać <xref:System.Threading.ThreadPool.GetMaxThreads%2A>metodę, aby określić liczbę wątków.</xref:System.Threading.ThreadPool.GetMaxThreads%2A> Liczba wątków w puli wątków można zmieniać za pomocą <xref:System.Threading.ThreadPool.SetMaxThreads%2A>metody.</xref:System.Threading.ThreadPool.SetMaxThreads%2A> Każdy wątek używa domyślny rozmiar stosu i uruchamia priorytetem domyślne.      > [!NOTE] > Kodu niezarządzanego, który jest hostem środowiska .NET Framework, można zmienić rozmiar puli wątków za pomocą `CorSetMaxThreads` funkcja zdefiniowana w pliku mscoree.h.       Puli wątków zawiera nowe wątków roboczych lub wątków zakończenia We/Wy na żądanie, dopóki nie osiągnie minimum dla każdej kategorii. Po osiągnięciu minimum puli wątków można utworzyć dodatkowe wątki w tej kategorii lub zaczekaj na zakończenie niektórych zadań. Począwszy od [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], pulą wątków tworzy i niszczy wątków roboczych w celu zoptymalizowania przepustowości, która jest zdefiniowana jako liczba zadań, kończące się na jednostkę czasu. Zbyt mało wątków może nie mieć optymalne wykorzystanie dostępnych zasobów, natomiast zbyt wiele wątków można zwiększyć rywalizacji.      > [!NOTE] > Gdy żądanie jest niskie, rzeczywista liczba wątków z puli wątków można spadnie poniżej wartości minimalnej.       Można użyć <xref:System.Threading.ThreadPool.GetMinThreads%2A>metodę, aby uzyskać te wartości minimalnej.</xref:System.Threading.ThreadPool.GetMinThreads%2A>      > [!CAUTION] > Można użyć <xref:System.Threading.ThreadPool.SetMinThreads%2A>metodę, aby zwiększyć minimalną liczbę wątków roboczych.</xref:System.Threading.ThreadPool.SetMinThreads%2A> Jednak niepotrzebnie zwiększenie tych wartości może spowodować problemy z wydajnością. Jeśli zbyt wiele zadań jest uruchomiona w tym samym czasie, wszystkie z nich wydaje się powoli. W większości przypadków puli wątków będą działać lepiej z własną algorytmu alokacji wątków."
  example:
  - "In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits. The `ThreadProc` method simply displays a message.  \n  \n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/cpp/t-system.threading.threa_5_1.cpp)]\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/visualbasic/t-system.threading.threa_5_1.vb)]\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/csharp/t-system.threading.threa_5_1.cs)]  \n  \n If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method, the main thread exits before         method runs on the thread pool thread.  The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.  (This         is a simple example of a race condition.)"
  syntax:
    content: public static class ThreadPool
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.BindHandle(System.IntPtr)
  id: BindHandle(System.IntPtr)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: BindHandle(IntPtr)
  nameWithType: ThreadPool.BindHandle(IntPtr)
  fullName: System.Threading.ThreadPool.BindHandle(IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Wiąże dojścia systemu operacyjnego do <xref href=&quot;System.Threading.ThreadPool&quot;> </xref>."
  syntax:
    content: public static bool BindHandle (IntPtr osHandle);
    parameters:
    - id: osHandle
      type: System.IntPtr
      description: "<xref:System.IntPtr>Przechowuje dojście.</xref:System.IntPtr> Dojście musi otwarte dla pokrywającej się z inną operacji We/Wy na stronie niezarządzane."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli dojście jest powiązana; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.BindHandle*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Obiekt wywołujący nie ma wymaganych uprawnień."
  platform:
  - net462
- uid: System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
  id: BindHandle(System.Runtime.InteropServices.SafeHandle)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: BindHandle(SafeHandle)
  nameWithType: ThreadPool.BindHandle(SafeHandle)
  fullName: System.Threading.ThreadPool.BindHandle(SafeHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Wiąże dojścia systemu operacyjnego do <xref href=&quot;System.Threading.ThreadPool&quot;> </xref>."
  remarks: "`osHandle` Parametr powinien być <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>co wynika ze abstrakcyjnej <xref:System.Runtime.InteropServices.SafeHandle>klasy.</xref:System.Runtime.InteropServices.SafeHandle> </xref:Microsoft.Win32.SafeHandles.SafeFileHandle>"
  syntax:
    content: public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);
    parameters:
    - id: osHandle
      type: System.Runtime.InteropServices.SafeHandle
      description: "A <xref:System.Runtime.InteropServices.SafeHandle>przechowuje dojście systemu operacyjnego.</xref:System.Runtime.InteropServices.SafeHandle> Dojście musi otwarte dla pokrywającej się z inną operacji We/Wy na stronie niezarządzane."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli dojście jest powiązana; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.BindHandle*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>osHandle</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
  id: GetAvailableThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: GetAvailableThreads(Int32,Int32)
  nameWithType: ThreadPool.GetAvailableThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetAvailableThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Pobiera różnicę między maksymalną liczbę wątków z puli wątków zwrócony przez <xref:System.Threading.ThreadPool.GetMaxThreads*>— Metoda i liczba aktywnych.</xref:System.Threading.ThreadPool.GetMaxThreads*>"
  remarks: "Gdy zwraca GetAvailableThreads, określonej przez zmienną `workerThreads` zawiera liczbę wątków roboczych dodatkowe, które można uruchomić, a zmienna określony przez `completionPortThreads` zawiera liczbę dodatkowych asynchronicznych wątków We/Wy, które może zostać uruchomiona.       Jeśli nie ma żadnych dostępnych wątków, żądania puli wątków dodatkowe pozostają w kolejce do momentu udostępnienie wątków z puli wątków."
  example:
  - "The following example displays the number of worker threads and I/O threads available when a simple app is started.  \n  \n [!code-cs[System.Threading.ThreadPool.GetAvailableThreads#2](~/add/codesnippet/csharp/m-system.threading.threa_23_1.cs)]\n [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/add/codesnippet/visualbasic/m-system.threading.threa_23_1.vb)]"
  syntax:
    content: public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "Liczba wątków roboczych dostępne."
    - id: completionPortThreads
      type: System.Int32
      description: "Liczba dostępnych asynchronicznych wątków We/Wy."
  overload: System.Threading.ThreadPool.GetAvailableThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
  id: GetMaxThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: GetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMaxThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Pobiera liczbę żądań w puli wątków, które mogą być jednocześnie aktywne. Wszystkie żądania powyżej tego numeru pozostają w kolejce do momentu udostępnienie wątków z puli wątków."
  remarks: "Gdy zwraca GetMaxThreads, określonej przez zmienną `workerThreads` zawiera maksymalną liczbę dozwolonych w puli wątków wątków roboczych, a zmienna określony przez `completionPortThreads` zawiera maksymalną liczbę asynchronicznych wątków We/Wy w puli wątków.       Można użyć <xref:System.Threading.ThreadPool.GetAvailableThreads%2A>metodę, aby określić rzeczywistą liczbę wątków w puli wątków w danym momencie.</xref:System.Threading.ThreadPool.GetAvailableThreads%2A>       Można użyć <xref:System.Threading.ThreadPool.SetMaxThreads%2A>Aby ustawić maksymalną liczbę wątków roboczych i asynchronicznych wątków We/Wy w puli wątków.</xref:System.Threading.ThreadPool.SetMaxThreads%2A>       Można dodać do kolejki jako wiele żądań w puli wątków zezwala pamięci systemowej. W przypadku żądań więcej niż wątków z puli wątków dodatkowe żądania pozostają w kolejce do momentu udostępnienie wątków z puli wątków."
  example:
  - "The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool. A work item is queued that uses `FileStream` to asynchronously write to two files. The callback methods are timed to overlap. A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.  \n  \n [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_14_1.cpp)]\n [!code-cs[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_14_1.cs)]\n [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_14_1.vb)]"
  syntax:
    content: public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "Maksymalna liczba wątków roboczych w puli wątków."
    - id: completionPortThreads
      type: System.Int32
      description: "Maksymalna liczba asynchronicznych wątków We/Wy w puli wątków."
  overload: System.Threading.ThreadPool.GetMaxThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
  id: GetMinThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: GetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMinThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Pobiera minimalną liczbę wątków, jakiej puli wątków tworzy na żądanie, jak zostały wprowadzone nowe żądania, przed przełączeniem do zarządzania wątku tworzenie i likwidacja algorytm."
  remarks: "Puli wątków zawiera nowe wątków roboczych lub wątków zakończenia We/Wy na żądanie, dopóki nie osiągnie minimum dla każdej kategorii. Minimalna liczba wątków domyślnie do liczby procesorów w systemie. Po osiągnięciu wartości minimalnej puli wątków można utworzyć dodatkowe wątki w tej kategorii lub zaczekaj na zakończenie niektórych zadań. Począwszy od [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], pulą wątków tworzy i niszczy wątki w celu zoptymalizowania przepustowości, która jest zdefiniowana jako liczba zadań, kończące się na jednostkę czasu. Zbyt mało wątków może nie mieć optymalne wykorzystanie dostępnych zasobów, natomiast zbyt wiele wątków można zwiększyć rywalizacji.      > [!NOTE] > Gdy żądanie jest niskie, rzeczywista liczba wątków z puli wątków można spadnie poniżej wartości minimalnej."
  example:
  - "The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.  \n  \n [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_20_1.vb)]\n [!code-cs[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_20_1.cs)]\n [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_20_1.cpp)]"
  syntax:
    content: public static void GetMinThreads (out int workerThreads, out int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "Gdy metoda zwróci wartość, zawiera minimalną liczbę wątków roboczych, utworzonych puli wątków na żądanie."
    - id: completionPortThreads
      type: System.Int32
      description: "Gdy metoda zwróci wartość, zawiera minimalną liczbę asynchronicznych wątków We/Wy, które tworzy puli wątków na żądanie."
  overload: System.Threading.ThreadPool.GetMinThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
  id: QueueUserWorkItem(System.Threading.WaitCallback)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: QueueUserWorkItem(WaitCallback)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Ustawia metodę do wykonania. Metoda jest wykonywana po udostępnieniu wątku puli wątków."
  remarks: "Można umieścić dane wymagane przez metodę umieszczonych w kolejce w pól wystąpień klasy, w którym zdefiniowano metody, lub można użyć <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>przeciążenia, które akceptuje obiekt zawierający potrzebne dane.</xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>      > [!NOTE] > Użytkowników programu Visual Basic można pominąć <xref:System.Threading.WaitCallback>Konstruktor i po prostu użyj `AddressOf` operator podczas przekazywania metody wywołania zwrotnego do <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> </xref:System.Threading.WaitCallback> Visual Basic automatycznie wywołuje konstruktor delegata poprawne.      ## Wersja informacji w programie .NET Framework w wersji 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>wartość właściwości jest propagowana do wątków w kolejce za pomocą <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>metody.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> We wcześniejszych wersjach głównych informacje nie są propagowane."
  example:
  - "The following example uses the QueueUserWorkItem method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available. No task information is supplied with this overload. Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.  \n  \n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/cpp/m-system.threading.threa_22_1.cpp)]\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/visualbasic/m-system.threading.threa_22_1.vb)]\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/csharp/m-system.threading.threa_22_1.cs)]"
  syntax:
    content: public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);
    parameters:
    - id: callBack
      type: System.Threading.WaitCallback
      description: "A <xref href=&quot;System.Threading.WaitCallback&quot;> </xref> reprezentujący metodę do wykonania."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli metoda pomyślnie znajduje się w kolejce; <xref:System.NotSupportedException>jest generowany, jeśli nie można umieścić w kolejce elementu roboczego.</xref:System.NotSupportedException>"
  overload: System.Threading.ThreadPool.QueueUserWorkItem*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Środowisko uruchomieniowe języka wspólnego (CLR) jest obsługiwana, i host nie obsługuje tej akcji."
  platform:
  - net462
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  id: QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: QueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Metody wykonywania kolejek i określa obiekt zawierający dane, które mają być używane przez metodę. Metoda jest wykonywana po udostępnieniu wątku puli wątków."
  remarks: "Jeśli metoda wywołania zwrotnego wymaga złożone dane, można zdefiniować klasy zawierają dane.      > [!NOTE] > Użytkowników programu Visual Basic można pominąć <xref:System.Threading.WaitCallback>Konstruktor i po prostu użyj `AddressOf` operator podczas przekazywania metody wywołania zwrotnego do QueueUserWorkItem.</xref:System.Threading.WaitCallback> Visual Basic automatycznie wywołuje konstruktor delegata poprawne.      ## Wersja informacji w programie .NET Framework w wersji 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>wartość właściwości jest propagowana do wątków w kolejce za pomocą <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>metody.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> We wcześniejszych wersjach głównych informacje nie są propagowane."
  example:
  - "The following example shows how to create an object that contains task information. It also demonstrates how to pass that object to a task that is queued for execution by the thread pool.  \n  \n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/cpp/9389ae71-aa49-4ceb-9b0a-_1.cpp)]\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/csharp/9389ae71-aa49-4ceb-9b0a-_1.cs)]\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/visualbasic/9389ae71-aa49-4ceb-9b0a-_1.vb)]"
  syntax:
    content: public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);
    parameters:
    - id: callBack
      type: System.Threading.WaitCallback
      description: "A <xref href=&quot;System.Threading.WaitCallback&quot;> </xref> reprezentujący metodę do wykonania."
    - id: state
      type: System.Object
      description: "Obiekt zawierający dane, które mają być używane przez metodę."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli metoda pomyślnie znajduje się w kolejce; <xref:System.NotSupportedException>jest generowany, jeśli nie można umieścić w kolejce elementu roboczego.</xref:System.NotSupportedException>"
  overload: System.Threading.ThreadPool.QueueUserWorkItem*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Środowisko uruchomieniowe języka wspólnego (CLR) jest obsługiwana, i host nie obsługuje tej akcji."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Rejestruje delegata oczekiwania <xref:System.Threading.WaitHandle>, określając 32-bitowej podpisanej liczby całkowitej wartość limitu czasu w milisekundach.</xref:System.Threading.WaitHandle>"
  remarks: "Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle>, który jest zwracany przez tę metodę należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metodę, aby zwolnić odwołania do dojścia oczekiwania.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Zaleca się, że należy zawsze wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metody, nawet jeśli określisz `true` dla `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Wyrzucanie elementów bezużytecznych działa więcej w wydajnie połączeń <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>zamiast metody w zależności od dojścia oczekiwania zarejestrowanych finalizator.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Metoda funkcji RegisterWaitForSingleObject kolejek określonego delegata do puli wątków. Wątek roboczy zostanie wykonany delegata, gdy wystąpi jedno z następujących czynności:-określony obiekt jest w stanie sygnałowego.      — Upłynie interwał limitu czasu.       Metoda funkcji RegisterWaitForSingleObject sprawdza bieżący stan określonego obiektu <xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle> Jeśli stan obiektu jest unsignaled, metoda rejestruje operacji oczekiwania. Operacja oczekiwania została wykonana przez wątek z puli wątków. Delegat jest wykonywana przez wątek roboczy w przypadku sygnalizowane staje się stan obiektu lub upłynie limit czasu. Jeśli `timeOutInterval` parametru jest 0 (zero) i `executeOnlyOnce` parametr jest `false`, jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane lub upłynie limit czasu.      > [!IMPORTANT] > Using <xref:System.Threading.Mutex>dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołań zwrotnych, ponieważ podstawowy interfejs API Win32 używa domyślnej `WT_EXECUTEDEFAULT` Flaga, więc każdego wywołania zwrotnego jest wywoływane w wątku puli oddzielnym wątku.</xref:System.Threading.Mutex> Zamiast <xref:System.Threading.Mutex>, użyj <xref:System.Threading.Semaphore>Maksymalna liczba 1.</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       Aby anulować operację oczekiwania, należy wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metody.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Wątek oczekiwania używa Win32 `WaitForMultipleObjects` funkcja monitorowania zarejestrowanych oczekiwania operacji. W związku z tym, jeśli w wielu wywołań funkcji registerwaitforsingleobject, należy użyć tego samego uchwyt macierzysty systemu operacyjnego, należy skopiować uchwyt, za pomocą środowiska Win32 `DuplicateHandle` funkcji. Należy pamiętać, że użytkownik powinien nie impulsów zdarzeń obiektu przekazanych do funkcji RegisterWaitForSingleObject, ponieważ oczekiwania wątku nie może wykryć, że zdarzenie jest sygnalizowane, zanim zostanie zresetowane.       Przed powrotem, funkcja modyfikuje stan niektórych typów obiektów synchronizacji. Modyfikacja występuje tylko dla obiektu, którego stan sygnałowego spowodował stan oczekiwania, należy spełnić. Na przykład Licznik semafora zostaje zmniejszona o jeden.      ## Wersja informacji w programie .NET Framework w wersji 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>wartość właściwości jest propagowana do wątków roboczych w kolejce za pomocą <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metody.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> We wcześniejszych wersjach głównych informacje nie są propagowane."
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>Do zarejestrowania.</xref:System.Threading.WaitHandle> Użyj <xref:System.Threading.WaitHandle>innego niż <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "<xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref> Delegata do wywołania, gdy `waitObject` jest sygnalizowane parametru."
    - id: state
      type: System.Object
      description: "Obiekt, który jest przekazywany do delegata."
    - id: millisecondsTimeOutInterval
      type: System.Int32
      description: "Limit czasu w milisekundach. Jeśli `millisecondsTimeOutInterval` parametru jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast. Jeśli `millisecondsTimeOutInterval` wynosi -1, nigdy nie upłynie funkcji limitu czasu."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby wskazać, że wątek nie będzie czekać `waitObject` parametru po wywołaniu delegata; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> resetowany czasomierz jest każdorazowo po zakończeniu operacji poczekaj, aż czas oczekiwania jest zarejestrowany."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> Która hermetyzuje uchwyt macierzysty."
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> millisecondsTimeOutInterval </code> Parametr jest mniejsza niż -1."
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Rejestruje delegata oczekiwania <xref:System.Threading.WaitHandle>, określając 64-bitowej podpisanej liczby całkowitej wartość limitu czasu w milisekundach.</xref:System.Threading.WaitHandle>"
  remarks: "Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle>, który jest zwracany przez tę metodę należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metodę, aby zwolnić odwołania do dojścia oczekiwania.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Zaleca się, że należy zawsze wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metody, nawet jeśli określisz `true` dla `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Wyrzucanie elementów bezużytecznych działa więcej w wydajnie połączeń <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>zamiast metody w zależności od dojścia oczekiwania zarejestrowanych finalizator.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Metoda funkcji RegisterWaitForSingleObject kolejek określonego delegata do puli wątków. Wątek roboczy zostanie wykonany delegata, gdy wystąpi jedno z następujących czynności:-określony obiekt jest w stanie sygnałowego.      — Upłynie interwał limitu czasu.       Metoda funkcji RegisterWaitForSingleObject sprawdza bieżący stan określonego obiektu <xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle> Jeśli stan obiektu jest unsignaled, metoda rejestruje operacji oczekiwania. Operacja oczekiwania została wykonana przez wątek z puli wątków. Delegat jest wykonywana przez wątek roboczy w przypadku sygnalizowane staje się stan obiektu lub upłynie limit czasu. Jeśli `timeOutInterval` parametru jest 0 (zero) i `executeOnlyOnce` parametr jest `false`, jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane lub upłynie limit czasu.      > [!IMPORTANT] > Using <xref:System.Threading.Mutex>dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołań zwrotnych, ponieważ podstawowy interfejs API Win32 używa domyślnej `WT_EXECUTEDEFAULT` Flaga, więc każdego wywołania zwrotnego jest wywoływane w wątku puli oddzielnym wątku.</xref:System.Threading.Mutex> Zamiast <xref:System.Threading.Mutex>, użyj <xref:System.Threading.Semaphore>Maksymalna liczba 1.</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       Aby anulować operację oczekiwania, należy wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metody.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Wątek oczekiwania używa Win32 `WaitForMultipleObjects` funkcja monitorowania zarejestrowanych oczekiwania operacji. W związku z tym, jeśli w wielu wywołań funkcji registerwaitforsingleobject, należy użyć tego samego uchwyt macierzysty systemu operacyjnego, należy skopiować uchwyt, za pomocą środowiska Win32 `DuplicateHandle` funkcji. Należy pamiętać, że użytkownik powinien nie impulsów zdarzeń obiektu przekazanych do funkcji RegisterWaitForSingleObject, ponieważ oczekiwania wątku nie może wykryć, że zdarzenie jest sygnalizowane, zanim zostanie zresetowane.       Przed powrotem, funkcja modyfikuje stan niektórych typów obiektów synchronizacji. Modyfikacja występuje tylko dla obiektu, którego stan sygnałowego spowodował stan oczekiwania, należy spełnić. Na przykład Licznik semafora zostaje zmniejszona o jeden.      ## Wersja informacji w programie .NET Framework w wersji 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>wartość właściwości jest propagowana do wątków roboczych w kolejce za pomocą <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metody.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> We wcześniejszych wersjach głównych informacje nie są propagowane."
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>Do zarejestrowania.</xref:System.Threading.WaitHandle> Użyj <xref:System.Threading.WaitHandle>innego niż <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "<xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref> Delegata do wywołania, gdy `waitObject` jest sygnalizowane parametru."
    - id: state
      type: System.Object
      description: "Obiekt przekazywany do delegata."
    - id: millisecondsTimeOutInterval
      type: System.Int64
      description: "Limit czasu w milisekundach. Jeśli `millisecondsTimeOutInterval` parametru jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast. Jeśli `millisecondsTimeOutInterval` wynosi -1, nigdy nie upłynie funkcji limitu czasu."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby wskazać, że wątek nie będzie czekać `waitObject` parametru po wywołaniu delegata; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> resetowany czasomierz jest każdorazowo po zakończeniu operacji poczekaj, aż czas oczekiwania jest zarejestrowany."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> Która hermetyzuje uchwyt macierzysty."
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> millisecondsTimeOutInterval </code> Parametr jest mniejsza niż -1."
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Rejestruje delegata oczekiwania <xref:System.Threading.WaitHandle>, określania <xref:System.TimeSpan>wartość limitu czasu.</xref:System.TimeSpan> </xref:System.Threading.WaitHandle>"
  remarks: "Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle>, który jest zwracany przez tę metodę należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metodę, aby zwolnić odwołania do dojścia oczekiwania.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Zaleca się, że należy zawsze wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metody, nawet jeśli określisz `true` dla `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Wyrzucanie elementów bezużytecznych działa więcej w wydajnie połączeń <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>zamiast metody w zależności od dojścia oczekiwania zarejestrowanych finalizator.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Metoda funkcji RegisterWaitForSingleObject kolejek określonego delegata do puli wątków. Wątek roboczy zostanie wykonany delegata, gdy wystąpi jedno z następujących czynności:-określony obiekt jest w stanie sygnałowego.      — Upłynie interwał limitu czasu.       Metoda funkcji RegisterWaitForSingleObject sprawdza bieżący stan określonego obiektu <xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle> Jeśli stan obiektu jest unsignaled, metoda rejestruje operacji oczekiwania. Operacja oczekiwania została wykonana przez wątek z puli wątków. Delegat jest wykonywana przez wątek roboczy w przypadku sygnalizowane staje się stan obiektu lub upłynie limit czasu. Jeśli `timeOutInterval` parametru jest 0 (zero) i `executeOnlyOnce` parametr jest `false`, jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane lub upłynie limit czasu.      > [!IMPORTANT] > Using <xref:System.Threading.Mutex>dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołań zwrotnych, ponieważ podstawowy interfejs API Win32 używa domyślnej `WT_EXECUTEDEFAULT` Flaga, więc każdego wywołania zwrotnego jest wywoływane w wątku puli oddzielnym wątku.</xref:System.Threading.Mutex> Zamiast <xref:System.Threading.Mutex>, użyj <xref:System.Threading.Semaphore>Maksymalna liczba 1.</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       Aby anulować operację oczekiwania, należy wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metody.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Wątek oczekiwania używa Win32 `WaitForMultipleObjects` funkcja monitorowania zarejestrowanych oczekiwania operacji. W związku z tym, jeśli w wielu wywołań funkcji registerwaitforsingleobject, należy użyć tego samego uchwyt macierzysty systemu operacyjnego, należy skopiować uchwyt, za pomocą środowiska Win32 `DuplicateHandle` funkcji. Należy pamiętać, że użytkownik powinien nie impulsów zdarzeń obiektu przekazanych do funkcji RegisterWaitForSingleObject, ponieważ oczekiwania wątku nie może wykryć, że zdarzenie jest sygnalizowane, zanim zostanie zresetowane.       Przed powrotem, funkcja modyfikuje stan niektórych typów obiektów synchronizacji. Modyfikacja występuje tylko dla obiektu, którego stan sygnałowego spowodował stan oczekiwania, należy spełnić. Na przykład Licznik semafora zostaje zmniejszona o jeden.      ## Wersja informacji w programie .NET Framework w wersji 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>wartość właściwości jest propagowana do wątków roboczych w kolejce za pomocą <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metody.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> We wcześniejszych wersjach głównych informacje nie są propagowane."
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>Do zarejestrowania.</xref:System.Threading.WaitHandle> Użyj <xref:System.Threading.WaitHandle>innego niż <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "<xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref> Delegata do wywołania, gdy `waitObject` jest sygnalizowane parametru."
    - id: state
      type: System.Object
      description: "Obiekt przekazywany do delegata."
    - id: timeout
      type: System.TimeSpan
      description: "Limit czasu reprezentowane przez <xref:System.TimeSpan>.</xref:System.TimeSpan> Jeśli `timeout` jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast. Jeśli `timeout` wynosi -1, nigdy nie upłynie funkcji limitu czasu."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby wskazać, że wątek nie będzie czekać `waitObject` parametru po wywołaniu delegata; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> resetowany czasomierz jest każdorazowo po zakończeniu operacji poczekaj, aż czas oczekiwania jest zarejestrowany."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> Która hermetyzuje uchwyt macierzysty."
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> timeout </code> Parametr jest mniejsza niż -1."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code> timeout </code> Parametru jest większa niż &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;."
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Rejestruje delegata oczekiwania <xref:System.Threading.WaitHandle>, określając 32-bitową nieznakowaną liczbą całkowitą wartość limitu czasu w milisekundach.</xref:System.Threading.WaitHandle>"
  remarks: "Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle>, który jest zwracany przez tę metodę należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metodę, aby zwolnić odwołania do dojścia oczekiwania.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Zaleca się, że należy zawsze wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metody, nawet jeśli określisz `true` dla `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Wyrzucanie elementów bezużytecznych działa więcej w wydajnie połączeń <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>zamiast metody w zależności od dojścia oczekiwania zarejestrowanych finalizator.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>Metody kolejki określonego delegata do puli wątków.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Wątek roboczy zostanie wykonany delegata, gdy wystąpi jedno z następujących czynności:-określony obiekt jest w stanie sygnałowego.      — Upłynie interwał limitu czasu.       <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>Metoda sprawdza bieżący stan określonego obiektu <xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle> </xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Jeśli stan obiektu jest unsignaled, metoda rejestruje operacji oczekiwania. Operacja oczekiwania została wykonana przez wątek z puli wątków. Delegat jest wykonywana przez wątek roboczy w przypadku sygnalizowane staje się stan obiektu lub upłynie limit czasu. Jeśli `timeOutInterval` parametru jest 0 (zero) i `executeOnlyOnce` parametr jest `false`, jest resetowany za każdym razem, gdy zdarzenie jest sygnalizowane lub upłynie limit czasu.      > [!IMPORTANT] > Using <xref:System.Threading.Mutex>dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołań zwrotnych, ponieważ podstawowy interfejs API Win32 używa domyślnej `WT_EXECUTEDEFAULT` Flaga, więc każdego wywołania zwrotnego jest wywoływane w wątku puli oddzielnym wątku.</xref:System.Threading.Mutex> Zamiast <xref:System.Threading.Mutex>, użyj <xref:System.Threading.Semaphore>Maksymalna liczba 1.</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       Aby anulować operację oczekiwania, należy wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metody.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Wątek oczekiwania używa Win32 `WaitForMultipleObjects` funkcja monitorowania zarejestrowanych oczekiwania operacji. W związku z tym należy używać tej samej uchwyt macierzysty system operacyjny w wielu wywołań <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, należy skopiować uchwyt, za pomocą środowiska Win32 `DuplicateHandle` funkcji.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Należy pamiętać, że nie należy impulsów zdarzeń obiektu przekazanych do <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ponieważ oczekiwania wątku nie może wykryć, że zdarzenie jest sygnalizowane, zanim zostanie zresetowane.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>       Przed powrotem, funkcja modyfikuje stan niektórych typów obiektów synchronizacji. Modyfikacja występuje tylko dla obiektu, którego stan sygnałowego spowodował stan oczekiwania, należy spełnić. Na przykład Licznik semafora zostaje zmniejszona o jeden.      ## Wersja informacji w programie .NET Framework w wersji 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>wartość właściwości jest propagowana do wątków roboczych w kolejce za pomocą <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metody.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> We wcześniejszych wersjach głównych informacje nie są propagowane."
  example:
  - "The following example shows how to use the RegisterWaitForSingleObject method to execute a specified callback method when a specified wait handle is signaled. In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.  \n  \n The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes. The example creates a `TaskInfo` object and assigns it some string data. The <xref:System.Threading.RegisteredWaitHandle> that is returned by the RegisterWaitForSingleObject method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.  \n  \n In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the RegisterWaitForSingleObject method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.  \n  \n When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked. The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred. If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks. In the case of a time-out, the task continues to wait. The `WaitProc` method ends by printing a message to the console.  \n  \n [!code-cs[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/csharp/2f901dc9-3ce0-4cdc-bf06-_1.cs)]\n [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/cpp/2f901dc9-3ce0-4cdc-bf06-_1.cpp)]\n [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/visualbasic/2f901dc9-3ce0-4cdc-bf06-_1.vb)]"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>Do zarejestrowania.</xref:System.Threading.WaitHandle> Użyj <xref:System.Threading.WaitHandle>innego niż <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "<xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref> Delegata do wywołania, gdy `waitObject` jest sygnalizowane parametru."
    - id: state
      type: System.Object
      description: "Obiekt przekazywany do delegata."
    - id: millisecondsTimeOutInterval
      type: System.UInt32
      description: "Limit czasu w milisekundach. Jeśli `millisecondsTimeOutInterval` parametru jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast. Jeśli `millisecondsTimeOutInterval` wynosi -1, nigdy nie upłynie funkcji limitu czasu."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby wskazać, że wątek nie będzie czekać `waitObject` parametru po wywołaniu delegata; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> resetowany czasomierz jest każdorazowo po zakończeniu operacji poczekaj, aż czas oczekiwania jest zarejestrowany."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> Można anulować operacji zarejestrowanych oczekiwania."
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> millisecondsTimeOutInterval </code> Parametr jest mniejsza niż -1."
  platform:
  - net462
- uid: System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
  id: SetMaxThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: SetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMaxThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Ustawia liczbę żądań w puli wątków, które mogą być jednocześnie aktywne. Wszystkie żądania powyżej tego numeru pozostają w kolejce do momentu udostępnienie wątków z puli wątków."
  remarks: "Nie można ustawić maksymalną liczbę wątków roboczych lub wątków zakończenia We/Wy na liczbę mniejszą niż liczba procesorów na komputerze. Aby ustalić liczbę procesorów są obecne, pobrać wartość <xref:System.Environment.ProcessorCount%2A?displayProperty=fullName>Właściwości.</xref:System.Environment.ProcessorCount%2A?displayProperty=fullName> Ponadto nie można ustawić maksymalną liczbę wątków roboczych lub zakończenia We/Wy wątków liczbą mniejszą niż odpowiedni minimalna liczba wątków roboczych lub wątków zakończenia We/Wy. Aby określić rozmiar puli wątków minimalne, należy wywołać <xref:System.Threading.ThreadPool.GetMinThreads%2A>metody.</xref:System.Threading.ThreadPool.GetMinThreads%2A>       Jeśli środowisko uruchomieniowe języka wspólnego jest obsługiwana, na przykład przez Internet Information Services (IIS) lub SQL Server hosta można ograniczyć lub uniemożliwić zmiany rozmiaru puli wątków.       Należy zachować ostrożność podczas zmiany maksymalną liczbę wątków w puli wątków. Gdy kod może korzystać, zmiany mogą mieć niekorzystny wpływ na bibliotekach kod, którego używasz.       Ustawienie zbyt duży rozmiar puli wątków może spowodować problemy z wydajnością. Zbyt wiele wątków wykonywania jednocześnie przełączanie zadań nakładów pracy, staje się ważnym czynnikiem."
  syntax:
    content: public static bool SetMaxThreads (int workerThreads, int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "Maksymalna liczba wątków roboczych w puli wątków."
    - id: completionPortThreads
      type: System.Int32
      description: "Maksymalna liczba asynchronicznych wątków We/Wy w puli wątków."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli zmiana zakończy się pomyślnie; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.SetMaxThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
  id: SetMinThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: SetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMinThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Ustawia minimalną liczbę wątków, jakiej puli wątków tworzy na żądanie, wprowadzono nowe żądania, przed przełączeniem algorytm zarządzania wątku tworzenie i likwidacja."
  remarks: "Puli wątków zawiera nowe wątków roboczych lub wątków zakończenia We/Wy na żądanie, dopóki nie osiągnie minimum dla każdej kategorii. Po osiągnięciu wartości minimalnej puli wątków można utworzyć dodatkowe wątki w tej kategorii lub zaczekaj na zakończenie niektórych zadań. Począwszy od [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], pulą wątków tworzy i niszczy wątki w celu zoptymalizowania przepustowości, która jest zdefiniowana jako liczba zadań, kończące się na jednostkę czasu. Zbyt mało wątków może nie mieć optymalne wykorzystanie dostępnych zasobów, natomiast zbyt wiele wątków można zwiększyć rywalizacji.       Jeśli żądanie jest niska, rzeczywista liczba wątków z puli wątków można spadnie poniżej wartości minimalnej.       Jeśli określono wartość ujemną lub większą niż maksymalna liczba aktywnych wątków z puli wątków liczbą (uzyskanych przy użyciu <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), zwraca SetMinThreads `false` i nie zmienia się od wartości minimalnej.</xref:System.Threading.ThreadPool.GetMaxThreads%2A>      > [!CAUTION] > Domyślnie, minimalna liczba wątków jest ustawiona wartość liczby procesorów w systemie. SetMinThreads — metoda umożliwia zwiększenie minimalna liczba ofthreads. Jednak niepotrzebnie zwiększenie tych wartości może spowodować problemy z wydajnością. Jeśli zbyt wiele zadań jest uruchomiona w tym samym czasie, wszystkie z nich wydaje się powoli. W większości przypadków puli wątków będą działać lepiej z własną algorytmu alokacji wątków. Zmniejszanie minimalnej na wartość mniejszą niż liczba procesorów również może pogarszać wydajność."
  example:
  - "The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.  \n  \n [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_10_1.vb)]\n [!code-cs[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_10_1.cs)]\n [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_10_1.cpp)]"
  syntax:
    content: public static bool SetMinThreads (int workerThreads, int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "Minimalna liczba wątków roboczych, utworzonych puli wątków na żądanie."
    - id: completionPortThreads
      type: System.Int32
      description: "Minimalna liczba asynchronicznych wątków We/Wy, które tworzy puli wątków na żądanie."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli zmiana zakończy się pomyślnie; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.SetMinThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  id: UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeQueueNativeOverlapped(NativeOverlapped*)
  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
  fullName: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Kolejkuje pokrywającej się z inną operacji We/Wy do wykonania."
  remarks: "Aby uzyskać informacji o korzystaniu z natywnego Win32 pokrywający się we/wy, zobacz <xref:System.Threading.Overlapped>klasy, <xref:System.Threading.NativeOverlapped>struktury i `OVERLAPPED` struktury w zestawie SDK platformy Win32.</xref:System.Threading.NativeOverlapped> </xref:System.Threading.Overlapped>      > [!CAUTION] > Przy użyciu UnsafeQueueNativeOverlapped metody przypadkowo może otworzyć się luka w zabezpieczeniach. Zabezpieczenia dostępu kodu podstawowych jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie. Podczas pracy przebywa w kolejce w wątku puli wątków, przy użyciu UnsafeQueueNativeOverlapped, stosu wątku puli wątków nie ma kontekście rzeczywiste obiekty wywołujące. Złośliwy kod może być w stanie wykorzystać, aby uniknąć kontroli uprawnień."
  syntax:
    content: public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);
    parameters:
    - id: overlapped
      type: System.Threading.NativeOverlapped*
      description: "<xref href=&quot;System.Threading.NativeOverlapped&quot;> </xref> Struktury do kolejki."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Operacja została pomyślnie umieszczane w kolejce do portu zakończenia We/Wy; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  id: UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeQueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Kolejkuje określonego delegata do puli wątków, ale nie propaguje stosu wywołania do wątku roboczego."
  remarks: "W odróżnieniu od <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>metody UnsafeQueueUserWorkItem nie propaguje stosu wywołania do wątku roboczego.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> Dzięki temu kod utratę stosu wywołania i tym samym podniesienie poziomu swoje uprawnienia zabezpieczeń.      > [!CAUTION] > UnsafeQueueUserWorkItem przy użyciu przypadkowo może otworzyć się luka w zabezpieczeniach. Zabezpieczenia dostępu kodu podstawowych jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie. Podczas pracy przebywa w kolejce w wątku puli wątków, przy użyciu UnsafeQueueUserWorkItem, stosu wątku puli wątków nie będzie miał kontekście rzeczywiste obiekty wywołujące. Złośliwy kod może być w stanie wykorzystać, aby uniknąć kontroli uprawnień."
  syntax:
    content: public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);
    parameters:
    - id: callBack
      type: System.Threading.WaitCallback
      description: "A <xref href=&quot;System.Threading.WaitCallback&quot;> </xref> reprezentujący delegata do wywołania, gdy wątek w puli wątków przejmuje elementu roboczego."
    - id: state
      type: System.Object
      description: "Obiekt, który jest przekazywany do delegata, gdy obsługiwany z puli wątków."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli metoda zakończy się pomyślnie; <xref:System.OutOfMemoryException>jest generowany, jeśli nie można umieścić w kolejce elementu roboczego.</xref:System.OutOfMemoryException>"
  overload: System.Threading.ThreadPool.UnsafeQueueUserWorkItem*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Obiekt wywołujący nie ma wymaganych uprawnień."
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "Wystąpił stan braku pamięci."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Element roboczy nie można umieścić w kolejce."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Rejestruje delegata oczekiwania <xref:System.Threading.WaitHandle>, przy użyciu 32-bitowej podpisanej liczby całkowitej wartość limitu czasu w milisekundach.</xref:System.Threading.WaitHandle> Ta metoda nie są propagowane stosu wywołania do wątku roboczego."
  remarks: "W odróżnieniu od <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metody UnsafeRegisterWaitForSingleObject nie propaguje stosu wywołania do wątku roboczego.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Dzięki temu kod utratę stosu wywołania i tym samym podniesienie poziomu swoje uprawnienia zabezpieczeń.      > [!CAUTION] > UnsafeRegisterWaitForSingleObject przy użyciu przypadkowo może otworzyć się luka w zabezpieczeniach. Zabezpieczenia dostępu kodu podstawowych jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie. Podczas pracy przebywa w kolejce w wątku puli wątków, przy użyciu UnsafeRegisterWaitForSingleObject, stosu wątku puli wątków nie będzie miał kontekście rzeczywiste obiekty wywołujące. Złośliwy kod może być w stanie wykorzystać, aby uniknąć kontroli uprawnień.       Przy użyciu <xref:System.Threading.Mutex>dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołań zwrotnych, ponieważ podstawowy interfejs API Win32 używa domyślnej `WT_EXECUTEDEFAULT` Flaga, więc każdego wywołania zwrotnego jest wywoływane w wątku puli oddzielnym wątku.</xref:System.Threading.Mutex>       Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle>, który jest zwracany przez tę metodę należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metodę, aby zwolnić odwołania do dojścia oczekiwania.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Zaleca się, że należy zawsze wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metody, nawet jeśli określisz `true` dla `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Wyrzucanie elementów bezużytecznych działa więcej w wydajnie połączeń <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>zamiast metody w zależności od dojścia oczekiwania zarejestrowanych finalizator.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>Do zarejestrowania.</xref:System.Threading.WaitHandle> Użyj <xref:System.Threading.WaitHandle>innego niż <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "Delegat do wywołania, gdy `waitObject` jest sygnalizowane parametru."
    - id: state
      type: System.Object
      description: "Obiekt, który jest przekazywany do delegata."
    - id: millisecondsTimeOutInterval
      type: System.Int32
      description: "Limit czasu w milisekundach. Jeśli `millisecondsTimeOutInterval` parametru jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast. Jeśli `millisecondsTimeOutInterval` wynosi -1, nigdy nie upłynie funkcji limitu czasu."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby wskazać, że wątek nie będzie czekać `waitObject` parametru po wywołaniu delegata; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> resetowany czasomierz jest każdorazowo po zakończeniu operacji poczekaj, aż czas oczekiwania jest zarejestrowany."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> Obiektu, który może służyć do anulowania operacji zarejestrowanych oczekiwania."
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> millisecondsTimeOutInterval </code> Parametr jest mniejsza niż -1."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Obiekt wywołujący nie ma wymaganych uprawnień."
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Rejestruje delegata oczekiwania <xref:System.Threading.WaitHandle>, określając 64-bitowej podpisanej liczby całkowitej wartość limitu czasu w milisekundach.</xref:System.Threading.WaitHandle> Ta metoda nie są propagowane stosu wywołania do wątku roboczego."
  remarks: "W odróżnieniu od <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metody UnsafeRegisterWaitForSingleObject nie propaguje stosu wywołania do wątku roboczego.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Dzięki temu kod utratę stosu wywołania i tym samym podniesienie poziomu swoje uprawnienia zabezpieczeń.      > [!CAUTION] > UnsafeRegisterWaitForSingleObject przy użyciu przypadkowo może otworzyć się luka w zabezpieczeniach. Zabezpieczenia dostępu kodu podstawowych jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie. Podczas pracy przebywa w kolejce w wątku puli wątków, przy użyciu UnsafeRegisterWaitForSingleObject, stosu wątku puli wątków nie będzie miał kontekście rzeczywiste obiekty wywołujące. Złośliwy kod może być w stanie wykorzystać, aby uniknąć kontroli uprawnień.       Przy użyciu <xref:System.Threading.Mutex>dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołań zwrotnych, ponieważ podstawowy interfejs API Win32 używa domyślnej `WT_EXECUTEDEFAULT` Flaga, więc każdego wywołania zwrotnego jest wywoływane w wątku puli oddzielnym wątku.</xref:System.Threading.Mutex>       Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle>, który jest zwracany przez tę metodę należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metodę, aby zwolnić odwołania do dojścia oczekiwania.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Zaleca się, że należy zawsze wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metody, nawet jeśli określisz `true` dla `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Wyrzucanie elementów bezużytecznych działa więcej w wydajnie połączeń <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>zamiast metody w zależności od dojścia oczekiwania zarejestrowanych finalizator.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>Do zarejestrowania.</xref:System.Threading.WaitHandle> Użyj <xref:System.Threading.WaitHandle>innego niż <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "Delegat do wywołania, gdy `waitObject` jest sygnalizowane parametru."
    - id: state
      type: System.Object
      description: "Obiekt, który jest przekazywany do delegata."
    - id: millisecondsTimeOutInterval
      type: System.Int64
      description: "Limit czasu w milisekundach. Jeśli `millisecondsTimeOutInterval` parametru jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast. Jeśli `millisecondsTimeOutInterval` wynosi -1, nigdy nie upłynie funkcji limitu czasu."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby wskazać, że wątek nie będzie czekać `waitObject` parametru po wywołaniu delegata; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> resetowany czasomierz jest każdorazowo po zakończeniu operacji poczekaj, aż czas oczekiwania jest zarejestrowany."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> Obiektu, który może służyć do anulowania operacji zarejestrowanych oczekiwania."
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> millisecondsTimeOutInterval </code> Parametr jest mniejsza niż -1."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Obiekt wywołujący nie ma wymaganych uprawnień."
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Rejestruje delegata oczekiwania <xref:System.Threading.WaitHandle>, określania <xref:System.TimeSpan>wartość limitu czasu.</xref:System.TimeSpan> </xref:System.Threading.WaitHandle> Ta metoda nie są propagowane stosu wywołania do wątku roboczego."
  remarks: "W odróżnieniu od <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metody UnsafeRegisterWaitForSingleObject nie propaguje stosu wywołania do wątku roboczego.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Dzięki temu kod utratę stosu wywołania i tym samym podniesienie poziomu swoje uprawnienia zabezpieczeń.      > [!CAUTION] > UnsafeRegisterWaitForSingleObject przy użyciu przypadkowo może otworzyć się luka w zabezpieczeniach. Zabezpieczenia dostępu kodu podstawowych jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie. Podczas pracy przebywa w kolejce w wątku puli wątków, przy użyciu UnsafeRegisterWaitForSingleObject, stosu wątku puli wątków nie będzie miał kontekście rzeczywiste obiekty wywołujące. Złośliwy kod może być w stanie wykorzystać, aby uniknąć kontroli uprawnień.       Przy użyciu <xref:System.Threading.Mutex>dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołań zwrotnych, ponieważ podstawowy interfejs API Win32 używa domyślnej `WT_EXECUTEDEFAULT` Flaga, więc każdego wywołania zwrotnego jest wywoływane w wątku puli oddzielnym wątku.</xref:System.Threading.Mutex>       Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle>, który jest zwracany przez tę metodę należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metodę, aby zwolnić odwołania do dojścia oczekiwania.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Zaleca się, że należy zawsze wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metody, nawet jeśli określisz `true` dla `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Wyrzucanie elementów bezużytecznych działa więcej w wydajnie połączeń <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>zamiast metody w zależności od dojścia oczekiwania zarejestrowanych finalizator.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>Do zarejestrowania.</xref:System.Threading.WaitHandle> Użyj <xref:System.Threading.WaitHandle>innego niż <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "Delegat do wywołania, gdy `waitObject` jest sygnalizowane parametru."
    - id: state
      type: System.Object
      description: "Obiekt, który jest przekazywany do delegata."
    - id: timeout
      type: System.TimeSpan
      description: "Limit czasu reprezentowane przez <xref:System.TimeSpan>.</xref:System.TimeSpan> Jeśli `timeout` jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast. Jeśli `timeout` wynosi -1, nigdy nie upłynie funkcji limitu czasu."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby wskazać, że wątek nie będzie czekać `waitObject` parametru po wywołaniu delegata; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> resetowany czasomierz jest każdorazowo po zakończeniu operacji poczekaj, aż czas oczekiwania jest zarejestrowany."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> Obiektu, który może służyć do anulowania operacji zarejestrowanych oczekiwania."
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> timeout </code> Parametr jest mniejsza niż -1."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code> timeout </code> Parametru jest większa niż &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Obiekt wywołujący nie ma wymaganych uprawnień."
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Rejestruje delegata oczekiwania <xref:System.Threading.WaitHandle>, określając 32-bitową nieznakowaną liczbą całkowitą wartość limitu czasu w milisekundach.</xref:System.Threading.WaitHandle> Ta metoda nie są propagowane stosu wywołania do wątku roboczego."
  remarks: "W odróżnieniu od <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>metody UnsafeRegisterWaitForSingleObject nie propaguje stosu wywołania do wątku roboczego.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Dzięki temu kod utratę stosu wywołania i tym samym podniesienie poziomu swoje uprawnienia zabezpieczeń.      > [!CAUTION] > UnsafeRegisterWaitForSingleObject przy użyciu przypadkowo może otworzyć się luka w zabezpieczeniach. Zabezpieczenia dostępu kodu podstawowych jego uprawnień kontroli uprawnienia wszystkich obiektów wywołujących na stosie. Podczas pracy przebywa w kolejce w wątku puli wątków, przy użyciu UnsafeRegisterWaitForSingleObject, stosu wątku puli wątków nie będzie miał kontekście rzeczywiste obiekty wywołujące. Złośliwy kod może być w stanie wykorzystać, aby uniknąć kontroli uprawnień.       Przy użyciu <xref:System.Threading.Mutex>dla `waitObject` nie zapewnia wzajemne wykluczenie dla wywołań zwrotnych, ponieważ podstawowy interfejs API Win32 używa domyślnej `WT_EXECUTEDEFAULT` Flaga, więc każdego wywołania zwrotnego jest wywoływane w wątku puli oddzielnym wątku.</xref:System.Threading.Mutex>       Po zakończeniu przy użyciu <xref:System.Threading.RegisteredWaitHandle>, który jest zwracany przez tę metodę należy wywołać jej <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metodę, aby zwolnić odwołania do dojścia oczekiwania.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Zaleca się, że należy zawsze wywołać <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>metody, nawet jeśli określisz `true` dla `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Wyrzucanie elementów bezużytecznych działa więcej w wydajnie połączeń <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>zamiast metody w zależności od dojścia oczekiwania zarejestrowanych finalizator.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>Do zarejestrowania.</xref:System.Threading.WaitHandle> Użyj <xref:System.Threading.WaitHandle>innego niż <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "Delegat do wywołania, gdy `waitObject` jest sygnalizowane parametru."
    - id: state
      type: System.Object
      description: "Obiekt, który jest przekazywany do delegata."
    - id: millisecondsTimeOutInterval
      type: System.UInt32
      description: "Limit czasu w milisekundach. Jeśli `millisecondsTimeOutInterval` parametru jest 0 (zero), funkcja sprawdza stan obiektu i zwraca natychmiast. Jeśli `millisecondsTimeOutInterval` wynosi -1, nigdy nie upłynie funkcji limitu czasu."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby wskazać, że wątek nie będzie czekać `waitObject` parametru po wywołaniu delegata; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> resetowany czasomierz jest każdorazowo po zakończeniu operacji poczekaj, aż czas oczekiwania jest zarejestrowany."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> Obiektu, który może służyć do anulowania operacji zarejestrowanych oczekiwania."
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Obiekt wywołujący nie ma wymaganych uprawnień."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ApplicationException
  parent: System
  isExternal: false
  name: ApplicationException
  nameWithType: ApplicationException
  fullName: System.ApplicationException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.Threading.ThreadPool.BindHandle(System.IntPtr)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: BindHandle(IntPtr)
  nameWithType: ThreadPool.BindHandle(IntPtr)
  fullName: System.Threading.ThreadPool.BindHandle(IntPtr)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: BindHandle(SafeHandle)
  nameWithType: ThreadPool.BindHandle(SafeHandle)
  fullName: System.Threading.ThreadPool.BindHandle(SafeHandle)
- uid: System.Runtime.InteropServices.SafeHandle
  parent: System.Runtime.InteropServices
  isExternal: true
  name: SafeHandle
  nameWithType: SafeHandle
  fullName: System.Runtime.InteropServices.SafeHandle
- uid: System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetAvailableThreads(Int32,Int32)
  nameWithType: ThreadPool.GetAvailableThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetAvailableThreads(Int32,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMaxThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMinThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: QueueUserWorkItem(WaitCallback)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback)
- uid: System.Threading.WaitCallback
  parent: System.Threading
  isExternal: false
  name: WaitCallback
  nameWithType: WaitCallback
  fullName: System.Threading.WaitCallback
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: QueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback,Object)
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
- uid: System.Threading.RegisteredWaitHandle
  parent: System.Threading
  isExternal: false
  name: RegisteredWaitHandle
  nameWithType: RegisteredWaitHandle
  fullName: System.Threading.RegisteredWaitHandle
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: true
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle
- uid: System.Threading.WaitOrTimerCallback
  parent: System.Threading
  isExternal: false
  name: WaitOrTimerCallback
  nameWithType: WaitOrTimerCallback
  fullName: System.Threading.WaitOrTimerCallback
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMaxThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMinThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueNativeOverlapped(NativeOverlapped*)
  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
  fullName: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
- uid: System.Threading.ThreadPool.BindHandle*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: BindHandle
  nameWithType: ThreadPool.BindHandle
- uid: System.Threading.ThreadPool.GetAvailableThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetAvailableThreads
  nameWithType: ThreadPool.GetAvailableThreads
- uid: System.Threading.ThreadPool.GetMaxThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMaxThreads
  nameWithType: ThreadPool.GetMaxThreads
- uid: System.Threading.ThreadPool.GetMinThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMinThreads
  nameWithType: ThreadPool.GetMinThreads
- uid: System.Threading.ThreadPool.QueueUserWorkItem*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: QueueUserWorkItem
  nameWithType: ThreadPool.QueueUserWorkItem
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject
  nameWithType: ThreadPool.RegisterWaitForSingleObject
- uid: System.Threading.ThreadPool.SetMaxThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMaxThreads
  nameWithType: ThreadPool.SetMaxThreads
- uid: System.Threading.ThreadPool.SetMinThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMinThreads
  nameWithType: ThreadPool.SetMinThreads
- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueNativeOverlapped
  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped
- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueUserWorkItem
  nameWithType: ThreadPool.UnsafeQueueUserWorkItem
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject
