### YamlMime:ManagedReference
items:
- uid: System.Timers.Timer
  id: Timer
  children:
  - System.Timers.Timer.#ctor
  - System.Timers.Timer.#ctor(System.Double)
  - System.Timers.Timer.AutoReset
  - System.Timers.Timer.BeginInit
  - System.Timers.Timer.Close
  - System.Timers.Timer.Dispose(System.Boolean)
  - System.Timers.Timer.Elapsed
  - System.Timers.Timer.Enabled
  - System.Timers.Timer.EndInit
  - System.Timers.Timer.Interval
  - System.Timers.Timer.Site
  - System.Timers.Timer.Start
  - System.Timers.Timer.Stop
  - System.Timers.Timer.SynchronizingObject
  langs:
  - csharp
  name: Timer
  nameWithType: Timer
  fullName: System.Timers.Timer
  type: Class
  summary: "Generuje zdarzenie po upływie czasu zestawu z opcją generowanie zdarzeń cyklicznego.       Aby przejrzeć kod źródłowy .NET Framework dla tego typu, zobacz [źródło odwołania](http://referencesource.microsoft.com/#System/services/timers/system/timers/Timer.cs#897683f27faba082)."
  remarks: "> [!NOTE]> Tak, aby wyświetlić kod źródłowy .NET Framework dla tego typu, zobacz [źródło odwołania](http://referencesource.microsoft.com/#System/services/timers/system/timers/Timer.cs#897683f27faba082). Można przejrzeć kod źródłowy w tryb online, Pobierz odwołanie do wyświetlenia w trybie offline i kroków opisanych źródeł (w tym poprawek i aktualizacji) podczas debugowania. zobacz [instrukcje](http://referencesource.microsoft.com/).       Timer — składnik jest czasomierza na serwerze, który wywołuje <xref:System.Timers.Timer.Elapsed>zdarzeń aplikacji po wyrażony w milisekundach czas, w <xref:System.Timers.Timer.Interval%2A>Właściwości upłynął.</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> Można skonfigurować obiekt czasomierza, aby zgłosić zdarzenie tylko raz lub wielokrotnie przy użyciu <xref:System.Timers.Timer.AutoReset%2A>Właściwości.</xref:System.Timers.Timer.AutoReset%2A> Zazwyczaj obiekt czasomierza jest zadeklarowane na poziomie klasy tak, aby pozostaje w zakresie tak długo, jak jest to potrzebne. Następnie można obsługiwać jego <xref:System.Timers.Timer.Elapsed>zdarzeń, aby zapewnić prawidłowe przetwarzania.</xref:System.Timers.Timer.Elapsed> Na przykład, załóżmy, że krytyczne serwer, który musi znajdować się systemem 24 godziny na dobę, 7 dni w tygodniu. Można utworzyć usługi, która używa obiektu czasomierza, aby okresowo Sprawdź serwer i upewnij się, że system jest uruchomiona. Jeśli system nie odpowiada, usługa może próbować ponownie uruchomić serwer lub zawiadomić administratora.      > [!IMPORTANT] > Klasa czasomierza jest dostępna tylko na platformie .NET. Nie znajduje się w bibliotece platformy .NET Standard, a nie jest dostępne na innych platformach, takich jak .NET Core lub platformy uniwersalnej systemu Windows. Na tych platformach, a także przenośności na wszystkich platformach .NET, należy użyć <xref:System.Threading.Timer?displayProperty=fullName>klasy zamiast.</xref:System.Threading.Timer?displayProperty=fullName>       Ten typ implementuje <xref:System.IDisposable>interfejsu.</xref:System.IDisposable> Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niego. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A>metody w `try` / `catch` bloku.</xref:System.IDisposable.Dispose%2A> Do usunięcia ich pośrednio, użyj konstrukcji języka takiego jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję &quot;Przy użyciu obiektu który implementuje interfejs IDisposable&quot; w <xref:System.IDisposable>tematu interfejsu.</xref:System.IDisposable>       Klasa czasomierza na serwerze jest przeznaczony do użytku z wątków roboczych w środowisku wielowątkowym. Czasomierze serwera można przenosić między wątków do obsługi zgłoszono <xref:System.Timers.Timer.Elapsed>zdarzenie powodujące dokładności więcej niż czasomierze systemu Windows w wywołaniem zdarzenia w czasie.</xref:System.Timers.Timer.Elapsed>       Timer — składnik wywołuje <xref:System.Timers.Timer.Elapsed>zdarzenia na podstawie wartości (w milisekundach) z <xref:System.Timers.Timer.Interval%2A>Właściwości.</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> Może obsłużyć tego zdarzenia do przetwarzania, które są potrzebne. Na przykład załóżmy, że masz aplikację sprzedaży online stale ogłoszeń zamówień z bazą danych. Usługi, który kompiluje się instrukcje dotyczące wysyłania działa na partię zamówienia, a nie poszczególnych kolejność przetwarzania indywidualnie. Możesz użyć czasomierz można uruchomić co 30 minut przetwarzania wsadowego.      > [!IMPORTANT] > System.Timers.Timer klasa ma taką samą rozdzielczość zegara systemowego. Oznacza to, że <xref:System.Timers.Timer.Elapsed>zdarzenia będą uruchamiane w odstępach czasu zdefiniowanych uzyskuje się poprzez rozpoznanie zegar systemowy, jeśli <xref:System.Timers.Timer.Interval%2A>Właściwości jest mniejsza niż rozdzielczość zegara systemowego.</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> Aby uzyskać więcej informacji, zobacz <xref:System.Timers.Timer.Interval%2A>Właściwości.</xref:System.Timers.Timer.Interval%2A>       Gdy <xref:System.Timers.Timer.AutoReset%2A>ma ustawioną wartość `false`, wywołuje obiekt czasomierza <xref:System.Timers.Timer.Elapsed>zdarzeń tylko jeden raz, po pierwszym <xref:System.Timers.Timer.Interval%2A>upłynął.</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.AutoReset%2A> Aby zachować wywoływanie <xref:System.Timers.Timer.Elapsed>zdarzeń regularnie w odstępach czasu zdefiniowanych przez <xref:System.Timers.Timer.Interval%2A>Ustaw <xref:System.Timers.Timer.AutoReset%2A>do `true`, która jest wartością domyślną.</xref:System.Timers.Timer.AutoReset%2A> </xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed>       Timer — składnik przechwytuje i pomija wszystkie wyjątki zgłaszane przez programy obsługi zdarzeń dla <xref:System.Timers.Timer.Elapsed>zdarzeń.</xref:System.Timers.Timer.Elapsed> Jest to zachowanie może ulec zmianie w przyszłych wersjach programu .NET Framework. Należy jednak pamiętać, że nie jest to wartość true, programów obsługi zdarzeń, które asynchroniczne i obejmują `await` — operator (w języku C#) lub `Await` — operator (w języku Visual Basic). Wyjątki zgłaszane w tych programów obsługi zdarzeń są propagowane do wątek wywołujący, jak pokazano w poniższym przykładzie. Aby uzyskać więcej informacji na wyjątki zgłaszane w metodach asynchronicznych, zobacz [obsługi wyjątków](~/add/includes/ajax-current-ext-md.md).       [!code-cs[System.Timers.Timer#3](~/add/codesnippet/csharp/t-system.timers.timer_1.cs)][!code-vb[System.Timers.Timer#3](~/add/codesnippet/visualbasic/t-system.timers.timer_1.vb) ] Jeśli <xref:System.Timers.Timer.SynchronizingObject%2A>właściwość jest `null`, <xref:System.Timers.Timer.Elapsed>zdarzenie jest zgłaszane przy <xref:System.Threading.ThreadPool>wątku.</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.SynchronizingObject%2A>   Jeśli przetwarzanie <xref:System.Timers.Timer.Elapsed>zdarzenia okresu dłuższego niż <xref:System.Timers.Timer.Interval%2A>, zdarzenie może zostać wywołane ponownie na innym <xref:System.Threading.ThreadPool>wątku.</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> W takiej sytuacji należy współużytkowane programu obsługi zdarzeń.      > [!NOTE] > Metoda obsługi zdarzeń może działać w jednym wątku, w tym samym czasie, który wywołuje inny wątek <xref:System.Timers.Timer.Stop%2A>metody lub zestawy <xref:System.Timers.Timer.Enabled%2A>właściwości `false`.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> Może to spowodować <xref:System.Timers.Timer.Elapsed>zdarzenie jest wywoływane po czasomierz jest zatrzymana.</xref:System.Timers.Timer.Elapsed> Przykład kodu dla <xref:System.Timers.Timer.Stop%2A>metody przedstawia sposób, aby uniknąć tej sytuacji wyścigu.</xref:System.Timers.Timer.Stop%2A>       Nawet wtedy, gdy <xref:System.Timers.Timer.SynchronizingObject%2A>nie jest `null`, <xref:System.Timers.Timer.Elapsed>zdarzeń może wystąpić po <xref:System.Timers.Timer.Dispose%2A>lub <xref:System.Timers.Timer.Stop%2A>została wywołana metoda lub po <xref:System.Timers.Timer.Enabled%2A>ustawioną właściwość `false`, ponieważ sygnału, aby podnieść <xref:System.Timers.Timer.Elapsed>zdarzenie jest zawsze w kolejce do wykonania w wątku puli wątków.</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> </xref:System.Timers.Timer.Dispose%2A> </xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.SynchronizingObject%2A> Jednym ze sposobów rozwiązania jest sytuacja wyścigu można ustawić flagi, który informuje program obsługi zdarzeń dla <xref:System.Timers.Timer.Elapsed>zdarzeń ignorowanie kolejnych zdarzeń.</xref:System.Timers.Timer.Elapsed>       Użycie klasy Timer z elementu interfejsu użytkownika, takich jak formularz lub formant, bez wprowadzania czasomierza na ten element interfejsu użytkownika, Przypisz formularz lub formant, który zawiera czasomierza na <xref:System.Timers.Timer.SynchronizingObject%2A>Właściwości, dzięki czemu zdarzenia jest przekazywane do wątku interfejsu użytkownika.</xref:System.Timers.Timer.SynchronizingObject%2A>       Listę domyślnych wartości właściwości dla wystąpienia czasomierza, zobacz <xref:System.Timers.Timer.%23ctor%2A>konstruktora.</xref:System.Timers.Timer.%23ctor%2A>      > [!TIP] > Należy pamiętać, że biblioteka klas programu .NET Framework zawiera cztery klasy o nazwie `Timer`, każdy z którym znajdują się różne funkcje: >>-czasomierza (w tym temacie): wyzwala zdarzenie w regularnych odstępach czasu. Klasa jest przeznaczony do użycia jako oparte na serwerze lub składnik usługi w środowisku wielowątkowym; nie ma interfejsu użytkownika, a nie jest widoczny w czasie wykonywania.   >- <xref:System.Threading.Timer?displayProperty=fullName>: wykonuje metodę jednego wywołania zwrotnego w wątku puli wątków w regularnych odstępach czasu.</xref:System.Threading.Timer?displayProperty=fullName> Metody wywołania zwrotnego jest zdefiniowany, gdy zegar zostanie uruchomiony i nie można zmienić. Podobnie jak klasa czasomierza ta klasa jest przeznaczone do użytku jako oparte na serwerze lub składnik usługi w środowisku wielowątkowym; nie ma interfejsu użytkownika, a nie jest widoczny w czasie wykonywania.   >- <xref:System.Windows.Forms.Timer?displayProperty=fullName>: składnik formularzy systemu Windows, który wyzwala zdarzenie w regularnych odstępach czasu.</xref:System.Windows.Forms.Timer?displayProperty=fullName> Składnik nie ma interfejsu użytkownika i jest przeznaczony do użytku w środowisku jednowątkowy.   >- <xref:System.Web.UI.Timer?displayProperty=fullName>: składnik ASP.NET, który wykonuje asynchroniczne i synchroniczne strony sieci web ogłaszania zwrotnego w regularnych odstępach czasu.</xref:System.Web.UI.Timer?displayProperty=fullName>"
  example:
  - "The following example instantiates a `System.Timers.Timer` object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2,000 milliseconds), sets up an event handler for the  event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cs[System.Timers.Timer#2](~/add/codesnippet/csharp/t-system.timers.timer_2.cs)]\n [!code-vb[System.Timers.Timer#2](~/add/codesnippet/visualbasic/t-system.timers.timer_2.vb)]"
  syntax:
    content: >-
      [System.ComponentModel.DefaultEvent("Elapsed")]

      [System.ComponentModel.DefaultProperty("Interval")]

      public class Timer : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements:
  - System.ComponentModel.ISupportInitialize
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Timers.Timer.#ctor
  id: '#ctor'
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Timer()
  nameWithType: Timer.Timer()
  fullName: System.Timers.Timer.Timer()
  type: Constructor
  assemblies:
  - System
  namespace: System.Timers
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Timers.Timer&quot;> </xref> klasy, a następnie ustawia wszystkie właściwości ich wartości początkowe."
  remarks: "W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Timers.Timer>.</xref:System.Timers.Timer>      | Właściwość | Nieprawidłowa wartość |   |--------------|-------------------|   | <xref:System.Timers.Timer.AutoReset%2A>| `true`|   | <xref:System.Timers.Timer.Enabled%2A>| `false`|   | <xref:System.Timers.Timer.Interval%2A>|&100; milisekund |   | <xref:System.Timers.Timer.SynchronizingObject%2A>| Odwołanie o wartości null (`Nothing` w języku Visual Basic). |</xref:System.Timers.Timer.SynchronizingObject%2A> </xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.AutoReset%2A>"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/m-system.timers.timer.sh_1_1.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/m-system.timers.timer.sh_1_1.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/m-system.timers.timer.sh_1_1.vb)]"
  syntax:
    content: public Timer ();
    parameters: []
  overload: System.Timers.Timer.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.#ctor(System.Double)
  id: '#ctor(System.Double)'
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Timer(Double)
  nameWithType: Timer.Timer(Double)
  fullName: System.Timers.Timer.Timer(Double)
  type: Constructor
  assemblies:
  - System
  namespace: System.Timers
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Timers.Timer&quot;> </xref> klasy i zestawy <xref:System.Timers.Timer.Interval*>Właściwości na określoną liczbę milisekund.</xref:System.Timers.Timer.Interval*>"
  remarks: "Ten konstruktor ustawia <xref:System.Timers.Timer.Interval%2A>Właściwości nowe wystąpienie czasomierza, ale nie obsługuje czasomierza.</xref:System.Timers.Timer.Interval%2A>"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cs[System.Timers.Timer#3](~/add/codesnippet/csharp/m-system.timers.timer.sh_0_1.cs)]\n [!code-vb[System.Timers.Timer#3](~/add/codesnippet/visualbasic/m-system.timers.timer.sh_0_1.vb)]"
  syntax:
    content: public Timer (double interval);
    parameters:
    - id: interval
      type: System.Double
      description: "Czas w milisekundach między zdarzeniami. Wartość musi być większa niż zero i mniejsza niż lub równe &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;."
  overload: System.Timers.Timer.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Wartość <code> interval </code> parametr jest większa od zera lub większej niż &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;."
  platform:
  - net462
- uid: System.Timers.Timer.AutoReset
  id: AutoReset
  parent: System.Timers.Timer
  langs:
  - csharp
  name: AutoReset
  nameWithType: Timer.AutoReset
  fullName: System.Timers.Timer.AutoReset
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "Pobiera lub ustawia wartość logiczna wskazującą czy <xref href=&quot;System.Timers.Timer&quot;> </xref> należy podnieść <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> zdarzeń tylko raz (<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>) lub wielokrotnie (<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>)."
  remarks: "Jeśli <xref:System.Timers.Timer>jest już włączona, gdy <xref:System.Timers.Timer.Start%2A>Metoda jest wywoływana, interwał zostanie zresetowana.</xref:System.Timers.Timer.Start%2A> </xref:System.Timers.Timer> Jeśli jest AutoReset `false`, <xref:System.Timers.Timer.Start%2A>można wywołać metody, aby ponownie rozpocząć obliczanie.</xref:System.Timers.Timer.Start%2A>       Resetowanie interwał wpływa na kiedy <xref:System.Timers.Timer.Elapsed>zdarzenie jest wywoływane.</xref:System.Timers.Timer.Elapsed> Na przykład ustawić interwał wynoszący 5 sekund, a następnie ustaw <xref:System.Timers.Timer.Enabled%2A>właściwości `true`, licznik, który rozpoczyna się w czasie <xref:System.Timers.Timer.Enabled%2A>jest ustawiona.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Enabled%2A> Jeśli zresetujesz interwał na 10 sekund, jeśli licznik osiągnie wartość 3 sekundy <xref:System.Timers.Timer.Elapsed>zdarzenie jest wywoływane po raz pierwszy 13 sekund po <xref:System.Timers.Timer.Enabled%2A>ustawiono właściwość `true`.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Elapsed>"
  example:
  - "The following example creates a <xref:System.Timers.Timer> whose <xref:System.Timers.Timer.Elapsed> event fires after 1.5 seconds. Its event handler then displays \"Hello World!\" on the console.  \n  \n [!code-vb[Classic Timer.Timer1 Example#1](~/add/codesnippet/visualbasic/p-system.timers.timer.au_1.vb)]\n [!code-cs[Classic Timer.Timer1 Example#1](~/add/codesnippet/csharp/p-system.timers.timer.au_1.cs)]\n [!code-cpp[Classic Timer.Timer1 Example#1](~/add/codesnippet/cpp/p-system.timers.timer.au_1.cpp)]"
  syntax:
    content: public bool AutoReset { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli <xref href=&quot;System.Timers.Timer&quot;> </xref> należy podnieść <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> zdarzeń zawsze czasu; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> powinien on podniesieniu <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> zdarzeń tylko raz, po raz pierwszy czasu. Wartość domyślna to <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Timers.Timer.AutoReset*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.BeginInit
  id: BeginInit
  parent: System.Timers.Timer
  langs:
  - csharp
  name: BeginInit()
  nameWithType: Timer.BeginInit()
  fullName: System.Timers.Timer.BeginInit()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "Rozpoczyna inicjowanie środowiska wykonawczego <xref href=&quot;System.Timers.Timer&quot;> </xref> używany w formularzu lub przez inny składnik."
  remarks: "[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] Projekt środowiska korzystania z tej metody można uruchomić inicjowania składnika, który jest używany w formularzu lub przez inny składnik. <xref:System.Timers.Timer.EndInit%2A>Metoda kończy się inicjowania.</xref:System.Timers.Timer.EndInit%2A> Przy użyciu BeginInit i <xref:System.Timers.Timer.EndInit%2A>metody uniemożliwia użycie przed pełnym zainicjowaniem kontrolki.</xref:System.Timers.Timer.EndInit%2A>"
  syntax:
    content: public void BeginInit ();
    parameters: []
  overload: System.Timers.Timer.BeginInit*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Close
  id: Close
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Close()
  nameWithType: Timer.Close()
  fullName: System.Timers.Timer.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "Zwalnia zasoby używane przez <xref href=&quot;System.Timers.Timer&quot;> </xref>."
  remarks: "Z kolei wywołuje metody Close `Dispose` metody."
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Timers.Timer.Close*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: Timer.Dispose(Boolean)
  fullName: System.Timers.Timer.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "Zwalnia wszelkie zasoby używane przez bieżące <xref href=&quot;System.Timers.Timer&quot;> </xref>."
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby zwolnić zasoby zarządzane i niezarządzane; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> aby zwolnić tylko zasoby niezarządzane."
  overload: System.Timers.Timer.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Elapsed
  id: Elapsed
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Elapsed
  nameWithType: Timer.Elapsed
  fullName: System.Timers.Timer.Elapsed
  type: Event
  assemblies:
  - System
  namespace: System.Timers
  summary: "Występuje, gdy upłynie interwał."
  remarks: "Zdarzenie upłynęło jest wywoływane, gdy <xref:System.Timers.Timer.Enabled%2A>właściwość jest `true` i przedział czasu (w milisekundach) zdefiniowanych przez <xref:System.Timers.Timer.Interval%2A>Właściwości upłynie.</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Enabled%2A> Jeśli <xref:System.Timers.Timer.AutoReset%2A>właściwość jest `true`, zdarzenie jest wywoływane wielokrotnie w odstępach czasu zdefiniowanych przez <xref:System.Timers.Timer.Interval%2A>właściwość; w przeciwnym razie zdarzenie jest wywoływane tylko raz, po raz pierwszy <xref:System.Timers.Timer.Interval%2A>wartość upłynie.</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.AutoReset%2A>       Jeśli <xref:System.Timers.Timer.Interval%2A>jest ustawiany po <xref:System.Timers.Timer>została uruchomiona, zostanie zresetowany.</xref:System.Timers.Timer> </xref:System.Timers.Timer.Interval%2A> Na przykład ustawić interwał wynoszący 5 sekund, a następnie ustaw <xref:System.Timers.Timer.Enabled%2A>do `true`, licznik, który rozpoczyna się w czasie <xref:System.Timers.Timer.Enabled%2A>jest ustawiona.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Enabled%2A> Jeśli zresetujesz interwał na 10 sekund, gdy liczba jest 3 sekundy, zdarzenie upłynęło jest wywoływane po raz pierwszy 13 sekund po <xref:System.Timers.Timer.Enabled%2A>ustawiono `true`.</xref:System.Timers.Timer.Enabled%2A>       Jeśli <xref:System.Timers.Timer.SynchronizingObject%2A>jest właściwość `null`, który upłynął zdarzenie jest zgłaszane przy <xref:System.Threading.ThreadPool>wątku.</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.SynchronizingObject%2A> Jeśli przetwarzanie zdarzeń upłynęło trwa dłużej niż <xref:System.Timers.Timer.Interval%2A>, zdarzenie może zostać wywołane ponownie na innym <xref:System.Threading.ThreadPool>wątku.</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Interval%2A> W takiej sytuacji należy współużytkowane programu obsługi zdarzeń.      > [!NOTE] > Metoda obsługi zdarzeń może działać w jednym wątku, w tym samym czasie, który wywołuje inny wątek <xref:System.Timers.Timer.Stop%2A>metody lub zestawy <xref:System.Timers.Timer.Enabled%2A>właściwości `false`.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> Może to spowodować zdarzeń upłynęło są zgłaszane po wyłączeniu czasomierza. Przykład kodu dla <xref:System.Timers.Timer.Stop%2A>metody przedstawia sposób, aby uniknąć tej sytuacji wyścigu.</xref:System.Timers.Timer.Stop%2A>       Nawet jeśli <xref:System.Timers.Timer.SynchronizingObject%2A>nie jest `null`, zdarzeń Elapsed może wystąpić po <xref:System.Timers.Timer.Dispose%2A>lub <xref:System.Timers.Timer.Stop%2A>została wywołana metoda lub po <xref:System.Timers.Timer.Enabled%2A>ustawioną właściwość `false`, ponieważ sygnału, aby zgłosić zdarzenie upłynęło zawsze jest przechowywane w kolejce do wykonania w wątku puli wątków.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> </xref:System.Timers.Timer.Dispose%2A> </xref:System.Timers.Timer.SynchronizingObject%2A> Jednym ze sposobów rozwiązania sytuacja wyścigu jest ustawiona flaga, która informuje program obsługi zdarzeń dla zdarzenia upłynęło ignorowanie kolejnych zdarzeń.       <xref:System.Timers.Timer>Składnika przechwytuje i pomija wszystkie wyjątki zgłaszane przez programy obsługi zdarzeń dla zdarzenia, który upłynął.</xref:System.Timers.Timer> Jest to zachowanie może ulec zmianie w przyszłych wersjach programu .NET Framework."
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its Elapsed event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/e-system.timers.timer.el_1.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/e-system.timers.timer.el_1.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/e-system.timers.timer.el_1.vb)]"
  syntax:
    content: public event System.Timers.ElapsedEventHandler Elapsed;
    return:
      type: System.Timers.ElapsedEventHandler
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Enabled
  id: Enabled
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Enabled
  nameWithType: Timer.Enabled
  fullName: System.Timers.Timer.Enabled
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "Pobiera lub ustawia wartość wskazującą czy <xref href=&quot;System.Timers.Timer&quot;> </xref> należy podnieść <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> zdarzeń."
  remarks: "Włączone ustawienie `true` jest taka sama jak wywołania <xref:System.Timers.Timer.Start%2A>, gdy ustawienie włączone do `false` jest taka sama jak wywołanie <xref:System.Timers.Timer.Stop%2A>.</xref:System.Timers.Timer.Stop%2A> </xref:System.Timers.Timer.Start%2A>      > [!NOTE] > Sygnału, aby podnieść <xref:System.Timers.Timer.Elapsed>zdarzenie jest zawsze umieszczonych w kolejce do wykonania na <xref:System.Threading.ThreadPool>wątku.</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Elapsed> Może to spowodować <xref:System.Timers.Timer.Elapsed>zdarzenie jest wywoływane po ma ustawioną właściwość Enabled `false`.</xref:System.Timers.Timer.Elapsed> Przykład kodu dla <xref:System.Timers.Timer.Stop%2A>metody przedstawia sposób obejścia sytuacja wyścigu.</xref:System.Timers.Timer.Stop%2A>       Jeśli włączone jest równa `true` i <xref:System.Timers.Timer.AutoReset%2A>ustawiono `false`, <xref:System.Timers.Timer>zgłasza <xref:System.Timers.Timer.Elapsed>zdarzeń tylko raz, po raz pierwszy interwał upływa.</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer> </xref:System.Timers.Timer.AutoReset%2A>       Jeśli interwał jest ustawiany po <xref:System.Timers.Timer>została uruchomiona, zostanie zresetowany.</xref:System.Timers.Timer> Na przykład ustawić interwał wynoszący 5 sekund, a następnie ustaw właściwości Enabled `true`, licznik rozpoczyna się od czasu ustawionego jest włączone. Jeśli zresetujesz interwał na 10 sekund, gdy liczba jest 3 sekundy <xref:System.Timers.Timer.Elapsed>zdarzenie jest wywoływane po raz pierwszy 13 sekund po włączone została ustawiona na `true`.</xref:System.Timers.Timer.Elapsed>      > [!NOTE] > Niektórych wizualnych projektantów, takich jak w programie Microsoft Visual Studio, ustaw dla właściwości włączone `true` podczas wstawiania nowych <xref:System.Timers.Timer>.</xref:System.Timers.Timer>"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the  event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/p-system.timers.timer.en_1.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/p-system.timers.timer.en_1.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/p-system.timers.timer.en_1.vb)]"
  syntax:
    content: public bool Enabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli <xref href=&quot;System.Timers.Timer&quot;> </xref> należy podnieść <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> zdarzeń; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Wartość domyślna to <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Timers.Timer.Enabled*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Nie można ustawić tej właściwości, ponieważ zegar został usunięty."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref:System.Timers.Timer.Interval*>Właściwość została ustawiona na wartość większą niż &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt; przed włączeniem czasomierza.</xref:System.Timers.Timer.Interval*>"
  platform:
  - net462
- uid: System.Timers.Timer.EndInit
  id: EndInit
  parent: System.Timers.Timer
  langs:
  - csharp
  name: EndInit()
  nameWithType: Timer.EndInit()
  fullName: System.Timers.Timer.EndInit()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "Kończy się inicjowanie środowiska wykonawczego <xref href=&quot;System.Timers.Timer&quot;> </xref> używany w formularzu lub przez inny składnik."
  remarks: "[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] Projekt środowiska korzystania z tej metody do zakończenia inicjowania składnika, który jest używany w formularzu lub przez inny składnik. <xref:System.Timers.Timer.BeginInit%2A>Metoda uruchamia inicjowania.</xref:System.Timers.Timer.BeginInit%2A> Przy użyciu <xref:System.Timers.Timer.BeginInit%2A>i metody EndInit uniemożliwia użycie przed pełnym zainicjowaniem kontrolki.</xref:System.Timers.Timer.BeginInit%2A>"
  syntax:
    content: public void EndInit ();
    parameters: []
  overload: System.Timers.Timer.EndInit*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Interval
  id: Interval
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Interval
  nameWithType: Timer.Interval
  fullName: System.Timers.Timer.Interval
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "Pobiera lub ustawia interwał wyrażony w milisekundach, w którym należy podnieść <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> zdarzeń."
  remarks: "Właściwość interwał służy do określenia częstotliwość, z jaką <xref:System.Timers.Timer.Elapsed>zdarzenie jest wywoływane.</xref:System.Timers.Timer.Elapsed> Ponieważ <xref:System.Timers.Timer>klasy zależy zegar systemowy, ma taką samą rozdzielczość zegara systemowego.</xref:System.Timers.Timer> Oznacza to, że <xref:System.Timers.Timer.Elapsed>zdarzenia będą uruchamiane w odstępach czasu zdefiniowanych uzyskuje się poprzez rozpoznanie zegar systemowy, jeśli właściwość interwał jest mniejsza niż rozdzielczość zegara systemowego.</xref:System.Timers.Timer.Elapsed> Poniższy przykład ustawia właściwości interwału do 5 w milisekundach. Uruchomienia [!INCLUDE[win7](~/add/includes/win7-md.md)] systemu, w których zegara systemowego ma rozdzielczość około 15 milisekund, generowane zdarzenie co około 15 milisekund niż co 5 milisekund.       [!code-cs[System.Timers.Timer.Interval#1](~/add/codesnippet/csharp/p-system.timers.timer.in_1.cs)][!code-vb[System.Timers.Timer.Interval#1](~/add/codesnippet/visualbasic/p-system.timers.timer.in_1.vb) ] poniższy kod umożliwia określenie rozdzielczości zegara systemowego w bieżącym systemie: [!code-cs [System.Timers.Timer.Interval#2](~/add/codesnippet/csharp/p-system.timers.timer.in_2.cs)][!code-vb[System.Timers.Timer.Interval#2](~/add/codesnippet/visualbasic/p-system.timers.timer.in_2.vb) ] Jeśli aplikacja wymaga rozpoznawania większa niż oferowane przez <xref:System.Timers.Timer>klasy lub zegar systemowy, użyj wysokiej rozdzielczości czasomierze multimediów; zobacz [porady: Użyj czasomierza rozdzielczości](http://msdn.microsoft.com/library/aa964692.aspx).</xref:System.Timers.Timer>           Jeśli interwał jest ustawiany po <xref:System.Timers.Timer>została uruchomiona, zostanie zresetowany.</xref:System.Timers.Timer> Na przykład ustawić interwał wynoszący 5 sekund, a następnie ustaw <xref:System.Timers.Timer.Enabled%2A>właściwości `true`, licznik, który rozpoczyna się w czasie <xref:System.Timers.Timer.Enabled%2A>jest ustawiona.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Enabled%2A> Jeśli zresetujesz interwał na 10 sekund, gdy liczba jest 3 sekundy <xref:System.Timers.Timer.Elapsed>zdarzenie jest wywoływane po raz pierwszy 13 sekund po <xref:System.Timers.Timer.Enabled%2A>ustawiono `true`.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Elapsed>       Jeśli <xref:System.Timers.Timer.Enabled%2A>ustawiono `true` i <xref:System.Timers.Timer.AutoReset%2A>ma ustawioną wartość `false`, <xref:System.Timers.Timer>zgłasza <xref:System.Timers.Timer.Elapsed>zdarzeń tylko raz, po raz pierwszy interwał upływa.</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer> </xref:System.Timers.Timer.AutoReset%2A> </xref:System.Timers.Timer.Enabled%2A> <xref:System.Timers.Timer.Enabled%2A>następnie ustawiono `false`.</xref:System.Timers.Timer.Enabled%2A>      > [!NOTE] > Jeśli <xref:System.Timers.Timer.Enabled%2A>i <xref:System.Timers.Timer.AutoReset%2A>są ustawione na `false`, i czasomierza wcześniej została włączona, ustawienie interwału przyczyny właściwości <xref:System.Timers.Timer.Elapsed>się jeden raz, zdarzenia tak, jakby <xref:System.Timers.Timer.Enabled%2A>właściwość ma ustawioną `true`.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.AutoReset%2A> </xref:System.Timers.Timer.Enabled%2A> Aby ustawić interwał bez wywołaniem zdarzenia, można tymczasowo ustawić <xref:System.Timers.Timer.Enabled%2A>właściwości `true`, ustaw dla właściwości interwału żądanego interwału, a następnie natychmiast ustaw <xref:System.Timers.Timer.Enabled%2A>Właściwości z powrotem do `false`.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Enabled%2A>"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/p-system.timers.timer.in_3.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/p-system.timers.timer.in_3.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/p-system.timers.timer.in_3.vb)]"
  syntax:
    content: public double Interval { get; set; }
    return:
      type: System.Double
      description: "Czas w milisekundach między <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> zdarzenia. Wartość musi być większa niż zero i mniejsza niż lub równe &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;. Wartość domyślna to 100 milisekund."
  overload: System.Timers.Timer.Interval*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Interwał jest mniejsza lub równa zero.       Interwał jest większa niż - lub - &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;, a czasomierz jest aktualnie włączone. (Jeśli licznik nie jest aktualnie włączone, nie jest zwracany wyjątek, dopóki nie zostanie włączona.)"
  platform:
  - net462
- uid: System.Timers.Timer.Site
  id: Site
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Site
  nameWithType: Timer.Site
  fullName: System.Timers.Timer.Site
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "Pobiera lub ustawia lokacji, która jest powiązywana <xref href=&quot;System.Timers.Timer&quot;> </xref> do jego kontenera w trybie projektowania."
  remarks: "Powiązania witryny <xref:System.ComponentModel.Component>do <xref:System.ComponentModel.Container>i umożliwić komunikację między nimi, dzięki czemu kontener, aby zarządzać jego składniki.</xref:System.ComponentModel.Container> </xref:System.ComponentModel.Component>"
  syntax:
    content: public override System.ComponentModel.ISite Site { get; set; }
    return:
      type: System.ComponentModel.ISite
      description: "<xref href=&quot;System.ComponentModel.ISite&quot;> </xref> Interfejs reprezentujący lokacji, która jest powiązywana <xref href=&quot;System.Timers.Timer&quot;> </xref> obiektu do jego kontenera."
  overload: System.Timers.Timer.Site*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Start
  id: Start
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Start()
  nameWithType: Timer.Start()
  fullName: System.Timers.Timer.Start()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "Uruchamia wywoływanie <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> zdarzenia przez ustawienie <xref:System.Timers.Timer.Enabled*>do <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Timers.Timer.Enabled*>"
  remarks: "Jeśli zostanie wywołany Start i <xref:System.Timers.Timer.AutoReset%2A>ma ustawioną wartość `false`, <xref:System.Timers.Timer>zgłasza <xref:System.Timers.Timer.Elapsed>upływa zdarzeń tylko raz, po raz pierwszy interwał.</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer> </xref:System.Timers.Timer.AutoReset%2A> Jeśli zostanie wywołany Start i <xref:System.Timers.Timer.AutoReset%2A>jest `true`, <xref:System.Timers.Timer>zgłasza <xref:System.Timers.Timer.Elapsed>czas trwania zdarzenia pierwszy interwał upływa i będzie nadal występować wywołać zdarzenia w określonym przedziale czasu.</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer> </xref:System.Timers.Timer.AutoReset%2A>       Można także uruchomić przez ustawienie czasu <xref:System.Timers.Timer.Enabled%2A>do `true`.</xref:System.Timers.Timer.Enabled%2A>      > [!NOTE] > Jeśli <xref:System.Timers.Timer.AutoReset%2A>jest `false`, musi zostać wywołana metoda Start Aby ponownie rozpocząć obliczanie.</xref:System.Timers.Timer.AutoReset%2A>       Wywołanie metody rozpoczęcia włączenie czasomierza nie ma znaczenia."
  syntax:
    content: public void Start ();
    parameters: []
  overload: System.Timers.Timer.Start*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<xref href=&quot;System.Timers.Timer&quot;> </xref> Utworzeniu interwał równy lub większy niż &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt; + 1 lub ustaw interwał mniejsze od zera."
  platform:
  - net462
- uid: System.Timers.Timer.Stop
  id: Stop
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Stop()
  nameWithType: Timer.Stop()
  fullName: System.Timers.Timer.Stop()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "Zatrzymuje wywoływanie <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> zdarzenia przez ustawienie <xref:System.Timers.Timer.Enabled*>do <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Timers.Timer.Enabled*>"
  remarks: "Można również zatrzymać chronometrażu przez ustawienie <xref:System.Timers.Timer.Enabled%2A>do `false`.</xref:System.Timers.Timer.Enabled%2A>      > [!NOTE] > Sygnału, aby podnieść <xref:System.Timers.Timer.Elapsed>zdarzenie jest zawsze umieszczonych w kolejce do wykonania na <xref:System.Threading.ThreadPool>wątku, dlatego metoda obsługi zdarzeń może działać w jednym wątku, w tym samym czasie, wykonywana przez wywołanie do metody Stop w innym wątku.</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Elapsed> Może to spowodować <xref:System.Timers.Timer.Elapsed>zdarzenie jest wywoływane po wywołaniu metody Stop.</xref:System.Timers.Timer.Elapsed> W następnej sekcji przykładowy kod przedstawia sposób obejścia sytuacja wyścigu."
  example:
  - "The following example instantiates a `System.Timers.Timer` object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2,000 milliseconds), sets up an event handler for the  event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised. When the user presses the Enter key, the application calls the  Stop method before terminating the application.  \n  \n [!code-cs[System.Timers.Timer#2](~/add/codesnippet/csharp/m-system.timers.timer.stop_1.cs)]\n [!code-vb[System.Timers.Timer#2](~/add/codesnippet/visualbasic/m-system.timers.timer.stop_1.vb)]  \n  \n The following code example shows one way to prevent the thread that calls the Stop method from continuing until a currently executing <xref:System.Timers.Timer.Elapsed> event ends, and also to prevent two <xref:System.Timers.Timer.Elapsed> events from executing the event handler at the same time (often referred to as reentrancy).  \n  \n The example executes 100 test runs. Each time the test is run, the timer is started with an interval of 150 milliseconds. The event handler uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method to simulate a task that randomly varies in length from 50 to 200 milliseconds. The test method also starts a control thread that waits for a second and then stops the timer. If an event is being handled when the control thread stops the timer, the control thread must wait until the event is finished before proceeding.  \n  \n The <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29?displayProperty=fullName> method overload is used to avoid reentrancy and to prevent the control thread from continuing until an executing event ends. The event handler uses the <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> method to set a control variable to 1, but only if the value is currently zero. This is an atomic operation. If the return value is zero, the control variable has been set to 1 and the event handler proceeds. If the return value is non-zero, the event is simply discarded to avoid reentrancy. (If it were necessary to execute every event, the <xref:System.Threading.Monitor> class would be a better way to synchronize the events.) When the event handler ends, it sets the control variable back to zero. The example records the total number of events that executed, that were discarded because of reentrancy, and that occurred after the Stop method was called.  \n  \n The control thread uses the <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> method to set the control variable to -1 (minus one), but only if the value is currently zero. If the atomic operation returns non-zero, an event is currently executing. The control thread waits and tries again. The example records the number of times the control thread had to wait for an event to finish.  \n  \n [!code-cs[Timer.Stop#1](~/add/codesnippet/csharp/m-system.timers.timer.stop_2.cs)]\n [!code-vb[Timer.Stop#1](~/add/codesnippet/visualbasic/m-system.timers.timer.stop_2.vb)]"
  syntax:
    content: public void Stop ();
    parameters: []
  overload: System.Timers.Timer.Stop*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.SynchronizingObject
  id: SynchronizingObject
  parent: System.Timers.Timer
  langs:
  - csharp
  name: SynchronizingObject
  nameWithType: Timer.SynchronizingObject
  fullName: System.Timers.Timer.SynchronizingObject
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "Pobiera lub ustawia obiekt używany do organizowania wywołań obsługi zdarzeń, które są wydawane po upłynięciu interwału."
  remarks: "Gdy jest SynchronizingObject `null`, metoda obsługująca <xref:System.Timers.Timer.Elapsed>zdarzenie jest wywoływane w wątku z puli wątków systemu.</xref:System.Timers.Timer.Elapsed> Aby uzyskać więcej informacji na pule wątków systemu zobacz <xref:System.Threading.ThreadPool>.</xref:System.Threading.ThreadPool>       Gdy <xref:System.Timers.Timer.Elapsed>zdarzenie jest obsługiwane przez składnik visual formularzy systemu Windows, takie jak przycisk, uzyskiwanie dostępu do składnika za pośrednictwem puli wątków systemu może wynik wyjątku lub po prostu mogą nie działać.</xref:System.Timers.Timer.Elapsed> Ustawiając SynchronizingObject do składnika formularzy systemu Windows, co powoduje, że metoda obsługująca uniknąć tego efektu <xref:System.Timers.Timer.Elapsed>zdarzeń ma być wywołane na tym samym wątku, który składnik został utworzony na.</xref:System.Timers.Timer.Elapsed>      > [!NOTE] > Nawet, jeśli właściwość SynchronizingObject nie jest `null`, <xref:System.Timers.Timer.Elapsed>zdarzeń może wystąpić po <xref:System.Timers.Timer.Dispose%2A>lub <xref:System.Timers.Timer.Stop%2A>została wywołana metoda lub po <xref:System.Timers.Timer.Enabled%2A>ustawioną właściwość `false`, ponieważ sygnału, aby podnieść <xref:System.Timers.Timer.Elapsed>zdarzenie jest zawsze w kolejce do wykonania w wątku puli wątków.</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> </xref:System.Timers.Timer.Dispose%2A> </xref:System.Timers.Timer.Elapsed> Jednym ze sposobów rozwiązania jest sytuacja wyścigu można ustawić flagi, który informuje program obsługi zdarzeń dla <xref:System.Timers.Timer.Elapsed>zdarzeń ignorowanie kolejnych zdarzeń.</xref:System.Timers.Timer.Elapsed>       Jeśli <xref:System.Timers.Timer>jest używany w programie Visual Studio za pomocą projektanta formularzy systemu Windows, SynchronizingObject jest automatycznie ustawiana formant, który zawiera <xref:System.Timers.Timer>.</xref:System.Timers.Timer> </xref:System.Timers.Timer> Na przykład, jeśli zostanie <xref:System.Timers.Timer>na projektanta dla `Form1` (który dziedziczy z <xref:System.Windows.Forms.Form>), z właściwością SynchronizingObject <xref:System.Timers.Timer>ustawiono wystąpienie `Form1`.</xref:System.Timers.Timer> </xref:System.Windows.Forms.Form> </xref:System.Timers.Timer>"
  example:
  - "The following example is a Windows Forms app that serves as a very simple text file editor. When the text in the text box has not been saved, the app asks the user at one-minute intervals whether he or she wants to save the contents of the text box.  To do this, the <xref:System.Timers.Timer.Interval%2A> property is set to one minute (60,000 milliseconds), and the SynchronizingObject property is set to the <xref:System.Windows.Forms.Form> object.  \n  \n [!code-cs[System.Timers.Timer.SynchronizingObject#1](~/add/codesnippet/csharp/SynchronizingObjectCS1/Form1.cs#1)]\n [!code-vb[System.Timers.Timer.SynchronizingObject#1](~/add/codesnippet/visualbasic/SynchronizingObjectVB1/Form1.vb#1)]  \n  \n The example requires that you add the following controls to the form:  \n  \n-   A <xref:System.Windows.Forms.TextBox> control named `TextBox1` (its default name).  \n  \n-   A <xref:System.Windows.Forms.Button> control named `Button1` (its default name).  \n  \n-   A <xref:System.Windows.Forms.SaveFileDialog> control named `SaveSaveFileDialog1` (its default name) ."
  syntax:
    content: public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }
    return:
      type: System.ComponentModel.ISynchronizeInvoke
      description: "<xref href=&quot;System.ComponentModel.ISynchronizeInvoke&quot;> </xref> Reprezentujący obiekt używany do organizowania wywołań obsługi zdarzeń, które są wydawane po upłynięciu interwału. Wartość domyślna to <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Timers.Timer.SynchronizingObject*
  exceptions: []
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Timers.Timer.#ctor
  parent: System.Timers.Timer
  isExternal: false
  name: Timer()
  nameWithType: Timer.Timer()
  fullName: System.Timers.Timer.Timer()
- uid: System.Timers.Timer.#ctor(System.Double)
  parent: System.Timers.Timer
  isExternal: false
  name: Timer(Double)
  nameWithType: Timer.Timer(Double)
  fullName: System.Timers.Timer.Timer(Double)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Timers.Timer.AutoReset
  parent: System.Timers.Timer
  isExternal: false
  name: AutoReset
  nameWithType: Timer.AutoReset
  fullName: System.Timers.Timer.AutoReset
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Timers.Timer.BeginInit
  parent: System.Timers.Timer
  isExternal: false
  name: BeginInit()
  nameWithType: Timer.BeginInit()
  fullName: System.Timers.Timer.BeginInit()
- uid: System.Timers.Timer.Close
  parent: System.Timers.Timer
  isExternal: false
  name: Close()
  nameWithType: Timer.Close()
  fullName: System.Timers.Timer.Close()
- uid: System.Timers.Timer.Dispose(System.Boolean)
  parent: System.Timers.Timer
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: Timer.Dispose(Boolean)
  fullName: System.Timers.Timer.Dispose(Boolean)
- uid: System.Timers.Timer.Elapsed
  parent: System.Timers.Timer
  isExternal: false
  name: Elapsed
  nameWithType: Timer.Elapsed
  fullName: System.Timers.Timer.Elapsed
- uid: System.Timers.ElapsedEventHandler
  parent: System.Timers
  isExternal: false
  name: ElapsedEventHandler
  nameWithType: ElapsedEventHandler
  fullName: System.Timers.ElapsedEventHandler
- uid: System.Timers.Timer.Enabled
  parent: System.Timers.Timer
  isExternal: false
  name: Enabled
  nameWithType: Timer.Enabled
  fullName: System.Timers.Timer.Enabled
- uid: System.Timers.Timer.EndInit
  parent: System.Timers.Timer
  isExternal: false
  name: EndInit()
  nameWithType: Timer.EndInit()
  fullName: System.Timers.Timer.EndInit()
- uid: System.Timers.Timer.Interval
  parent: System.Timers.Timer
  isExternal: false
  name: Interval
  nameWithType: Timer.Interval
  fullName: System.Timers.Timer.Interval
- uid: System.Timers.Timer.Site
  parent: System.Timers.Timer
  isExternal: false
  name: Site
  nameWithType: Timer.Site
  fullName: System.Timers.Timer.Site
- uid: System.ComponentModel.ISite
  parent: System.ComponentModel
  isExternal: false
  name: ISite
  nameWithType: ISite
  fullName: System.ComponentModel.ISite
- uid: System.Timers.Timer.Start
  parent: System.Timers.Timer
  isExternal: false
  name: Start()
  nameWithType: Timer.Start()
  fullName: System.Timers.Timer.Start()
- uid: System.Timers.Timer.Stop
  parent: System.Timers.Timer
  isExternal: false
  name: Stop()
  nameWithType: Timer.Stop()
  fullName: System.Timers.Timer.Stop()
- uid: System.Timers.Timer.SynchronizingObject
  parent: System.Timers.Timer
  isExternal: false
  name: SynchronizingObject
  nameWithType: Timer.SynchronizingObject
  fullName: System.Timers.Timer.SynchronizingObject
- uid: System.ComponentModel.ISynchronizeInvoke
  parent: System.ComponentModel
  isExternal: false
  name: ISynchronizeInvoke
  nameWithType: ISynchronizeInvoke
  fullName: System.ComponentModel.ISynchronizeInvoke
- uid: System.Timers.Timer.#ctor*
  parent: System.Timers.Timer
  isExternal: false
  name: Timer
  nameWithType: Timer.Timer
- uid: System.Timers.Timer.AutoReset*
  parent: System.Timers.Timer
  isExternal: false
  name: AutoReset
  nameWithType: Timer.AutoReset
- uid: System.Timers.Timer.BeginInit*
  parent: System.Timers.Timer
  isExternal: false
  name: BeginInit
  nameWithType: Timer.BeginInit
- uid: System.Timers.Timer.Close*
  parent: System.Timers.Timer
  isExternal: false
  name: Close
  nameWithType: Timer.Close
- uid: System.Timers.Timer.Dispose*
  parent: System.Timers.Timer
  isExternal: false
  name: Dispose
  nameWithType: Timer.Dispose
- uid: System.Timers.Timer.Enabled*
  parent: System.Timers.Timer
  isExternal: false
  name: Enabled
  nameWithType: Timer.Enabled
- uid: System.Timers.Timer.EndInit*
  parent: System.Timers.Timer
  isExternal: false
  name: EndInit
  nameWithType: Timer.EndInit
- uid: System.Timers.Timer.Interval*
  parent: System.Timers.Timer
  isExternal: false
  name: Interval
  nameWithType: Timer.Interval
- uid: System.Timers.Timer.Site*
  parent: System.Timers.Timer
  isExternal: false
  name: Site
  nameWithType: Timer.Site
- uid: System.Timers.Timer.Start*
  parent: System.Timers.Timer
  isExternal: false
  name: Start
  nameWithType: Timer.Start
- uid: System.Timers.Timer.Stop*
  parent: System.Timers.Timer
  isExternal: false
  name: Stop
  nameWithType: Timer.Stop
- uid: System.Timers.Timer.SynchronizingObject*
  parent: System.Timers.Timer
  isExternal: false
  name: SynchronizingObject
  nameWithType: Timer.SynchronizingObject
