### YamlMime:ManagedReference
items:
- uid: System.Security.AccessControl.SemaphoreSecurity
  id: SemaphoreSecurity
  children:
  - System.Security.AccessControl.SemaphoreSecurity.#ctor
  - System.Security.AccessControl.SemaphoreSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.SemaphoreSecurity.AccessRightType
  - System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  - System.Security.AccessControl.SemaphoreSecurity.AccessRuleType
  - System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  - System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  - System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  - System.Security.AccessControl.SemaphoreSecurity.AuditRuleType
  - System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  - System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)
  - System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)
  - System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  - System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)
  - System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule)
  - System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  - System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  - System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  langs:
  - csharp
  name: SemaphoreSecurity
  nameWithType: SemaphoreSecurity
  fullName: System.Security.AccessControl.SemaphoreSecurity
  type: Class
  summary: "Reprezentuje kontrolę dostępu systemu Windows o nazwie semafora. Ta klasa nie może być dziedziczona."
  remarks: "Obiekt SemaphoreSecurity określa prawa dostępu do semafora systemu o nazwie oraz określa, jak są poddawane inspekcji prób dostępu. Prawa dostępu do semafora są wyrażane jako reguł, z dostępu reprezentowany przez <xref:System.Security.AccessControl.SemaphoreAccessRule>obiektu.</xref:System.Security.AccessControl.SemaphoreAccessRule> Każda reguła inspekcji jest reprezentowana przez <xref:System.Security.AccessControl.SemaphoreAuditRule>obiektu.</xref:System.Security.AccessControl.SemaphoreAuditRule>       Odzwierciedla to podstawowy system zabezpieczeń systemu Windows, w którym każdy zabezpieczanego obiektu ma co najwyżej jeden poufnej listy kontroli dostępu (DACL), że kontroluje dostęp do bezpiecznego obiektu i co najwyżej jeden system listy kontroli dostępu (SACL) określający, którego prób dostępu są poddawane inspekcji. Listy DACL i SACL są uporządkowane listy wpisów kontroli dostępu (ACE), które określają dostępu i inspekcji dla użytkowników i grup. A <xref:System.Security.AccessControl.SemaphoreAccessRule>lub <xref:System.Security.AccessControl.SemaphoreAuditRule>object może reprezentować więcej niż jednego wpisu ACE.</xref:System.Security.AccessControl.SemaphoreAuditRule> </xref:System.Security.AccessControl.SemaphoreAccessRule>      > [!NOTE] > A <xref:System.Threading.Semaphore>obiektu może reprezentować semafora lokalnego lub semafora systemu nazwanego.</xref:System.Threading.Semaphore> Kontrolę dostępu systemu Windows jest znaczący tylko w przypadku systemu o nazwie semaforów.       SemaphoreSecurity, <xref:System.Security.AccessControl.SemaphoreAccessRule>, i <xref:System.Security.AccessControl.SemaphoreAuditRule>klasy Ukryj szczegóły implementacji listy kontroli dostępu i ACE.</xref:System.Security.AccessControl.SemaphoreAuditRule> </xref:System.Security.AccessControl.SemaphoreAccessRule> Umożliwiają one Ignoruj siedemnaście różne typy ACE i złożoność poprawnie obsługi dziedziczenia i propagacji praw dostępu. Te obiekty są również zaprojektowana tak, aby zapobiec następujące typowe błędy kontroli dostępu:-tworzenie o wartości null DACL deskryptora zabezpieczeń. Odwołanie o wartości null do listy DACL umożliwia dowolnym użytkownikom dodawanie reguły dostępu do obiektu, potencjalnie tworzenie ataku typu &quot;odmowa usługi&quot;. Nowy obiekt SemaphoreSecurity zawsze rozpoczyna się od pusty listy DACL, która nie zezwala na dostęp dla wszystkich użytkowników.      -Naruszania canonical kolejność ACE. Lista ACE w listy DACL nie jest przechowywany w Porządek kanoniczny, użytkownicy mogą przypadkowo uzyskać dostęp do zabezpieczonego obiektu. Na przykład prawa dostępu odmowy zawsze musi występować przed dozwolone uprawnienia. Obiekty SemaphoreSecurity Obsługa wewnętrznie właściwej kolejności.      -Flagi deskryptora zabezpieczeń, które powinny być pod kontrolą Menedżera zasobów tylko manipulowanie.      -Tworzenie nieprawidłową kombinację flag ACE.      -Manipulowanie ACE dziedziczone. Dziedziczenie i propagacji są obsługiwane przez Menedżera zasobów w odpowiedzi na zmiany wprowadzone do reguł dostępu i inspekcji.      -Wstawianie znaczenia wpisy kontroli dostępu do listy kontroli dostępu.       Tylko funkcje nie są obsługiwane przez obiekty zabezpieczeń .NET są niebezpieczne działania, które należy unikać przez większość deweloperów aplikacji, takich jak następujące:-zadań niskiego poziomu, które są wykonywane zwykle przez Menedżera zasobów.      — Dodawanie lub usuwanie wpisów kontroli dostępu w sposób, w którym nie obsługują canonical porządkowania.       Aby zmodyfikować Windows kontrolę dostępu dla nazwanego semafora, użyj <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName>metody można pobrać obiektu SemaphoreSecurity.</xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName> Zmodyfikuj obiekt zabezpieczeń przez dodawanie i usuwanie reguł, a następnie użyj <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>metody ponownie dołączyć go.</xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>      > [!IMPORTANT] > Zmiany wprowadzone do obiektu SemaphoreSecurity nie wpływają na poziomów dostępu o nazwie semafora czasu wywołania <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>metody można przypisać obiektu zmieniony zabezpieczeń do semafora nazwanego.</xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>       Aby skopiować kontrolę dostępu z jednego semafora do innego, należy użyć <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName>metodę, aby uzyskać obiekt SemaphoreSecurity reprezentuje reguł dostępu i inspekcji dla pierwszego semafora, a następnie użyj <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>metody lub konstruktora akceptującego obiektu SemaphoreSecurity można przypisać te reguły do drugiego semafora.</xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName> </xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName>       Użytkownicy z inwestycji w definicji deskryptora zabezpieczeń w języku (SDDL) można używać <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A>metodę, aby ustawić zasady dostępu o nazwie semafora i <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A>metodę, aby uzyskać ciąg reprezentujący reguł dostępu w formacie SDDL.</xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> </xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> Nie jest to zalecane w przypadku nowych wdrożeń.      > [!NOTE] > Zabezpieczeń obiektów synchronizacji nie jest obsługiwana dla systemu Windows 98 lub Windows Millennium Edition."
  example:
  - "The following code example demonstrates the separation between <xref:System.Security.AccessControl.AccessControlType> rules and <xref:System.Security.AccessControl.AccessControlType> rules, and shows the combination of rights in compatible rules. The example creates a SemaphoreSecurity object, adds rules that allow and deny various rights for the current user, and displays the resulting pair of rules. The example then allows new rights for the current user and displays the result, showing that the new rights are merged with the existing <xref:System.Security.AccessControl.AccessControlType> rule.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Semaphore> object. Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-cs[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/add/codesnippet/csharp/t-system.security.access_8_1.cs)]\n [!code-vb[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/add/codesnippet/visualbasic/t-system.security.access_8_1.vb)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(false)]

      public sealed class SemaphoreSecurity : System.Security.AccessControl.NativeObjectSecurity
  inheritance:
  - System.Object
  - System.Security.AccessControl.ObjectSecurity
  - System.Security.AccessControl.CommonObjectSecurity
  - System.Security.AccessControl.NativeObjectSecurity
  implements: []
  inheritedMembers:
  - System.Security.AccessControl.CommonObjectSecurity.AddAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.AddAuditRule(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.GetAccessRules(System.Boolean,System.Boolean,System.Type)
  - System.Security.AccessControl.CommonObjectSecurity.GetAuditRules(System.Boolean,System.Boolean,System.Type)
  - System.Security.AccessControl.CommonObjectSecurity.ModifyAccess(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AccessRule,System.Boolean@)
  - System.Security.AccessControl.CommonObjectSecurity.ModifyAudit(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AuditRule,System.Boolean@)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAccessRuleAll(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAuditRule(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAuditRuleAll(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.ResetAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.SetAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.SetAuditRule(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.Runtime.InteropServices.SafeHandle,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.Runtime.InteropServices.SafeHandle,System.Security.AccessControl.AccessControlSections,System.Object)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.String,System.Security.AccessControl.AccessControlSections,System.Object)
  - System.Security.AccessControl.ObjectSecurity.AccessRulesModified
  - System.Security.AccessControl.ObjectSecurity.AreAccessRulesCanonical
  - System.Security.AccessControl.ObjectSecurity.AreAccessRulesProtected
  - System.Security.AccessControl.ObjectSecurity.AreAuditRulesCanonical
  - System.Security.AccessControl.ObjectSecurity.AreAuditRulesProtected
  - System.Security.AccessControl.ObjectSecurity.AuditRulesModified
  - System.Security.AccessControl.ObjectSecurity.GetGroup(System.Type)
  - System.Security.AccessControl.ObjectSecurity.GetOwner(System.Type)
  - System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm
  - System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm(System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.GroupModified
  - System.Security.AccessControl.ObjectSecurity.IsContainer
  - System.Security.AccessControl.ObjectSecurity.IsDS
  - System.Security.AccessControl.ObjectSecurity.IsSddlConversionSupported
  - System.Security.AccessControl.ObjectSecurity.ModifyAccessRule(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AccessRule,System.Boolean@)
  - System.Security.AccessControl.ObjectSecurity.ModifyAuditRule(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AuditRule,System.Boolean@)
  - System.Security.AccessControl.ObjectSecurity.OwnerModified
  - System.Security.AccessControl.ObjectSecurity.Persist(System.Boolean,System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.PurgeAccessRules(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.PurgeAuditRules(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.ReadLock
  - System.Security.AccessControl.ObjectSecurity.ReadUnlock
  - System.Security.AccessControl.ObjectSecurity.SetAccessRuleProtection(System.Boolean,System.Boolean)
  - System.Security.AccessControl.ObjectSecurity.SetAuditRuleProtection(System.Boolean,System.Boolean)
  - System.Security.AccessControl.ObjectSecurity.SetGroup(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.SetOwner(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm(System.Byte[])
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm(System.Byte[],System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm(System.String)
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm(System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.WriteLock
  - System.Security.AccessControl.ObjectSecurity.WriteUnlock
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.#ctor
  id: '#ctor'
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: SemaphoreSecurity()
  nameWithType: SemaphoreSecurity.SemaphoreSecurity()
  fullName: System.Security.AccessControl.SemaphoreSecurity.SemaphoreSecurity()
  type: Constructor
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Security.AccessControl.SemaphoreSecurity&quot;> </xref> z domyślnymi wartościami."
  remarks: "Nowy <xref:System.Security.AccessControl.SemaphoreSecurity>obiektu zawsze rozpoczyna się od listy pusty dostępu (DACL), która nie zezwala na dostęp dla wszystkich użytkowników.</xref:System.Security.AccessControl.SemaphoreSecurity>"
  syntax:
    content: public SemaphoreSecurity ();
    parameters: []
  overload: System.Security.AccessControl.SemaphoreSecurity.#ctor*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Ta klasa nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)
  id: '#ctor(System.String,System.Security.AccessControl.AccessControlSections)'
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: SemaphoreSecurity(String,AccessControlSections)
  nameWithType: SemaphoreSecurity.SemaphoreSecurity(String,AccessControlSections)
  fullName: System.Security.AccessControl.SemaphoreSecurity.SemaphoreSecurity(String,AccessControlSections)
  type: Constructor
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Security.AccessControl.SemaphoreSecurity&quot;> </xref> klasy z określonej sekcji zasady zabezpieczeń kontroli dostępu z semafora systemowego o określonej nazwie."
  remarks: "Ten konstruktor umożliwia uzyskiwanie kontrolę dostępu do semafora systemu o nazwie bez tworzenia <xref:System.Threading.Semaphore>obiektu.</xref:System.Threading.Semaphore>       Uwaga muszą być wykonywane podczas pracy z obiektami systemu o nazwie. Jeśli jest obiektem systemu o nazwie `name` nie jest semafora, kontroli dostępu zabezpieczeń może pobrać."
  syntax:
    content: public SemaphoreSecurity (string name, System.Security.AccessControl.AccessControlSections includeSections);
    parameters:
    - id: name
      type: System.String
      description: "Nazwa semafora systemowego, której reguły zabezpieczeń kontroli dostępu mają zostać pobrane."
    - id: includeSections
      type: System.Security.AccessControl.AccessControlSections
      description: "Kombinację <xref href=&quot;System.Security.AccessControl.AccessControlSections&quot;> </xref> flagi określające sekcje do pobrania."
  overload: System.Security.AccessControl.SemaphoreSecurity.#ctor*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Ta klasa nie jest obsługiwana w systemie Windows 98 lub Windows Millennium Edition."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.AccessRightType
  id: AccessRightType
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: AccessRightType
  nameWithType: SemaphoreSecurity.AccessRightType
  fullName: System.Security.AccessControl.SemaphoreSecurity.AccessRightType
  type: Property
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Pobiera wyliczenie, który <xref href=&quot;System.Security.AccessControl.SemaphoreSecurity&quot;> </xref> klasa używana do reprezentowania praw dostępu."
  remarks: "Klasy, które pochodzą z <xref:System.Security.AccessControl.ObjectSecurity>klasy zastąpienie <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A>Właściwości i zwracany typ przejdą do reprezentowania praw dostępu.</xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> </xref:System.Security.AccessControl.ObjectSecurity> Podczas pracy z tablicą lub kolekcje zawierające wiele typów obiektów zabezpieczeń, używają tej właściwości można określić typu wyliczenia poprawne korzystać z każdego obiektu zabezpieczeń."
  syntax:
    content: public override Type AccessRightType { get; }
    return:
      type: System.Type
      description: "A <xref:System.Type>reprezentujący obiekt <xref href=&quot;System.Security.AccessControl.SemaphoreRights&quot;> </xref> wyliczenie.</xref:System.Type>"
  overload: System.Security.AccessControl.SemaphoreSecurity.AccessRightType*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  id: AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  nameWithType: SemaphoreSecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  fullName: System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Tworzy nową regułę kontroli dostępu dla określonego użytkownika z określonego uprawnienia kontroli dostępu i flagi."
  remarks: "Zalecanym sposobem tworzenia regułami kontroli dostępu jest użycie konstruktorów <xref:System.Security.AccessControl.SemaphoreAccessRule>klasy.</xref:System.Security.AccessControl.SemaphoreAccessRule>      > [!NOTE] > Chociaż flagi dziedziczenia i propagacji nie mają znaczenia dla nazwanego semaforów, jest nadal możliwe określić ich nie jest to zalecane, ponieważ niepotrzebnie utrudnia to konserwacji zasad, na przykład przez zakłócać kombinację reguł, które w przeciwnym razie będą zgodne."
  syntax:
    content: public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
    parameters:
    - id: identityReference
      type: System.Security.Principal.IdentityReference
      description: "<xref href=&quot;System.Security.Principal.IdentityReference&quot;> </xref> , Które identyfikują użytkownik lub grupa reguła dotyczy."
    - id: accessMask
      type: System.Int32
      description: "Bitowe połączenie <xref href=&quot;System.Security.AccessControl.SemaphoreRights&quot;> </xref> wartości określających prawa dostępu do dozwolonych lub zablokowanych, rzutowania na liczbę całkowitą."
    - id: isInherited
      type: System.Boolean
      description: "Znaczenia dla semaforów nazwanego, ponieważ mają one nie hierarchii."
    - id: inheritanceFlags
      type: System.Security.AccessControl.InheritanceFlags
      description: "Znaczenia dla semaforów nazwanego, ponieważ mają one nie hierarchii."
    - id: propagationFlags
      type: System.Security.AccessControl.PropagationFlags
      description: "Znaczenia dla semaforów nazwanego, ponieważ mają one nie hierarchii."
    - id: type
      type: System.Security.AccessControl.AccessControlType
      description: "Jeden z <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> wartości określający, czy prawa zezwolono na dostęp lub odmowa dostępu."
    return:
      type: System.Security.AccessControl.AccessRule
      description: "A <xref href=&quot;System.Security.AccessControl.SemaphoreAccessRule&quot;> </xref> obiekt reprezentujący określonego uprawnienia dla określonego użytkownika."
  overload: System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>accessMask</code>, <code>inheritanceFlags</code>, <code>propagationFlags</code>, lub <code>type</code> określa nieprawidłową wartość."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>identityReference</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - lub - <code>accessMask</code> wynosi zero."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>identityReference</code>nie jest ani typu <xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>, ani typu, takich jak <xref href=&quot;System.Security.Principal.NTAccount&quot;> </xref> którego można przekonwertować na typ <xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.AccessRuleType
  id: AccessRuleType
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: AccessRuleType
  nameWithType: SemaphoreSecurity.AccessRuleType
  fullName: System.Security.AccessControl.SemaphoreSecurity.AccessRuleType
  type: Property
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Pobiera typ, który <xref href=&quot;System.Security.AccessControl.SemaphoreSecurity&quot;> </xref> klasa używana do reprezentowania zasad dostępu."
  remarks: "Klasy, które pochodzą z <xref:System.Security.AccessControl.ObjectSecurity>klasy zastąpienie <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A>Właściwości i zwracany typ przejdą do reprezentowania zasad dostępu.</xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> </xref:System.Security.AccessControl.ObjectSecurity> Podczas pracy z tablicą lub kolekcje zawierające wiele typów obiektów zabezpieczeń, używają tej właściwości można określić typu reguły dostępu do użycia z każdego obiektu zabezpieczeń."
  syntax:
    content: public override Type AccessRuleType { get; }
    return:
      type: System.Type
      description: "A <xref:System.Type>reprezentujący obiekt <xref href=&quot;System.Security.AccessControl.SemaphoreAccessRule&quot;> </xref> klasy</xref:System.Type>"
  overload: System.Security.AccessControl.SemaphoreSecurity.AccessRuleType*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  id: AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: AddAccessRule(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.AddAccessRule(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(SemaphoreAccessRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Wyszukuje Reguła dopasowywania, z którego można by scalić nowej reguły. Jeśli żaden nie zostaną znalezione, dodaje nową regułę."
  remarks: "Metoda AddAccessRule wyszukuje reguły z tego samego użytkownika lub grupy i tym samym <xref:System.Security.AccessControl.AccessControlType>jako `rule`.</xref:System.Security.AccessControl.AccessControlType> Jeśli żaden nie zostaną znalezione, `rule` został dodany. Jeśli reguła dopasowywania zostanie znaleziony, prawa w `rule` są łączone z istniejącą regułą."
  example:
  - "The following code example demonstrates the separation between <xref:System.Security.AccessControl.AccessControlType> rules and <xref:System.Security.AccessControl.AccessControlType> rules, and shows the combination of rights in compatible rules. The example creates a <xref:System.Security.AccessControl.SemaphoreSecurity> object, adds rules that allow and deny various rights for the current user, and displays the resulting pair of rules. The example then allows new rights for the current user and displays the result, showing that the new rights are merged with the existing <xref:System.Security.AccessControl.AccessControlType> rule.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Semaphore> object. Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-cs[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/add/codesnippet/csharp/5be6d691-cc28-4e1b-ae9c-_1.cs)]\n [!code-vb[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/add/codesnippet/visualbasic/5be6d691-cc28-4e1b-ae9c-_1.vb)]"
  syntax:
    content: public void AddAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAccessRule
      description: "Reguła kontroli dostępu do dodania."
  overload: System.Security.AccessControl.SemaphoreSecurity.AddAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  id: AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: AddAuditRule(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.AddAuditRule(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(SemaphoreAuditRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Wyszukuje reguła inspekcji, z którego można by scalić nowej reguły. Jeśli żaden nie zostaną znalezione, dodaje nową regułę."
  remarks: "Metoda AddAuditRule wyszukuje reguły z tego samego użytkownika lub grupy jako `rule`. Jeśli żaden nie zostaną znalezione, `rule` został dodany. Jeśli reguła dopasowywania zostanie znaleziony, flagi w `rule` są scalane w istniejącą regułę."
  syntax:
    content: public void AddAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAuditRule
      description: "Reguła inspekcji, aby dodać. Użytkownik określony przez tę regułę określa wyszukiwania."
  overload: System.Security.AccessControl.SemaphoreSecurity.AddAuditRule*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  id: AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  nameWithType: SemaphoreSecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  fullName: System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Tworzy nową regułę inspekcji, określając użytkownika, którego dotyczy reguła, prawa dostępu do inspekcji i wyników, które wyzwala reguła inspekcji."
  remarks: "Zalecanym sposobem tworzenia zasady inspekcji jest użycie konstruktorów <xref:System.Security.AccessControl.SemaphoreAuditRule>klasy.</xref:System.Security.AccessControl.SemaphoreAuditRule>      > [!NOTE] > Chociaż flagi dziedziczenia i propagacji nie mają znaczenia dla nazwanego semaforów, jest nadal możliwe je określić. Nie jest to zalecane, ponieważ niepotrzebnie utrudnia to konserwacji zasad, na przykład przez zakłócać kombinację reguł, które w przeciwnym razie będą zgodne."
  syntax:
    content: public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
    parameters:
    - id: identityReference
      type: System.Security.Principal.IdentityReference
      description: "<xref href=&quot;System.Security.Principal.IdentityReference&quot;> </xref> , Które identyfikują użytkownik lub grupa reguła dotyczy."
    - id: accessMask
      type: System.Int32
      description: "Bitowe połączenie <xref href=&quot;System.Security.AccessControl.SemaphoreRights&quot;> </xref> wartości określających prawa dostępu do inspekcji, rzutowania na liczbę całkowitą."
    - id: isInherited
      type: System.Boolean
      description: "Znaczenia dla uchwyty oczekiwania nazwanego, ponieważ mają one nie hierarchii."
    - id: inheritanceFlags
      type: System.Security.AccessControl.InheritanceFlags
      description: "Znaczenia dla uchwyty oczekiwania nazwanego, ponieważ mają one nie hierarchii."
    - id: propagationFlags
      type: System.Security.AccessControl.PropagationFlags
      description: "Znaczenia dla uchwyty oczekiwania nazwanego, ponieważ mają one nie hierarchii."
    - id: flags
      type: System.Security.AccessControl.AuditFlags
      description: "Bitowe połączenie <xref href=&quot;System.Security.AccessControl.AuditFlags&quot;> </xref> wartości, które określają, czy inspekcji pomyślnego dostępu i dostępu nie powiodło się."
    return:
      type: System.Security.AccessControl.AuditRule
      description: "A <xref href=&quot;System.Security.AccessControl.SemaphoreAuditRule&quot;> </xref> obiekt reprezentujący reguła określonego inspekcji dla określonego użytkownika. Klasa podstawowa jest zwracany typ metody <xref href=&quot;System.Security.AccessControl.AuditRule&quot;> </xref>, ale wartość zwracaną mogą bezpiecznie rzutowane do klasy pochodnej."
  overload: System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>accessMask</code>, <code>inheritanceFlags</code>, <code>propagationFlags</code>, lub <code>flags</code> określa nieprawidłową wartość."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>identityReference</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       - lub - <code>accessMask</code> wynosi zero."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>identityReference</code>nie jest ani typu <xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>, ani typu, takich jak <xref href=&quot;System.Security.Principal.NTAccount&quot;> </xref> którego można przekonwertować na typ <xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.AuditRuleType
  id: AuditRuleType
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: AuditRuleType
  nameWithType: SemaphoreSecurity.AuditRuleType
  fullName: System.Security.AccessControl.SemaphoreSecurity.AuditRuleType
  type: Property
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Pobiera typ, który <xref href=&quot;System.Security.AccessControl.SemaphoreSecurity&quot;> </xref> klasa używana do reprezentowania zasad inspekcji."
  remarks: "Klasy, które pochodzą z <xref:System.Security.AccessControl.ObjectSecurity>klasy zastąpienie <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A>Właściwości i zwracany typ przejdą do reprezentowania prawa inspekcji.</xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> </xref:System.Security.AccessControl.ObjectSecurity> Podczas pracy z tablicą lub kolekcje zawierające wiele typów obiektów zabezpieczeń, używają tej właściwości można określić typu reguły poprawne inspekcji do użycia z każdego obiektu zabezpieczeń."
  syntax:
    content: public override Type AuditRuleType { get; }
    return:
      type: System.Type
      description: "A <xref:System.Type>reprezentujący obiekt <xref href=&quot;System.Security.AccessControl.SemaphoreAuditRule&quot;> </xref> klasy</xref:System.Type>"
  overload: System.Security.AccessControl.SemaphoreSecurity.AuditRuleType*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  id: RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: RemoveAccessRule(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.RemoveAccessRule(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(SemaphoreAccessRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Wyszukuje reguły kontroli dostępu z tego samego użytkownika i <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> (zezwalania lub odmowy) jako określonej reguły oraz zgodne dziedziczenia i flagi propagacji; jeśli taka reguła zostanie znaleziony, prawa zawarte w tej regule określonego dostępu są usuwane z go."
  remarks: "Bieżący <xref:System.Security.AccessControl.SemaphoreSecurity>jest wyszukiwany regułę, która ma ten sam użytkownik i tym samym <xref:System.Security.AccessControl.AccessControlType>wartość jako `rule`.</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.SemaphoreSecurity> Jeśli takie reguła nie zostanie znaleziony, nie podjęto żadnej akcji i metoda zwraca `false`. W przypadku znalezienia pasujących reguł ich flagi dziedziczenia i zgodności są sprawdzane pod kątem zgodności z flag określonych we `rule`. Jeśli zostanie znaleziony nie niezgodne reguły, nie podjęto żadnej akcji, a metoda zwraca `false`. Jeśli znaleziono reguły z flagami zgodne, prawa określone w `rule` są usuwane z niezgodne reguły, a metoda zwraca `true`. Jeśli `rule` określa prawa nie zawiera niezgodne reguły, nie podjęto żadnej akcji w odniesieniu do tych praw. Jeśli wszystkie prawa są usuwane z niezgodne reguły, cały reguła jest usuwana z bieżącego <xref:System.Security.AccessControl.SemaphoreSecurity>obiektu.</xref:System.Security.AccessControl.SemaphoreSecurity>      > [!IMPORTANT] > Mimo że można określić flagi dziedziczenia i propagacji dla reguły dostępu do semafora, tworząc je za pomocą <xref:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory%2A>metody, nie jest to zalecane.</xref:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory%2A> Dziedziczenie i propagacji mają znaczenia dla nazwanego semaforów, a konserwacji reguł dostępu umożliwiają bardziej skomplikowane."
  example:
  - "The following code example demonstrates the use of the RemoveAccessRule method to remove rights from an <xref:System.Security.AccessControl.AccessControlType> rule in a <xref:System.Security.AccessControl.SemaphoreSecurity> object. It also shows that other rights in `rule` are ignored.  \n  \n The example creates a <xref:System.Security.AccessControl.SemaphoreSecurity> object and adds rules that allow and deny various rights for the current user. The rights allowed include <xref:System.Security.AccessControl.SemaphoreRights>, <xref:System.Security.AccessControl.SemaphoreRights>, and <xref:System.Security.AccessControl.SemaphoreRights>. The example then creates a new rule for the current user, including <xref:System.Security.AccessControl.SemaphoreRights> and <xref:System.Security.AccessControl.SemaphoreRights> rights, and uses that rule with the RemoveAccessRule method to remove <xref:System.Security.AccessControl.SemaphoreRights> from the <xref:System.Security.AccessControl.AccessControlType> rule in the <xref:System.Security.AccessControl.SemaphoreSecurity> object. The extraneous <xref:System.Security.AccessControl.SemaphoreRights> right in `rule` is ignored.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Semaphore> object. Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-cs[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule#1](~/add/codesnippet/csharp/967006c5-d60e-4018-a570-_1.cs)]\n [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule#1](~/add/codesnippet/visualbasic/967006c5-d60e-4018-a570-_1.vb)]"
  syntax:
    content: public bool RemoveAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAccessRule
      description: "A <xref href=&quot;System.Security.AccessControl.SemaphoreAccessRule&quot;> </xref> użytkownik, który określa i <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> wyszukiwanie i zestaw dziedziczenia i propagacji flag, które pasujący do reguły, jeśli znaleziono, musi być zgodny z. Określa, że uprawnienia do usunięcia z niezgodne reguły, jeśli znaleziono."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli zostanie znaleziony zgodne reguły; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)
  id: RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: RemoveAccessRuleAll(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.RemoveAccessRuleAll(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(SemaphoreAccessRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Wyszukuje wszystkie reguły kontroli z tego samego użytkownika dostępu i <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> (zezwalania lub odmowy) jako określona reguła oraz, jeśli znaleziono usuwa je."
  remarks: "Bieżący <xref:System.Security.AccessControl.SemaphoreSecurity>reguły, które mają ten sam użytkownik i tym samym przeszukiwany jest obiekt <xref:System.Security.AccessControl.AccessControlType>wartość jako `rule`.</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.SemaphoreSecurity> Wszelkie prawa określone przez `rule` są ignorowane, podczas wykonywania tego wyszukiwania. Jeśli nie zostaną znalezione żadne reguły dopasowywania, nie podjęto żadnej akcji."
  example:
  - "The following code example shows that the RemoveAccessRuleAll method removes all rules that match user and <xref:System.Security.AccessControl.AccessControlType>, ignoring rights.  \n  \n The example creates a <xref:System.Security.AccessControl.SemaphoreSecurity> object, adds rules that allow and deny various rights for the current user, and then merges additional rights into the <xref:System.Security.AccessControl.AccessControlType> rule. The example then creates a new rule that allows the current user to take ownership, and uses that rule to remove the <xref:System.Security.AccessControl.AccessControlType> rule from the <xref:System.Security.AccessControl.SemaphoreSecurity> object.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Semaphore> object. Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll#1](~/add/codesnippet/visualbasic/0b2e6ab3-65bc-4eea-922e-_1.vb)]\n [!code-cs[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll#1](~/add/codesnippet/csharp/0b2e6ab3-65bc-4eea-922e-_1.cs)]"
  syntax:
    content: public void RemoveAccessRuleAll (System.Security.AccessControl.SemaphoreAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAccessRule
      description: "A <xref href=&quot;System.Security.AccessControl.SemaphoreAccessRule&quot;> </xref> użytkownik, który określa i <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> do wyszukania. Wszelkie prawa określone przez tę regułę są ignorowane."
  overload: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)
  id: RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: RemoveAccessRuleSpecific(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.RemoveAccessRuleSpecific(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(SemaphoreAccessRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Wyszukuje reguły kontroli dostępu, która dokładnie odpowiada określonym reguły oraz, jeśli znaleziono i usuwa go."
  remarks: "Reguła zostanie usunięta tylko wtedy, gdy dokładnie odpowiada `rule` wszystkie szczegóły, w tym flag. Inne zasady z tego samego użytkownika i <xref:System.Security.AccessControl.AccessControlType>pozostają niezmienione.</xref:System.Security.AccessControl.AccessControlType>      > [!IMPORTANT] > Reguły reprezentuje jeden lub więcej podstawowych wpisów kontroli dostępu (ACE), a te wpisy są podzielić lub łączyć w razie potrzeby zmodyfikować zasady zabezpieczeń dostępu dla użytkownika. W związku z tym reguły może już nie istnieje w określonym formularz, który znajdował się, gdy ten element został dodany, a w tym przypadku metoda RemoveAccessRuleSpecific nie można go usunąć."
  example:
  - "The following code example shows that the RemoveAccessRuleSpecific method requires an exact match in order to remove a rule, and that rules to allow and deny rights are independent of each other.  \n  \n The example creates a <xref:System.Security.AccessControl.SemaphoreSecurity> object, adds rules that allow and deny various rights for the current user, and then merges additional rights into the <xref:System.Security.AccessControl.AccessControlType> access rule. The example then passes the original <xref:System.Security.AccessControl.AccessControlType> rule to the RemoveAccessRuleSpecific method, and displays the results, showing that nothing is deleted. The example then constructs a rule that matches the <xref:System.Security.AccessControl.AccessControlType> rule in the <xref:System.Security.AccessControl.SemaphoreSecurity> object, and successfully uses the RemoveAccessRuleSpecific method to remove the rule.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Semaphore> object. Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific#1](~/add/codesnippet/visualbasic/0797aedd-e0bb-444b-b25e-_1.vb)]\n [!code-cs[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific#1](~/add/codesnippet/csharp/0797aedd-e0bb-444b-b25e-_1.cs)]"
  syntax:
    content: public void RemoveAccessRuleSpecific (System.Security.AccessControl.SemaphoreAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAccessRule
      description: "<xref href=&quot;System.Security.AccessControl.SemaphoreAccessRule&quot;> </xref> Do usunięcia."
  overload: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  id: RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: RemoveAuditRule(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.RemoveAuditRule(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(SemaphoreAuditRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Wyszukuje reguły inspekcji z tego samego użytkownika określoną regułą oraz zgodne dziedziczenia i flagi propagacji; Jeśli znaleziono niezgodne reguły, prawa zawarte w określonej reguły są usuwane z niej."
  remarks: "Bieżący <xref:System.Security.AccessControl.SemaphoreSecurity>jest wyszukiwany zasady inspekcji, który ma tego samego użytkownika `rule`.</xref:System.Security.AccessControl.SemaphoreSecurity> Jeśli takie reguła nie zostanie znaleziony, nie podjęto żadnej akcji i metoda zwraca `false`. W przypadku znalezienia pasujących reguł ich flagi dziedziczenia i zgodności są sprawdzane pod kątem zgodności z flag określonych we `rule`. Jeśli zostanie znaleziony nie niezgodne reguły, nie podjęto żadnej akcji, a metoda zwraca `false`. Jeśli znaleziono reguły z flagami zgodne, prawa określone w `rule` są usuwane z niezgodne reguły, a metoda zwraca `true`. Jeśli `rule` określa prawa nie zawiera niezgodne reguły, nie podjęto żadnej akcji w odniesieniu do tych praw. Jeśli wszystkie prawa są usuwane z niezgodne reguły, cały reguła jest usuwana z bieżącego <xref:System.Security.AccessControl.SemaphoreSecurity>obiektu.</xref:System.Security.AccessControl.SemaphoreSecurity>      > [!IMPORTANT] > Mimo że można określić flagi dziedziczenia i propagacji semafora zasady inspekcji, tworząc je za pomocą <xref:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory%2A>metody, nie jest to zalecane.</xref:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory%2A> Dziedziczenie i propagacji mają znaczenia dla nazwanego semaforów a konserwacji zasad inspekcji umożliwiają bardziej skomplikowane."
  syntax:
    content: public bool RemoveAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAuditRule
      description: "A <xref href=&quot;System.Security.AccessControl.SemaphoreAuditRule&quot;> </xref> , który określa użytkownika, aby wyszukać i zestaw flagi dziedziczenia i propagacji, które pasujący reguły, jeśli znaleziono, musi być zgodny z. Określa, że uprawnienia do usunięcia z niezgodne reguły, jeśli znaleziono."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli zostanie znaleziony zgodne reguły; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)
  id: RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: RemoveAuditRuleAll(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.RemoveAuditRuleAll(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(SemaphoreAuditRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Przeszukuje wszystkie inspekcji reguły z określoną regułą tego samego użytkownika i, jeśli znaleziono, usuwa je."
  remarks: "Bieżący <xref:System.Security.AccessControl.SemaphoreSecurity>jest wyszukiwany zasady inspekcji, które mają tego samego użytkownika `rule`.</xref:System.Security.AccessControl.SemaphoreSecurity> Wszelkie prawa określone przez `rule` są ignorowane, podczas wykonywania tego wyszukiwania. Wszystkie reguły dopasowywania zostaną usunięte. Jeśli nie zostaną znalezione żadne reguły dopasowywania, nie podjęto żadnej akcji."
  syntax:
    content: public void RemoveAuditRuleAll (System.Security.AccessControl.SemaphoreAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAuditRule
      description: "A <xref href=&quot;System.Security.AccessControl.SemaphoreAuditRule&quot;> </xref> , który określa użytkownika do wyszukania. Wszelkie prawa określone przez tę regułę są ignorowane."
  overload: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule)
  id: RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: RemoveAuditRuleSpecific(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.RemoveAuditRuleSpecific(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(SemaphoreAuditRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Wyszukuje zasady inspekcji, która dokładnie odpowiada określonym reguły oraz, jeśli znaleziono i usuwa go."
  remarks: "Reguła zostanie usunięta tylko wtedy, gdy dokładnie odpowiada `rule` wszystkie szczegóły, w tym flag. Nie wpływa na inne zasady inspekcji dla tego użytkownika.      > [!IMPORTANT] > Reguły reprezentuje jeden lub więcej podstawowych wpisów kontroli dostępu (ACE), a te wpisy są podzielić lub łączyć w razie potrzeby zmodyfikować zasady zabezpieczeń inspekcji dla użytkownika. W związku z tym reguły może już nie istnieje w określonym formularz, który znajdował się, gdy ten element został dodany, a w tym przypadku metoda RemoveAuditRuleSpecific nie można go usunąć."
  syntax:
    content: public void RemoveAuditRuleSpecific (System.Security.AccessControl.SemaphoreAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAuditRule
      description: "<xref href=&quot;System.Security.AccessControl.SemaphoreAuditRule&quot;> </xref> Do usunięcia."
  overload: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  id: ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: ResetAccessRule(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.ResetAccessRule(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(SemaphoreAccessRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Usuwa wszystkie zasady kontroli dostępu z tego samego użytkownika określoną regułą, niezależnie od tego <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref>, a następnie dodaje określoną regułą."
  remarks: "Jeśli brak reguł dostępu do których użytkownik odpowiada określonej reguły `rule` został dodany."
  example:
  - "The following code example shows how the ResetAccessRule method replaces all rules for the matching user with the rule specified for the match.  \n  \n The example creates a <xref:System.Security.AccessControl.SemaphoreSecurity> object and adds rules that allow and deny various rights for the current user. The example then creates a new rule that allows the current user full control, and uses the ResetAccessRule method to replace both of the existing rules with the new rule.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Semaphore> object. Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-cs[System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule#1](~/add/codesnippet/csharp/950b9d2b-d0bb-443e-8790-_1.cs)]\n [!code-vb[System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule#1](~/add/codesnippet/visualbasic/950b9d2b-d0bb-443e-8790-_1.vb)]"
  syntax:
    content: public void ResetAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAccessRule
      description: "The <xref href=&quot;System.Security.AccessControl.SemaphoreAccessRule&quot;></xref> to add. Użytkownik określony przez tę regułę określa reguły, aby usunąć przed dodaniem tej reguły."
  overload: System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  id: SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: SetAccessRule(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.SetAccessRule(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(SemaphoreAccessRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Usuwa wszystkie zasady kontroli dostępu z tego samego użytkownika i <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> (zezwalania lub odmowy) jako określonej reguły, a następnie dodaje określoną regułą."
  remarks: "Jeśli dla określonej reguły <xref:System.Security.AccessControl.AccessControlType>, ta metoda powoduje usunięcie wszystkich <xref:System.Security.AccessControl.AccessControlType>reguły dla określonego użytkownika, zastępując je z określoną regułą.</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.AccessControlType> Jeśli dla określonej reguły <xref:System.Security.AccessControl.AccessControlType>, wszystkie <xref:System.Security.AccessControl.AccessControlType>zastępuje reguły dla określonego użytkownika z określoną regułą.</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.AccessControlType>       Jeśli brak reguł której użytkownika i <xref:System.Security.AccessControl.AccessControlType>zgodne z określoną regułą `rule` został dodany.</xref:System.Security.AccessControl.AccessControlType>"
  example:
  - "The following code example shows how the SetAccessRule method removes all rules that match both the user and the <xref:System.Security.AccessControl.AccessControlType> of `rule`, replacing them with `rule`.  \n  \n The example creates a <xref:System.Security.AccessControl.SemaphoreSecurity> object and adds rules that allow and deny various rights for the current user. The example then creates a new rule that allows the current user full control, and uses the SetAccessRule method to replace the existing Allow rule with the new rule. The rule that denies access is not affected.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:System.Threading.Semaphore> object. Examples that attach security objects can be found in <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=fullName> and <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-vb[System.Security.AccessControl.SemaphoreSecurity.SetAccessRule#1](~/add/codesnippet/visualbasic/8a133971-d359-43dd-87ab-_1.vb)]\n [!code-cs[System.Security.AccessControl.SemaphoreSecurity.SetAccessRule#1](~/add/codesnippet/csharp/8a133971-d359-43dd-87ab-_1.cs)]"
  syntax:
    content: public void SetAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAccessRule
      description: "The <xref href=&quot;System.Security.AccessControl.SemaphoreAccessRule&quot;></xref> to add. Użytkownik i <xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> tej zasady określają zasady można usunąć przed dodaniem tej reguły."
  overload: System.Security.AccessControl.SemaphoreSecurity.SetAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  id: SetAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  langs:
  - csharp
  name: SetAuditRule(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.SetAuditRule(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(SemaphoreAuditRule)
  type: Method
  assemblies:
  - System
  namespace: System.Security.AccessControl
  summary: "Usuwa wszystkie reguły z tego samego użytkownika określoną regułą inspekcji, niezależnie od tego <xref href=&quot;System.Security.AccessControl.AuditFlags&quot;> </xref> wartość, a następnie dodaje określoną regułą."
  remarks: "Jeśli brak reguł inspekcji, w których użytkownik odpowiada określonej reguły `rule` został dodany."
  syntax:
    content: public void SetAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.SemaphoreAuditRule
      description: "The <xref href=&quot;System.Security.AccessControl.SemaphoreAuditRule&quot;></xref> to add. Użytkownik określony przez tę regułę określa reguły, aby usunąć przed dodaniem tej reguły."
  overload: System.Security.AccessControl.SemaphoreSecurity.SetAuditRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
references:
- uid: System.Security.AccessControl.NativeObjectSecurity
  isExternal: false
  name: System.Security.AccessControl.NativeObjectSecurity
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Security.AccessControl.SemaphoreSecurity.#ctor
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: SemaphoreSecurity()
  nameWithType: SemaphoreSecurity.SemaphoreSecurity()
  fullName: System.Security.AccessControl.SemaphoreSecurity.SemaphoreSecurity()
- uid: System.Security.AccessControl.SemaphoreSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: SemaphoreSecurity(String,AccessControlSections)
  nameWithType: SemaphoreSecurity.SemaphoreSecurity(String,AccessControlSections)
  fullName: System.Security.AccessControl.SemaphoreSecurity.SemaphoreSecurity(String,AccessControlSections)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Security.AccessControl.AccessControlSections
  parent: System.Security.AccessControl
  isExternal: false
  name: AccessControlSections
  nameWithType: AccessControlSections
  fullName: System.Security.AccessControl.AccessControlSections
- uid: System.Security.AccessControl.SemaphoreSecurity.AccessRightType
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AccessRightType
  nameWithType: SemaphoreSecurity.AccessRightType
  fullName: System.Security.AccessControl.SemaphoreSecurity.AccessRightType
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  nameWithType: SemaphoreSecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  fullName: System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
- uid: System.Security.AccessControl.AccessRule
  parent: System.Security.AccessControl
  isExternal: false
  name: AccessRule
  nameWithType: AccessRule
  fullName: System.Security.AccessControl.AccessRule
- uid: System.Security.Principal.IdentityReference
  parent: System.Security.Principal
  isExternal: false
  name: IdentityReference
  nameWithType: IdentityReference
  fullName: System.Security.Principal.IdentityReference
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Security.AccessControl.InheritanceFlags
  parent: System.Security.AccessControl
  isExternal: false
  name: InheritanceFlags
  nameWithType: InheritanceFlags
  fullName: System.Security.AccessControl.InheritanceFlags
- uid: System.Security.AccessControl.PropagationFlags
  parent: System.Security.AccessControl
  isExternal: false
  name: PropagationFlags
  nameWithType: PropagationFlags
  fullName: System.Security.AccessControl.PropagationFlags
- uid: System.Security.AccessControl.AccessControlType
  parent: System.Security.AccessControl
  isExternal: false
  name: AccessControlType
  nameWithType: AccessControlType
  fullName: System.Security.AccessControl.AccessControlType
- uid: System.Security.AccessControl.SemaphoreSecurity.AccessRuleType
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AccessRuleType
  nameWithType: SemaphoreSecurity.AccessRuleType
  fullName: System.Security.AccessControl.SemaphoreSecurity.AccessRuleType
- uid: System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AddAccessRule(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.AddAccessRule(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(SemaphoreAccessRule)
- uid: System.Security.AccessControl.SemaphoreAccessRule
  parent: System.Security.AccessControl
  isExternal: false
  name: SemaphoreAccessRule
  nameWithType: SemaphoreAccessRule
  fullName: System.Security.AccessControl.SemaphoreAccessRule
- uid: System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AddAuditRule(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.AddAuditRule(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(SemaphoreAuditRule)
- uid: System.Security.AccessControl.SemaphoreAuditRule
  parent: System.Security.AccessControl
  isExternal: false
  name: SemaphoreAuditRule
  nameWithType: SemaphoreAuditRule
  fullName: System.Security.AccessControl.SemaphoreAuditRule
- uid: System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  nameWithType: SemaphoreSecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  fullName: System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
- uid: System.Security.AccessControl.AuditRule
  parent: System.Security.AccessControl
  isExternal: false
  name: AuditRule
  nameWithType: AuditRule
  fullName: System.Security.AccessControl.AuditRule
- uid: System.Security.AccessControl.AuditFlags
  parent: System.Security.AccessControl
  isExternal: false
  name: AuditFlags
  nameWithType: AuditFlags
  fullName: System.Security.AccessControl.AuditFlags
- uid: System.Security.AccessControl.SemaphoreSecurity.AuditRuleType
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AuditRuleType
  nameWithType: SemaphoreSecurity.AuditRuleType
  fullName: System.Security.AccessControl.SemaphoreSecurity.AuditRuleType
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAccessRule(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.RemoveAccessRule(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(SemaphoreAccessRule)
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAccessRuleAll(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.RemoveAccessRuleAll(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(SemaphoreAccessRule)
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAccessRuleSpecific(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.RemoveAccessRuleSpecific(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(SemaphoreAccessRule)
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAuditRule(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.RemoveAuditRule(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(SemaphoreAuditRule)
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAuditRuleAll(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.RemoveAuditRuleAll(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(SemaphoreAuditRule)
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAuditRuleSpecific(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.RemoveAuditRuleSpecific(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(SemaphoreAuditRule)
- uid: System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: ResetAccessRule(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.ResetAccessRule(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(SemaphoreAccessRule)
- uid: System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: SetAccessRule(SemaphoreAccessRule)
  nameWithType: SemaphoreSecurity.SetAccessRule(SemaphoreAccessRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(SemaphoreAccessRule)
- uid: System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(System.Security.AccessControl.SemaphoreAuditRule)
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: SetAuditRule(SemaphoreAuditRule)
  nameWithType: SemaphoreSecurity.SetAuditRule(SemaphoreAuditRule)
  fullName: System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(SemaphoreAuditRule)
- uid: System.Security.AccessControl.SemaphoreSecurity.#ctor*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: SemaphoreSecurity
  nameWithType: SemaphoreSecurity.SemaphoreSecurity
- uid: System.Security.AccessControl.SemaphoreSecurity.AccessRightType*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AccessRightType
  nameWithType: SemaphoreSecurity.AccessRightType
- uid: System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AccessRuleFactory
  nameWithType: SemaphoreSecurity.AccessRuleFactory
- uid: System.Security.AccessControl.SemaphoreSecurity.AccessRuleType*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AccessRuleType
  nameWithType: SemaphoreSecurity.AccessRuleType
- uid: System.Security.AccessControl.SemaphoreSecurity.AddAccessRule*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AddAccessRule
  nameWithType: SemaphoreSecurity.AddAccessRule
- uid: System.Security.AccessControl.SemaphoreSecurity.AddAuditRule*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AddAuditRule
  nameWithType: SemaphoreSecurity.AddAuditRule
- uid: System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AuditRuleFactory
  nameWithType: SemaphoreSecurity.AuditRuleFactory
- uid: System.Security.AccessControl.SemaphoreSecurity.AuditRuleType*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: AuditRuleType
  nameWithType: SemaphoreSecurity.AuditRuleType
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAccessRule
  nameWithType: SemaphoreSecurity.RemoveAccessRule
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAccessRuleAll
  nameWithType: SemaphoreSecurity.RemoveAccessRuleAll
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAccessRuleSpecific
  nameWithType: SemaphoreSecurity.RemoveAccessRuleSpecific
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAuditRule
  nameWithType: SemaphoreSecurity.RemoveAuditRule
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAuditRuleAll
  nameWithType: SemaphoreSecurity.RemoveAuditRuleAll
- uid: System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: RemoveAuditRuleSpecific
  nameWithType: SemaphoreSecurity.RemoveAuditRuleSpecific
- uid: System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: ResetAccessRule
  nameWithType: SemaphoreSecurity.ResetAccessRule
- uid: System.Security.AccessControl.SemaphoreSecurity.SetAccessRule*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: SetAccessRule
  nameWithType: SemaphoreSecurity.SetAccessRule
- uid: System.Security.AccessControl.SemaphoreSecurity.SetAuditRule*
  parent: System.Security.AccessControl.SemaphoreSecurity
  isExternal: false
  name: SetAuditRule
  nameWithType: SemaphoreSecurity.SetAuditRule
