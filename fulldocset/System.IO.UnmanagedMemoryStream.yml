### YamlMime:ManagedReference
items:
- uid: System.IO.UnmanagedMemoryStream
  id: UnmanagedMemoryStream
  children:
  - System.IO.UnmanagedMemoryStream.#ctor
  - System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)
  - System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64)
  - System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  - System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  - System.IO.UnmanagedMemoryStream.CanRead
  - System.IO.UnmanagedMemoryStream.CanSeek
  - System.IO.UnmanagedMemoryStream.CanWrite
  - System.IO.UnmanagedMemoryStream.Capacity
  - System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)
  - System.IO.UnmanagedMemoryStream.Flush
  - System.IO.UnmanagedMemoryStream.FlushAsync(System.Threading.CancellationToken)
  - System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  - System.IO.UnmanagedMemoryStream.Initialize(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  - System.IO.UnmanagedMemoryStream.Length
  - System.IO.UnmanagedMemoryStream.Position
  - System.IO.UnmanagedMemoryStream.PositionPointer
  - System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.UnmanagedMemoryStream.ReadByte
  - System.IO.UnmanagedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.IO.UnmanagedMemoryStream.SetLength(System.Int64)
  - System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.IO.UnmanagedMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)
  langs:
  - csharp
  name: UnmanagedMemoryStream
  nameWithType: UnmanagedMemoryStream
  fullName: System.IO.UnmanagedMemoryStream
  type: Class
  summary: "Zapewnia dostęp do niezarządzanego bloków pamięci z kodu zarządzanego."
  remarks: "Ta klasa obsługuje dostęp do niezarządzanego pamięci przy użyciu istniejącego modelu na podstawie strumienia i nie jest wymagane, czy zawartość w pamięci niezarządzanej skopiowana do sterty.      > [!IMPORTANT] > Ten typ implementuje <xref:System.IDisposable>interfejsu.</xref:System.IDisposable> Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niego. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A>metody w `try` / `catch` bloku.</xref:System.IDisposable.Dispose%2A> Do usunięcia ich pośrednio, użyj konstrukcji języka takiego jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję &quot;Przy użyciu obiektu który implementuje interfejs IDisposable&quot; w <xref:System.IDisposable>tematu interfejsu.</xref:System.IDisposable>"
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the UnmanagedMemoryStream class.  A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream#1](~/add/codesnippet/csharp/t-system.io.unmanagedmem_1.cs)]"
  syntax:
    content: 'public class UnmanagedMemoryStream : System.IO.Stream'
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.#ctor
  id: '#ctor'
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: UnmanagedMemoryStream()
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream()
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref> klasy."
  syntax:
    content: protected UnmanagedMemoryStream ();
    parameters: []
  overload: System.IO.UnmanagedMemoryStream.#ctor*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Użytkownik nie ma wymaganych uprawnień."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)
  id: '#ctor(System.Byte*,System.Int64)'
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: UnmanagedMemoryStream(Byte*,Int64)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref> przy użyciu określonej długości lokalizacji i pamięci."
  remarks: "Ten konstruktor tworzy nowe wystąpienie klasy <xref:System.IO.UnmanagedMemoryStream>klasy, a domyślnie ustawia <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A>właściwości `false` i <xref:System.IO.UnmanagedMemoryStream.CanRead%2A>właściwości `true`.</xref:System.IO.UnmanagedMemoryStream.CanRead%2A> </xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> </xref:System.IO.UnmanagedMemoryStream> <xref:System.IO.UnmanagedMemoryStream.Length%2A>Właściwości ustawiono wartość `length` parametru i nie można zmienić.</xref:System.IO.UnmanagedMemoryStream.Length%2A>"
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/m-system.io.unmanagedmem_4_1.cs)]"
  syntax:
    content: public UnmanagedMemoryStream (byte* pointer, long length);
    parameters:
    - id: pointer
      type: System.Byte*
      description: "Wskaźnik do lokalizacji w pamięci niezarządzanej."
    - id: length
      type: System.Int64
      description: "Długość pamięci, aby użyć."
  overload: System.IO.UnmanagedMemoryStream.#ctor*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Użytkownik nie ma wymaganych uprawnień."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>pointer</code> value is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "The <code>length</code> value is less than zero.  \n  \n \\- or -  \n  \n The <code>length</code> is large enough to cause an overflow."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64)
  id: '#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64)'
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: UnmanagedMemoryStream(SafeBuffer,Int64,Int64)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref> klasy bezpieczne buforu z określonego przesunięcia i długości."
  syntax:
    content: public UnmanagedMemoryStream (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length);
    parameters:
    - id: buffer
      type: System.Runtime.InteropServices.SafeBuffer
      description: "Bufor zawiera strumienia pamięci niezarządzanej."
    - id: offset
      type: System.Int64
      description: "Pozycja bajtów w buforze, od którego należy rozpocząć strumienia pamięci niezarządzanej."
    - id: length
      type: System.Int64
      description: "Długość strumienia pamięci niezarządzanej."
  overload: System.IO.UnmanagedMemoryStream.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  id: '#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)'
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: UnmanagedMemoryStream(Byte*,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64,Int64,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref> przy użyciu określonej lokalizacji, długość pamięci, łączna ilość pamięci i wartości dotyczące dostępu do pliku."
  remarks: "`length` Parametr definiuje Bieżąca ilość pamięci w użyciu. Jeśli odczytu lub dołączanie danych w strumieniu `length` wartość powinna być równa ilości prawidłowych danych w strumieniu do odczytu lub zachowane. W przypadku zapisywania do strumienia, ta wartość powinna wynosić zero.       `capacity` Parametr wskazuje ilość całkowitej dostępnej pamięci. Tę wartość można opisać region, który jest dłuższy niż określona długość lub wskazać region, który można dołączyć do. Próba zapisu poza tę wartość zakończy się niepowodzeniem.       `access` Zestawów parametrów <xref:System.IO.UnmanagedMemoryStream.CanRead%2A>, i <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A>Właściwości.</xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> </xref:System.IO.UnmanagedMemoryStream.CanRead%2A> Należy pamiętać, że określenie <xref:System.IO.FileAccess>nie gwarantuje, że strumień będzie możliwa do zapisu.</xref:System.IO.FileAccess> Parametry dostępu mogą zostać implementujący do utworzenia obiektu, którego implementacja można dopasować do rzeczywistego strumienia, który jest uwidaczniany."
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.  A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream#1](~/add/codesnippet/csharp/62930bcb-5dff-4d38-8341-_1.cs)]"
  syntax:
    content: public UnmanagedMemoryStream (byte* pointer, long length, long capacity, System.IO.FileAccess access);
    parameters:
    - id: pointer
      type: System.Byte*
      description: "Wskaźnik do lokalizacji w pamięci niezarządzanej."
    - id: length
      type: System.Int64
      description: "Długość pamięci, aby użyć."
    - id: capacity
      type: System.Int64
      description: "Całkowita ilość pamięci przypisana do strumienia."
    - id: access
      type: System.IO.FileAccess
      description: "Jeden z <xref href=&quot;System.IO.FileAccess&quot;> </xref> wartości."
  overload: System.IO.UnmanagedMemoryStream.#ctor*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Użytkownik nie ma wymaganych uprawnień."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>pointer</code> value is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "The <code>length</code> value is less than zero.  \n  \n \\- or -  \n  \n The <code>capacity</code> value is less than zero.  \n  \n \\- or -  \n  \n The <code>length</code> value is greater than the <code>capacity</code> value."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  id: '#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)'
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: UnmanagedMemoryStream(SafeBuffer,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref> klasy bezpieczne buforu z przesunięciem określonej długości, a dostęp do plików."
  syntax:
    content: public UnmanagedMemoryStream (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length, System.IO.FileAccess access);
    parameters:
    - id: buffer
      type: System.Runtime.InteropServices.SafeBuffer
      description: "Bufor zawiera strumienia pamięci niezarządzanej."
    - id: offset
      type: System.Int64
      description: "Pozycja bajtów w buforze, od którego należy rozpocząć strumienia pamięci niezarządzanej."
    - id: length
      type: System.Int64
      description: "Długość strumienia pamięci niezarządzanej."
    - id: access
      type: System.IO.FileAccess
      description: "Tryb dostępu do pliku w strumieniu niezarządzanej pamięci."
  overload: System.IO.UnmanagedMemoryStream.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.CanRead
  id: CanRead
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: CanRead
  nameWithType: UnmanagedMemoryStream.CanRead
  fullName: System.IO.UnmanagedMemoryStream.CanRead
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Pobiera wartość wskazującą, czy strumień obsługuje odczytu."
  remarks: "Ta właściwość wskazuje, czy bieżący obiekt strumienia obsługuje odczytu."
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class. In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the CanRead property before attempting to display the contents to the console.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/p-system.io.unmanagedmem_2_1.cs)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>Jeśli obiekt został utworzony przez konstruktora z <code> access </code> parametru, która nie zawiera odczytu strumienia i jeśli strumień jest zamknięty, a w przeciwnym razie <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.UnmanagedMemoryStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.CanSeek
  id: CanSeek
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: UnmanagedMemoryStream.CanSeek
  fullName: System.IO.UnmanagedMemoryStream.CanSeek
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Pobiera wartość wskazującą, czy strumień obsługuje operacji wyszukiwania."
  remarks: "Ta właściwość wskazuje, czy bieżący obiekt strumienia obsługuje operacji wyszukiwania."
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>Jeśli strumień jest zamknięty; w przeciwnym razie <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.UnmanagedMemoryStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.CanWrite
  id: CanWrite
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: UnmanagedMemoryStream.CanWrite
  fullName: System.IO.UnmanagedMemoryStream.CanWrite
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Pobiera wartość wskazującą, czy strumień obsługuje zapisu."
  remarks: "Ta właściwość wskazuje, czy bieżący obiekt strumienia obsługuje zapisu."
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class. In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the CanWrite property before attempting to write the data to the stream.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/p-system.io.unmanagedmem_0_1.cs)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>Jeśli obiekt został utworzony przez konstruktora z <code> access </code> wartość parametru, która obsługuje zapis lub został utworzony przez konstruktora, który miał bez parametrów, czy strumień jest zamknięty, a w przeciwnym razie <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.UnmanagedMemoryStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Capacity
  id: Capacity
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Capacity
  nameWithType: UnmanagedMemoryStream.Capacity
  fullName: System.IO.UnmanagedMemoryStream.Capacity
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Pobiera długość strumienia (rozmiar) lub łączną ilość pamięci przypisana do strumienia (pojemności)."
  remarks: "Ta właściwość zwraca `capacity` wartości przekazanej do konstruktora. Jeśli nie `capacity` wartość została określona podczas inicjowania strumienia, ta właściwość zwraca długość strumienia."
  syntax:
    content: public long Capacity { get; }
    return:
      type: System.Int64
      description: "Rozmiar lub pojemności strumienia."
  overload: System.IO.UnmanagedMemoryStream.Capacity*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Strumień jest zamknięty."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: UnmanagedMemoryStream.Dispose(Boolean)
  fullName: System.IO.UnmanagedMemoryStream.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Zwalnia zasoby niezarządzane używane przez <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref> i opcjonalnie zwalnia zasoby zarządzane."
  remarks: "Ta metoda jest wywoływana przez metodę publiczną <xref:System.ComponentModel.Component.Dispose%2A>— Metoda i <xref:System.Object.Finalize%2A>metody.</xref:System.Object.Finalize%2A> </xref:System.ComponentModel.Component.Dispose%2A> <xref:System.ComponentModel.Component.Dispose%2A>wywołuje metodę Dispose chronionego z `disposing` ustawiono parametr `true`.</xref:System.ComponentModel.Component.Dispose%2A> <xref:System.Object.Finalize%2A>wywołuje metodę Dispose z `disposing` ustawioną `false`.</xref:System.Object.Finalize%2A>       Gdy `disposing` parametr jest `true`, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane przez to <xref:System.IO.UnmanagedMemoryStream>odwołań.</xref:System.IO.UnmanagedMemoryStream> Ta metoda wywołuje <xref:System.ComponentModel.Component.Dispose%2A>metody każdego odwołuje się do obiektu.</xref:System.ComponentModel.Component.Dispose%2A>"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby zwolnić zasoby zarządzane i niezarządzane; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> aby zwolnić tylko zasoby niezarządzane."
  overload: System.IO.UnmanagedMemoryStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Flush
  id: Flush
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Flush()
  nameWithType: UnmanagedMemoryStream.Flush()
  fullName: System.IO.UnmanagedMemoryStream.Flush()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Zastępuje <xref:System.IO.Stream.Flush*>metody, aby nie wykonano żadnej akcji.</xref:System.IO.Stream.Flush*>"
  remarks: "Ta metoda nie wykonuje żadnej akcji dla tej klasy, ale wchodzi w skład <xref:System.IO.Stream>klasy podstawowej.</xref:System.IO.Stream> Ponieważ wszystkie dane są zapisywane do pamięci RAM, ta metoda jest nadmiarowy."
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.IO.UnmanagedMemoryStream.Flush*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Strumień jest zamknięty."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: UnmanagedMemoryStream.FlushAsync(CancellationToken)
  fullName: System.IO.UnmanagedMemoryStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Zastępuje &lt;xref:System.IO.Stream.FlushAsync%2A?displayProperty=fullName&gt; metody, aby anulowanie operacji, jeśli zostanie określony, ale nie inne czynności.       Dostępne od wersji[!INCLUDE[net_2015](~/add/includes/net-2015-md.md)]"
  remarks: "Jeśli operacja nie jest anulowana, <xref:System.IO.UnmanagedMemoryStream>wywołania <xref:System.IO.UnmanagedMemoryStream.Flush%2A>metody, co oznacza, że nie wykonano żadnej akcji.</xref:System.IO.UnmanagedMemoryStream.Flush%2A> </xref:System.IO.UnmanagedMemoryStream>"
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Token do monitorowania żądań anulowania. Wartość domyślna to <xref:System.Threading.CancellationToken.None*>.</xref:System.Threading.CancellationToken.None*>"
    return:
      type: System.Threading.Tasks.Task
      description: "Zadanie reprezentujące asynchroniczną operację opróżniania."
  overload: System.IO.UnmanagedMemoryStream.FlushAsync*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  id: Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Initialize(Byte*,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.Initialize(Byte*,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.Initialize(Byte*,Int64,Int64,FileAccess)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref> przy użyciu wskaźnika do lokalizacji w pamięci niezarządzanej."
  remarks: "Ta metoda jest odpowiednikiem <xref:System.IO.UnmanagedMemoryStream.%23ctor%2A>konstruktora.</xref:System.IO.UnmanagedMemoryStream.%23ctor%2A> Obsługuje ona metody, które należy zainicjować wskaźnika przed ustawieniem zmienne strumienia i, w związku z tym nie można wywołać konstruktora sparametryzowana. Takie metody należy użyć konstruktora domyślnego, <xref:System.IO.UnmanagedMemoryStream.%23ctor>, zainicjować wskaźnik, a następnie wywołać metodę Initialize.</xref:System.IO.UnmanagedMemoryStream.%23ctor>"
  syntax:
    content: protected void Initialize (byte* pointer, long length, long capacity, System.IO.FileAccess access);
    parameters:
    - id: pointer
      type: System.Byte*
      description: "Wskaźnik do lokalizacji w pamięci niezarządzanej."
    - id: length
      type: System.Int64
      description: "Długość pamięci, aby użyć."
    - id: capacity
      type: System.Int64
      description: "Całkowita ilość pamięci przypisana do strumienia."
    - id: access
      type: System.IO.FileAccess
      description: "Jeden z <xref href=&quot;System.IO.FileAccess&quot;> </xref> wartości."
  overload: System.IO.UnmanagedMemoryStream.Initialize*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Użytkownik nie ma wymaganych uprawnień."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>pointer</code> value is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "The <code>length</code> value is less than zero.  \n  \n \\- or -  \n  \n The <code>capacity</code> value is less than zero.  \n  \n \\- or -  \n  \n The <code>length</code> value is large enough to cause an overflow."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Initialize(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  id: Initialize(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Initialize(SafeBuffer,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.Initialize(SafeBuffer,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.Initialize(SafeBuffer,Int64,Int64,FileAccess)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.IO.UnmanagedMemoryStream&quot;> </xref> klasy bezpieczne buforu z przesunięciem określonej długości, a dostęp do plików."
  syntax:
    content: protected void Initialize (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length, System.IO.FileAccess access);
    parameters:
    - id: buffer
      type: System.Runtime.InteropServices.SafeBuffer
      description: "Bufor zawiera strumienia pamięci niezarządzanej."
    - id: offset
      type: System.Int64
      description: "Pozycja bajtów w buforze, od którego należy rozpocząć strumienia pamięci niezarządzanej."
    - id: length
      type: System.Int64
      description: "Długość strumienia pamięci niezarządzanej."
    - id: access
      type: System.IO.FileAccess
      description: "Tryb dostępu do pliku w strumieniu niezarządzanej pamięci."
  overload: System.IO.UnmanagedMemoryStream.Initialize*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Length
  id: Length
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Length
  nameWithType: UnmanagedMemoryStream.Length
  fullName: System.IO.UnmanagedMemoryStream.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Pobiera długość danych w strumieniu."
  remarks: "Jeśli bez zmian, ponieważ strumień został zainicjowany, ta właściwość zwraca wartość długości przekazane konstruktorowi. Jeśli wystąpiły zmiany w strumieniu, ta właściwość odzwierciedla wszystkie zmiany do długości danych."
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/p-system.io.unmanagedmem_1_1.cs)]"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "Długość danych w strumieniu."
  overload: System.IO.UnmanagedMemoryStream.Length*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Strumień jest zamknięty."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Position
  id: Position
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Position
  nameWithType: UnmanagedMemoryStream.Position
  fullName: System.IO.UnmanagedMemoryStream.Position
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Pobiera lub ustawia bieżącą pozycję w strumieniu."
  remarks: "Po zainicjowaniu strumienia tej właściwości jest równa zero.       Mimo że można ustawić pozycji strumienia poza pojemność strumienia, nie będzie mógł uzyskać dostępu do tego obszaru za pomocą <xref:System.IO.UnmanagedMemoryStream.Read%2A>i <xref:System.IO.UnmanagedMemoryStream.Write%2A>metody.</xref:System.IO.UnmanagedMemoryStream.Write%2A> </xref:System.IO.UnmanagedMemoryStream.Read%2A> <xref:System.IO.UnmanagedMemoryStream.Read%2A>Zwraca 0 i <xref:System.IO.UnmanagedMemoryStream.Write%2A>zgłosi <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.UnmanagedMemoryStream.Write%2A></xref:System.IO.UnmanagedMemoryStream.Read%2A> Ta obsługa jest przeznaczone głównie dla projektu i kodu zgodności z operacjami strumienia podstawowego."
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "Bieżąca pozycja w strumieniu."
  overload: System.IO.UnmanagedMemoryStream.Position*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Strumień jest zamknięty."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Pozycja ma ustawioną wartość, która jest mniejsza od zera lub pozycja jest większy niż <xref:System.Int32.MaxValue>lub przepełnienie podczas dodawania do bieżącego wskaźnika nie zwróciło wyników.</xref:System.Int32.MaxValue>"
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.PositionPointer
  id: PositionPointer
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: PositionPointer
  nameWithType: UnmanagedMemoryStream.PositionPointer
  fullName: System.IO.UnmanagedMemoryStream.PositionPointer
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Pobiera lub ustawia wskaźnik bajtów do strumienia, w oparciu o bieżącą pozycję w strumieniu."
  remarks: "Aby zwraca wskaźnik do całego strumienia, ustaw <xref:System.IO.UnmanagedMemoryStream.Position%2A>właściwości do zera, a następnie wywołać tej właściwości.</xref:System.IO.UnmanagedMemoryStream.Position%2A>"
  syntax:
    content: public byte* PositionPointer { get; set; }
    return:
      type: System.Byte*
      description: "Wskaźnik bajtów."
  overload: System.IO.UnmanagedMemoryStream.PositionPointer*
  exceptions:
  - type: System.IndexOutOfRangeException
    commentId: T:System.IndexOutOfRangeException
    description: "Bieżące położenie jest większa niż pojemność strumienia."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Pozycja jest zestaw nie jest prawidłową pozycją w strumieniu bieżącej."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wskaźnik jest ustawiany na mniejszą wartość niż pozycja początkowa strumienia."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Zainicjowano strumień do użycia z <xref:System.Runtime.InteropServices.SafeBuffer>.</xref:System.Runtime.InteropServices.SafeBuffer> Właściwość PositionPointer jest prawidłowa tylko dla strumieni, które są inicjowane z <xref:System.Byte>wskaźnik.</xref:System.Byte>"
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: UnmanagedMemoryStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.UnmanagedMemoryStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Odczytuje określoną liczbę bajtów w określonej tablicy."
  remarks: "`offset` Parametru zapewnia Przesunięcie bajtów w `array` parametr (indeks bufora), w którym ma rozpocząć się odczyt i `count` parametru zapewnia maksymalną liczbę bajtów do odczytu tego strumienia. Zwrócona wartość jest rzeczywista liczba bajtów odczytanych lub zero, jeśli zostanie osiągnięty koniec strumienia. Jeśli operacja odczytu zakończy się pomyślnie, bieżącej pozycji strumienia jest zaawansowane przez liczbę bajtów do odczytu. Jeśli wystąpi wyjątek, bieżącej pozycji strumienia jest bez zmian.       Metody Read zwraca zero tylko po dojściu do końca strumienia. W przeciwnym razie odczytu ma zawsze wartość co najmniej jednego bajtu ze strumienia przed zwróceniem. Jeśli dane są niedostępne ze strumienia podczas wywołania odczytu, metoda zablokuje dopóki co najmniej jednego bajtu danych może być zwracany. Implementacja jest bezpłatna do zwrócenia mniej bajtów niż żądana, nawet jeżeli nie osiągnięto koniec strumienia."
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.  A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream#1](~/add/codesnippet/csharp/m-system.io.unmanagedmem_2_1.cs)]"
  syntax:
    content: public override int Read (byte[] buffer, int offset, int count);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Po powrocie z tej metody zawiera określonej tablicy bajtów z wartością pomiędzy `offset` i (`offset`  +  `count` - 1) zastępuje Bajty odczytane z bieżącego źródła. Ten parametr jest przekazywany jako niezainicjowany."
    - id: offset
      type: System.Int32
      description: "Zerze przesunięcie w `buffer` rozpoczęcia przechowywania danych przeczytanie z bieżącego strumienia."
    - id: count
      type: System.Int32
      description: "Maksymalna liczba bajtów do odczytania strumienia bieżącego."
    return:
      type: System.Int32
      description: "Całkowita liczba bajtów odczytanych w buforze. Może to być mniejsza niż żądana liczba bajtów Jeśli wiele bajtów nie są obecnie dostępne, czy zero (0), jeśli został osiągnięty koniec strumienia."
  overload: System.IO.UnmanagedMemoryStream.Read*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Strumień jest zamknięty."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The underlying memory does not support reading.  \n  \n \\- or -  \n  \n The <xref:System.IO.UnmanagedMemoryStream.CanRead*> property is set to <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is set to <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "The <code>offset</code> parameter is less than zero.  \n  \n \\- or -  \n  \n The <code>count</code> parameter is less than zero."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Długość tablicy buforu pomniejszona o <code> offset </code> parametr jest mniejsza niż <code> count </code> parametru."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: UnmanagedMemoryStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.UnmanagedMemoryStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Asynchronicznie odczytuje określoną liczbę bajtów w określonej tablicy.       Dostępne od wersji[!INCLUDE[net_2015](~/add/includes/net-2015-md.md)]"
  remarks: "Jeśli wystąpi wyjątek podczas operacji odczytu, zostanie ustawione jako <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=fullName>Właściwości zadania zwróconego.</xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=fullName>"
  syntax:
    content: public override System.Threading.Tasks.Task<int> ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Bufor zapisu danych do."
    - id: offset
      type: System.Int32
      description: "Przesunięcie bajtów w `buffer` jaką rozpocząć pisanie danych ze strumienia."
    - id: count
      type: System.Int32
      description: "Maksymalna liczba bajtów do odczytania."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Token do monitorowania żądań anulowania. Wartość domyślna to <xref:System.Threading.CancellationToken.None*>.</xref:System.Threading.CancellationToken.None*>"
    return:
      type: System.Threading.Tasks.Task{System.Int32}
      description: "Zadanie reprezentujące asynchroniczną operacji odczytu. Wartość <code> TResult </code> parametr zawiera całkowitą liczbę bajtów odczytanych w buforze. Wartość wyniku może być mniejsza niż żądana liczba bajtów Liczba dostępnych bajtów jest mniejsza niż żądany numer, czy może być 0 (zero), jeśli osiągnięto koniec strumienia."
  overload: System.IO.UnmanagedMemoryStream.ReadAsync*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.ReadByte
  id: ReadByte
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: ReadByte()
  nameWithType: UnmanagedMemoryStream.ReadByte()
  fullName: System.IO.UnmanagedMemoryStream.ReadByte()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Odczytuje bajtów ze strumienia i zmienia pozycję w strumieniu przez jednego bajtu lub zwraca wartość -1, jeśli na koniec strumienia."
  remarks: "Użyj tej metody, aby zwrócić wartości będące liczbami całkowitymi ze strumienia."
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class. In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> property before attempting to read and display the contents to the console.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/m-system.io.unmanagedmem_1_1.cs)]"
  syntax:
    content: public override int ReadByte ();
    parameters: []
    return:
      type: System.Int32
      description: "Rzutować bajtu bez znaku <xref:System.Int32>obiektu lub -1, jeśli na koniec strumienia.</xref:System.Int32>"
  overload: System.IO.UnmanagedMemoryStream.ReadByte*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Strumień jest zamknięty."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The underlying memory does not support reading.  \n  \n \\- or -  \n  \n The current position is at the end of the stream."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: UnmanagedMemoryStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.UnmanagedMemoryStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Ustawia bieżącą pozycję bieżący strumień podanej wartości."
  remarks: "Aby uzyskać więcej informacji na temat wyszukiwania zobacz <xref:System.IO.FileStream.Seek%2A>.</xref:System.IO.FileStream.Seek%2A>"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin loc);
    parameters:
    - id: offset
      type: System.Int64
      description: "Punkt względem `origin` aby rozpocząć wyszukiwanie z."
    - id: loc
      type: System.IO.SeekOrigin
      description: "Określa początek, końcu lub bieżącą pozycję jako punkt odniesienia dla `origin`, za pomocą wartości typu <xref:System.IO.SeekOrigin>.</xref:System.IO.SeekOrigin>"
    return:
      type: System.Int64
      description: "Nowa pozycja w strumieniu."
  overload: System.IO.UnmanagedMemoryStream.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Nastąpiła próba można wyszukiwać przed początkiem strumienia."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> offset </code> Wartości jest większy niż maksymalny rozmiar strumienia."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>loc</code>jest nieprawidłowy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Strumień jest zamknięty."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: UnmanagedMemoryStream.SetLength(Int64)
  fullName: System.IO.UnmanagedMemoryStream.SetLength(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Ustawia określoną wartość długości strumienia."
  remarks: "Jeśli dana wartość jest mniejsza niż bieżąca długość strumienia, zostanie obcięta strumienia. Jeśli dana wartość jest większa niż bieżąca długość strumienia, strumień jest rozwinięta. Jeśli strumień jest rozwinięty, zawartość strumienia między stary i nowy długości jest niezdefiniowany.       Strumień musi obsługiwać zarówno zapisu i wyszukiwania dla SetLength do pracy."
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "Długość strumienia."
  overload: System.IO.UnmanagedMemoryStream.SetLength*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Strumień jest zamknięty."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The underlying memory does not support writing.  \n  \n \\- or -  \n  \n An attempt is made to write to the stream and the <xref:System.IO.UnmanagedMemoryStream.CanWrite*> property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "The specified <code>value</code> exceeds the capacity of the stream.  \n  \n \\- or -  \n  \n The specified <code>value</code> is negative."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: UnmanagedMemoryStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.UnmanagedMemoryStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Zapisuje bieżący strumień przy użyciu danych z bufora bloku bajtów."
  remarks: "Zapisywanie występuje w bieżącej pozycji w strumieniu."
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.  A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream#1](~/add/codesnippet/csharp/m-system.io.unmanagedmem_3_1.cs)]"
  syntax:
    content: public override void Write (byte[] buffer, int offset, int count);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Tablica bajtów do skopiowania do bieżącego strumienia bajtów."
    - id: offset
      type: System.Int32
      description: "Przesunięcie w buforze, od którego należy zacząć kopiowanie bajtów do bieżącego strumienia."
    - id: count
      type: System.Int32
      description: "Liczba bajtów do zapisania w strumieniu bieżącej."
  overload: System.IO.UnmanagedMemoryStream.Write*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Strumień jest zamknięty."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The underlying memory does not support writing.  \n  \n \\- or -  \n  \n An attempt is made to write to the stream and the <xref:System.IO.UnmanagedMemoryStream.CanWrite*> property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The <code>count</code> value is greater than the capacity of the stream.  \n  \n \\- or -  \n  \n The position is at the end of the stream capacity."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Występuje błąd We/Wy."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Jeden z wymaganych parametrów jest mniejsza od zera."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> offset </code> Parametru minus długość <code> buffer </code> parametr jest mniejsza niż <code> count </code> parametru."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: UnmanagedMemoryStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.UnmanagedMemoryStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Asynchronicznie zapisuje sekwencję bajtów bieżący strumień przesuwa bieżącą pozycję w tym strumieniu przez liczba zapisanych bajtów i monitoruje żądań anulowania.       Dostępne od wersji[!INCLUDE[net_2015](~/add/includes/net-2015-md.md)]"
  remarks: "Jeśli wystąpi wyjątek podczas operacji zapisu, zostanie ustawione jako <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=fullName>Właściwości zadania zwróconego.</xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=fullName>"
  syntax:
    content: public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Bufor zapisywania danych z."
    - id: offset
      type: System.Int32
      description: "Zerze przesunięcie w `buffer` z którego należy zacząć kopiowanie bajtów do strumienia."
    - id: count
      type: System.Int32
      description: "Maksymalna liczba bajtów do zapisania."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Token do monitorowania żądań anulowania. Wartość domyślna to <xref:System.Threading.CancellationToken.None*>.</xref:System.Threading.CancellationToken.None*>"
    return:
      type: System.Threading.Tasks.Task
      description: "Zadanie reprezentujące operację asynchronicznego zapisu."
  overload: System.IO.UnmanagedMemoryStream.WriteAsync*
  exceptions: []
  platform:
  - net462
- uid: System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)
  id: WriteByte(System.Byte)
  parent: System.IO.UnmanagedMemoryStream
  langs:
  - csharp
  name: WriteByte(Byte)
  nameWithType: UnmanagedMemoryStream.WriteByte(Byte)
  fullName: System.IO.UnmanagedMemoryStream.WriteByte(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Zapisuje bajt bieżącą pozycję w strumieniu plików."
  remarks: ''
  example:
  - "The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class. A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class. In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> property before attempting to write the data to the stream.  \n  \n [!code-cs[System.IO.UnmanagedMemoryStream_Example#00](~/add/codesnippet/csharp/m-system.io.unmanagedmem_0_1.cs)]"
  syntax:
    content: public override void WriteByte (byte value);
    parameters:
    - id: value
      type: System.Byte
      description: "Bajt zapisywane do strumienia."
  overload: System.IO.UnmanagedMemoryStream.WriteByte*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Strumień jest zamknięty."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The underlying memory does not support writing.  \n  \n \\- or -  \n  \n An attempt is made to write to the stream and the <xref:System.IO.UnmanagedMemoryStream.CanWrite*> property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The current position is at the end of the capacity of the stream."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Podana <code> value </code> powoduje, że strumień przekracza maksymalną pojemność."
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IndexOutOfRangeException
  isExternal: true
  name: System.IndexOutOfRangeException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.IO.UnmanagedMemoryStream.#ctor
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: UnmanagedMemoryStream()
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream()
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream()
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: UnmanagedMemoryStream(Byte*,Int64)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: UnmanagedMemoryStream(SafeBuffer,Int64,Int64)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64)
- uid: System.Runtime.InteropServices.SafeBuffer
  parent: System.Runtime.InteropServices
  isExternal: true
  name: SafeBuffer
  nameWithType: SafeBuffer
  fullName: System.Runtime.InteropServices.SafeBuffer
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: UnmanagedMemoryStream(Byte*,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(Byte*,Int64,Int64,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: UnmanagedMemoryStream(SafeBuffer,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.UnmanagedMemoryStream(SafeBuffer,Int64,Int64,FileAccess)
- uid: System.IO.UnmanagedMemoryStream.CanRead
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: CanRead
  nameWithType: UnmanagedMemoryStream.CanRead
  fullName: System.IO.UnmanagedMemoryStream.CanRead
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.UnmanagedMemoryStream.CanSeek
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: CanSeek
  nameWithType: UnmanagedMemoryStream.CanSeek
  fullName: System.IO.UnmanagedMemoryStream.CanSeek
- uid: System.IO.UnmanagedMemoryStream.CanWrite
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: CanWrite
  nameWithType: UnmanagedMemoryStream.CanWrite
  fullName: System.IO.UnmanagedMemoryStream.CanWrite
- uid: System.IO.UnmanagedMemoryStream.Capacity
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Capacity
  nameWithType: UnmanagedMemoryStream.Capacity
  fullName: System.IO.UnmanagedMemoryStream.Capacity
- uid: System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: UnmanagedMemoryStream.Dispose(Boolean)
  fullName: System.IO.UnmanagedMemoryStream.Dispose(Boolean)
- uid: System.IO.UnmanagedMemoryStream.Flush
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Flush()
  nameWithType: UnmanagedMemoryStream.Flush()
  fullName: System.IO.UnmanagedMemoryStream.Flush()
- uid: System.IO.UnmanagedMemoryStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: UnmanagedMemoryStream.FlushAsync(CancellationToken)
  fullName: System.IO.UnmanagedMemoryStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Initialize(Byte*,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.Initialize(Byte*,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.Initialize(Byte*,Int64,Int64,FileAccess)
- uid: System.IO.UnmanagedMemoryStream.Initialize(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Initialize(SafeBuffer,Int64,Int64,FileAccess)
  nameWithType: UnmanagedMemoryStream.Initialize(SafeBuffer,Int64,Int64,FileAccess)
  fullName: System.IO.UnmanagedMemoryStream.Initialize(SafeBuffer,Int64,Int64,FileAccess)
- uid: System.IO.UnmanagedMemoryStream.Length
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Length
  nameWithType: UnmanagedMemoryStream.Length
  fullName: System.IO.UnmanagedMemoryStream.Length
- uid: System.IO.UnmanagedMemoryStream.Position
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Position
  nameWithType: UnmanagedMemoryStream.Position
  fullName: System.IO.UnmanagedMemoryStream.Position
- uid: System.IO.UnmanagedMemoryStream.PositionPointer
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: PositionPointer
  nameWithType: UnmanagedMemoryStream.PositionPointer
  fullName: System.IO.UnmanagedMemoryStream.PositionPointer
- uid: System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: UnmanagedMemoryStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.UnmanagedMemoryStream.Read(Byte[],Int32,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: UnmanagedMemoryStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.UnmanagedMemoryStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.Threading.Tasks.Task{System.Int32}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<Int32>
  nameWithType: Task<Int32>
  fullName: System.Threading.Tasks.Task<System.Int32>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Int32>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.UnmanagedMemoryStream.ReadByte
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: ReadByte()
  nameWithType: UnmanagedMemoryStream.ReadByte()
  fullName: System.IO.UnmanagedMemoryStream.ReadByte()
- uid: System.IO.UnmanagedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: UnmanagedMemoryStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.UnmanagedMemoryStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.IO.UnmanagedMemoryStream.SetLength(System.Int64)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: UnmanagedMemoryStream.SetLength(Int64)
  fullName: System.IO.UnmanagedMemoryStream.SetLength(Int64)
- uid: System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: UnmanagedMemoryStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.UnmanagedMemoryStream.Write(Byte[],Int32,Int32)
- uid: System.IO.UnmanagedMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: UnmanagedMemoryStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.UnmanagedMemoryStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: WriteByte(Byte)
  nameWithType: UnmanagedMemoryStream.WriteByte(Byte)
  fullName: System.IO.UnmanagedMemoryStream.WriteByte(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.IO.UnmanagedMemoryStream.#ctor*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: UnmanagedMemoryStream
  nameWithType: UnmanagedMemoryStream.UnmanagedMemoryStream
- uid: System.IO.UnmanagedMemoryStream.CanRead*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: CanRead
  nameWithType: UnmanagedMemoryStream.CanRead
- uid: System.IO.UnmanagedMemoryStream.CanSeek*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: CanSeek
  nameWithType: UnmanagedMemoryStream.CanSeek
- uid: System.IO.UnmanagedMemoryStream.CanWrite*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: CanWrite
  nameWithType: UnmanagedMemoryStream.CanWrite
- uid: System.IO.UnmanagedMemoryStream.Capacity*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Capacity
  nameWithType: UnmanagedMemoryStream.Capacity
- uid: System.IO.UnmanagedMemoryStream.Dispose*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Dispose
  nameWithType: UnmanagedMemoryStream.Dispose
- uid: System.IO.UnmanagedMemoryStream.Flush*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Flush
  nameWithType: UnmanagedMemoryStream.Flush
- uid: System.IO.UnmanagedMemoryStream.FlushAsync*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: FlushAsync
  nameWithType: UnmanagedMemoryStream.FlushAsync
- uid: System.IO.UnmanagedMemoryStream.Initialize*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Initialize
  nameWithType: UnmanagedMemoryStream.Initialize
- uid: System.IO.UnmanagedMemoryStream.Length*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Length
  nameWithType: UnmanagedMemoryStream.Length
- uid: System.IO.UnmanagedMemoryStream.Position*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Position
  nameWithType: UnmanagedMemoryStream.Position
- uid: System.IO.UnmanagedMemoryStream.PositionPointer*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: PositionPointer
  nameWithType: UnmanagedMemoryStream.PositionPointer
- uid: System.IO.UnmanagedMemoryStream.Read*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Read
  nameWithType: UnmanagedMemoryStream.Read
- uid: System.IO.UnmanagedMemoryStream.ReadAsync*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: ReadAsync
  nameWithType: UnmanagedMemoryStream.ReadAsync
- uid: System.IO.UnmanagedMemoryStream.ReadByte*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: ReadByte
  nameWithType: UnmanagedMemoryStream.ReadByte
- uid: System.IO.UnmanagedMemoryStream.Seek*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Seek
  nameWithType: UnmanagedMemoryStream.Seek
- uid: System.IO.UnmanagedMemoryStream.SetLength*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: SetLength
  nameWithType: UnmanagedMemoryStream.SetLength
- uid: System.IO.UnmanagedMemoryStream.Write*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: Write
  nameWithType: UnmanagedMemoryStream.Write
- uid: System.IO.UnmanagedMemoryStream.WriteAsync*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: WriteAsync
  nameWithType: UnmanagedMemoryStream.WriteAsync
- uid: System.IO.UnmanagedMemoryStream.WriteByte*
  parent: System.IO.UnmanagedMemoryStream
  isExternal: false
  name: WriteByte
  nameWithType: UnmanagedMemoryStream.WriteByte
