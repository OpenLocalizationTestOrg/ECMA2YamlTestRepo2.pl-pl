### YamlMime:ManagedReference
items:
- uid: System.Windows.Media.Animation.Animatable
  id: Animatable
  children:
  - System.Windows.Media.Animation.Animatable.#ctor
  - System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  - System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  - System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.Media.Animation.Animatable.Clone
  - System.Windows.Media.Animation.Animatable.FreezeCore(System.Boolean)
  - System.Windows.Media.Animation.Animatable.GetAnimationBaseValue(System.Windows.DependencyProperty)
  - System.Windows.Media.Animation.Animatable.HasAnimatedProperties
  - System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference(System.Windows.DependencyObject)
  langs:
  - csharp
  name: Animatable
  nameWithType: Animatable
  fullName: System.Windows.Media.Animation.Animatable
  type: Class
  summary: "Klasa abstrakcyjna, która zapewnia obsługę animacji."
  syntax:
    content: 'public abstract class Animatable : System.Windows.Freezable, System.Windows.Media.Animation.IAnimatable'
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  - System.Windows.DependencyObject
  - System.Windows.Freezable
  implements:
  - System.Windows.Media.Animation.IAnimatable
  inheritedMembers:
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.DependencyObjectType
  - System.Windows.DependencyObject.Equals(System.Object)
  - System.Windows.DependencyObject.GetHashCode
  - System.Windows.DependencyObject.GetLocalValueEnumerator
  - System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.IsSealed
  - System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)
  - System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)
  - System.Windows.Freezable.CanFreeze
  - System.Windows.Freezable.Changed
  - System.Windows.Freezable.CloneCore(System.Windows.Freezable)
  - System.Windows.Freezable.CloneCurrentValue
  - System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)
  - System.Windows.Freezable.CreateInstance
  - System.Windows.Freezable.CreateInstanceCore
  - System.Windows.Freezable.Freeze
  - System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)
  - System.Windows.Freezable.GetAsFrozen
  - System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)
  - System.Windows.Freezable.GetCurrentValueAsFrozen
  - System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)
  - System.Windows.Freezable.IsFrozen
  - System.Windows.Freezable.OnChanged
  - System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)
  - System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)
  - System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.Freezable.ReadPreamble
  - System.Windows.Freezable.WritePostscript
  - System.Windows.Freezable.WritePreamble
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  platform:
  - net462
- uid: System.Windows.Media.Animation.Animatable.#ctor
  id: '#ctor'
  parent: System.Windows.Media.Animation.Animatable
  langs:
  - csharp
  name: Animatable()
  nameWithType: Animatable.Animatable()
  fullName: System.Windows.Media.Animation.Animatable.Animatable()
  type: Constructor
  assemblies:
  - PresentationCore
  namespace: System.Windows.Media.Animation
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Windows.Media.Animation.Animatable&quot;> </xref> klasy."
  syntax:
    content: protected Animatable ();
    parameters: []
  overload: System.Windows.Media.Animation.Animatable.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  id: ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  parent: System.Windows.Media.Animation.Animatable
  langs:
  - csharp
  name: ApplyAnimationClock(DependencyProperty,AnimationClock)
  nameWithType: Animatable.ApplyAnimationClock(DependencyProperty,AnimationClock)
  fullName: System.Windows.Media.Animation.Animatable.ApplyAnimationClock(DependencyProperty,AnimationClock)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Media.Animation
  summary: "Stosuje <xref href=&quot;System.Windows.Media.Animation.AnimationClock&quot;> </xref> do określonego <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>. Jeśli właściwość jest już animowany, <xref href=&quot;System.Windows.Media.Animation.HandoffBehavior&quot;> </xref> przekazaniem zachowanie jest używany."
  remarks: "Należy pamiętać, że usunięcie zegary z właściwością przy użyciu tej metody nie zatrzymuje tych zegary."
  syntax:
    content: public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "Właściwość animacji."
    - id: clock
      type: System.Windows.Media.Animation.AnimationClock
      description: "Zegara, z którą ma zostać animować określonej właściwości. Jeśli `clock` jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, wszystkie animacje zostaną usunięte z określonej właściwości (ale nie zatrzymać)."
  overload: System.Windows.Media.Animation.Animatable.ApplyAnimationClock*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  id: ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.Media.Animation.Animatable
  langs:
  - csharp
  name: ApplyAnimationClock(DependencyProperty,AnimationClock,HandoffBehavior)
  nameWithType: Animatable.ApplyAnimationClock(DependencyProperty,AnimationClock,HandoffBehavior)
  fullName: System.Windows.Media.Animation.Animatable.ApplyAnimationClock(DependencyProperty,AnimationClock,HandoffBehavior)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Media.Animation
  summary: "Stosuje <xref href=&quot;System.Windows.Media.Animation.AnimationClock&quot;> </xref> do określonego <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>. Jeśli właściwość jest już animowany, określony <xref href=&quot;System.Windows.Media.Animation.HandoffBehavior&quot;> </xref> jest używany."
  remarks: "Należy pamiętać, że za pomocą tej metody, aby usunąć z właściwości zegary nie zatrzymuje tych zegary.      ## Przy użyciu tworzą HandoffBehavior przy zastosowaniu <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock>je przy użyciu właściwości <xref:System.Windows.Media.Animation.HandoffBehavior> <xref:System.Windows.Media.Animation.HandoffBehavior>oraz <xref:System.Windows.Media.Animation.Clock>obiekty wcześniej skojarzone z tą właściwością nadal zużywają zasoby systemowe; system chronometrażu nie spowoduje usunięcia zegary automatycznie.</xref:System.Windows.Media.Animation.Clock> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.AnimationTimeline> </xref:System.Windows.Media.Animation.Storyboard>       Aby uniknąć problemów z wydajnością podczas stosowania dużej liczby zegary przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior>, tworzenie zegary należy usunąć z właściwości animowany po ich zakończeniu.</xref:System.Windows.Media.Animation.HandoffBehavior> Istnieje kilka sposobów, aby usunąć zegara.      -Aby usunąć wszystkie zegary z właściwością, użyj <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>metoda obiektu animowany.</xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> </xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> Określ właściwość animowanej jako pierwszego parametru oraz `null` jako drugiego. Spowoduje to usunięcie wszystkich zegary animacji z właściwości.      -Aby usunąć określonego <xref:System.Windows.Media.Animation.AnimationClock>z listy zegary, użyj <xref:System.Windows.Media.Animation.Clock.Controller%2A>właściwości <xref:System.Windows.Media.Animation.AnimationClock>do pobrania <xref:System.Windows.Media.Animation.ClockController>następnie wywołaj <xref:System.Windows.Media.Animation.ClockController.Remove%2A>metodę <xref:System.Windows.Media.Animation.ClockController>.</xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.ClockController.Remove%2A> </xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.AnimationClock> Jest to zazwyczaj wykonywane <xref:System.Windows.Media.Animation.Clock.Completed>programu obsługi zdarzeń dla obiektu clock.</xref:System.Windows.Media.Animation.Clock.Completed> Należy pamiętać, że tylko zegary głównego mogą być kontrolowane przez <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A>zwróci właściwości zegara podrzędnych `null`.</xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.ClockController> Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed>zdarzenie nie zostanie wywołany, jeśli efektywny czas trwania zegar jest nieskończoność.</xref:System.Windows.Media.Animation.Clock.Completed>  W takim przypadku użytkownik musi określić, kiedy wywołać metodę <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</xref:System.Windows.Media.Animation.ClockController.Remove%2A>       To przede wszystkim problemu dla animacji na obiektach, które mają długi okres istnienia.  Gdy obiekt jest bezużytecznych, jego zegary również zostanie rozłączona i w ramach odzyskiwania pamięci.       Aby uzyskać więcej informacji o obiektach zegara, zobacz [animacji i Przegląd systemu chronometrażu](~/add/includes/ajax-current-ext-md.md)."
  example:
  - The following example shows how to apply animation clocks using different <xref:System.Windows.Media.Animation.HandoffBehavior> settings.
  syntax:
    content: public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "Właściwość animacji."
    - id: clock
      type: System.Windows.Media.Animation.AnimationClock
      description: "Zegara, z którą ma zostać animować określonej właściwości. Jeśli `handoffBehavior` jest <xref href=&quot;System.Windows.Media.Animation.HandoffBehavior&quot;> </xref> i `clock` jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, wszystkie animacje zostaną usunięte z określonej właściwości (ale nie zatrzymać). Jeśli `handoffBehavior` jest <xref href=&quot;System.Windows.Media.Animation.HandoffBehavior&quot;> </xref> i zegarem <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, ta metoda nie ma wpływu."
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "Wartość, która określa nowe animacji powinien interakcję z dowolne animacje bieżącego już wpływu na wartość właściwości."
  overload: System.Windows.Media.Animation.Animatable.ApplyAnimationClock*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  id: BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  parent: System.Windows.Media.Animation.Animatable
  langs:
  - csharp
  name: BeginAnimation(DependencyProperty,AnimationTimeline)
  nameWithType: Animatable.BeginAnimation(DependencyProperty,AnimationTimeline)
  fullName: System.Windows.Media.Animation.Animatable.BeginAnimation(DependencyProperty,AnimationTimeline)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Media.Animation
  summary: "Powoduje zastosowanie animacji do określonego <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>. Animacja została uruchomiona podczas renderowania następnej ramki. Jeśli określona właściwość jest już animowany, <xref href=&quot;System.Windows.Media.Animation.HandoffBehavior&quot;> </xref> przekazaniem zachowanie jest używany."
  remarks: "Jeśli animacja ma <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>większą niż zero, po upływie tego przedziału czasu od chwili renderowania następnej ramki rozpoczęcia animacji.</xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>"
  syntax:
    content: public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "Właściwość animacji."
    - id: animation
      type: System.Windows.Media.Animation.AnimationTimeline
      description: "Animacja użyć do animowania określonej właściwości.       Jeśli animacji <xref:System.Windows.Media.Animation.Timeline.BeginTime*>jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, zostaną usunięte wszystkie bieżące animacji i będzie on wstrzymany bieżącej wartości właściwości.</xref:System.Windows.Media.Animation.Timeline.BeginTime*>       Jeśli `animation` jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, wszystkie animacje zostanie usunięta z właściwości i wartość właściwości zostanie przywrócona do jego wartości podstawowej."
  overload: System.Windows.Media.Animation.Animatable.BeginAnimation*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  id: BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.Media.Animation.Animatable
  langs:
  - csharp
  name: BeginAnimation(DependencyProperty,AnimationTimeline,HandoffBehavior)
  nameWithType: Animatable.BeginAnimation(DependencyProperty,AnimationTimeline,HandoffBehavior)
  fullName: System.Windows.Media.Animation.Animatable.BeginAnimation(DependencyProperty,AnimationTimeline,HandoffBehavior)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Media.Animation
  summary: "Powoduje zastosowanie animacji do określonego <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>. Animacja została uruchomiona podczas renderowania następnej ramki. Jeśli określona właściwość jest już animowany, określony <xref href=&quot;System.Windows.Media.Animation.HandoffBehavior&quot;> </xref> jest używany."
  remarks: "Jeśli animacja ma <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>większą niż zero, po upływie tego przedziału czasu od chwili renderowania następnej ramki rozpoczęcia animacji.</xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>      ## Przy użyciu tworzą HandoffBehavior przy zastosowaniu <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock>je przy użyciu właściwości <xref:System.Windows.Media.Animation.HandoffBehavior> <xref:System.Windows.Media.Animation.HandoffBehavior>oraz <xref:System.Windows.Media.Animation.Clock>obiekty wcześniej skojarzone z tą właściwością nadal zużywają zasoby systemowe; system chronometrażu nie spowoduje usunięcia zegary automatycznie.</xref:System.Windows.Media.Animation.Clock> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.AnimationTimeline> </xref:System.Windows.Media.Animation.Storyboard>       Aby uniknąć problemów z wydajnością podczas stosowania dużej liczby zegary przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior>, tworzenie zegary należy usunąć z właściwości animowany po ich zakończeniu.</xref:System.Windows.Media.Animation.HandoffBehavior> Istnieje kilka sposobów, aby usunąć zegara.      -Aby usunąć wszystkie zegary z właściwością, użyj <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>metoda obiektu animowany.</xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> </xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> Określ właściwość animowanej jako pierwszego parametru oraz `null` jako drugiego. Spowoduje to usunięcie wszystkich zegary animacji z właściwości.      -Aby usunąć określonego <xref:System.Windows.Media.Animation.AnimationClock>z listy zegary, użyj <xref:System.Windows.Media.Animation.Clock.Controller%2A>właściwości <xref:System.Windows.Media.Animation.AnimationClock>do pobrania <xref:System.Windows.Media.Animation.ClockController>następnie wywołaj <xref:System.Windows.Media.Animation.ClockController.Remove%2A>metodę <xref:System.Windows.Media.Animation.ClockController>.</xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.ClockController.Remove%2A> </xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.AnimationClock> Jest to zazwyczaj wykonywane <xref:System.Windows.Media.Animation.Clock.Completed>programu obsługi zdarzeń dla obiektu clock.</xref:System.Windows.Media.Animation.Clock.Completed> Należy pamiętać, że tylko zegary głównego mogą być kontrolowane przez <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A>zwróci właściwości zegara podrzędnych `null`.</xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.ClockController> Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed>zdarzenie nie zostanie wywołany, jeśli efektywny czas trwania zegar jest nieskończoność.</xref:System.Windows.Media.Animation.Clock.Completed>  W takim przypadku użytkownik musi określić, kiedy wywołać metodę <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</xref:System.Windows.Media.Animation.ClockController.Remove%2A>       To przede wszystkim problemu dla animacji na obiektach, które mają długi okres istnienia.  Gdy obiekt jest bezużytecznych, jego zegary również zostanie rozłączona i w ramach odzyskiwania pamięci.       Aby uzyskać więcej informacji o obiektach zegara, zobacz [animacji i Przegląd systemu chronometrażu](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example shows how to apply animations using different <xref:System.Windows.Media.Animation.HandoffBehavior> settings.  \n  \n [!code-cpp[animateproperty#InteractiveAnimationExampleWholePage](~/add/codesnippet/cpp/animagionproperty_cpp/InteractiveExample.cpp#interactiveanimationexamplewholepage)]\n [!code-cs[animateproperty#InteractiveAnimationExampleWholePage](~/add/codesnippet/csharp/animateproperty_csharp/InteractiveExample.cs#interactiveanimationexamplewholepage)]\n [!code-vb[animateproperty#InteractiveAnimationExampleWholePage](~/add/codesnippet/visualbasic/animateproperty_vb/InteractiveExample.vb#interactiveanimationexamplewholepage)]"
  syntax:
    content: public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "Właściwość animacji."
    - id: animation
      type: System.Windows.Media.Animation.AnimationTimeline
      description: "Animacja użyć do animowania określonej właściwości.       Jeśli `handoffBehavior` jest <xref href=&quot;System.Windows.Media.Animation.HandoffBehavior&quot;> </xref> i animacji <> </> *> jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, zostaną usunięte wszystkie bieżące animacji i będzie on wstrzymany bieżącej wartości właściwości.       Jeśli `handoffBehavior` jest <xref href=&quot;System.Windows.Media.Animation.HandoffBehavior&quot;> </xref> i `animation` jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> odwołania, wszystkie animacje zostanie usunięta z właściwości i wartość właściwości zostanie przywrócona do jego wartości podstawowej.       Jeśli `handoffBehavior` jest <xref href=&quot;System.Windows.Media.Animation.HandoffBehavior&quot;> </xref>, ta metoda nie przyniesie efektu Jeśli animacji lub jego <> </> *> jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "Wartość, która określa nowe animacji powinien interakcję z dowolne animacje bieżącego już wpływu na wartość właściwości."
  overload: System.Windows.Media.Animation.Animatable.BeginAnimation*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Media.Animation.Animatable.Clone
  id: Clone
  parent: System.Windows.Media.Animation.Animatable
  langs:
  - csharp
  name: Clone()
  nameWithType: Animatable.Clone()
  fullName: System.Windows.Media.Animation.Animatable.Clone()
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Media.Animation
  summary: "Tworzy modyfikowalną klonu tego <xref href=&quot;System.Windows.Media.Animation.Animatable&quot;> </xref>, tworzenie bezpośrednich kopii wartości tego obiektu. Podczas kopiowania właściwości zależności tego obiektu, ta metoda umożliwia skopiowanie powiązania odwołań i dane zasobów, ale nie rozpoznają może ale animacje lub ich bieżącymi wartościami."
  remarks: "Metody Clone może służyć do tworzenia kopii można modyfikować zablokowane <xref:System.Windows.Freezable>obiektów.</xref:System.Windows.Freezable> Dla wygody, ta metoda zasłania dziedziczonego <xref:System.Windows.Freezable.Clone%2A>metodę w celu zapewnienia silnie typizowaną implementację.</xref:System.Windows.Freezable.Clone%2A>"
  syntax:
    content: public System.Windows.Media.Animation.Animatable Clone ();
    parameters: []
    return:
      type: System.Windows.Media.Animation.Animatable
      description: "Można modyfikować klonu tego wystąpienia. Zwrócony klon skutecznie jest głęboką kopię bieżącego obiektu. Klonu <> </> *> właściwość jest * *false**."
  overload: System.Windows.Media.Animation.Animatable.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Media.Animation.Animatable.FreezeCore(System.Boolean)
  id: FreezeCore(System.Boolean)
  parent: System.Windows.Media.Animation.Animatable
  langs:
  - csharp
  name: FreezeCore(Boolean)
  nameWithType: Animatable.FreezeCore(Boolean)
  fullName: System.Windows.Media.Animation.Animatable.FreezeCore(Boolean)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Media.Animation
  summary: "Sprawia to, że <xref href=&quot;System.Windows.Media.Animation.Animatable&quot;> </xref> obiektu unmodifiable lub określa, czy można go było unmodifiable."
  remarks: "Ta metoda zwróci **false** podczas <xref:System.Windows.Media.Animation.Animatable.HasAnimatedProperties%2A>jest **true**.</xref:System.Windows.Media.Animation.Animatable.HasAnimatedProperties%2A>       Nie wywołuj tej metody bezpośrednio (za wyjątkiem podczas wywoływania base w implementacji). Ta metoda jest wywoływana wewnętrznie przez <xref:System.Windows.Freezable.CanFreeze%2A>(z `isChecking` równa `true`) i <xref:System.Windows.Freezable.Freeze%2A>(z `isChecking` równa `false`).</xref:System.Windows.Freezable.Freeze%2A> </xref:System.Windows.Freezable.CanFreeze%2A>"
  syntax:
    content: protected override bool FreezeCore (bool isChecking);
    parameters:
    - id: isChecking
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli ta metoda po prostu określić, czy to wystąpienie może być zablokowana. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>Jeśli to wystąpienie faktycznie powinien zawieszać się się, gdy ta metoda jest wywoływana."
    return:
      type: System.Boolean
      description: "Jeśli <code> isChecking </code> jest <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, ta metoda zwraca <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> Jeśli <xref href=&quot;System.Windows.Media.Animation.Animatable&quot;> </xref> może się unmodifiable, lub <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> , jeśli nie można dokonać unmodifiable.       Jeśli <code> isChecking </code> jest <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>, ta metoda zwraca <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> Jeśli Jeżeli to <xref href=&quot;System.Windows.Media.Animation.Animatable&quot;> </xref> jest teraz unmodifiable, lub <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> , jeśli nie można dokonać unmodifiable z efektem ubocznym o uruchomione zmiany zablokowane stanu tego obiektu."
  overload: System.Windows.Media.Animation.Animatable.FreezeCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Media.Animation.Animatable.GetAnimationBaseValue(System.Windows.DependencyProperty)
  id: GetAnimationBaseValue(System.Windows.DependencyProperty)
  parent: System.Windows.Media.Animation.Animatable
  langs:
  - csharp
  name: GetAnimationBaseValue(DependencyProperty)
  nameWithType: Animatable.GetAnimationBaseValue(DependencyProperty)
  fullName: System.Windows.Media.Animation.Animatable.GetAnimationBaseValue(DependencyProperty)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Media.Animation
  summary: "Zwraca wartość animowany określonego <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>."
  remarks: "Jeśli określona właściwość nie jest animowany, ta metoda zwraca takiego samego wyniku jako <xref:System.Windows.DependencyObject.GetValue%2A>.</xref:System.Windows.DependencyObject.GetValue%2A>"
  example:
  - "In the following example, the non-animated values of animated properties are retrieved and displayed.  \n  \n [!code-cs[timingbehaviors_procedural_snip#GetAnimationBaseValueExampleWholePage](~/add/codesnippet/csharp/TimingBehavior_csharp/GetAnimationBaseValueExample.cs#getanimationbasevalueexamplewholepage)]\n [!code-vb[timingbehaviors_procedural_snip#GetAnimationBaseValueExampleWholePage](~/add/codesnippet/visualbasic/timingbehavior_vb/getanimationbasevalueexample.vb#getanimationbasevalueexamplewholepage)]"
  syntax:
    content: public object GetAnimationBaseValue (System.Windows.DependencyProperty dp);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "Określa właściwość, której wartości podstawowej (z systemem innym niż animowane) powinny zostać pobrane."
    return:
      type: System.Object
      description: "Wartość, która będzie zwracany, jeśli określona właściwość nie zostały animowany."
  overload: System.Windows.Media.Animation.Animatable.GetAnimationBaseValue*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Media.Animation.Animatable.HasAnimatedProperties
  id: HasAnimatedProperties
  parent: System.Windows.Media.Animation.Animatable
  langs:
  - csharp
  name: HasAnimatedProperties
  nameWithType: Animatable.HasAnimatedProperties
  fullName: System.Windows.Media.Animation.Animatable.HasAnimatedProperties
  type: Property
  assemblies:
  - PresentationCore
  namespace: System.Windows.Media.Animation
  summary: "Pobiera wartość wskazującą, czy co najmniej jeden <xref href=&quot;System.Windows.Media.Animation.AnimationClock&quot;> </xref> obiektów jest skojarzona z żadną właściwości zależności tego obiektu."
  remarks: "Ta właściwość nie wskazuje, czy ten obiekt zawiera animowany obiektów podrzędnych."
  syntax:
    content: public bool HasAnimatedProperties { get; }
    return:
      type: System.Boolean
      description: '**true** if one or more <xref href="System.Windows.Media.Animation.AnimationClock"></xref> objects is associated with any of this object''s dependency properties; otherwise, **false**.'
  overload: System.Windows.Media.Animation.Animatable.HasAnimatedProperties*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference(System.Windows.DependencyObject)
  id: ShouldSerializeStoredWeakReference(System.Windows.DependencyObject)
  parent: System.Windows.Media.Animation.Animatable
  langs:
  - csharp
  name: ShouldSerializeStoredWeakReference(DependencyObject)
  nameWithType: Animatable.ShouldSerializeStoredWeakReference(DependencyObject)
  fullName: System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference(DependencyObject)
  type: Method
  assemblies:
  - PresentationCore
  namespace: System.Windows.Media.Animation
  summary: "Określa, czy powinien zostać Zserializowany obiekt zależności."
  remarks: "<xref:System.ComponentModel.TypeDescriptor>Klasy używa metody ShouldSerializeStoredWeakReference w celu określenia właściwości powinny być serializowane.</xref:System.ComponentModel.TypeDescriptor>"
  syntax:
    content: public static bool ShouldSerializeStoredWeakReference (System.Windows.DependencyObject target);
    parameters:
    - id: target
      type: System.Windows.DependencyObject
      description: "Reprezentuje obiekt, który uczestniczy w systemie właściwości zależności."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>to serialize <code>target</code>; otherwise, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>. Wartość domyślna to <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.Freezable
  isExternal: false
  name: System.Windows.Freezable
- uid: System.Windows.Media.Animation.Animatable.#ctor
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: Animatable()
  nameWithType: Animatable.Animatable()
  fullName: System.Windows.Media.Animation.Animatable.Animatable()
- uid: System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: ApplyAnimationClock(DependencyProperty,AnimationClock)
  nameWithType: Animatable.ApplyAnimationClock(DependencyProperty,AnimationClock)
  fullName: System.Windows.Media.Animation.Animatable.ApplyAnimationClock(DependencyProperty,AnimationClock)
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Windows.Media.Animation.AnimationClock
  parent: System.Windows.Media.Animation
  isExternal: false
  name: AnimationClock
  nameWithType: AnimationClock
  fullName: System.Windows.Media.Animation.AnimationClock
- uid: System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: ApplyAnimationClock(DependencyProperty,AnimationClock,HandoffBehavior)
  nameWithType: Animatable.ApplyAnimationClock(DependencyProperty,AnimationClock,HandoffBehavior)
  fullName: System.Windows.Media.Animation.Animatable.ApplyAnimationClock(DependencyProperty,AnimationClock,HandoffBehavior)
- uid: System.Windows.Media.Animation.HandoffBehavior
  parent: System.Windows.Media.Animation
  isExternal: false
  name: HandoffBehavior
  nameWithType: HandoffBehavior
  fullName: System.Windows.Media.Animation.HandoffBehavior
- uid: System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: BeginAnimation(DependencyProperty,AnimationTimeline)
  nameWithType: Animatable.BeginAnimation(DependencyProperty,AnimationTimeline)
  fullName: System.Windows.Media.Animation.Animatable.BeginAnimation(DependencyProperty,AnimationTimeline)
- uid: System.Windows.Media.Animation.AnimationTimeline
  parent: System.Windows.Media.Animation
  isExternal: false
  name: AnimationTimeline
  nameWithType: AnimationTimeline
  fullName: System.Windows.Media.Animation.AnimationTimeline
- uid: System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: BeginAnimation(DependencyProperty,AnimationTimeline,HandoffBehavior)
  nameWithType: Animatable.BeginAnimation(DependencyProperty,AnimationTimeline,HandoffBehavior)
  fullName: System.Windows.Media.Animation.Animatable.BeginAnimation(DependencyProperty,AnimationTimeline,HandoffBehavior)
- uid: System.Windows.Media.Animation.Animatable.Clone
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: Clone()
  nameWithType: Animatable.Clone()
  fullName: System.Windows.Media.Animation.Animatable.Clone()
- uid: System.Windows.Media.Animation.Animatable
  parent: System.Windows.Media.Animation
  isExternal: false
  name: Animatable
  nameWithType: Animatable
  fullName: System.Windows.Media.Animation.Animatable
- uid: System.Windows.Media.Animation.Animatable.FreezeCore(System.Boolean)
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: FreezeCore(Boolean)
  nameWithType: Animatable.FreezeCore(Boolean)
  fullName: System.Windows.Media.Animation.Animatable.FreezeCore(Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Media.Animation.Animatable.GetAnimationBaseValue(System.Windows.DependencyProperty)
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: GetAnimationBaseValue(DependencyProperty)
  nameWithType: Animatable.GetAnimationBaseValue(DependencyProperty)
  fullName: System.Windows.Media.Animation.Animatable.GetAnimationBaseValue(DependencyProperty)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.Media.Animation.Animatable.HasAnimatedProperties
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: HasAnimatedProperties
  nameWithType: Animatable.HasAnimatedProperties
  fullName: System.Windows.Media.Animation.Animatable.HasAnimatedProperties
- uid: System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference(System.Windows.DependencyObject)
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: ShouldSerializeStoredWeakReference(DependencyObject)
  nameWithType: Animatable.ShouldSerializeStoredWeakReference(DependencyObject)
  fullName: System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference(DependencyObject)
- uid: System.Windows.DependencyObject
  parent: System.Windows
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
- uid: System.Windows.Media.Animation.Animatable.#ctor*
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: Animatable
  nameWithType: Animatable.Animatable
- uid: System.Windows.Media.Animation.Animatable.ApplyAnimationClock*
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: ApplyAnimationClock
  nameWithType: Animatable.ApplyAnimationClock
- uid: System.Windows.Media.Animation.Animatable.BeginAnimation*
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: BeginAnimation
  nameWithType: Animatable.BeginAnimation
- uid: System.Windows.Media.Animation.Animatable.Clone*
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: Clone
  nameWithType: Animatable.Clone
- uid: System.Windows.Media.Animation.Animatable.FreezeCore*
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: FreezeCore
  nameWithType: Animatable.FreezeCore
- uid: System.Windows.Media.Animation.Animatable.GetAnimationBaseValue*
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: GetAnimationBaseValue
  nameWithType: Animatable.GetAnimationBaseValue
- uid: System.Windows.Media.Animation.Animatable.HasAnimatedProperties*
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: HasAnimatedProperties
  nameWithType: Animatable.HasAnimatedProperties
- uid: System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference*
  parent: System.Windows.Media.Animation.Animatable
  isExternal: false
  name: ShouldSerializeStoredWeakReference
  nameWithType: Animatable.ShouldSerializeStoredWeakReference
