### YamlMime:ManagedReference
items:
- uid: System.IO.Log.IRecordSequence
  id: IRecordSequence
  children:
  - System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.IRecordSequence.BaseSequenceNumber
  - System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.CreateReservationCollection
  - System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.Flush
  - System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.LastSequenceNumber
  - System.IO.Log.IRecordSequence.MaximumRecordLength
  - System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  - System.IO.Log.IRecordSequence.ReadRestartAreas
  - System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.IRecordSequence.ReservedBytes
  - System.IO.Log.IRecordSequence.RestartSequenceNumber
  - System.IO.Log.IRecordSequence.RetryAppend
  - System.IO.Log.IRecordSequence.TailPinned
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  langs:
  - csharp
  name: IRecordSequence
  nameWithType: IRecordSequence
  fullName: System.IO.Log.IRecordSequence
  type: Interface
  summary: "Udostępnia interfejs generyczny sekwencji rekordów."
  remarks: "Interfejs IRecordSequence interfejs abstrakcyjny strumień zorientowane na rekordy. Wystąpienie IRecordSequence może służyć do odczytu i zapisu rekordów dziennika.       Interfejs IRecordSequence zapewnia następujące możliwości - dołącza dziennika rekordów przy użyciu <xref:System.IO.Log.IRecordSequence.Append%2A>metody.</xref:System.IO.Log.IRecordSequence.Append%2A>      — Przeczytaj dołączane rekordy przy użyciu <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>metody.</xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>      -Zapisu ponownego uruchomienia specjalne rekordów przy użyciu <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>metody.</xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>      -Odczytu, uruchom ponownie rekordy z niedawno napisanych ponownego uruchomienia rekordów przy użyciu <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>metody.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>      -Zapisywanie rekordów do magazynu trwałego za pomocą <xref:System.IO.Log.IRecordSequence.Flush%2A>metody.</xref:System.IO.Log.IRecordSequence.Flush%2A>      -Zarezerwować miejsce na potrzeby dołączania rekordów.      — Dziennik wolne miejsce, zaawansowane base dziennika.      -Receive <xref:System.IO.Log.IRecordSequence.TailPinned>powiadomienia o zdarzeniach można przenieść base dziennika do wolnego miejsca.</xref:System.IO.Log.IRecordSequence.TailPinned>       Rekordy dziennika są dołączane do wystąpienia IRecordSequence, a każdy rekord dziennika otrzymuje unikatowy numer kolejny. W ramach sekwencji rekord ściśle monotonicznie coraz numerów sekwencji. Rekord dziennika składa się z nieprzezroczyste dane, do wystąpienia IRecordSequence w <xref:System.Collections.IList>z ArraySegments bajtów.</xref:System.Collections.IList>       Interfejs IRecordSequence udostępnia również kilka podstawowych właściwości, które zawiera informacje o granicach dziennika.      - <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>Właściwości zawiera numer sekwencji pierwszy rekord Nieprawidłowa sekwencja rekordów.</xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>      - <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>Właściwości zawiera numer sekwencji, który może być większa niż liczba sekwencji ostatniej dołączany rekordu.</xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>      - <xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A>Właściwości zawiera numer sekwencji ostatniej obszaru napisane ponownego uruchomienia.</xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A>      - <xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A>Właściwość zawiera rozmiar największego rekordu, które mogą być dołączane do lub odczytu z sekwencji.</xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A>      - <xref:System.IO.Log.IRecordSequence.ReservedBytes%2A>Właściwość zawiera łączny rozmiar wszystkich rezerwacji dokonanych w tej sekwencji rekordu.</xref:System.IO.Log.IRecordSequence.ReservedBytes%2A>      -Jeśli <xref:System.IO.Log.IRecordSequence.RetryAppend%2A>właściwość jest ustawiona na `true`i <xref:System.IO.Log.IRecordSequence.Append%2A>Operacja nie powiedzie się, ponieważ nie ma miejsca w sekwencji, sekwencja rekordów podejmie próbę wolnego miejsca i ponów próbę wykonania operacji dołączania.</xref:System.IO.Log.IRecordSequence.Append%2A> </xref:System.IO.Log.IRecordSequence.RetryAppend%2A>"
  syntax:
    content: 'public interface IRecordSequence : IDisposable'
  implements:
  - System.IDisposable
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  id: AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Przenosi do przodu numer sekwencji podstawowej dziennika."
  remarks: "Jeśli używasz <xref:System.IO.Log.LogRecordSequence>wystąpienie i spróbuj można poprawić numer sekwencyjny w celu zwolnienia miejsca w dzienniku nowy numer sekwencji podstawowy musi znajdować się w w zakresie różnych dziennika dla poprzedniego zakresu, może być oznaczony jako pusta.</xref:System.IO.Log.LogRecordSequence> Zwalnianie częściowo zakresów nie jest obsługiwane."
  syntax:
    content: public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Nowy numer sekwencji podstawowej sekwencja rekordów."
  overload: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSequenceNumber</code>jest nieprawidłowy."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSequenceNumber</code>nie jest aktywny w dzienniku."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas modyfikowania sekwencji."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów jest pełna."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej, zapisuje rekord dziennika <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.IRecordSequence.Flush%2A>metody.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji rekordu dziennika dołączany."
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas dołączania rekordu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów nie można utworzyć z wystarczającą ilością wolnego miejsca w celu uwzględnienia nowego rekordu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej, dołącza rekord dziennika <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.IRecordSequence.Flush%2A>metody.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji rekordu dziennika dołączany."
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas dołączania rekordu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów nie można utworzyć z wystarczającą ilością wolnego miejsca w celu uwzględnienia nowego rekordu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej, dołącza rekord dziennika <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>, przy użyciu wcześniej zastrzeżonej w sekwencji."
  remarks: "Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Dołączany rekordu będzie zajmować dużo miejsca, wcześniej zarezerwowanych, za pomocą rezerwacji, określony przez `reservations` parametru. Dołącz zakończy się powodzeniem, zużyje na najmniejszą obszaru rezerwacji, który przechowywania danych, a obszar rezerwacji zostanie usunięty z kolekcji.       Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.IRecordSequence.Flush%2A>metody.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> zawierający rezerwacji, które mają być używane dla tego rekordu."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji rekordu dziennika dołączany."
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas dołączania rekordu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów nie można utworzyć z wystarczającą ilością wolnego miejsca w celu uwzględnienia nowego rekordu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej, dołącza rekord dziennika <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>, przy użyciu wcześniej zastrzeżonej w sekwencji."
  remarks: "Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Dołączany rekordu będzie zajmować dużo miejsca, wcześniej zarezerwowanych, za pomocą rezerwacji, określony przez `reservations` parametru. Dołącz zakończy się powodzeniem, zużyje na najmniejszą obszaru rezerwacji, który przechowywania danych, a obszar rezerwacji zostanie usunięty z kolekcji.       Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.IRecordSequence.Flush%2A>metody.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> zawierający rezerwacji, które mają być używane dla tego rekordu."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji rekordu dziennika dołączany."
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas dołączania rekordu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów nie można utworzyć z wystarczającą ilością wolnego miejsca w celu uwzględnienia nowego rekordu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber
  id: BaseSequenceNumber
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BaseSequenceNumber
  nameWithType: IRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.IRecordSequence.BaseSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej pobiera numer sekwencji pierwszy rekord prawidłowe w bieżącym <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Prawidłowych numerów sekwencji jest większa niż lub równa BaseSequenceNumber i mniejsza niż <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.</xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>       Wartość tej właściwości można zmienić przez wywołanie metody <xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A>lub <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>metody.</xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> </xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "Najniższy numer sekwencji, umożliwiająca prawidłowy rekord w <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  overload: System.IO.Log.IRecordSequence.BaseSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Właściwość uzyskano po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się asynchroniczną operację dołączania."
  remarks: "Należy przekazać <xref:System.IAsyncResult>zwrócona przez tę metodę w celu <xref:System.IO.Log.IRecordSequence.EndAppend%2A>metodę, aby zapewnić, że ukończono operacji dołączania i zasobów można odpowiednio zwalniane.</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Jeśli wystąpił błąd podczas dołączania asynchroniczne, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.IRecordSequence.EndAppend%2A>Metoda jest wywoływana z <xref:System.IAsyncResult>zwracane przez tę metodę.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.IRecordSequence.Flush%2A>metody.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu dołączania."
    - id: state
      type: System.Object
      description: "Dostarczane przez użytkownika obiekt, który odróżni ten określonego asynchroniczne Dołącz żądań z innych żądań."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Reprezentujący Dołącz asynchroniczne mogą nadal oczekiwać.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas dołączania rekordu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów nie można utworzyć z wystarczającą ilością wolnego miejsca w celu uwzględnienia nowego rekordu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się asynchroniczną operację przy użyciu wcześniej zastrzeżonej w sekwencji dołączania."
  remarks: "Należy przekazać <xref:System.IAsyncResult>zwrócona przez tę metodę w celu <xref:System.IO.Log.IRecordSequence.EndAppend%2A>metodę, aby zapewnić, że ukończono operacji dołączania i zasobów można odpowiednio zwalniane.</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Jeśli wystąpił błąd podczas dołączania asynchroniczne, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.IRecordSequence.EndAppend%2A>Metoda jest wywoływana z <xref:System.IAsyncResult>zwracane przez tę metodę.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.IRecordSequence.Flush%2A>metody.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu dołączania."
    - id: state
      type: System.Object
      description: "Dostarczane przez użytkownika obiekt, który odróżni ten określonego asynchroniczne Dołącz żądań z innych żądań."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Reprezentujący Dołącz asynchroniczne mogą nadal oczekiwać.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas dołączania rekordu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów nie można utworzyć z wystarczającą ilością wolnego miejsca w celu uwzględnienia nowego rekordu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się asynchronicznego Dołącz operację przy użyciu wcześniej zastrzeżonej w sekwencji."
  remarks: "Należy przekazać <xref:System.IAsyncResult>zwrócona przez tę metodę w celu <xref:System.IO.Log.IRecordSequence.EndAppend%2A>metodę, aby zapewnić, że ukończono operacji dołączania i zasobów można odpowiednio zwalniane.</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Jeśli wystąpił błąd podczas dołączania asynchroniczne, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.IRecordSequence.EndAppend%2A>Metoda jest wywoływana z <xref:System.IAsyncResult>zwracane przez tę metodę.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Dołączany rekordu będzie zajmować dużo miejsca, wcześniej zarezerwowanych, za pomocą rezerwacji, określony przez `reservations` parametru. Dołącz zakończy się powodzeniem, zużyje na najmniejszą obszaru rezerwacji, który przechowywania danych, a obszar rezerwacji zostanie usunięty z kolekcji.       Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.IRecordSequence.Flush%2A>metody.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> zawierający rezerwacji, które mają być używane dla tego rekordu."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu dołączania."
    - id: state
      type: System.Object
      description: "Dostarczane przez użytkownika obiekt, który odróżni ten określonego asynchroniczne Dołącz żądań z innych żądań."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Reprezentujący Dołącz asynchroniczne mogą nadal oczekiwać.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas dołączania rekordu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów nie można utworzyć z wystarczającą ilością wolnego miejsca w celu uwzględnienia nowego rekordu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się asynchroniczną operację przy użyciu wcześniej zastrzeżonej w sekwencji dołączania."
  remarks: "Należy przekazać <xref:System.IAsyncResult>zwrócona przez tę metodę w celu <xref:System.IO.Log.IRecordSequence.EndAppend%2A>metodę, aby zapewnić, że ukończono operacji dołączania i zasobów można odpowiednio zwalniane.</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Jeśli wystąpił błąd podczas dołączania asynchroniczne, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.IRecordSequence.EndAppend%2A>Metoda jest wywoływana z <xref:System.IAsyncResult>zwracane przez tę metodę.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Dołączany rekordu będzie zajmować dużo miejsca, wcześniej zarezerwowanych, za pomocą rezerwacji, określony przez `reservations` parametru. Dołącz zakończy się powodzeniem, zużyje na najmniejszą obszaru rezerwacji, który przechowywania danych, a obszar rezerwacji zostanie usunięty z kolekcji.       Zwykle ta metoda kończy się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.IRecordSequence.Flush%2A>metody.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousUndoRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> zawierający rezerwacji, które mają być używane dla tego rekordu."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu dołączania."
    - id: state
      type: System.Object
      description: "Dostarczane przez użytkownika obiekt, który odróżni ten określonego asynchroniczne Dołącz żądań z innych żądań."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Reprezentujący Dołącz asynchroniczne mogą nadal oczekiwać.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas dołączania rekordu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów nie można utworzyć z wystarczającą ilością wolnego miejsca w celu uwzględnienia nowego rekordu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  id: BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej, rozpoczyna operację asynchroniczną opróżniania, przy użyciu wcześniej zastrzeżonej w sekwencji."
  remarks: "Należy przekazać <xref:System.IAsyncResult>zwróconych przez metodę bieżącego <xref:System.IO.Log.IRecordSequence.EndFlush%2A>metodę, aby zapewnić, że zakończeniu opróżniania i zasoby są zwalniane odpowiednio.</xref:System.IO.Log.IRecordSequence.EndFlush%2A> </xref:System.IAsyncResult> Jeśli wystąpi błąd podczas asynchronicznego opróżniania, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.IRecordSequence.EndFlush%2A>Metoda jest wywoływana z <xref:System.IAsyncResult>zwracane przez tę metodę.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndFlush%2A>       Wywołanie tej metody gwarantuje, że wszystkie rekordy, które zostały dołączone do <xref:System.IO.Log.IRecordSequence>trwałym są zapisywane.</xref:System.IO.Log.IRecordSequence>       Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchronicznego opróżniania, na przykład awaria dysku podczas wykonywania żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.IRecordSequence.EndFlush%2A>Metoda jest wywoływana.</xref:System.IO.Log.IRecordSequence.EndFlush%2A>"
  syntax:
    content: public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny najnowszego rekordu, który musi być napisana. Jeśli <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> jest nieprawidłowy, a następnie wszystkie rekordy muszą być zapisane."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu flush."
    - id: state
      type: System.Object
      description: "Obiekt dostarczane przez użytkownika, która odróżnia to asynchroniczne żądanie opróżniania od innych żądań."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Czy reprezentuje asynchroniczną opróżnić operacja, która może nadal oczekiwać.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas opróżniania danych."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej rozpoczyna się asynchroniczne rezerwy i Dołącz operacji."
  remarks: "Należy przekazać <xref:System.IAsyncResult>zwrócona przez tę metodę w celu <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>metodę, aby zapewnić, że ukończono operacji dołączania i zasobów można odpowiednio zwalniane.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> Jeśli wystąpił błąd podczas dołączania asynchroniczne, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>Metoda jest wywoływana z <xref:System.IAsyncResult>zwracane przez tę metodę.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>       Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Określony rezerwacji są dodawane podana rezerwacji operację dołączania kolekcji w niepodzielną operację z rekordu. W przypadku niepowodzenia Dołącz miejsce nie jest zarezerwowana.       Zwykle ta metoda może zakończyć się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.IRecordSequence.Flush%2A>metody.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>Metoda jest wywoływana.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "Kolekcja rezerwacji dokonanie rezerwacji w."
    - id: reservations
      type: System.Int64[]
      description: "Zastrzeżenia dokonanie w bajtach."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu dołączania."
    - id: state
      type: System.Object
      description: "Dostarczane przez użytkownika obiekt, który odróżni ten określonego asynchroniczne Dołącz żądań z innych żądań."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Reprezentujący operację asynchroniczną, która może być oczekujące.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas dołączania rekordu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów nie można utworzyć wystarczającej ilości wolnego miejsca na zawierają nowy rekord lub aby wprowadzić zastrzeżenie."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej rozpoczyna się asynchroniczne rezerwy i Dołącz operacji."
  remarks: "Należy przekazać <xref:System.IAsyncResult>zwrócona przez tę metodę w celu <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>metodę, aby zapewnić, że ukończono operacji dołączania i zasobów można odpowiednio zwalniane.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> Jeśli wystąpił błąd podczas dołączania asynchroniczne, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>Metoda jest wywoływana z <xref:System.IAsyncResult>zwracane przez tę metodę.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>       Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Określony rezerwacji są dodawane podana rezerwacji operację dołączania kolekcji w niepodzielną operację z rekordu. W przypadku niepowodzenia Dołącz miejsce nie jest zarezerwowana.       Zwykle ta metoda może zakończyć się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.IRecordSequence.Flush%2A>metody.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>Metoda jest wywoływana.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "Kolekcja rezerwacji dokonanie rezerwacji w."
    - id: reservations
      type: System.Int64[]
      description: "Zastrzeżenia dokonanie w bajtach."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu dołączania."
    - id: state
      type: System.Object
      description: "Dostarczane przez użytkownika obiekt, który odróżni ten określonego asynchroniczne Dołącz żądań z innych żądań."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Reprezentujący operację asynchroniczną, która może być oczekujące.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas dołączania rekordu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów nie można utworzyć wystarczającej ilości wolnego miejsca na zawierają nowy rekord lub aby wprowadzić zastrzeżenie."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się operacji zapisu obszaru asynchroniczne ponowne uruchomienie, przy użyciu wcześniej zastrzeżonej w sekwencji."
  remarks: "Należy przekazać <xref:System.IAsyncResult>zwrócona przez tę metodę w celu <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>metody, aby zapewnić, że operacja zapisu obszaru ponowne uruchomienie zostało ukończone i zasobów można odpowiednio zwalniane.</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> Jeśli wystąpił błąd podczas operacji zapisu obszaru asynchroniczne ponowne uruchomienie, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>Metoda jest wywoływana z <xref:System.IAsyncResult>zwracane przez tę metodę.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>       Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Po pomyślnym zakończeniu operacji numer sekwencyjny podstawowy został zaktualizowany. Rejestrowania wszystkich rekordów z numerami sekwencji mniej niż nowy numer sekwencji podstawowej są niedostępne.       Jeśli <xref:System.IO.Log.ReservationCollection>określono obszaru napisane ponownego uruchamiania będą korzystać z miejsca wcześniej zarezerwowanych, za pomocą rezerwacji zawartych w kolekcji.</xref:System.IO.Log.ReservationCollection> Jeśli metoda zakończy się powodzeniem, zużyje najmniejszą rezerwacji, który przechowywania danych, a rezerwacji zostanie usunięty z kolekcji.       Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>Metoda jest wywoływana.</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa bieżący numer sekwencyjny podstawowej."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> zawierający rezerwacji, które mają być używane dla tego obszaru ponownego uruchomienia."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu zapisu obszaru ponownego uruchomienia."
    - id: state
      type: System.Object
      description: "Obiekt dostarczane przez użytkownika, która odróżnia to żądanie zapisu obszaru określonego asynchroniczne ponownego uruchomienia od innych żądań."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Czy reprezentuje asynchroniczną ponownie uruchomić operację zapisu obszar, który można nadal oczekiwać.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginWriteRestartArea*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej, rozpoczyna się operacji zapisu obszaru asynchroniczne ponowne uruchomienie, przy użyciu wcześniej zastrzeżonej w sekwencji."
  remarks: "Należy przekazać <xref:System.IAsyncResult>zwrócona przez tę metodę w celu <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>metodę, aby zapewnić, że operacja zapisu obszaru ponowne uruchomienie zostało ukończone i zasobów można odpowiednio zwalniane.</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> Jeśli wystąpił błąd podczas operacji zapisu obszaru asynchroniczne ponowne uruchomienie, dopóki nie jest zgłaszany wyjątek <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>Metoda jest wywoływana z <xref:System.IAsyncResult>zwracane przez tę metodę.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>       Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Po pomyślnym zakończeniu operacji numer sekwencyjny podstawowy został zaktualizowany. Rejestrowania wszystkich rekordów z numerami sekwencji mniej niż nowy numer sekwencji podstawowej są niedostępne.       Jeśli <xref:System.IO.Log.ReservationCollection>określono obszaru napisane ponownego uruchamiania będą korzystać z miejsca wcześniej zarezerwowanych, za pomocą rezerwacji zawartych w kolekcji.</xref:System.IO.Log.ReservationCollection> Jeśli metoda zakończy się powodzeniem, zużyje najmniejszą rezerwacji, który przechowywania danych, a rezerwacji zostanie usunięty z kolekcji.       Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>Metoda jest wywoływana.</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa bieżący numer sekwencyjny podstawowej."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> zawierający rezerwacji, które mają być używane dla tego obszaru ponownego uruchomienia."
    - id: callback
      type: System.AsyncCallback
      description: "Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu zapisu obszaru ponownego uruchomienia."
    - id: state
      type: System.Object
      description: "Obiekt dostarczane przez użytkownika, która odróżnia to żądanie zapisu obszaru określonego asynchroniczne ponownego uruchomienia od innych żądań."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Czy reprezentuje asynchroniczną ponownie uruchomić operację zapisu obszar, który można nadal oczekiwać.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas zapisu obszaru ponownego uruchamiania."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów nie można utworzyć z wystarczającą ilością wolnego miejsca w celu uwzględnienia nowego rekordu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.CreateReservationCollection
  id: CreateReservationCollection
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: CreateReservationCollection()
  nameWithType: IRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.IRecordSequence.CreateReservationCollection()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej tworzy nowy <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>."
  syntax:
    content: public System.IO.Log.ReservationCollection CreateReservationCollection ();
    parameters: []
    return:
      type: System.IO.Log.ReservationCollection
      description: "Nowo utworzony <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>."
  overload: System.IO.Log.IRecordSequence.CreateReservationCollection*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)
  id: EndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej, operację dołączania kończy się asynchroniczne."
  remarks: "Ta metoda umożliwia blokowanie dopiero po ukończeniu operacji We/Wy. Błędów występujących podczas żądania asynchronicznego zapisu, takiej jak awaria dysku podczas wykonywania żądania We/Wy stają się widoczne, gdy jest wywoływana EndAppend.       Ta metoda musi zostać wywołana tylko raz w każdej <xref:System.IAsyncResult>zwrócony przez <xref:System.IO.Log.IRecordSequence.BeginAppend%2A>metody.</xref:System.IO.Log.IRecordSequence.BeginAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Odwołanie do oczekujących żądania asynchroniczne We/Wy."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji rekordu dziennika dołączany."
  overload: System.IO.Log.IRecordSequence.EndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)
  id: EndFlush(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndFlush(IAsyncResult)
  nameWithType: IRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndFlush(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej, kończy operację asynchroniczną opróżniania."
  remarks: "Ta metoda umożliwia blokowanie dopiero po ukończeniu operacji We/Wy. Błędów występujących podczas opróżniania żądania asynchronicznego, takiej jak awaria dysku podczas wykonywania żądania We/Wy stają się widoczne, gdy jest wywoływana EndFlush.       Ta metoda musi zostać wywołana tylko raz w każdej <xref:System.IAsyncResult>zwrócony przez <xref:System.IO.Log.IRecordSequence.BeginFlush%2A>metody.</xref:System.IO.Log.IRecordSequence.BeginFlush%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Odwołanie do oczekujących żądania asynchroniczne We/Wy."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji ostatni rekord zapisywane."
  overload: System.IO.Log.IRecordSequence.EndFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  id: EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndReserveAndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej, kończy się asynchroniczne rezerwowa i Dołącz operacji."
  remarks: "Ta metoda umożliwia blokowanie dopiero po ukończeniu operacji We/Wy. Błędów występujących podczas żądania asynchronicznego zapisu, takiej jak awaria dysku podczas wykonywania żądania We/Wy stają się widoczne, gdy jest wywoływana EndReserveAndAppend.       Ta metoda musi zostać wywołana tylko raz w każdej <xref:System.IAsyncResult>zwrócony przez <xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A>metody.</xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Odwołanie do oczekujących żądania asynchroniczne We/Wy."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji rekordu dziennika dołączany."
  overload: System.IO.Log.IRecordSequence.EndReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  id: EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: IRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndWriteRestartArea(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej, kończy operację zapisu obszaru asynchroniczne ponownego uruchomienia."
  remarks: "Ta metoda umożliwia blokowanie dopiero po ukończeniu operacji We/Wy. Błędów występujących podczas żądania asynchronicznego zapisu, takiej jak awaria dysku podczas wykonywania żądania We/Wy stają się widoczne, gdy jest wywoływana EndWriteRestartArea.       Ta metoda musi zostać wywołana tylko raz w każdej <xref:System.IAsyncResult>zwrócony przez <xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A>metody.</xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Odwołanie do oczekujących żądania asynchroniczne We/Wy."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji rekordu dziennika napisane."
  overload: System.IO.Log.IRecordSequence.EndWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Flush
  id: Flush
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Flush()
  nameWithType: IRecordSequence.Flush()
  fullName: System.IO.Log.IRecordSequence.Flush()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej zapewnia zapisano wszystkich dołączonych rekordów."
  remarks: "Wywołanie tej metody gwarantuje, że wszystkie rekordy, które zostały dołączone do <xref:System.IO.Log.IRecordSequence>trwale zapisano.</xref:System.IO.Log.IRecordSequence>"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush ();
    parameters: []
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji ostatni rekord zapisywane."
  overload: System.IO.Log.IRecordSequence.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas opróżniania danych."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)
  id: Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Flush(SequenceNumber)
  nameWithType: IRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.Flush(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej zapewnia, że dołączane rekordy, w tym rekord z określony numer sekwencji zostanie trwale zapisanych."
  remarks: "Wywołanie tej metody powoduje do liczby wszystkich rekordów z sekwencją i określony numer sekwencji, w tym trwale zapisano."
  syntax:
    content: public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny najnowszego rekordu, który musi być napisana. Jeśli <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> jest nieprawidłowy, a następnie wszystkie rekordy muszą być zapisane."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji ostatni rekord zapisywane."
  overload: System.IO.Log.IRecordSequence.Flush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas opróżniania danych."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.LastSequenceNumber
  id: LastSequenceNumber
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: LastSequenceNumber
  nameWithType: IRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.IRecordSequence.LastSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej pobiera numer sekwencji jest ona większa niż ostatni rekord dołączane."
  remarks: "Ta właściwość zawiera numer sekwencji, który może być większa niż liczba sekwencji ostatniej dołączany rekordu. Prawidłowych numerów sekwencji są większe niż lub równe <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>i mniejsza niż LastSequenceNumber.</xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>      > [!NOTE] > Podczas przy użyciu <xref:System.IO.Log.LogRecordSequence>wystąpienia, <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>wartość może stać się nieaktualne dopóki rekordy są opróżniane w dzienniku.</xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> </xref:System.IO.Log.LogRecordSequence> Zobacz <xref:System.IO.Log.IRecordSequence.Flush%2A>i <xref:System.IO.Log.RecordAppendOptions>uzyskać więcej informacji o opróżnianie rekordów.</xref:System.IO.Log.RecordAppendOptions> </xref:System.IO.Log.IRecordSequence.Flush%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji jest ona większa niż ostatni rekord dołączane."
  overload: System.IO.Log.IRecordSequence.LastSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Właściwość uzyskano po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.MaximumRecordLength
  id: MaximumRecordLength
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: MaximumRecordLength
  nameWithType: IRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.IRecordSequence.MaximumRecordLength
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej pobiera rozmiar największego rekordu, które mogą być dołączane do lub odczytu z tej sekwencji, w bajtach."
  syntax:
    content: public long MaximumRecordLength { get; }
    return:
      type: System.Int64
      description: "Rozmiar największego rekordu, które mogą być dołączane do lub odczytu z tej sekwencji, w bajtach."
  overload: System.IO.Log.IRecordSequence.MaximumRecordLength*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Właściwość uzyskano po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  id: ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej zwraca wyliczalny kolekcji rekordów w sekwencji."
  remarks: "W przypadku przesłonięcia w klasie pochodnej zwraca wyliczalny kolekcji rekordów w sekwencji. Kolejność wyliczany rekordów zależy od wartości `logRecordEnum` parametru."
  example:
  - "This sample demonstrates the use of the ReadLogRecords method.  \n  \n```c#  \nusing System;  \n using System.IO;  \n using System.IO.Log;  \n  \n class ReadRecordsSample  \n {  \n     static SequenceNumber AppendRecord(IRecordSequence sequence,  \n                                        string message,  \n                                        SequenceNumber user,  \n                                        SequenceNumber previous)  \n     {  \n         MemoryStream data = new MemoryStream();  \n         BinaryWriter writer = new BinaryWriter(data);  \n         writer.Write(message);  \n  \n         ArraySegment<byte>[] segments;  \n         segments = new ArraySegment<byte>[1];  \n         segments[0] = new ArraySegment(data.GetBuffer(),  \n                                        0,  \n                                        Data.Length);  \n  \n         return sequence.Append(segments,  \n                                user,  \n                                previous,  \n                                WriteFlags.None);  \n     }  \n  \n     public static void Main(string[] args)  \n     {  \n         IRecordSequence sequence;  \n         sequence = new FileIRecordSequence(args[0]);  \n  \n         SequenceNumber a, b, c, d;  \n  \n         a = AppendRecord(sequence,  \n                          \"This is record A\",  \n                          SequenceNumber.Invalid,  \n                          SequenceNumber.Invalid);  \n         Console.WriteLine(\"Record A has sequence number System.IO.Log\", a);  \n  \n         b = AppendRecord(sequence,  \n                          \"This is record B\",  \n                          a,  \n                          a);  \n         Console.WriteLine(\"Record B has sequence number System.IO.Log\", b);  \n  \n         c = AppendRecord(sequence,  \n                          \"This is record C\",  \n                          a,  \n                          a);  \n         Console.WriteLine(\"Record C has sequence number System.IO.Log\", c);  \n  \n         d = AppendRecord(sequence,  \n                          \"This is record D\",  \n                          b,  \n                          c);  \n         Console.WriteLine(\"Record D has sequence number System.IO.Log\", d);  \n  \n         foreach(LogRecord record in  \n                 sequence.ReadLogRecords(a, ReadDirection.Forward))  \n         {  \n             BinaryReader reader = new BinaryReader(record.Data);  \n             Console.WriteLine(\"System.IO.Log: T:System.IO.Log.IRecordSequence\",  \n                               record.SequenceNumber,  \n                               reader.ReadString());  \n         }  \n  \n         foreach(LogRecord record in  \n                 sequence.ReadLogRecords(d, ReadDirection.User))  \n         {  \n             BinaryReader reader = new BinaryReader(record.Data);  \n             Console.WriteLine(\"System.IO.Log: T:System.IO.Log.IRecordSequence\",  \n                               record.SequenceNumber,  \n                               reader.ReadString());  \n         }  \n  \n         foreach(LogRecord record in  \n                 sequence.ReadLogRecords(d, ReadDirection.Previous))  \n         {  \n             BinaryReader reader = new BinaryReader(record.Data);  \n             Console.WriteLine(\"System.IO.Log: T:System.IO.Log.IRecordSequence\",  \n                               record.SequenceNumber,  \n                               reader.ReadString());  \n         }  \n     }  \n       }  \n```"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);
    parameters:
    - id: start
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji pierwszy rekord, gdy rozpoczyna się odczyt."
    - id: logRecordEnum
      type: System.IO.Log.LogRecordEnumeratorType
      description: "Prawidłowy <xref href=&quot;System.IO.Log.LogRecordEnumeratorType&quot;> </xref> wartość, która określa sposób (to znaczy, do przodu lub wstecz), w którym rejestrowane są odczytywane z <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>."
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "Ustalony zbiór rekordów w sekwencji."
  overload: System.IO.Log.IRecordSequence.ReadLogRecords*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas odczytywania rekordu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReadRestartAreas
  id: ReadRestartAreas
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReadRestartAreas()
  nameWithType: IRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.IRecordSequence.ReadRestartAreas()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej zwraca wyliczalny kolekcji obszarów ponownego uruchomienia w sekwencji."
  remarks: "Obszarów ponownego uruchomienia są wymienione w kolejności odwrotnej kolejności, oznacza to, z najwyższym numerem najniższy numer sekwencyjny. Tylko ponownie obszarów z numerami sekwencji między ostatni numer sekwencji i numer sekwencyjny podstawowej są wyliczone.      > [!NOTE] > Jeśli dziennik zawierający zakres <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>staje się uszkodzony, ta metoda może zgłosić <xref:System.IO.IOException>z komunikatem o błędzie &quot;nie można wykonać żądania z powodu nieoczekiwanego wyjątku We/Wy.</xref:System.IO.IOException> </xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> Został zwrócony następujący kod błędu: &quot;80070026&quot; &quot;."
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadRestartAreas ();
    parameters: []
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "Wyliczalny kolekcja obszarów ponownego uruchomienia w sekwencji."
  overload: System.IO.Log.IRecordSequence.ReadRestartAreas*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas odczytywania rekordu."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej, automatycznie sprawia, że pojedynczy rezerwacji i dołącza rekordu do sekwencji."
  remarks: "Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Określony rezerwacji są dodawane podana rezerwacji operację dołączania kolekcji w niepodzielną operację z rekordu. W przypadku niepowodzenia Dołącz miejsce nie jest zarezerwowana.       Zwykle ta metoda może zakończyć się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.IRecordSequence.Flush%2A>metody.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> zawierający dokonanie rezerwacji w kolekcji."
    - id: reservations
      type: System.Int64[]
      description: "Zastrzeżenia dokonanie w bajtach."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji rekordu dziennika dołączany."
  overload: System.IO.Log.IRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas dołączania rekordu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów nie można utworzyć wystarczającej ilości wolnego miejsca na zawierają nowy rekord lub aby wprowadzić zastrzeżenie."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej, automatycznie sprawia, że pojedynczy rezerwacji i dołącza rekordu do sekwencji."
  remarks: "Dane zawarte w `data` parametr zostanie połączony tablicy bajtów pojedynczego dołączania jako rekord. Jednak nie dokonano do dzielenia danych do tablicy segmentów podczas odczytywania rekordu.       Określony rezerwacji są dodawane podana rezerwacji operację dołączania kolekcji w niepodzielną operację z rekordu. W przypadku niepowodzenia Dołącz miejsce nie jest zarezerwowana.       Zwykle ta metoda może zakończyć się przed rekord został zapisany. Aby upewnić się, że rekord został zapisany, albo określić <xref:System.IO.Log.RecordAppendOptions>Flaga przy użyciu `recordAppendOptions` parametr lub wywołanie <xref:System.IO.Log.IRecordSequence.Flush%2A>metody.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencyjny następnego rekordu w kolejności określonej przez użytkownika."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Następnego rekordu w kolejności poprzedni numer sekwencji."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Nieprawidłowa wartość <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> określający, jak mają być zapisywane dane."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "Kolekcja rezerwacji dokonanie rezerwacji w."
    - id: reservations
      type: System.Int64[]
      description: "Zastrzeżenia dokonanie w bajtach."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji rekordu dziennika dołączany."
  overload: System.IO.Log.IRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas dołączania rekordu."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów nie można utworzyć wystarczającej ilości wolnego miejsca na zawierają nowy rekord lub aby wprowadzić zastrzeżenie."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReservedBytes
  id: ReservedBytes
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReservedBytes
  nameWithType: IRecordSequence.ReservedBytes
  fullName: System.IO.Log.IRecordSequence.ReservedBytes
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej pobiera całkowita liczba bajtów, które zostały zarezerwowane."
  syntax:
    content: public long ReservedBytes { get; }
    return:
      type: System.Int64
      description: "Całkowity rozmiar wszystkich rezerwacji dokonanych w tej sekwencji rekordu."
  overload: System.IO.Log.IRecordSequence.ReservedBytes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Właściwość uzyskano po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber
  id: RestartSequenceNumber
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: RestartSequenceNumber
  nameWithType: IRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.IRecordSequence.RestartSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej pobiera numer sekwencyjny niedawno napisanych obszaru ponownego uruchomienia."
  remarks: "Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Podczas odzyskiwania jest niezbędne, można przeanalizować obszaru ponownego uruchomienia, aby pobrać wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania."
  syntax:
    content: public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji najbardziej ostatnio zapisany ponownie obszar."
  overload: System.IO.Log.IRecordSequence.RestartSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Właściwość uzyskano po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.RetryAppend
  id: RetryAppend
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: RetryAppend
  nameWithType: IRecordSequence.RetryAppend
  fullName: System.IO.Log.IRecordSequence.RetryAppend
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Pobiera lub ustawia wartość wskazującą czy dołącza są automatycznie podjęta, jeśli dziennik jest zapełniony."
  remarks: "Jeśli wartość tej właściwości jest `true`i <xref:System.IO.Log.IRecordSequence.Append%2A>Wywołanie zakończy się niepowodzeniem, ponieważ nie ma wystarczającej ilości miejsca w sekwencji, sekwencja rekordów spróbuje wolnego miejsca, a następnie spróbuj ponownie Dołącz.</xref:System.IO.Log.IRecordSequence.Append%2A>"
  syntax:
    content: public bool RetryAppend { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli dołącza są automatycznie podjęta, jeśli dziennik jest zapełniony; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Wartość domyślna to <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.Log.IRecordSequence.RetryAppend*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Właściwość uzyskano po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.TailPinned
  id: TailPinned
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: TailPinned
  nameWithType: IRecordSequence.TailPinned
  fullName: System.IO.Log.IRecordSequence.TailPinned
  type: Event
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Występuje, gdy sekwencja rekordów Określa, że końcowego fragmentu musi zostać przeniesiona do przodu."
  remarks: "Mogą wyzwalać to zdarzenie, gdy sekwencja rekordów zabrakło miejsca. To zdarzenie jest wywoływane, tail sekwencji (to znaczy numer sekwencji podstawowej) jest przenoszony do przodu w celu zwolnienia miejsca."
  syntax:
    content: public event EventHandler<System.IO.Log.TailPinnedEventArgs> TailPinned;
    return:
      type: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  id: WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej, zapisuje obszar ponownego uruchomienia <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Typowe dziennika File System (CLFS) obsługuje dwa obszary, aby zagwarantować, że co najmniej jeden nieprawidłowy obszar jest zawsze dostępna po ponownym uruchomieniu. Podczas odzyskiwania jest niezbędne, CLFS odczytuje obszaru jego ponownego uruchomienia i wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania.       Obszar ponowne uruchomienie może zostać odczytany przy użyciu <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>metody.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Dane w segmentach tablicy bajtów zostaną połączone tablicy bajtów pojedynczego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów przeczytaniu obszaru ponownego uruchamiania."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji zapisany ponownie obszar."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas zapisu obszaru ponownego uruchamiania."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów nie można utworzyć wystarczającej ilości wolnego miejsca, aby zawierają nowy obszar ponownego uruchomienia."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej, zapisuje obszar ponownego uruchomienia <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Podczas odzyskiwania jest niezbędne, można przeanalizować obszaru ponownego uruchomienia, aby pobrać wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania. Obszar ponowne uruchomienie może zostać odczytany przy użyciu <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>metody.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Dane w segmentach tablicy bajtów zostaną połączone tablicy bajtów pojedynczego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów przeczytaniu obszaru ponownego uruchamiania."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji zapisany ponownie obszar."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas zapisu obszaru ponownego uruchamiania."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów nie można utworzyć wystarczającej ilości wolnego miejsca, aby zawierają nowy obszar ponownego uruchomienia."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej, zapisuje obszar ponownego uruchomienia <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref> i aktualizuje numer sekwencyjny podstawowej"
  remarks: "Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Podczas odzyskiwania jest niezbędne, można przeanalizować obszaru ponownego uruchomienia, aby pobrać wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania. Obszar ponowne uruchomienie może zostać odczytany przy użyciu <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>metody.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Gdy obszar ponownego uruchomienia zostanie zapisany, dane w segmentach tablicy typu byte są łączone tablicy bajtów pojedynczego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów przeczytaniu obszaru ponownego uruchamiania.       Po pomyślnym zakończeniu tej metody, numer sekwencyjny podstawowy został zaktualizowany. Rejestrowania wszystkich rekordów z numerami sekwencji mniej niż nowy numer sekwencji podstawowej są niedostępne."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa bieżący numer sekwencyjny podstawowej."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji zapisany ponownie obszar."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas zapisu obszaru ponownego uruchamiania."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów nie można utworzyć wystarczającej ilości wolnego miejsca, aby zawierają nowy obszar ponownego uruchomienia."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej, zapisuje obszar ponownego uruchomienia <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref> i aktualizuje numer sekwencyjny podstawowej."
  remarks: "Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Podczas odzyskiwania jest niezbędne, można przeanalizować obszaru ponownego uruchomienia, aby pobrać wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania. Obszar ponowne uruchomienie może zostać odczytany przy użyciu <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>metody.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Gdy obszar ponownego uruchomienia zostanie zapisany, dane w segmentach tablicy typu byte są łączone tablicy bajtów pojedynczego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów przeczytaniu obszaru ponownego uruchamiania.       Po pomyślnym zakończeniu tej metody, numer sekwencyjny podstawowy został zaktualizowany. Rejestrowania wszystkich rekordów z numerami sekwencji mniej niż nowy numer sekwencji podstawowej są niedostępne."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa bieżący numer sekwencyjny podstawowej."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji zapisany ponownie obszar."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas zapisu obszaru ponownego uruchamiania."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów nie można utworzyć wystarczającej ilości wolnego miejsca, aby zawierają nowy obszar ponownego uruchomienia."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej, zapisuje obszar ponownego uruchomienia <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref> za pomocą rezerwacji i aktualizuje numer sekwencyjny podstawowej"
  remarks: "Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Podczas odzyskiwania jest niezbędne, można przeanalizować obszaru ponownego uruchomienia, aby pobrać wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania. Obszar ponowne uruchomienie może zostać odczytany przy użyciu <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>metody.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Gdy obszar ponownego uruchomienia zostanie zapisany, dane w segmentach tablicy typu byte są łączone tablicy bajtów pojedynczego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów przeczytaniu obszaru ponownego uruchamiania.       Jeśli określono zastrzeżenie, obszar napisane ponownego uruchamiania będą korzystać z miejsca wcześniej zarezerwowanych, za pomocą rezerwacji zawartych w kolekcji. Jeśli metoda zakończy się powodzeniem, zużyje najmniejszą rezerwacji zawierające dane, a rezerwacji zostanie usunięty z kolekcji.       Po pomyślnym zakończeniu tej metody, numer sekwencyjny podstawowy został zaktualizowany. Rejestrowania wszystkich rekordów z numerami sekwencji mniej niż nowy numer sekwencji podstawowej są niedostępne.       Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>Metoda jest wywoływana.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa bieżący numer sekwencyjny podstawowej."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> zawierający rezerwacji, które mają być używane dla tego obszaru ponownego uruchomienia."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji zapisany ponownie obszar."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas zapisu obszaru ponownego uruchamiania."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów nie można utworzyć wystarczającej ilości wolnego miejsca, aby zawierają nowy obszar ponownego uruchomienia."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "W przypadku przesłonięcia w klasie pochodnej, zapisuje obszar ponownego uruchomienia <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref> za pomocą rezerwacji i aktualizuje numer sekwencyjny podstawowej."
  remarks: "Obszar ponownego uruchamiania służy do tymczasowego przechowywania informacji zawierających klienta Ostatnia operacja punktu kontrolnego. Podczas odzyskiwania jest niezbędne, można przeanalizować obszaru ponownego uruchomienia, aby pobrać wszystkich danych z ostatniej operacji punktu kontrolnego. Te dane inicjuje tabeli transakcji, tabeli stron z zanieczyszczeniu i Otwórz plik tabeli dzięki mogą być używane w procesie odzyskiwania. Obszar ponowne uruchomienie może zostać odczytany przy użyciu <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>metody.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Gdy obszar ponownego uruchomienia zostanie zapisany, dane w segmentach tablicy typu byte są łączone tablicy bajtów pojedynczego dołączania jako rekord. Nie dokonano do dzielenia danych do tablicy segmentów przeczytaniu obszaru ponownego uruchamiania.       Jeśli określono zastrzeżenie, obszar napisane ponownego uruchamiania będą korzystać z miejsca wcześniej zarezerwowanych, za pomocą rezerwacji zawartych w kolekcji. Jeśli metoda zakończy się powodzeniem, zużyje najmniejszą rezerwacji zawierające dane, a rezerwacji zostanie usunięty z kolekcji.       Po pomyślnym zakończeniu tej metody, numer sekwencyjny podstawowy został zaktualizowany. Rejestrowania wszystkich rekordów z numerami sekwencji mniej niż nowy numer sekwencji podstawowej są niedostępne.       Jeśli sekwencja rekordów został usunięty z lub Przekaż nieprawidłowy argument, są zgłaszane wyjątki od razu w ramach tej operacji. Błędy, które wystąpiły podczas żądania asynchroniczne append, na przykład awaria dysku podczas żądania We/Wy spowoduje wyjątki zgłaszane, gdy <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>Metoda jest wywoływana.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Lista segmentów tablicy bajtów, które zostaną połączone i dołączone jako rekord."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Nowy numer sekwencji podstawowej. Określony numer sekwencji musi być większa lub równa bieżący numer sekwencyjny podstawowej."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> zawierający rezerwacji, które mają być używane dla tego obszaru ponownego uruchomienia."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Numer sekwencji zapisany ponownie obszar."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Co najmniej jeden z argumentów jest nieprawidłowa."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd We/Wy podczas zapisu obszaru ponownego uruchamiania."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Sekwencja rekordów nie można utworzyć wystarczającej ilości wolnego miejsca, aby zawierają nowy obszar ponownego uruchomienia."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Metoda została wywołana po sekwencji został zlikwidowany."
  platform:
  - net462
references:
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
- uid: System.IO.Log.SequenceNumber
  parent: System.IO.Log
  isExternal: false
  name: SequenceNumber
  nameWithType: SequenceNumber
  fullName: System.IO.Log.SequenceNumber
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.ArraySegment{System.Byte}
  parent: System
  isExternal: true
  name: ArraySegment<Byte>
  nameWithType: ArraySegment<Byte>
  fullName: System.ArraySegment<System.Byte>
  spec.csharp:
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.RecordAppendOptions
  parent: System.IO.Log
  isExternal: false
  name: RecordAppendOptions
  nameWithType: RecordAppendOptions
  fullName: System.IO.Log.RecordAppendOptions
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
  parent: System.Collections.Generic
  isExternal: true
  name: IList<ArraySegment<Byte>>
  nameWithType: IList<ArraySegment<Byte>>
  fullName: System.Collections.Generic.IList<System.ArraySegment<System.Byte>>
  spec.csharp:
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: IList<System.ArraySegment<System.Byte>>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.ReservationCollection
  parent: System.IO.Log
  isExternal: false
  name: ReservationCollection
  nameWithType: ReservationCollection
  fullName: System.IO.Log.ReservationCollection
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: IRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.IRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.Int64[]
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64[]
  spec.csharp:
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: Int64[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.CreateReservationCollection
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: CreateReservationCollection()
  nameWithType: IRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.IRecordSequence.CreateReservationCollection()
- uid: System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndAppend(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndFlush(IAsyncResult)
  nameWithType: IRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndFlush(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndReserveAndAppend(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: IRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndWriteRestartArea(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.Flush
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Flush()
  nameWithType: IRecordSequence.Flush()
  fullName: System.IO.Log.IRecordSequence.Flush()
- uid: System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Flush(SequenceNumber)
  nameWithType: IRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.Flush(SequenceNumber)
- uid: System.IO.Log.IRecordSequence.LastSequenceNumber
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: IRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.IRecordSequence.LastSequenceNumber
- uid: System.IO.Log.IRecordSequence.MaximumRecordLength
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: IRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.IRecordSequence.MaximumRecordLength
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
- uid: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<LogRecord>
  nameWithType: IEnumerable<LogRecord>
  fullName: System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.IO.Log.LogRecord>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.LogRecord
    name: LogRecord
    nameWithType: LogRecord
    fullName: LogRecord
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordEnumeratorType
  parent: System.IO.Log
  isExternal: false
  name: LogRecordEnumeratorType
  nameWithType: LogRecordEnumeratorType
  fullName: System.IO.Log.LogRecordEnumeratorType
- uid: System.IO.Log.IRecordSequence.ReadRestartAreas
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadRestartAreas()
  nameWithType: IRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.IRecordSequence.ReadRestartAreas()
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.IRecordSequence.ReservedBytes
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: IRecordSequence.ReservedBytes
  fullName: System.IO.Log.IRecordSequence.ReservedBytes
- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: IRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.IRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.IRecordSequence.RetryAppend
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: IRecordSequence.RetryAppend
  fullName: System.IO.Log.IRecordSequence.RetryAppend
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.IRecordSequence.TailPinned
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: TailPinned
  nameWithType: IRecordSequence.TailPinned
  fullName: System.IO.Log.IRecordSequence.TailPinned
- uid: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<TailPinnedEventArgs>
  nameWithType: EventHandler<TailPinnedEventArgs>
  fullName: System.EventHandler<System.IO.Log.TailPinnedEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.IO.Log.TailPinnedEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.TailPinnedEventArgs
    name: TailPinnedEventArgs
    nameWithType: TailPinnedEventArgs
    fullName: TailPinnedEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber
  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber
- uid: System.IO.Log.IRecordSequence.Append*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append
  nameWithType: IRecordSequence.Append
- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: IRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.IRecordSequence.BeginAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend
  nameWithType: IRecordSequence.BeginAppend
- uid: System.IO.Log.IRecordSequence.BeginFlush*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginFlush
  nameWithType: IRecordSequence.BeginFlush
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginReserveAndAppend
  nameWithType: IRecordSequence.BeginReserveAndAppend
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginWriteRestartArea
  nameWithType: IRecordSequence.BeginWriteRestartArea
- uid: System.IO.Log.IRecordSequence.CreateReservationCollection*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: CreateReservationCollection
  nameWithType: IRecordSequence.CreateReservationCollection
- uid: System.IO.Log.IRecordSequence.EndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndAppend
  nameWithType: IRecordSequence.EndAppend
- uid: System.IO.Log.IRecordSequence.EndFlush*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndFlush
  nameWithType: IRecordSequence.EndFlush
- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndReserveAndAppend
  nameWithType: IRecordSequence.EndReserveAndAppend
- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndWriteRestartArea
  nameWithType: IRecordSequence.EndWriteRestartArea
- uid: System.IO.Log.IRecordSequence.Flush*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Flush
  nameWithType: IRecordSequence.Flush
- uid: System.IO.Log.IRecordSequence.LastSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: IRecordSequence.LastSequenceNumber
- uid: System.IO.Log.IRecordSequence.MaximumRecordLength*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: IRecordSequence.MaximumRecordLength
- uid: System.IO.Log.IRecordSequence.ReadLogRecords*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadLogRecords
  nameWithType: IRecordSequence.ReadLogRecords
- uid: System.IO.Log.IRecordSequence.ReadRestartAreas*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadRestartAreas
  nameWithType: IRecordSequence.ReadRestartAreas
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReserveAndAppend
  nameWithType: IRecordSequence.ReserveAndAppend
- uid: System.IO.Log.IRecordSequence.ReservedBytes*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: IRecordSequence.ReservedBytes
- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: IRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.IRecordSequence.RetryAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: IRecordSequence.RetryAppend
- uid: System.IO.Log.IRecordSequence.WriteRestartArea*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea
  nameWithType: IRecordSequence.WriteRestartArea
