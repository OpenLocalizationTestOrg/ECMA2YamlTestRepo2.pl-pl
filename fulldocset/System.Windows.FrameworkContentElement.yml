### YamlMime:ManagedReference
items:
- uid: System.Windows.FrameworkContentElement
  id: FrameworkContentElement
  children:
  - System.Windows.FrameworkContentElement.#ctor
  - System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)
  - System.Windows.FrameworkContentElement.BeginInit
  - System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  - System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  - System.Windows.FrameworkContentElement.BindingGroup
  - System.Windows.FrameworkContentElement.BindingGroupProperty
  - System.Windows.FrameworkContentElement.BringIntoView
  - System.Windows.FrameworkContentElement.ContextMenu
  - System.Windows.FrameworkContentElement.ContextMenuClosing
  - System.Windows.FrameworkContentElement.ContextMenuClosingEvent
  - System.Windows.FrameworkContentElement.ContextMenuOpening
  - System.Windows.FrameworkContentElement.ContextMenuOpeningEvent
  - System.Windows.FrameworkContentElement.ContextMenuProperty
  - System.Windows.FrameworkContentElement.Cursor
  - System.Windows.FrameworkContentElement.CursorProperty
  - System.Windows.FrameworkContentElement.DataContext
  - System.Windows.FrameworkContentElement.DataContextChanged
  - System.Windows.FrameworkContentElement.DataContextProperty
  - System.Windows.FrameworkContentElement.DefaultStyleKey
  - System.Windows.FrameworkContentElement.DefaultStyleKeyProperty
  - System.Windows.FrameworkContentElement.EndInit
  - System.Windows.FrameworkContentElement.FindName(System.String)
  - System.Windows.FrameworkContentElement.FindResource(System.Object)
  - System.Windows.FrameworkContentElement.FocusVisualStyle
  - System.Windows.FrameworkContentElement.FocusVisualStyleProperty
  - System.Windows.FrameworkContentElement.ForceCursor
  - System.Windows.FrameworkContentElement.ForceCursorProperty
  - System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)
  - System.Windows.FrameworkContentElement.GetUIParentCore
  - System.Windows.FrameworkContentElement.Initialized
  - System.Windows.FrameworkContentElement.InputScope
  - System.Windows.FrameworkContentElement.InputScopeProperty
  - System.Windows.FrameworkContentElement.IsInitialized
  - System.Windows.FrameworkContentElement.IsLoaded
  - System.Windows.FrameworkContentElement.Language
  - System.Windows.FrameworkContentElement.LanguageProperty
  - System.Windows.FrameworkContentElement.Loaded
  - System.Windows.FrameworkContentElement.LoadedEvent
  - System.Windows.FrameworkContentElement.LogicalChildren
  - System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)
  - System.Windows.FrameworkContentElement.Name
  - System.Windows.FrameworkContentElement.NameProperty
  - System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  - System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  - System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)
  - System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)
  - System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  - System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  - System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  - System.Windows.FrameworkContentElement.OverridesDefaultStyle
  - System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty
  - System.Windows.FrameworkContentElement.Parent
  - System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  - System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)
  - System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)
  - System.Windows.FrameworkContentElement.Resources
  - System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)
  - System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  - System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  - System.Windows.FrameworkContentElement.ShouldSerializeResources
  - System.Windows.FrameworkContentElement.ShouldSerializeStyle
  - System.Windows.FrameworkContentElement.SourceUpdated
  - System.Windows.FrameworkContentElement.Style
  - System.Windows.FrameworkContentElement.StyleProperty
  - System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  - System.Windows.FrameworkContentElement.Tag
  - System.Windows.FrameworkContentElement.TagProperty
  - System.Windows.FrameworkContentElement.TargetUpdated
  - System.Windows.FrameworkContentElement.TemplatedParent
  - System.Windows.FrameworkContentElement.ToolTip
  - System.Windows.FrameworkContentElement.ToolTipClosing
  - System.Windows.FrameworkContentElement.ToolTipClosingEvent
  - System.Windows.FrameworkContentElement.ToolTipOpening
  - System.Windows.FrameworkContentElement.ToolTipOpeningEvent
  - System.Windows.FrameworkContentElement.ToolTipProperty
  - System.Windows.FrameworkContentElement.TryFindResource(System.Object)
  - System.Windows.FrameworkContentElement.Unloaded
  - System.Windows.FrameworkContentElement.UnloadedEvent
  - System.Windows.FrameworkContentElement.UnregisterName(System.String)
  - System.Windows.FrameworkContentElement.UpdateDefaultStyle
  langs:
  - csharp
  name: FrameworkContentElement
  nameWithType: FrameworkContentElement
  fullName: System.Windows.FrameworkContentElement
  type: Class
  summary: "FrameworkContentElement jest implementacji poziomie struktury WPF i rozszerzenie <xref href=&quot;System.Windows.ContentElement&quot;> </xref> klasy podstawowej. FrameworkContentElement dodaje obsługę dodatkowych danych wejściowych [!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)] (w tym menu etykietki narzędzi i kontekst) scenorys, kontekst danych dla powiązania danych, Obsługa stylów i pomocnika drzewa logicznego [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]."
  remarks: "FrameworkContentElement jeszcze nie definiować własne sposób renderowania; instancji rzeczywiste FrameworkContentElement klasy w kod lub znacznik jest możliwe, ale nie wyświetla żadnego obrazu w [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] aplikacji [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]. Renderowanie logiki musi zapewniać klasy, które ma elementy podrzędne FrameworkContentElement jako część ich modelu zawartości lub klas pochodnych FrameworkContentElement.       Wiele takich samych równoleżnikami celowo FrameworkContentElement [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] jako <xref:System.Windows.FrameworkElement>.</xref:System.Windows.FrameworkElement> Uwaga, że niektóre [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] na <xref:System.Windows.FrameworkElement>nie mają odpowiednika FrameworkContentElement.</xref:System.Windows.FrameworkElement> Kilka <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] są funkcje, takie jak Geometria reprezentacja lub układ, które nie są istotne dla FrameworkContentElement.</xref:System.Windows.FrameworkElement>       Większość istniejących FrameworkContentElement klas pochodnych zostaną znalezione w <xref:System.Windows.Documents>przestrzeni nazw.</xref:System.Windows.Documents> Wiele z tych klas pochodnych implementować elementy modelu przepływu dokumentu. Niektórych klas pochodnych, takich jak <xref:System.Windows.Documents.Hyperlink>mają niektóre funkcje kontroli podobne, ale pochodzą od FrameworkContentElement w taki sposób, że elementy kontroli przypominającej nadal mogą uczestniczyć w modelu przepływu dokumentu.</xref:System.Windows.Documents.Hyperlink>"
  syntax:
    content: >-
      [System.Windows.Markup.RuntimeNameProperty("Name")]

      [System.Windows.Markup.UsableDuringInitialization(true)]

      [System.Windows.Markup.XmlLangProperty("Language")]

      [System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))]

      public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  - System.Windows.DependencyObject
  - System.Windows.ContentElement
  implements:
  - System.ComponentModel.ISupportInitialize
  - System.Windows.IFrameworkInputElement
  - System.Windows.Markup.IQueryAmbient
  inheritedMembers:
  - System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)
  - System.Windows.ContentElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)
  - System.Windows.ContentElement.AllowDrop
  - System.Windows.ContentElement.AllowDropProperty
  - System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  - System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.ContentElement.AreAnyTouchesCaptured
  - System.Windows.ContentElement.AreAnyTouchesCapturedProperty
  - System.Windows.ContentElement.AreAnyTouchesCapturedWithin
  - System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty
  - System.Windows.ContentElement.AreAnyTouchesDirectlyOver
  - System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty
  - System.Windows.ContentElement.AreAnyTouchesOver
  - System.Windows.ContentElement.AreAnyTouchesOverProperty
  - System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  - System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.ContentElement.CaptureMouse
  - System.Windows.ContentElement.CaptureStylus
  - System.Windows.ContentElement.CaptureTouch(System.Windows.Input.TouchDevice)
  - System.Windows.ContentElement.CommandBindings
  - System.Windows.ContentElement.DragEnter
  - System.Windows.ContentElement.DragEnterEvent
  - System.Windows.ContentElement.DragLeave
  - System.Windows.ContentElement.DragLeaveEvent
  - System.Windows.ContentElement.DragOver
  - System.Windows.ContentElement.DragOverEvent
  - System.Windows.ContentElement.Drop
  - System.Windows.ContentElement.DropEvent
  - System.Windows.ContentElement.Focus
  - System.Windows.ContentElement.Focusable
  - System.Windows.ContentElement.FocusableChanged
  - System.Windows.ContentElement.FocusableProperty
  - System.Windows.ContentElement.GetAnimationBaseValue(System.Windows.DependencyProperty)
  - System.Windows.ContentElement.GiveFeedback
  - System.Windows.ContentElement.GiveFeedbackEvent
  - System.Windows.ContentElement.GotFocus
  - System.Windows.ContentElement.GotFocusEvent
  - System.Windows.ContentElement.GotKeyboardFocus
  - System.Windows.ContentElement.GotKeyboardFocusEvent
  - System.Windows.ContentElement.GotMouseCapture
  - System.Windows.ContentElement.GotMouseCaptureEvent
  - System.Windows.ContentElement.GotStylusCapture
  - System.Windows.ContentElement.GotStylusCaptureEvent
  - System.Windows.ContentElement.GotTouchCapture
  - System.Windows.ContentElement.GotTouchCaptureEvent
  - System.Windows.ContentElement.HasAnimatedProperties
  - System.Windows.ContentElement.InputBindings
  - System.Windows.ContentElement.IsEnabled
  - System.Windows.ContentElement.IsEnabledChanged
  - System.Windows.ContentElement.IsEnabledCore
  - System.Windows.ContentElement.IsEnabledProperty
  - System.Windows.ContentElement.IsFocused
  - System.Windows.ContentElement.IsFocusedProperty
  - System.Windows.ContentElement.IsInputMethodEnabled
  - System.Windows.ContentElement.IsKeyboardFocused
  - System.Windows.ContentElement.IsKeyboardFocusedChanged
  - System.Windows.ContentElement.IsKeyboardFocusedProperty
  - System.Windows.ContentElement.IsKeyboardFocusWithin
  - System.Windows.ContentElement.IsKeyboardFocusWithinChanged
  - System.Windows.ContentElement.IsKeyboardFocusWithinProperty
  - System.Windows.ContentElement.IsMouseCaptured
  - System.Windows.ContentElement.IsMouseCapturedChanged
  - System.Windows.ContentElement.IsMouseCapturedProperty
  - System.Windows.ContentElement.IsMouseCaptureWithin
  - System.Windows.ContentElement.IsMouseCaptureWithinChanged
  - System.Windows.ContentElement.IsMouseCaptureWithinProperty
  - System.Windows.ContentElement.IsMouseDirectlyOver
  - System.Windows.ContentElement.IsMouseDirectlyOverChanged
  - System.Windows.ContentElement.IsMouseDirectlyOverProperty
  - System.Windows.ContentElement.IsMouseOver
  - System.Windows.ContentElement.IsMouseOverProperty
  - System.Windows.ContentElement.IsStylusCaptured
  - System.Windows.ContentElement.IsStylusCapturedChanged
  - System.Windows.ContentElement.IsStylusCapturedProperty
  - System.Windows.ContentElement.IsStylusCaptureWithin
  - System.Windows.ContentElement.IsStylusCaptureWithinChanged
  - System.Windows.ContentElement.IsStylusCaptureWithinProperty
  - System.Windows.ContentElement.IsStylusDirectlyOver
  - System.Windows.ContentElement.IsStylusDirectlyOverChanged
  - System.Windows.ContentElement.IsStylusDirectlyOverProperty
  - System.Windows.ContentElement.IsStylusOver
  - System.Windows.ContentElement.IsStylusOverProperty
  - System.Windows.ContentElement.KeyDown
  - System.Windows.ContentElement.KeyDownEvent
  - System.Windows.ContentElement.KeyUp
  - System.Windows.ContentElement.KeyUpEvent
  - System.Windows.ContentElement.LostFocus
  - System.Windows.ContentElement.LostFocusEvent
  - System.Windows.ContentElement.LostKeyboardFocus
  - System.Windows.ContentElement.LostKeyboardFocusEvent
  - System.Windows.ContentElement.LostMouseCapture
  - System.Windows.ContentElement.LostMouseCaptureEvent
  - System.Windows.ContentElement.LostStylusCapture
  - System.Windows.ContentElement.LostStylusCaptureEvent
  - System.Windows.ContentElement.LostTouchCapture
  - System.Windows.ContentElement.LostTouchCaptureEvent
  - System.Windows.ContentElement.MouseDown
  - System.Windows.ContentElement.MouseDownEvent
  - System.Windows.ContentElement.MouseEnter
  - System.Windows.ContentElement.MouseEnterEvent
  - System.Windows.ContentElement.MouseLeave
  - System.Windows.ContentElement.MouseLeaveEvent
  - System.Windows.ContentElement.MouseLeftButtonDown
  - System.Windows.ContentElement.MouseLeftButtonDownEvent
  - System.Windows.ContentElement.MouseLeftButtonUp
  - System.Windows.ContentElement.MouseLeftButtonUpEvent
  - System.Windows.ContentElement.MouseMove
  - System.Windows.ContentElement.MouseMoveEvent
  - System.Windows.ContentElement.MouseRightButtonDown
  - System.Windows.ContentElement.MouseRightButtonDownEvent
  - System.Windows.ContentElement.MouseRightButtonUp
  - System.Windows.ContentElement.MouseRightButtonUpEvent
  - System.Windows.ContentElement.MouseUp
  - System.Windows.ContentElement.MouseUpEvent
  - System.Windows.ContentElement.MouseWheel
  - System.Windows.ContentElement.MouseWheelEvent
  - System.Windows.ContentElement.OnCreateAutomationPeer
  - System.Windows.ContentElement.OnDragEnter(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnDragLeave(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnDragOver(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnDrop(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.ContentElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.ContentElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.ContentElement.OnKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.ContentElement.OnLostFocus(System.Windows.RoutedEventArgs)
  - System.Windows.ContentElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.ContentElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.ContentElement.OnPreviewDragEnter(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnPreviewDragLeave(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnPreviewDragOver(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnPreviewDrop(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.ContentElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.ContentElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.ContentElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.ContentElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.ContentElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.ContentElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)
  - System.Windows.ContentElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.ContentElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.ContentElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.ContentElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.ContentElement.OnStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.ContentElement.OnTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.PreviewDragEnter
  - System.Windows.ContentElement.PreviewDragEnterEvent
  - System.Windows.ContentElement.PreviewDragLeave
  - System.Windows.ContentElement.PreviewDragLeaveEvent
  - System.Windows.ContentElement.PreviewDragOver
  - System.Windows.ContentElement.PreviewDragOverEvent
  - System.Windows.ContentElement.PreviewDrop
  - System.Windows.ContentElement.PreviewDropEvent
  - System.Windows.ContentElement.PreviewGiveFeedback
  - System.Windows.ContentElement.PreviewGiveFeedbackEvent
  - System.Windows.ContentElement.PreviewGotKeyboardFocus
  - System.Windows.ContentElement.PreviewGotKeyboardFocusEvent
  - System.Windows.ContentElement.PreviewKeyDown
  - System.Windows.ContentElement.PreviewKeyDownEvent
  - System.Windows.ContentElement.PreviewKeyUp
  - System.Windows.ContentElement.PreviewKeyUpEvent
  - System.Windows.ContentElement.PreviewLostKeyboardFocus
  - System.Windows.ContentElement.PreviewLostKeyboardFocusEvent
  - System.Windows.ContentElement.PreviewMouseDown
  - System.Windows.ContentElement.PreviewMouseDownEvent
  - System.Windows.ContentElement.PreviewMouseLeftButtonDown
  - System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent
  - System.Windows.ContentElement.PreviewMouseLeftButtonUp
  - System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent
  - System.Windows.ContentElement.PreviewMouseMove
  - System.Windows.ContentElement.PreviewMouseMoveEvent
  - System.Windows.ContentElement.PreviewMouseRightButtonDown
  - System.Windows.ContentElement.PreviewMouseRightButtonDownEvent
  - System.Windows.ContentElement.PreviewMouseRightButtonUp
  - System.Windows.ContentElement.PreviewMouseRightButtonUpEvent
  - System.Windows.ContentElement.PreviewMouseUp
  - System.Windows.ContentElement.PreviewMouseUpEvent
  - System.Windows.ContentElement.PreviewMouseWheel
  - System.Windows.ContentElement.PreviewMouseWheelEvent
  - System.Windows.ContentElement.PreviewQueryContinueDrag
  - System.Windows.ContentElement.PreviewQueryContinueDragEvent
  - System.Windows.ContentElement.PreviewStylusButtonDown
  - System.Windows.ContentElement.PreviewStylusButtonDownEvent
  - System.Windows.ContentElement.PreviewStylusButtonUp
  - System.Windows.ContentElement.PreviewStylusButtonUpEvent
  - System.Windows.ContentElement.PreviewStylusDown
  - System.Windows.ContentElement.PreviewStylusDownEvent
  - System.Windows.ContentElement.PreviewStylusInAirMove
  - System.Windows.ContentElement.PreviewStylusInAirMoveEvent
  - System.Windows.ContentElement.PreviewStylusInRange
  - System.Windows.ContentElement.PreviewStylusInRangeEvent
  - System.Windows.ContentElement.PreviewStylusMove
  - System.Windows.ContentElement.PreviewStylusMoveEvent
  - System.Windows.ContentElement.PreviewStylusOutOfRange
  - System.Windows.ContentElement.PreviewStylusOutOfRangeEvent
  - System.Windows.ContentElement.PreviewStylusSystemGesture
  - System.Windows.ContentElement.PreviewStylusSystemGestureEvent
  - System.Windows.ContentElement.PreviewStylusUp
  - System.Windows.ContentElement.PreviewStylusUpEvent
  - System.Windows.ContentElement.PreviewTextInput
  - System.Windows.ContentElement.PreviewTextInputEvent
  - System.Windows.ContentElement.PreviewTouchDown
  - System.Windows.ContentElement.PreviewTouchDownEvent
  - System.Windows.ContentElement.PreviewTouchMove
  - System.Windows.ContentElement.PreviewTouchMoveEvent
  - System.Windows.ContentElement.PreviewTouchUp
  - System.Windows.ContentElement.PreviewTouchUpEvent
  - System.Windows.ContentElement.QueryContinueDrag
  - System.Windows.ContentElement.QueryContinueDragEvent
  - System.Windows.ContentElement.QueryCursor
  - System.Windows.ContentElement.QueryCursorEvent
  - System.Windows.ContentElement.RaiseEvent(System.Windows.RoutedEventArgs)
  - System.Windows.ContentElement.ReleaseAllTouchCaptures
  - System.Windows.ContentElement.ReleaseMouseCapture
  - System.Windows.ContentElement.ReleaseStylusCapture
  - System.Windows.ContentElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)
  - System.Windows.ContentElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.ContentElement.ShouldSerializeCommandBindings
  - System.Windows.ContentElement.ShouldSerializeInputBindings
  - System.Windows.ContentElement.StylusButtonDown
  - System.Windows.ContentElement.StylusButtonDownEvent
  - System.Windows.ContentElement.StylusButtonUp
  - System.Windows.ContentElement.StylusButtonUpEvent
  - System.Windows.ContentElement.StylusDown
  - System.Windows.ContentElement.StylusDownEvent
  - System.Windows.ContentElement.StylusEnter
  - System.Windows.ContentElement.StylusEnterEvent
  - System.Windows.ContentElement.StylusInAirMove
  - System.Windows.ContentElement.StylusInAirMoveEvent
  - System.Windows.ContentElement.StylusInRange
  - System.Windows.ContentElement.StylusInRangeEvent
  - System.Windows.ContentElement.StylusLeave
  - System.Windows.ContentElement.StylusLeaveEvent
  - System.Windows.ContentElement.StylusMove
  - System.Windows.ContentElement.StylusMoveEvent
  - System.Windows.ContentElement.StylusOutOfRange
  - System.Windows.ContentElement.StylusOutOfRangeEvent
  - System.Windows.ContentElement.StylusSystemGesture
  - System.Windows.ContentElement.StylusSystemGestureEvent
  - System.Windows.ContentElement.StylusUp
  - System.Windows.ContentElement.StylusUpEvent
  - System.Windows.ContentElement.TextInput
  - System.Windows.ContentElement.TextInputEvent
  - System.Windows.ContentElement.TouchDown
  - System.Windows.ContentElement.TouchDownEvent
  - System.Windows.ContentElement.TouchEnter
  - System.Windows.ContentElement.TouchEnterEvent
  - System.Windows.ContentElement.TouchesCaptured
  - System.Windows.ContentElement.TouchesCapturedWithin
  - System.Windows.ContentElement.TouchesDirectlyOver
  - System.Windows.ContentElement.TouchesOver
  - System.Windows.ContentElement.TouchLeave
  - System.Windows.ContentElement.TouchLeaveEvent
  - System.Windows.ContentElement.TouchMove
  - System.Windows.ContentElement.TouchMoveEvent
  - System.Windows.ContentElement.TouchUp
  - System.Windows.ContentElement.TouchUpEvent
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.DependencyObjectType
  - System.Windows.DependencyObject.Equals(System.Object)
  - System.Windows.DependencyObject.GetHashCode
  - System.Windows.DependencyObject.GetLocalValueEnumerator
  - System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.IsSealed
  - System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)
  - System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.#ctor
  id: '#ctor'
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: FrameworkContentElement()
  nameWithType: FrameworkContentElement.FrameworkContentElement()
  fullName: System.Windows.FrameworkContentElement.FrameworkContentElement()
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref> klasy."
  syntax:
    content: public FrameworkContentElement ();
    parameters: []
  overload: System.Windows.FrameworkContentElement.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)
  id: AddLogicalChild(System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: AddLogicalChild(Object)
  nameWithType: FrameworkContentElement.AddLogicalChild(Object)
  fullName: System.Windows.FrameworkContentElement.AddLogicalChild(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Dodaje podany element jako element podrzędny tego elementu."
  remarks: "Ta metoda może zgłosić wyjątek, jeśli wywołana w chwili, gdy drzewa logicznego jest on iterowane przez inny proces.       Większość <xref:System.Windows.FrameworkContentElement>pochodnej klasy Uwidacznianie dedykowanego kolekcje, które są odpowiedzialne za zawierania (na przykład <xref:System.Windows.Documents.Span.Inlines%2A>w klasie <xref:System.Windows.Documents.Span>; <xref:System.Windows.Documents.Section.Blocks%2A>na <xref:System.Windows.Documents.Section>klasy).</xref:System.Windows.Documents.Section> </xref:System.Windows.Documents.Section.Blocks%2A> </xref:System.Windows.Documents.Span> </xref:System.Windows.Documents.Span.Inlines%2A> </xref:System.Windows.FrameworkContentElement> Zazwyczaj można uniknąć konieczności modyfikowania drzewa logicznego bezpośrednio, jeśli pochodzi z tych klas zamiast tego. Praca z drzewa logicznego elementów zawartości jest bardziej zaawansowany scenariusz, które mogą wymagać specjalnych analizatora składni lub specjalistycznej <xref:System.Windows.FrameworkElement>działający jako renderowania elementu nadrzędnego (host zawartości).</xref:System.Windows.FrameworkElement>       Aby uzyskać więcej informacji o sposobie używania <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A>i AddLogicalChild, zobacz [drzewa WPF](~/add/includes/ajax-current-ext-md.md).</xref:System.Windows.FrameworkContentElement.LogicalChildren%2A>"
  syntax:
    content: protected void AddLogicalChild (object child);
    parameters:
    - id: child
      type: System.Object
      description: "Element podrzędny, która ma zostać dodana."
  overload: System.Windows.FrameworkContentElement.AddLogicalChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BeginInit
  id: BeginInit
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BeginInit()
  nameWithType: FrameworkContentElement.BeginInit()
  fullName: System.Windows.FrameworkContentElement.BeginInit()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Wywołuje się przed zainicjowaniem elementu."
  syntax:
    content: public virtual void BeginInit ();
    parameters: []
  overload: System.Windows.FrameworkContentElement.BeginInit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Rozpoczyna się sekwencję akcji uwzględnionych w podanych scenorysu."
  remarks: "W przypadku podpisów, które nie korzystają z `isControllable`, parametr, lub gdy został określony parametr parametru `false`, zegary osi czasu skojarzone z nią zostaną usunięte natychmiast po osiągnięciu okresu &quot;Fill&quot;. W związku z tym animacji nie może zostać uruchomiony ponownie po raz uruchomione. Należy pamiętać, że animacja kontrolowanie również wymaga, aby scenorysu nazwanych lub dostępne w momencie wystąpienia w kodzie."
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "Scenorysu, aby rozpocząć."
  overload: System.Windows.FrameworkContentElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard,HandoffBehavior)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Rozpoczyna się Sekwencja akcji, które są zawarte w podanych scenorysu, z opcjami dla co ma nastąpić, jeśli właściwość jest już animowany."
  remarks: "W przypadku podpisów, które nie korzystają z `isControllable`, parametr, lub gdy został określony parametr parametru `false`, zegary osi czasu skojarzone z nią zostaną usunięte natychmiast po osiągnięciu okresu &quot;Fill&quot;. W związku z tym animacji nie może zostać uruchomiony ponownie po raz uruchomione. Należy pamiętać, że animacja kontrolowanie również wymaga, aby scenorysu nazwanych lub dostępne w momencie wystąpienia w kodzie.      ## Przy użyciu tworzą HandoffBehavior przy zastosowaniu <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock>Właściwości przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior> <xref:System.Windows.Media.Animation.HandoffBehavior>oraz <xref:System.Windows.Media.Animation.Clock>obiekty wcześniej skojarzone z tą właściwością nadal zużywają zasoby systemowe; system chronometrażu nie usuwa automatycznie zegary.</xref:System.Windows.Media.Animation.Clock> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.AnimationTimeline> </xref:System.Windows.Media.Animation.Storyboard>       Aby uniknąć problemów z wydajnością, podczas stosowania dużej liczby zegary za pomocą <xref:System.Windows.Media.Animation.HandoffBehavior>, tworzenie zegary należy usunąć z właściwości animowany po ich zakończeniu.</xref:System.Windows.Media.Animation.HandoffBehavior> Istnieje kilka sposobów, aby usunąć zegar: - Aby usunąć wszystkie zegary z właściwością, użyj <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>metoda obiektu animowany.</xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> </xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> Określ właściwość animowanej jako pierwszego parametru oraz `null` jako drugiego. Spowoduje to usunięcie wszystkich zegary animacji z właściwości.      -Aby usunąć określonego <xref:System.Windows.Media.Animation.AnimationClock>z listy zegary, użyj <xref:System.Windows.Media.Animation.Clock.Controller%2A>właściwości <xref:System.Windows.Media.Animation.AnimationClock>do pobrania <xref:System.Windows.Media.Animation.ClockController>następnie wywołaj <xref:System.Windows.Media.Animation.ClockController.Remove%2A>metodę <xref:System.Windows.Media.Animation.ClockController>.</xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.ClockController.Remove%2A> </xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.AnimationClock> Jest to zazwyczaj wykonywane <xref:System.Windows.Media.Animation.Clock.Completed>programu obsługi zdarzeń dla obiektu clock.</xref:System.Windows.Media.Animation.Clock.Completed> Należy pamiętać, że tylko zegary głównego mogą być kontrolowane przez <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A>Właściwość zegara podrzędnych zwraca `null`.</xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.ClockController> Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed>zdarzenie nie jest wywoływane, jeśli efektywny czas trwania zegar jest nieskończoność.</xref:System.Windows.Media.Animation.Clock.Completed>  W takim przypadku użytkownik musi ustalić, kiedy wywołać metodę <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</xref:System.Windows.Media.Animation.ClockController.Remove%2A>       To przede wszystkim problemu dla animacji na obiektach, które mają długi okres istnienia.  Gdy obiekt jest bezużytecznych, jego zegary również są odłączone i w ramach odzyskiwania pamięci.       Aby uzyskać więcej informacji o obiektach zegara, zobacz [animacji i Przegląd systemu chronometrażu](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "Scenorysu, aby rozpocząć."
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "Wartość wyliczenia opisujący zachowanie do użycia, jeśli właściwość opisanego w scenorysu jest już animowany."
  overload: System.Windows.FrameworkContentElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Rozpoczyna się sekwencję akcji uwzględnionych w podanych scenorysu, o określonym stanie dla formantu animacji po jej uruchomieniu."
  remarks: "W przypadku podpisów, które nie korzystają z `isControllable`, parametr, lub gdy został określony parametr parametru `false`, zegary osi czasu skojarzone z nią zostaną usunięte natychmiast po osiągnięciu okresu &quot;Fill&quot;. W związku z tym animacji nie może zostać uruchomiony ponownie po raz uruchomione. Należy pamiętać, że animacja kontrolowanie również wymaga, aby scenorysu nazwanych lub dostępne w momencie wystąpienia w kodzie.      ## Przy użyciu tworzą HandoffBehavior przy zastosowaniu <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, lub <xref:System.Windows.Media.Animation.AnimationClock>Właściwości przy użyciu <xref:System.Windows.Media.Animation.HandoffBehavior> <xref:System.Windows.Media.Animation.HandoffBehavior>oraz <xref:System.Windows.Media.Animation.Clock>obiekty wcześniej skojarzone z tą właściwością nadal zużywają zasoby systemowe; system chronometrażu nie usuwa automatycznie zegary.</xref:System.Windows.Media.Animation.Clock> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.AnimationTimeline> </xref:System.Windows.Media.Animation.Storyboard>       Aby uniknąć problemów z wydajnością, podczas stosowania dużej liczby zegary za pomocą <xref:System.Windows.Media.Animation.HandoffBehavior>, tworzenie zegary należy usunąć z właściwości animowany po ich zakończeniu.</xref:System.Windows.Media.Animation.HandoffBehavior> Istnieje kilka sposobów, aby usunąć zegar: - Aby usunąć wszystkie zegary z właściwością, użyj <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>lub <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>metoda obiektu animowany.</xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> </xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> Określ właściwość animowanej jako pierwszego parametru oraz `null` jako drugiego. Spowoduje to usunięcie wszystkich zegary animacji z właściwości.      -Aby usunąć określonego <xref:System.Windows.Media.Animation.AnimationClock>z listy zegary, użyj <xref:System.Windows.Media.Animation.Clock.Controller%2A>właściwości <xref:System.Windows.Media.Animation.AnimationClock>do pobrania <xref:System.Windows.Media.Animation.ClockController>następnie wywołaj <xref:System.Windows.Media.Animation.ClockController.Remove%2A>metodę <xref:System.Windows.Media.Animation.ClockController>.</xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.ClockController.Remove%2A> </xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.AnimationClock> Jest to zazwyczaj wykonywane <xref:System.Windows.Media.Animation.Clock.Completed>programu obsługi zdarzeń dla obiektu clock.</xref:System.Windows.Media.Animation.Clock.Completed> Należy pamiętać, że tylko zegary głównego mogą być kontrolowane przez <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A>Właściwość zegara podrzędnych zwraca `null`.</xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.ClockController> Należy zauważyć, że <xref:System.Windows.Media.Animation.Clock.Completed>zdarzenie nie jest wywoływane, jeśli efektywny czas trwania zegar jest nieskończoność.</xref:System.Windows.Media.Animation.Clock.Completed>  W takim przypadku użytkownik musi ustalić, kiedy wywołać metodę <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</xref:System.Windows.Media.Animation.ClockController.Remove%2A>       To przede wszystkim problemu dla animacji na obiektach, które mają długi okres istnienia.  Gdy obiekt jest bezużytecznych, jego zegary również są odłączone i w ramach odzyskiwania pamięci.       Aby uzyskać więcej informacji o obiektach zegara, zobacz [animacji i Przegląd systemu chronometrażu](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "Scenorysu, aby rozpocząć."
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "Wartość wyliczenia opisujący zachowanie do użycia, jeśli właściwość opisanego w scenorysu jest już animowany."
    - id: isControllable
      type: System.Boolean
      description: "Deklaruje, czy animacja jest kontrolowane (może być wstrzymane) po jej uruchomieniu."
  overload: System.Windows.FrameworkContentElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BindingGroup
  id: BindingGroup
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BindingGroup
  nameWithType: FrameworkContentElement.BindingGroup
  fullName: System.Windows.FrameworkContentElement.BindingGroup
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Pobiera lub ustawia <xref href=&quot;System.Windows.Data.BindingGroup&quot;> </xref> używany dla elementu."
  remarks: "A <xref:System.Windows.Data.BindingGroup>może służyć do sprawdzania poprawności wartości wielu właściwości obiektu.</xref:System.Windows.Data.BindingGroup> Załóżmy na przykład, że aplikacja monituje użytkownika o podanie adresu i wypełnienie klasy obiektu typu `Address`, który zawiera właściwości `Street`, `City`, `ZipCode`, i `Country`, wartościami, których użytkownik podał. Aplikacja ma panelu, który zawiera cztery <xref:System.Windows.Controls.TextBox>formantów, z których każdy jest powiązany z jedną z właściwości obiektu.</xref:System.Windows.Controls.TextBox> Można użyć <xref:System.Windows.Controls.ValidationRule>w <xref:System.Windows.Data.BindingGroup>do sprawdzania poprawności `Address` obiektu.</xref:System.Windows.Data.BindingGroup> </xref:System.Windows.Controls.ValidationRule> Na przykład <xref:System.Windows.Controls.ValidationRule>można zapewnić, że kod pocztowy jest prawidłowy dla kraju adresu.</xref:System.Windows.Controls.ValidationRule>       Elementy podrzędne dziedziczą <xref:System.Windows.Data.BindingGroup>z ich elementów nadrzędnych, po prostu tak jak w przypadku innych właściwości dziedziczonych.</xref:System.Windows.Data.BindingGroup>      <a name=&quot;dependencyPropertyInfo_BindingGroup&quot;></a>## Informacje dotyczące właściwości zależności |||   |-|-|   | Pole identyfikatora | <xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|   | Wartość właściwości metadanych **true**|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkContentElement.BindingGroupProperty>"
  syntax:
    content: public System.Windows.Data.BindingGroup BindingGroup { get; set; }
    return:
      type: System.Windows.Data.BindingGroup
      description: "<xref href=&quot;System.Windows.Data.BindingGroup&quot;> </xref> Używany dla elementu."
  overload: System.Windows.FrameworkContentElement.BindingGroup*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BindingGroupProperty
  id: BindingGroupProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BindingGroupProperty
  nameWithType: FrameworkContentElement.BindingGroupProperty
  fullName: System.Windows.FrameworkContentElement.BindingGroupProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identyfikuje <xref:System.Windows.FrameworkContentElement.BindingGroup*>Właściwości zależności.</xref:System.Windows.FrameworkContentElement.BindingGroup*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty BindingGroupProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BringIntoView
  id: BringIntoView
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BringIntoView()
  nameWithType: FrameworkContentElement.BringIntoView()
  fullName: System.Windows.FrameworkContentElement.BringIntoView()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Podejmuje próbę wprowadzenia tego elementu w widoku w ramach żadnych przewijanego regionów, który jest zawarty w."
  remarks: "Wywołując tę metodę można skutecznie wywoła <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>na wszelkie przewijany obszar nadrzędny, który zawiera element (element nadrzędny bardzo dobrze może być <xref:System.Windows.FrameworkElement>, a nie <xref:System.Windows.FrameworkContentElement>).</xref:System.Windows.FrameworkContentElement> </xref:System.Windows.FrameworkElement> </xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> Jeśli ten element nie jest zawarta w przewijany obszar, jest nadal zdarzenia, ale nie będzie żadnego skutku."
  syntax:
    content: public void BringIntoView ();
    parameters: []
  overload: System.Windows.FrameworkContentElement.BringIntoView*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenu
  id: ContextMenu
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenu
  nameWithType: FrameworkContentElement.ContextMenu
  fullName: System.Windows.FrameworkContentElement.ContextMenu
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Pobiera lub ustawia element menu kontekstowego, który powinien zostać wyświetlony każdorazowo zażądano za pomocą menu kontekstowego [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] z wewnątrz tego elementu."
  remarks: "<a name=&quot;dependencyPropertyInfo_ContextMenu&quot;></a>## Informacje dotyczące właściwości zależności |||   |-|-|   | Pole identyfikatora | <xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|   | Wartość właściwości metadanych `true`| None |</xref:System.Windows.FrameworkContentElement.ContextMenuProperty>"
  example:
  - "The following example places a <xref:System.Windows.Controls.ContextMenu> on a <xref:System.Windows.Documents.Paragraph>.  \n  \n [!code-xml[ContentElementsSmorgasbord#ContextMenu](~/add/codesnippet/xaml/ContentElementsSmorgasbord/page1.xaml#contextmenu)]"
  syntax:
    content: public System.Windows.Controls.ContextMenu ContextMenu { get; set; }
    return:
      type: System.Windows.Controls.ContextMenu
      description: "Menu kontekstowe, która używa tego elementu."
  overload: System.Windows.FrameworkContentElement.ContextMenu*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenuClosing
  id: ContextMenuClosing
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenuClosing
  nameWithType: FrameworkContentElement.ContextMenuClosing
  fullName: System.Windows.FrameworkContentElement.ContextMenuClosing
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Występuje zaraz przed zamknięciem dowolnego menu kontekstowego w elemencie."
  remarks: "Aby pominąć zamknięcia menu kontekstowe, programy obsługi zdarzenia należy oznaczyć go jako obsłużone.       Aby użyć tego zdarzenia jako <xref:System.Windows.EventTrigger>w stylu, musi odwoływać się podstawowy identyfikator zdarzenia usługi: [!code-xml [CorePseudocode #FEContextMenuClosing](~/add/codesnippet/xaml/CorePseudocode/pseudocode.xaml#fecontextmenuclosing) ] (to użycie jest konieczne, ponieważ implementacja zdarzeń na <xref:System.Windows.FrameworkContentElement>wyzwala czy ujawnia odpowiadające mu zdarzenie usługi nie jest poprawnie mapowany identyfikator ContextMenuClosing do użycia w).</xref:System.Windows.FrameworkContentElement> </xref:System.Windows.EventTrigger>      <a name=&quot;routedEventInfo_ContextMenuClosing&quot;></a>## Przesyłane informacje o zdarzeniach |||   |-|-|   | Pole identyfikatora | <xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|   | Strategii routingu | Propagacji |   | Delegat | <xref:System.Windows.Controls.ContextMenuEventHandler>|</xref:System.Windows.Controls.ContextMenuEventHandler></xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>"
  example:
  - "The following example implements a handler that changes the cursor over a named region `DisplayArea` (not shown). The comment hints at a <xref:System.Windows.UIElement> usage, but in fact this sample would be identical if `DisplayArea` were a <xref:System.Windows.FrameworkContentElement>.  \n  \n [!code-cs[cursors#ChangeCursorsSample](~/add/codesnippet/csharp/cursors/Window1.xaml.cs#changecursorssample)]\n [!code-vb[cursors#ChangeCursorsSample](~/add/codesnippet/visualbasic/cursors/Window1.xaml.vb#changecursorssample)]"
  syntax:
    content: public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;
    return:
      type: System.Windows.Controls.ContextMenuEventHandler
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenuClosingEvent
  id: ContextMenuClosingEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenuClosingEvent
  nameWithType: FrameworkContentElement.ContextMenuClosingEvent
  fullName: System.Windows.FrameworkContentElement.ContextMenuClosingEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identyfikuje <xref href=&quot;System.Windows.FrameworkContentElement.ContextMenuClosing&quot;> </xref> [kierowane Przegląd zdarzeń](~/add/includes/ajax-current-ext-md.md)."
  remarks: "Obiekty identyfikator zdarzenia są tworzone podczas kierowane zdarzenia są rejestrowane (zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>), a następnie można dodać obsługę klas (zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> Identyfikator obiekty zawierają nazwę identyfikującą, typ właściciela typ obsługi, strategii routingu i metodę narzędzia na potrzeby dodawania właścicieli dla zdarzenia."
  syntax:
    content: public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenuOpening
  id: ContextMenuOpening
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenuOpening
  nameWithType: FrameworkContentElement.ContextMenuOpening
  fullName: System.Windows.FrameworkContentElement.ContextMenuOpening
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Występuje po otwarciu dowolnego menu kontekstowego w elemencie."
  remarks: "Można ręcznie otworzyć menu kontekstowe, programy obsługi zdarzeń należy oznaczyć dane zdarzenie jako obsłużone. W przeciwnym razie wartość istniejących <xref:System.Windows.FrameworkContentElement.ContextMenu%2A>Właściwości będzie można użyć do automatycznego otwierania menu kontekstowego.</xref:System.Windows.FrameworkContentElement.ContextMenu%2A> Oznaczenie zdarzenia obsługiwane skutecznie spowoduje anulowanie domyślne działanie i może być możliwość Resetuj wartość <xref:System.Windows.FrameworkContentElement.ContextMenu%2A>Właściwości, a następnie otwórz nowe <xref:System.Windows.Controls.ContextMenu>.</xref:System.Windows.Controls.ContextMenu> </xref:System.Windows.FrameworkContentElement.ContextMenu%2A> Jednak jest to problem chronometrażu, które należy zwrócić uwagę. Aby całkowicie zastąpić menu kontekstowe do obsługi ContextMenuOpening, menu kontekstowe początkowy nie może być null / puste. Alternatywnie konieczne może być zdarzenie, a następnie ręcznie otworzyć nowego menu kontekstowego. Aby uzyskać więcej informacji, zobacz [porady: Obsługa zdarzenia ContextMenuOpening](~/add/includes/ajax-current-ext-md.md).       Aby użyć tego zdarzenia jako <xref:System.Windows.EventTrigger>w stylu, musi odwoływać się podstawowy identyfikator zdarzenia usługi: [!code-xml [CorePseudocode #FEContextMenuOpening](~/add/codesnippet/xaml/CorePseudocode/pseudocode.xaml#fecontextmenuopening) ] (to użycie jest konieczne, ponieważ implementacja zdarzeń na <xref:System.Windows.FrameworkContentElement>wyzwala czy ujawnia odpowiadające mu zdarzenie usługi nie jest poprawnie mapowany identyfikator ContextMenuOpening do użycia w).</xref:System.Windows.FrameworkContentElement> </xref:System.Windows.EventTrigger>      <a name=&quot;routedEventInfo_ContextMenuOpening&quot;></a>## Przesyłane informacje o zdarzeniach |||   |-|-|   | Pole identyfikatora | <xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|   | Strategii routingu | Propagacji |   | Delegat | <xref:System.Windows.Controls.ContextMenuEventHandler>|</xref:System.Windows.Controls.ContextMenuEventHandler></xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>"
  syntax:
    content: public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;
    return:
      type: System.Windows.Controls.ContextMenuEventHandler
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenuOpeningEvent
  id: ContextMenuOpeningEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenuOpeningEvent
  nameWithType: FrameworkContentElement.ContextMenuOpeningEvent
  fullName: System.Windows.FrameworkContentElement.ContextMenuOpeningEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identyfikuje <xref href=&quot;System.Windows.FrameworkContentElement.ContextMenuOpening&quot;> </xref> [kierowane Przegląd zdarzeń](~/add/includes/ajax-current-ext-md.md)."
  remarks: "Obiekty identyfikator zdarzenia są tworzone podczas kierowane zdarzenia są rejestrowane (zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>), a następnie można dodać obsługę klas (zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> Identyfikator obiekty zawierają nazwę identyfikującą, typ właściciela typ obsługi, strategii routingu i metodę narzędzia na potrzeby dodawania właścicieli dla zdarzenia."
  syntax:
    content: public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenuProperty
  id: ContextMenuProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenuProperty
  nameWithType: FrameworkContentElement.ContextMenuProperty
  fullName: System.Windows.FrameworkContentElement.ContextMenuProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identyfikuje <xref:System.Windows.FrameworkContentElement.ContextMenu*>Właściwości zależności.</xref:System.Windows.FrameworkContentElement.ContextMenu*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ContextMenuProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Cursor
  id: Cursor
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Cursor
  nameWithType: FrameworkContentElement.Cursor
  fullName: System.Windows.FrameworkContentElement.Cursor
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Pobiera lub ustawia kursor wyświetlany, gdy wskaźnik myszy znajduje się nad tym elementem."
  remarks: "Podczas ustawiania tej właściwości w [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] procesora zależy od typu konwersji <xref:System.Windows.Input.Cursor>klasę, aby ocenić ten ciąg.</xref:System.Windows.Input.Cursor> Podany ciąg powinno zostać oszacowane <xref:System.Windows.Input.CursorType>wartość.</xref:System.Windows.Input.CursorType> Zobacz <xref:System.Windows.Input.Cursor>szczegółowe informacje.</xref:System.Windows.Input.Cursor>       Czy kursor zgodnie z ustaleniami tej właściwości będzie lub nie będą wyświetlane, gdy wskaźnik myszy znajduje się nad tym elementem również jest zależny od wartości <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>Właściwości.</xref:System.Windows.FrameworkContentElement.ForceCursor%2A> Ponadto związane ze zdarzeniami zagadnienia, takie jak active przeciągania, przechwytywanie myszy, tryby w kontrolek i tak dalej do edycji tekstu wpłynie również na kursor mające wyższy priorytet niż określona wartość określoną w tej właściwości.       Aby przywrócić zachowanie ostatecznego domyślne ustawienie dla tej właściwości, należy ustawić ją na `null` ponownie.       `null` Domyślne naprawdę oznacza, że określenie wartości praktyczne kursora została odroczona tutaj mają być uzyskiwane z innej lokalizacji. Jeśli przedstawione bez programowe wartości z dowolnego źródła, gdy kursor domyślny za pośrednictwem [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] aplikacja będzie strzałka.       Każdy przepływ myszy nad [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] zgłasza aplikacji <xref:System.Windows.ContentElement.QueryCursor>zdarzeń.</xref:System.Windows.ContentElement.QueryCursor> Dymki zdarzeń, a każdy element marszruty ma możliwość obsługi zdarzenia i ustawić wartość kursora za pośrednictwem argumentów tego zdarzenia. Jeśli tak się stanie, fakt, że zdarzenie jest obsługiwana i została zmieniona wartość w argumentach pierwszeństwo wartość właściwości Cursor na dowolnym poziomie, chyba że <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>jest ustawiona.</xref:System.Windows.FrameworkContentElement.ForceCursor%2A>       Jeśli bez tworzenia niestandardowych kursorów, zazwyczaj zostanie ustawiona na wartość właściwości statycznej <xref:System.Windows.Input.Cursors>klasy.</xref:System.Windows.Input.Cursors>       Ustawienie <xref:System.Windows.Input.Cursor>do niestandardowej wartości nie jest włączone w częściowej relacji zaufania.</xref:System.Windows.Input.Cursor> Aby uzyskać więcej informacji o niestandardowych kursorów, zobacz [omówienie wprowadzania](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;dependencyPropertyInfo_Cursor&quot;></a>## Informacje dotyczące właściwości zależności |||   |-|-|   | Pole identyfikatora | <xref:System.Windows.FrameworkContentElement.CursorProperty>|   | Wartość właściwości metadanych `true`| None |</xref:System.Windows.FrameworkContentElement.CursorProperty>"
  example:
  - "The following example sets the cursor to a custom value.  \n  \n [!code-cs[cursors#ChangeCursorsSample](~/add/codesnippet/csharp/cursors/Window1.xaml.cs#changecursorssample)]\n [!code-vb[cursors#ChangeCursorsSample](~/add/codesnippet/visualbasic/cursors/Window1.xaml.vb#changecursorssample)]"
  syntax:
    content: public System.Windows.Input.Cursor Cursor { get; set; }
    return:
      type: System.Windows.Input.Cursor
      description: "Kursor do wyświetlenia. Wartością domyślną jest zdefiniowany jako <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> na ta właściwość zależności. Jednak domyślnie praktyczne w czasie wykonywania będzie pochodził z różnych czynników."
  overload: System.Windows.FrameworkContentElement.Cursor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.CursorProperty
  id: CursorProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: CursorProperty
  nameWithType: FrameworkContentElement.CursorProperty
  fullName: System.Windows.FrameworkContentElement.CursorProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identyfikuje <xref:System.Windows.FrameworkContentElement.Cursor*>Właściwości zależności.</xref:System.Windows.FrameworkContentElement.Cursor*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty CursorProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.DataContext
  id: DataContext
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: DataContext
  nameWithType: FrameworkContentElement.DataContext
  fullName: System.Windows.FrameworkContentElement.DataContext
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Pobiera lub ustawia kontekst danych dla elementu, gdy uczestniczy w powiązaniu danych."
  remarks: "*Kontekst danych* to pojęcie umożliwia elementom dziedziczenie informacji z ich elementów nadrzędnych o źródle powiązania, używany do wiązania, a także innych charakterystyk powiązania, takich jak ścieżka.       Kontekst danych można ustawić bezpośrednio do [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] obiektu z powiązaniami obliczane do właściwości tego obiektu. Alternatywnie można ustawić kontekstu danych <xref:System.Windows.Data.DataSourceProvider>obiektu.</xref:System.Windows.Data.DataSourceProvider>       Ta właściwość zależności dziedziczy wartości właściwości. W przypadku elementów podrzędnych o ma inne wartości DataContext nawiązane za pomocą wartości lokalnej lub style systemu właściwość ustawi wartości DataContext najbliższym elemencie nadrzędnym z to wartość przypisana wartość.       Alternatywnie można użyć jednej z następujących właściwości <xref:System.Windows.Data.Binding>klasy, aby jawnie określić źródło powiązania: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, lub <xref:System.Windows.Data.Binding.RelativeSource%2A>.</xref:System.Windows.Data.Binding.RelativeSource%2A> </xref:System.Windows.Data.Binding.Source%2A> </xref:System.Windows.Data.Binding.ElementName%2A> </xref:System.Windows.Data.Binding> Aby uzyskać więcej informacji, zobacz [porady: Określanie powiązania źródła](~/add/includes/ajax-current-ext-md.md).       W [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], DataContext najczęściej ma ustawioną jako <xref:System.Windows.Data.Binding>deklaracji.</xref:System.Windows.Data.Binding> Można użyć składni elementu właściwości lub Składnia atrybutu. Składnia atrybutu jest pokazano w przykładzie na tej stronie. Można również ustawić element DataContext w kodzie.      <a name=&quot;xamlPropertyElementUsage_DataContext&quot;></a>## Użycie elementu właściwości języka XAML ```   <object>     <object.DataContext>       <dataContextObject />     </object.DataContext>   </object>   ``` <a name=&quot;xamlAttributeUsage_DataContext&quot;> </a> ## użycie atrybutu XAML ```   <object DataContext=&quot;bindingUsage&quot;/>   - or -   <object DataContext=&quot;{resourceExtension contextResourceKey}&quot;/>   ``` <a name=&quot;xamlValues_DataContext&quot;> </a> ## wartości XAML *dataContextObject* bezpośrednio osadzonego obiektu, który służy jako kontekst danych dla powiązań w elemencie nadrzędnym.             Zazwyczaj jest to obiekt <xref:System.Windows.Data.Binding>lub innym <xref:System.Windows.Data.BindingBase>podklasy.</xref:System.Windows.Data.BindingBase> </xref:System.Windows.Data.Binding> Alternatywnie nieprzetworzone dane dowolnego [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] przeznaczone do powiązania mogą być umieszczane w tym miejscu z rzeczywistego powiązań zdefiniowanych później typu obiektu.       *bindingUsage* użycie powiązanie daje w wyniku kontekstu odpowiednich danych. Aby uzyskać więcej informacji, zobacz [powiązanie — rozszerzenie znaczników](~/add/includes/ajax-current-ext-md.md).       *resourceExtension* jedną z następujących: `StaticResource`, lub `DynamicResource`. To użycie jest używany podczas odwoływania się do danych pierwotnych definiowana jako obiekt w zasobach. Zobacz [zasobów XAML](~/add/includes/ajax-current-ext-md.md).       *contextResourceKey* identyfikatora klucza dla obiekt żądanej z wewnątrz <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>      <a name=&quot;dependencyPropertyInfo_DataContext&quot;></a>## Informacje dotyczące właściwości zależności |||   |-|-|   | Pole identyfikatora | <xref:System.Windows.FrameworkContentElement.DataContextProperty>|   | Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkContentElement.DataContextProperty>"
  example:
  - "The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as DataContext, and setting the binding path to a property within it.  \n  \n [!code-cs[ContentElementsSmorgasbord#DataContext](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#datacontext)]\n [!code-vb[ContentElementsSmorgasbord#DataContext](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#datacontext)]"
  syntax:
    content: public object DataContext { get; set; }
    return:
      type: System.Object
      description: "Obiekt, który ma być używana jako kontekst danych."
  overload: System.Windows.FrameworkContentElement.DataContext*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.DataContextChanged
  id: DataContextChanged
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: DataContextChanged
  nameWithType: FrameworkContentElement.DataContextChanged
  fullName: System.Windows.FrameworkContentElement.DataContextChanged
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Występuje po zmianie kontekstu danych tego elementu."
  remarks: "Aby uzyskać informacje o kontekstach danych i powiązania danych, zobacz [omówienie powiązania danych](~/add/includes/ajax-current-ext-md.md).      > [!IMPORTANT] > Po elemencie <xref:System.Windows.FrameworkContentElement.DataContext%2A>potencjalnie uwzględnianych zmian, wszystkie właściwości powiązanych z danymi w tym elemencie.</xref:System.Windows.FrameworkContentElement.DataContext%2A> Dotyczy to elementów, które elementy podrzędne bieżącego elementu, dziedziczących kontekstu danych, a także bieżącego elementu. Wszystkie takie powiązania ponownie zinterpretować nowe <xref:System.Windows.FrameworkContentElement.DataContext%2A>Aby odzwierciedlić nową wartość w powiązaniach.</xref:System.Windows.FrameworkContentElement.DataContext%2A> Nie ma żadnej gwarancji, informacje dotyczące kolejności tych zmian względem wywoływanie zdarzeń DataContextChanged.  Zmiany mogą wystąpić przed zdarzeniem, po zdarzeniu lub w dowolnej kombinacji."
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.DataContextProperty
  id: DataContextProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: DataContextProperty
  nameWithType: FrameworkContentElement.DataContextProperty
  fullName: System.Windows.FrameworkContentElement.DataContextProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identyfikuje <xref:System.Windows.FrameworkContentElement.DataContext*>Właściwości zależności.</xref:System.Windows.FrameworkContentElement.DataContext*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty DataContextProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.DefaultStyleKey
  id: DefaultStyleKey
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: DefaultStyleKey
  nameWithType: FrameworkContentElement.DefaultStyleKey
  fullName: System.Windows.FrameworkContentElement.DefaultStyleKey
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Pobiera lub ustawia klucz do użycia można znaleźć szablonu stylu dla tego formantu w kompozycji."
  remarks: "Ta właściwość zazwyczaj nie ustawiono przez dowolne jego bezpośredniego ustawiające. Zamiast tego można zastąpić metadane specyficzne dla typu ta właściwość zależności, za każdym razem, gdy utworzysz nową podklasę. Gdy użytkownik podklasy, wywołaj <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>metody przed <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>identyfikator w konstruktorze statycznym podklasy formantu.</xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> </xref:System.Windows.DependencyProperty.OverrideMetadata%2A>       Na przykład klasę wbudowany, taką jak <xref:System.Windows.Documents.Bold>faktycznie ma bardzo mało implementację poza Zastępowanie metadanych DefaultStyleKey w swoich konstruktorach statycznych i udostępnianie kilka wystąpień konstruktorów.</xref:System.Windows.Documents.Bold> Fakt, że elementy otoczona <xref:System.Windows.Documents.Bold>tagu korzyści <xref:System.Windows.Documents.TextElement.FontWeight%2A>Właściwość <xref:System.Windows.FontWeights.Bold%2A>jest zaimplementowana w obrębie stylu motywu przywoływany przez domyślnego ustawienia DefaultStyleKey do `typeof(Bold)`.</xref:System.Windows.FontWeights.Bold%2A> </xref:System.Windows.Documents.TextElement.FontWeight%2A> </xref:System.Windows.Documents.Bold>       Jeśli chcesz, elementu lub formantu celowo nie style kompozycji, ustawić <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A>właściwości `true`.</xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A>      <a name=&quot;dependencyPropertyInfo_DefaultStyleKey&quot;></a>## Informacje dotyczące właściwości zależności |||   |-|-|   | Pole identyfikatora | <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|   | Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>"
  syntax:
    content: protected object DefaultStyleKey { get; set; }
    return:
      type: System.Object
      description: "Klucz stylu. Działała prawidłowo, jako część wyszukiwania stylów motywu, ta wartość powinna być <xref:System.Type>elementu trwa stylem.</xref:System.Type> <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>zaakceptowane wartości dla niektórych przypadku; Zobacz uwagi."
  overload: System.Windows.FrameworkContentElement.DefaultStyleKey*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.DefaultStyleKeyProperty
  id: DefaultStyleKeyProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: DefaultStyleKeyProperty
  nameWithType: FrameworkContentElement.DefaultStyleKeyProperty
  fullName: System.Windows.FrameworkContentElement.DefaultStyleKeyProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identyfikuje <xref:System.Windows.FrameworkContentElement.DefaultStyleKey*>Właściwości zależności.</xref:System.Windows.FrameworkContentElement.DefaultStyleKey*>"
  syntax:
    content: protected static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.EndInit
  id: EndInit
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: EndInit()
  nameWithType: FrameworkContentElement.EndInit()
  fullName: System.Windows.FrameworkContentElement.EndInit()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Wywoływana natychmiast po zainicjowaniu elementu."
  remarks: "Zaimplementuj tę metodę w celu zapewnienia specjalnej obsługi, która powinna wystąpić po zainicjowaniu danego elementu w elemencie proces ładowania.       Implementacji powinny wywoływać implementację podstawową, ponieważ niektóre wewnętrzny flagi do śledzenia inicjowania ustawia implementacji base (ustawienie domyślne).       Jeśli <xref:System.Windows.FrameworkContentElement.BeginInit%2A>wcześniej została wywołana, podstawowym zgłosi implementacji <xref:System.Windows.FrameworkContentElement.Initialized>zdarzeń.</xref:System.Windows.FrameworkContentElement.Initialized> </xref:System.Windows.FrameworkContentElement.BeginInit%2A> W przeciwnym razie, jeśli <xref:System.Windows.FrameworkContentElement.BeginInit%2A>nie została wywołana lub nie można ustalić, czy <xref:System.Windows.FrameworkContentElement.BeginInit%2A>została wywołana, zdarzenie nie jest wywoływane.</xref:System.Windows.FrameworkContentElement.BeginInit%2A> </xref:System.Windows.FrameworkContentElement.BeginInit%2A>"
  syntax:
    content: public virtual void EndInit ();
    parameters: []
  overload: System.Windows.FrameworkContentElement.EndInit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.FindName(System.String)
  id: FindName(System.String)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: FindName(String)
  nameWithType: FrameworkContentElement.FindName(String)
  fullName: System.Windows.FrameworkContentElement.FindName(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Odnajduje element o podanym identyfikatorze nazwie."
  remarks: "Jeśli ten element ma elementy podrzędne, te elementy podrzędne są wszystkie rekursywnie przeszukiwane dla żądanego o nazwie elementu."
  example:
  - "The following example sets a property on an element found by name within a referenced <xref:System.Windows.Documents.FlowDocument> on a page.  \n  \n [!code-cs[ContentElementsSmorgasbord#FindName](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#findname)]\n [!code-vb[ContentElementsSmorgasbord#FindName](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#findname)]"
  syntax:
    content: public object FindName (string name);
    parameters:
    - id: name
      type: System.String
      description: "Nazwa elementu do wyszukania."
    return:
      type: System.Object
      description: "Żądany element. Może być <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> , jeśli nie został znaleziony."
  overload: System.Windows.FrameworkContentElement.FindName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.FindResource(System.Object)
  id: FindResource(System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: FindResource(Object)
  nameWithType: FrameworkContentElement.FindResource(Object)
  fullName: System.Windows.FrameworkContentElement.FindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Wyszukuje zasób z określonym kluczem i zostanie Zgłoś wyjątek, jeśli nie odnaleziono żądanego zasobu."
  remarks: "> [!IMPORTANT]> Jeśli ta metoda jest wywoływana dla klucza, którego nie można znaleźć, jest zwracany wyjątek. Jeśli nie chcesz obsługi wyjątków dla tej sprawy, należy zamiast tego wywołać <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>.</xref:System.Windows.FrameworkContentElement.TryFindResource%2A> <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>Zwraca `null` po zostanie znaleziony żaden z zasobów, a nie zgłasza wyjątek.</xref:System.Windows.FrameworkContentElement.TryFindResource%2A>       Jeśli nie można znaleźć zasobu w elemencie wywołującym, drzewa nadrzędnego jest przeszukiwana przy użyciu drzewa logicznego, w taki sam sposób, która byłaby drzewa przeszukane Jeśli zasobów prosili klucza w czasie wykonywania.       Zwykle będzie natychmiast rzutowania wartości zwracanej typu właściwości, którą próbujesz ustawić o wartości zwracane zasobów."
  example:
  - "The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.  \n  \n [!code-cs[ContentElementsSmorgasbord#FindResource](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#findresource)]\n [!code-vb[ContentElementsSmorgasbord#FindResource](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#findresource)]"
  syntax:
    content: public object FindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "Identyfikator klucza zasobu, który ma zostać odnaleziona."
    return:
      type: System.Object
      description: "Znaleziono zasobu lub <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Jeżeli nie znaleziono pasującego zasobów (ale również zgłosi wyjątek, jeśli <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>)."
  overload: System.Windows.FrameworkContentElement.FindResource*
  exceptions:
  - type: System.Windows.ResourceReferenceKeyNotFoundException
    commentId: T:System.Windows.ResourceReferenceKeyNotFoundException
    description: "Nie znaleziono klucza żądanego zasobu."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceKey</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.FocusVisualStyle
  id: FocusVisualStyle
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: FocusVisualStyle
  nameWithType: FrameworkContentElement.FocusVisualStyle
  fullName: System.Windows.FrameworkContentElement.FocusVisualStyle
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Pobiera lub ustawia obiekt, który umożliwia dostosowanie wyglądu, efekty lub inne właściwości stylu, które zostaną zastosowane do tego elementu po zarejestrowaniu fokus klawiatury."
  remarks: "Podczas ustawiania tej właściwości w [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], style prawie zawsze są zdefiniowane jako zasób, zamiast wbudowanego jako elementu, a ten zasób jest zwykle przywoływany jako <xref:System.Windows.StaticResourceExtension>.</xref:System.Windows.StaticResourceExtension>       Należy pamiętać, że ta właściwość ma wpływ na wygląd, ale nie zgłasza to w metadanych. To dlatego Zmień wygląd jest sterowane zdarzeniami i nie może być stosowane przez cały czas i w związku z tym należy nie ogólnie raportować żadnych informacji visual ani układu w metadanych.       Koncepcyjnie visual zachowanie fokus do formantu powinna być spójne element elementu. Najbardziej za pośrednictwem sposób, aby wymusić spójność jest tylko zmiana fokusu stylu wizualnego. w przypadku redagowania całego motywu. Ustawienie tej właściwości na poszczególnych stylów, a nie jako część kompozycji nie jest zamierzone użycie tej właściwości, ponieważ może dojść do mylące czynności użytkownika dotyczących fokus klawiatury. Jeśli są mają zostać zachowanie specyficzne dla elementu celowo nie jest spójny we motywu, dużo lepszym rozwiązaniem jest używanie wyzwalaczy w stylach właściwości poszczególnych stanu danych wejściowych, takich jak <xref:System.Windows.UIElement.IsFocused%2A>lub <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>i aby to zrobić w taki sposób, aby nie wizualnie zakłóca żadnych istniejących stylu wizualnego fokus.</xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A> </xref:System.Windows.UIElement.IsFocused%2A> Uzyskać więcej informacji o zamiarze projektu FocusVisualStyle i właściwości fokus alternatywnych, zobacz [style dla zespołu w formantach i FocusVisualStyle](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;xamlAttributeUsage_FocusVisualStyle&quot;></a>## Użycie atrybutu XAML ```   <object FocusVisualStyle=&quot;{resourceExtension styleResourceKey}&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_FocusVisualStyle&quot;> </a> ## użycie elementu właściwości XAML <a name=&quot;xamlValues_FocusVisualStyle&quot;> </a> ## wartości XAML *resourceExtension* jedną z następujących:, lub.       Zobacz [zasobów XAML](~/add/includes/ajax-current-ext-md.md).       *styleResourceKey* klucz identyfikujący styl żądanej. Klucz odnosi się do istniejącego zasobu w <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>      > [!NOTE] > Składni elementu właściwości jest technicznie możliwe, ale nie jest zalecane. Zobacz [style wbudowane i szablony](~/add/includes/ajax-current-ext-md.md).  Odwołanie do wiązania za pomocą lub <xref:System.Windows.Data.Binding>jest także możliwe, ale rzadko.</xref:System.Windows.Data.Binding>      <a name=&quot;dependencyPropertyInfo_FocusVisualStyle&quot;></a>## Informacje dotyczące właściwości zależności |||   |-|-|   | Pole identyfikatora | <xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|   | Wartość właściwości metadanych `true`| None |</xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>"
  syntax:
    content: public System.Windows.Style FocusVisualStyle { get; set; }
    return:
      type: System.Windows.Style
      description: "Żądany styl, aby zastosować na fokus. Wartość domyślna, zgodnie z deklaracją w właściwości zależności jest pusty statyczne <xref href=&quot;System.Windows.Style&quot;> </xref>. Jednak wartość w czasie wykonywania jest często (ale nie zawsze) styl dostarczony przez motywu obsługę formantów."
  overload: System.Windows.FrameworkContentElement.FocusVisualStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.FocusVisualStyleProperty
  id: FocusVisualStyleProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: FocusVisualStyleProperty
  nameWithType: FrameworkContentElement.FocusVisualStyleProperty
  fullName: System.Windows.FrameworkContentElement.FocusVisualStyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identyfikuje <xref:System.Windows.FrameworkContentElement.FocusVisualStyle*>Właściwości zależności.</xref:System.Windows.FrameworkContentElement.FocusVisualStyle*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ForceCursor
  id: ForceCursor
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ForceCursor
  nameWithType: FrameworkContentElement.ForceCursor
  fullName: System.Windows.FrameworkContentElement.ForceCursor
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Pobiera lub ustawia wartość wskazującą czy to <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref> powinien wymusić [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] do renderowania kursora w postaci zadeklarowanej przez to wystąpienie <xref:System.Windows.FrameworkContentElement.Cursor*>Właściwości.</xref:System.Windows.FrameworkContentElement.Cursor*>"
  remarks: "Ustawienie tej właściwości na `true` spowoduje zastąpienie preferencje kursora ustala elementy podrzędne. To dlatego na ogół aplikacji [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] może być mylące dla użytkownika, zwłaszcza w przypadku, gdy próbuje określić kursory elementy podrzędne. Ustawienie <xref:System.Windows.FrameworkElement.ForceCursor%2A>jest bardziej odpowiednie w scenariuszach kontroli podklasy lub składania.</xref:System.Windows.FrameworkElement.ForceCursor%2A>      <a name=&quot;dependencyPropertyInfo_ForceCursor&quot;></a>## Informacje dotyczące właściwości zależności |||   |-|-|   | Pole identyfikatora | <xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|   | Wartość właściwości metadanych `true`| None |</xref:System.Windows.FrameworkContentElement.ForceCursorProperty>"
  example:
  - "The following example forces the cursor while over the element.  \n  \n [!code-xml[ForceCursor#ForceCursor](~/add/codesnippet/xaml/forcecursor/default.xaml#forcecursor)]"
  syntax:
    content: public bool ForceCursor { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby wymusić prezentacji kursora za pośrednictwem tego elementu, aby użyć tego wystąpienia obiektu ustawienie kursora (w tym na wszystkie elementy podrzędne); w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Wartość domyślna to <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkContentElement.ForceCursor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ForceCursorProperty
  id: ForceCursorProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ForceCursorProperty
  nameWithType: FrameworkContentElement.ForceCursorProperty
  fullName: System.Windows.FrameworkContentElement.ForceCursorProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identyfikuje <xref:System.Windows.FrameworkContentElement.ForceCursor*>Właściwości zależności.</xref:System.Windows.FrameworkContentElement.ForceCursor*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ForceCursorProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)
  id: GetBindingExpression(System.Windows.DependencyProperty)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: GetBindingExpression(DependencyProperty)
  nameWithType: FrameworkContentElement.GetBindingExpression(DependencyProperty)
  fullName: System.Windows.FrameworkContentElement.GetBindingExpression(DependencyProperty)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Pobiera <xref href=&quot;System.Windows.Data.BindingExpression&quot;> </xref> dla określonej właściwości powiązania."
  remarks: ''
  example:
  - "The following example retrieves a binding by querying a property.  \n  \n [!code-cs[ContentElementsSmorgasbord#GetBindingExpression](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#getbindingexpression)]\n [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#getbindingexpression)]"
  syntax:
    content: public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "Element docelowy <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> służący do pobierania powiązania."
    return:
      type: System.Windows.Data.BindingExpression
      description: "Zwraca <xref href=&quot;System.Windows.Data.BindingExpression&quot;> </xref> Jeśli obiektem docelowym są danymi powiązanymi; w przeciwnym razie <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkContentElement.GetBindingExpression*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.GetUIParentCore
  id: GetUIParentCore
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: GetUIParentCore()
  nameWithType: FrameworkContentElement.GetUIParentCore()
  fullName: System.Windows.FrameworkContentElement.GetUIParentCore()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Zwraca alternatywnych logiczny obiekt nadrzędny dla tego elementu, jeśli nie elementu nadrzędnego visual. W takim przypadku <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref> nadrzędny jest zawsze taką samą wartość jak <xref:System.Windows.FrameworkContentElement.Parent*>Właściwości.</xref:System.Windows.FrameworkContentElement.Parent*>"
  remarks: "Domyślna implementacja zwraca Oczekiwano jednego nadrzędnego visual. Implementacje niestandardowe mogą zwracać relacje alternatywny nadrzędny."
  syntax:
    content: protected override System.Windows.DependencyObject GetUIParentCore ();
    parameters: []
    return:
      type: System.Windows.DependencyObject
      description: "Zwraca coś innego niż <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> po każdej zmianie WPF poziomie struktury implementacja tej metody ma połączenie Niewizualne nadrzędnej."
  overload: System.Windows.FrameworkContentElement.GetUIParentCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Initialized
  id: Initialized
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Initialized
  nameWithType: FrameworkContentElement.Initialized
  fullName: System.Windows.FrameworkContentElement.Initialized
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Występuje, gdy to <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref> został zainicjowany. Pokrywa się to z przypadkami, w którym wartość <xref:System.Windows.FrameworkContentElement.IsInitialized*>Właściwość zmienia się z <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (lub niezdefiniowaną) do <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkContentElement.IsInitialized*>"
  remarks: "Będzie to zdarzenie wywoływane, gdy <xref:System.Windows.FrameworkContentElement.EndInit%2A>lub <xref:System.Windows.FrameworkContentElement.OnInitialized%2A>metody są wywoływane.</xref:System.Windows.FrameworkContentElement.OnInitialized%2A> </xref:System.Windows.FrameworkContentElement.EndInit%2A> Wywołania tych metod można zostały dokonane przez kod zamierzonego lub przez [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] proces ładowania."
  syntax:
    content: public event EventHandler Initialized;
    return:
      type: System.EventHandler
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.InputScope
  id: InputScope
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: InputScope
  nameWithType: FrameworkContentElement.InputScope
  fullName: System.Windows.FrameworkContentElement.InputScope
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Pobiera lub ustawia kontekst dla danych wejściowych używanych przez to <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref>."
  remarks: "Ta właściwość zależności dziedziczy wartości właściwości. Jeśli istnieją elementy podrzędne z ma inne wartości <xref:System.Windows.FrameworkElement.InputScope%2A>nawiązane za pomocą wartości lokalnej lub style, system właściwość zostanie ustaw wartość na <xref:System.Windows.FrameworkElement.InputScope%2A>wartości najbliższym elemencie nadrzędnym z tej wartości przypisane.</xref:System.Windows.FrameworkElement.InputScope%2A> </xref:System.Windows.FrameworkElement.InputScope%2A>       Mimo że [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] składni użycia ma na liście i składnia jest dozwolona, ustawienie dla tej właściwości [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] nie jest często.      <a name=&quot;dependencyPropertyInfo_InputScope&quot;></a>## Informacje dotyczące właściwości zależności |||   |-|-|   | Pole identyfikatora | <xref:System.Windows.FrameworkContentElement.InputScopeProperty>|   | Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkContentElement.InputScopeProperty>"
  syntax:
    content: public System.Windows.Input.InputScope InputScope { get; set; }
    return:
      type: System.Windows.Input.InputScope
      description: "Wejściowych zakresu, który modyfikuje interpretacji danych wejściowych z alternatywne metody wprowadzania tekstu. Wartość domyślna to <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> (które powoduje domyślna obsługa poleceń)."
  overload: System.Windows.FrameworkContentElement.InputScope*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.InputScopeProperty
  id: InputScopeProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: InputScopeProperty
  nameWithType: FrameworkContentElement.InputScopeProperty
  fullName: System.Windows.FrameworkContentElement.InputScopeProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identyfikuje <xref:System.Windows.FrameworkContentElement.InputScope*>Właściwości zależności.</xref:System.Windows.FrameworkContentElement.InputScope*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty InputScopeProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.IsInitialized
  id: IsInitialized
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: IsInitialized
  nameWithType: FrameworkContentElement.IsInitialized
  fullName: System.Windows.FrameworkContentElement.IsInitialized
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Pobiera wartość wskazującą, czy ten element został zainicjowany, albo przez ładowany jako [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)], albo przez zdefiniowanie jawnie jego <xref:System.Windows.FrameworkContentElement.EndInit*>wywołana metoda.</xref:System.Windows.FrameworkContentElement.EndInit*>"
  remarks: "Ta właściwość może być również `true` Jeśli ten element został przeniesiony w obrębie drzewa element taki sposób, że ma nowy element nadrzędny, a w związku z tym staje się ponownie załadowana ponownie."
  syntax:
    content: public bool IsInitialized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli element jest inicjowana na wyżej wymienione ładowania lub metody wywołań; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkContentElement.IsInitialized*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.IsLoaded
  id: IsLoaded
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: IsLoaded
  nameWithType: FrameworkContentElement.IsLoaded
  fullName: System.Windows.FrameworkContentElement.IsLoaded
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Pobiera wartość wskazującą, czy ten element został załadowany do prezentacji."
  remarks: "Z nowo utworzone wystąpienie, ta właściwość jest uruchamiany `false`i pozostaje `true` po ustawieniu `true`, nawet jeśli później usunięte przez kod."
  example:
  - "The following example code uses IsLoaded as a conditional check to assure that a function `displayData` (not shown) will have valid elements loaded on the page to work against, as part of an on-demand handler. That same logic is run as an event handler for <xref:System.Windows.FrameworkContentElement.Loaded>.  \n  \n [!code-cs[ContentElementsSmorgasbord#IsLoaded](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#isloaded)]\n [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#isloaded)]"
  syntax:
    content: public bool IsLoaded { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli bieżący element jest dołączona do drzewa i wyrenderowaniu; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Jeśli element nie został dołączony do drzewa załadowanych elementów."
  overload: System.Windows.FrameworkContentElement.IsLoaded*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Language
  id: Language
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Language
  nameWithType: FrameworkContentElement.Language
  fullName: System.Windows.FrameworkContentElement.Language
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Pobiera lub ustawia informacje języka lokalizacji/globalizacji, który dotyczy pojedynczego elementu."
  remarks: "Formaty ciągu zgodne ze standardem RFC 3066. Na przykład stany USA Język angielski jest &quot;en US&quot;. Zobacz <xref:System.Windows.Markup.XmlLanguage>uzyskać więcej informacji o wartości i formatu.</xref:System.Windows.Markup.XmlLanguage>       Ta właściwość zależności dziedziczy wartości właściwości. Jeśli istnieją elementy podrzędne z ma inne wartości <xref:System.Windows.FrameworkElement.Language%2A>nawiązane za pomocą wartości lokalnej lub style, system właściwość zostanie ustaw wartość na <xref:System.Windows.FrameworkElement.Language%2A>wartości najbliższym elemencie nadrzędnym z tej wartości przypisane.</xref:System.Windows.FrameworkElement.Language%2A> </xref:System.Windows.FrameworkElement.Language%2A>      <a name=&quot;dependencyPropertyInfo_CultureInfo&quot;></a>## Informacje dotyczące właściwości zależności |||   |-|-|   | Pole identyfikatora | <xref:System.Windows.FrameworkContentElement.LanguageProperty>|   | Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkContentElement.LanguageProperty>"
  syntax:
    content: public System.Windows.Markup.XmlLanguage Language { get; set; }
    return:
      type: System.Windows.Markup.XmlLanguage
      description: "Informacje o ustawieniach kulturowych dla tego elementu. Wartość domyślna to <xref href=&quot;System.Windows.Markup.XmlLanguage&quot;> </xref> wystąpienia z jego <xref:System.Windows.Markup.XmlLanguage.IetfLanguageTag*>wartość ciągu &quot;en US&quot;.</xref:System.Windows.Markup.XmlLanguage.IetfLanguageTag*>"
  overload: System.Windows.FrameworkContentElement.Language*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.LanguageProperty
  id: LanguageProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: LanguageProperty
  nameWithType: FrameworkContentElement.LanguageProperty
  fullName: System.Windows.FrameworkContentElement.LanguageProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identyfikuje <xref:System.Windows.FrameworkContentElement.Language*>Właściwości zależności.</xref:System.Windows.FrameworkContentElement.Language*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty LanguageProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Loaded
  id: Loaded
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Loaded
  nameWithType: FrameworkContentElement.Loaded
  fullName: System.Windows.FrameworkContentElement.Loaded
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Występuje, gdy element jest poukładany, wyrenderowany i gotowy do interakcji."
  remarks: "Bezpośrednie kierowane zdarzenia nie wykonuj trasy, są obsługiwane tylko w obrębie tego samego elementu, na którym jest uruchamiany. Bezpośrednie kierowane zdarzenia obsługuje inne zachowanie kierowanego zdarzenia: obsługują dostępny obsługi kolekcji i mogą być używane jako <xref:System.Windows.EventTrigger>w stylu.</xref:System.Windows.EventTrigger>      <a name=&quot;routedEventInfo_Loaded&quot;></a>## Przesyłane informacje o zdarzeniach |||   |-|-|   | Pole identyfikatora | <xref:System.Windows.FrameworkContentElement.LoadedEvent>|   | Strategii routingu | Bezpośrednie |   | Delegat | <xref:System.Windows.RoutedEventHandler>|</xref:System.Windows.RoutedEventHandler></xref:System.Windows.FrameworkContentElement.LoadedEvent>"
  syntax:
    content: public event System.Windows.RoutedEventHandler Loaded;
    return:
      type: System.Windows.RoutedEventHandler
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.LoadedEvent
  id: LoadedEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: LoadedEvent
  nameWithType: FrameworkContentElement.LoadedEvent
  fullName: System.Windows.FrameworkContentElement.LoadedEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identyfikuje <xref href=&quot;System.Windows.FrameworkContentElement.Loaded&quot;> </xref> [kierowane Przegląd zdarzeń](~/add/includes/ajax-current-ext-md.md)."
  remarks: "Obiekty identyfikator zdarzenia są tworzone podczas kierowane zdarzenia są rejestrowane (zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>), a następnie można dodać obsługę klas (zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> Identyfikator obiekty zawierają nazwę identyfikującą, typ właściciela typ obsługi, strategii routingu i metodę narzędzia na potrzeby dodawania właścicieli dla zdarzenia."
  syntax:
    content: public static readonly System.Windows.RoutedEvent LoadedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.LogicalChildren
  id: LogicalChildren
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: LogicalChildren
  nameWithType: FrameworkContentElement.LogicalChildren
  fullName: System.Windows.FrameworkContentElement.LogicalChildren
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Pobiera moduł wyliczający logicznym podrzędnym elementy tego elementu."
  remarks: "Aby uzyskać więcej informacji na temat korzystania z LogicalChildren i <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, zobacz [drzewa WPF](~/add/includes/ajax-current-ext-md.md).</xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>"
  syntax:
    content: protected virtual System.Collections.IEnumerator LogicalChildren { get; }
    return:
      type: System.Collections.IEnumerator
      description: "Moduł wyliczający dla elementów podrzędnych logicznej tego elementu."
  overload: System.Windows.FrameworkContentElement.LogicalChildren*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)
  id: MoveFocus(System.Windows.Input.TraversalRequest)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: MoveFocus(TraversalRequest)
  nameWithType: FrameworkContentElement.MoveFocus(TraversalRequest)
  fullName: System.Windows.FrameworkContentElement.MoveFocus(TraversalRequest)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Przenosi fokus klawiatury z tego elementu do innego elementu."
  syntax:
    content: public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);
    parameters:
    - id: request
      type: System.Windows.Input.TraversalRequest
      description: "Kierunek, który koncentruje się na przenoszenie jako wartość wyliczenia."
    return:
      type: System.Boolean
      description: "Zwraca <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> Jeśli fokus zostanie przeniesiony pomyślnie; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> , jeśli określony element docelowy w kierunku nie istnieje."
  overload: System.Windows.FrameworkContentElement.MoveFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Name
  id: Name
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Name
  nameWithType: FrameworkContentElement.Name
  fullName: System.Windows.FrameworkContentElement.Name
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Pobiera lub ustawia nazwę identyfikującą elementu. Nazwa zawiera odwołania do wystąpienia, aby po jest tworzony podczas analizowania programowe związane z kodem, takie jak kod obsługi zdarzeń, może odwoływać się do elementu [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  remarks: "Najbardziej typowe użycie tej właściwości jest podczas określania [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] nazwy elementu w znaczniku.       Ta właściwość zapewnia zasadniczo można ustawić właściwości wygody poziomie struktury WPF [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] [x: Name — dyrektywa](~/add/includes/ajax-current-ext-md.md).       Podczas pobierania nazwy z kodu nie jest często, ponieważ jeśli już ma odwołanie do odpowiedniego w kodzie, po prostu można wywoływać metod i właściwości w elemencie odwołania, a nie zawierają zazwyczaj potrzeby nazwę. Wyjątek ma, gdy ciąg ma, na przykład niektóre przeciążone oznacza Jeśli przydaje się do wyświetlania tej nazwy w [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]. Nazwa ustawienia z kodu, jeśli oryginalna nazwa została ustawiona z poziomu znacznika nie zaleca się i zmiana właściwości nie zmieni się odwołanie do obiektu. Odwołania do takich obiektów są tworzone tylko wtedy, gdy podstawowy namescopes jawnie są tworzone podczas [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] ładowania.       W szczególności należy wywołać <xref:System.Windows.FrameworkContentElement.RegisterName%2A>Aby zmiana na właściwość Name elementu już załadowana.</xref:System.Windows.FrameworkContentElement.RegisterName%2A>       Jeden przypadek zauważalne, których nazwa ustawienia z kodu jest ważna jest nazewnictwa elementów, które będzie uruchamiana scenorys. Przed zarejestrowaniem nazwę może także zajść potrzeba utworzenia wystąpienia i przypisz <xref:System.Windows.NameScope>wystąpienia.</xref:System.Windows.NameScope> Zobacz sekcję przykład lub [omówienie Scenorys](~/add/includes/ajax-current-ext-md.md).       Nazwa ustawienia z kodu jest ograniczona do aplikacji, ale wyszukiwania według nazwy elementu jest bardziej popularne, zwłaszcza w przypadku, gdy są wykorzystujących model nawigacji, gdzie stron ponownie załadować do aplikacji i kodu w czasie wykonywania nie jest kodem odpowiednich strony. Metoda narzędzie <xref:System.Windows.FrameworkContentElement.FindName%2A>, która jest dostępna z dowolnego <xref:System.Windows.FrameworkContentElement>, można znaleźć żadnych elementów według nazwy w rekursywnie drzewa logicznego tego elementu.</xref:System.Windows.FrameworkContentElement> </xref:System.Windows.FrameworkContentElement.FindName%2A> Lub użyć <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>metody statycznej z <xref:System.Windows.LogicalTreeHelper>, który przyjmuje również ciąg nazwy jako argument.</xref:System.Windows.LogicalTreeHelper> </xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>       Najczęściej używanych elementów głównych (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page>na przykład) implementować interfejs <xref:System.Windows.Markup.INameScope>.</xref:System.Windows.Markup.INameScope> </xref:System.Windows.Controls.Page> </xref:System.Windows.Window> Implementacje tego interfejsu powinny wymuszanie nazwy być jednoznaczne w swoim zakresie.      <a name=&quot;dependencyPropertyInfo_Name&quot;></a>## Informacje dotyczące właściwości zależności |||   |-|-|   | Pole identyfikatora | <xref:System.Windows.FrameworkContentElement.NameProperty>|   | Wartość właściwości metadanych `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|</xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> </xref:System.Windows.FrameworkContentElement.NameProperty>"
  syntax:
    content: public string Name { get; set; }
    return:
      type: System.String
      description: "Nazwa elementu."
  overload: System.Windows.FrameworkContentElement.Name*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.NameProperty
  id: NameProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: NameProperty
  nameWithType: FrameworkContentElement.NameProperty
  fullName: System.Windows.FrameworkContentElement.NameProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identyfikuje <xref:System.Windows.FrameworkContentElement.Name*>Właściwości zależności.</xref:System.Windows.FrameworkContentElement.Name*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty NameProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  id: OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnContextMenuClosing(ContextMenuEventArgs)
  nameWithType: FrameworkContentElement.OnContextMenuClosing(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnContextMenuClosing(ContextMenuEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Wywoływane, gdy <xref href=&quot;System.Windows.FrameworkContentElement.ContextMenuClosing&quot;> </xref> kierowanego zdarzenia osiągnie tej klasy w jego trasy. Zaimplementuj tę metodę, aby dodać klasę obsługi dla tego zdarzenia."
  remarks: "This method has no default implementation. You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers. Therefore, your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route."
  syntax:
    content: protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ContextMenuEventArgs
      description: "Zapewnia dane o zdarzeniu."
  overload: System.Windows.FrameworkContentElement.OnContextMenuClosing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  id: OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnContextMenuOpening(ContextMenuEventArgs)
  nameWithType: FrameworkContentElement.OnContextMenuOpening(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnContextMenuOpening(ContextMenuEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Wywoływane, gdy <xref href=&quot;System.Windows.FrameworkContentElement.ContextMenuOpening&quot;> </xref> kierowanego zdarzenia osiągnie tej klasy w jego trasy. Zaimplementuj tę metodę, aby dodać klasę obsługi dla tego zdarzenia."
  remarks: "This method has no default implementation. You should still call base() in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route."
  syntax:
    content: protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ContextMenuEventArgs
      description: "Dane zdarzeń dla zdarzenia."
  overload: System.Windows.FrameworkContentElement.OnContextMenuOpening*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)
  id: OnGotFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnGotFocus(RoutedEventArgs)
  nameWithType: FrameworkContentElement.OnGotFocus(RoutedEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnGotFocus(RoutedEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Klasy obsługi <xref href=&quot;System.Windows.ContentElement.GotFocus&quot;> </xref> zdarzeń."
  remarks: "Ten program obsługi klasy Ustawia zachowanie odpowiednie fokus w tym elemencie, jeśli pochodzi z tego elementu. Jeśli źródło zdarzenia innego elementu w drzewie, program obsługi nie działa.       Zastępuje tę metodę, aby zmienić domyślne koncentrujących się zachowanie w elemencie."
  syntax:
    content: protected override void OnGotFocus (System.Windows.RoutedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.RoutedEventArgs
      description: "Dane zdarzeń dla zdarzenia."
  overload: System.Windows.FrameworkContentElement.OnGotFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)
  id: OnInitialized(System.EventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnInitialized(EventArgs)
  nameWithType: FrameworkContentElement.OnInitialized(EventArgs)
  fullName: System.Windows.FrameworkContentElement.OnInitialized(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Zgłasza <xref href=&quot;System.Windows.FrameworkContentElement.Initialized&quot;> </xref> zdarzeń. Ta metoda jest wywoływana przy każdym <xref:System.Windows.FrameworkContentElement.IsInitialized*>ustawiono <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkContentElement.IsInitialized*>"
  remarks: "Domyślna implementacja tej metody wirtualnej zgłasza zdarzenie, zgodnie z opisem we wcześniejszej części tego tematu. Zastąpienia powinny wywoływać base(), aby zachować to zachowanie.       Należy pamiętać, że <xref:System.Windows.FrameworkContentElement.IsInitialized%2A>właściwość jest tylko do odczytu.</xref:System.Windows.FrameworkContentElement.IsInitialized%2A> W związku z tym nie można ustawić, aby wymusić zachowanie inicjowania w ten sposób. Ustawienia ma być wykonywane tylko przez [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] framework."
  syntax:
    content: protected virtual void OnInitialized (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "Dane zdarzeń dla zdarzenia."
  overload: System.Windows.FrameworkContentElement.OnInitialized*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnPropertyChanged(DependencyPropertyChangedEventArgs)
  nameWithType: FrameworkContentElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Wywoływane, gdy wartość efektywna dowolnej właściwości zależności na tym <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref> została zaktualizowana. Właściwości określonych zależności, które zmienić jest zgłaszana w parametrze argumentów. Zastępuje <xref:System.Windows.DependencyObject.OnPropertyChanged*>.</xref:System.Windows.DependencyObject.OnPropertyChanged*>"
  remarks: "Ta metoda nie jest przeznaczona do ogólnie wykrycia zmian właściwości lub invalidations. Zamiast tego ma ona modyfikacji wzorca ogólne unieważniania Jeśli znane jest niektórych informacji o klasyfikacjach szeroki właściwości.       Tej metody jest potencjalnie wywołana wiele razy w okresie istnienia obiektu. W związku z tym można osiągnąć lepszą wydajność, jeśli Zastępowanie metadanych określonych właściwości, a następnie dołącz <xref:System.Windows.CoerceValueCallback>lub <xref:System.Windows.PropertyChangedCallback>funkcje dla poszczególnych właściwości.</xref:System.Windows.PropertyChangedCallback> </xref:System.Windows.CoerceValueCallback> Jednak czy użyć tej metody, jeśli <xref:System.Windows.FrameworkContentElement>obejmuje znaczących właściwości zależności powiązanych wartości, lub jeśli zawiera logikę, takich jak zachowanie renderowania, który musi zostać uruchomiony ponownie dla kilku powiązanych przypadków właściwość invalidations.</xref:System.Windows.FrameworkContentElement>       Należy pamiętać, że o identycznej nazwie `OnPropertyChanged` metody o innym podpisie (typ parametru jest <xref:System.ComponentModel.PropertyChangedEventArgs>) wyświetlanych na liczbę klas.</xref:System.ComponentModel.PropertyChangedEventArgs> Czy `OnPropertyChanged` jest używany dla powiadomienia obiektu danych i jest częścią kontraktu dla <xref:System.ComponentModel.INotifyPropertyChanged>.</xref:System.ComponentModel.INotifyPropertyChanged>"
  syntax:
    content: protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "Dane zdarzenia, które opisano zmiany, w tym starej i nowej wartości właściwości."
  overload: System.Windows.FrameworkContentElement.OnPropertyChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  id: OnStyleChanged(System.Windows.Style,System.Windows.Style)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnStyleChanged(Style,Style)
  nameWithType: FrameworkContentElement.OnStyleChanged(Style,Style)
  fullName: System.Windows.FrameworkContentElement.OnStyleChanged(Style,Style)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Wywoływane, gdy styl jest używany w przypadku zmiany tego elementu."
  remarks: "Ta metoda ma domyślną implementację, która ustawia flaga wewnętrzna, biorąc pod uwagę warunek zmieniony styl."
  syntax:
    content: protected virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);
    parameters:
    - id: oldStyle
      type: System.Windows.Style
      description: "Stary styl."
    - id: newStyle
      type: System.Windows.Style
      description: "Nowy styl."
  overload: System.Windows.FrameworkContentElement.OnStyleChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  id: OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnToolTipClosing(ToolTipEventArgs)
  nameWithType: FrameworkContentElement.OnToolTipClosing(ToolTipEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnToolTipClosing(ToolTipEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Wywoływane, gdy <xref href=&quot;System.Windows.FrameworkContentElement.ToolTipClosing&quot;> </xref> kierowanego zdarzenia osiągnie tej klasy w jego trasy. Zaimplementuj tę metodę, aby dodać klasę obsługi dla tego zdarzenia."
  remarks: "This method has no default implementation. You should still call base() in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route."
  syntax:
    content: protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ToolTipEventArgs
      description: "Zapewnia dane o zdarzeniu."
  overload: System.Windows.FrameworkContentElement.OnToolTipClosing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  id: OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnToolTipOpening(ToolTipEventArgs)
  nameWithType: FrameworkContentElement.OnToolTipOpening(ToolTipEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnToolTipOpening(ToolTipEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Wywoływane, gdy <xref href=&quot;System.Windows.FrameworkContentElement.ToolTipOpening&quot;> </xref> kierowanego zdarzenia osiągnie tej klasy w jego trasy. Zaimplementuj tę metodę, aby dodać klasę obsługi dla tego zdarzenia."
  remarks: "This method has no default implementation. You should still call base() in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route."
  syntax:
    content: protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ToolTipEventArgs
      description: "Zapewnia dane o zdarzeniu."
  overload: System.Windows.FrameworkContentElement.OnToolTipOpening*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OverridesDefaultStyle
  id: OverridesDefaultStyle
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OverridesDefaultStyle
  nameWithType: FrameworkContentElement.OverridesDefaultStyle
  fullName: System.Windows.FrameworkContentElement.OverridesDefaultStyle
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Pobiera lub ustawia wartość wskazującą, czy ten element uwzględnia właściwości stylu ze stylów motywu."
  remarks: "Najbardziej typowe użycie tej właściwości jest pośrednie użycia w ramach metody ustawiającej stylu dostarczające style motywów.      <a name=&quot;dependencyPropertyInfo_OverridesDefaultStyle&quot;></a>## Informacje dotyczące właściwości zależności |||   |-|-|   | Pole identyfikatora | <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|   | Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>"
  syntax:
    content: public bool OverridesDefaultStyle { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli ten element nie używa właściwości style kompozycji; wszystkie właściwości stylu pochodzące pochodzą z aplikacji lokalnej style i właściwości style kompozycji nie mają zastosowania. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>Jeśli style aplikacji się najpierw, a następnie Zastosuj style kompozycji dla właściwości, które nie zostały ustawione w szczególności w stylach aplikacji."
  overload: System.Windows.FrameworkContentElement.OverridesDefaultStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty
  id: OverridesDefaultStyleProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OverridesDefaultStyleProperty
  nameWithType: FrameworkContentElement.OverridesDefaultStyleProperty
  fullName: System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identyfikuje <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle*>Właściwości zależności.</xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Parent
  id: Parent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Parent
  nameWithType: FrameworkContentElement.Parent
  fullName: System.Windows.FrameworkContentElement.Parent
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Pobiera element nadrzędny w drzewie logicznym dla tego elementu."
  remarks: "Zauważ, że logiczny obiekt nadrzędny elementu nie może zmienić w zależności od funkcji z aplikacji, i utrzymywanie wartość tej właściwości nie zreflektuje tej zmiany. Należy zwykle pobrać wartość natychmiast, zanim zajdzie taka potrzeba.       Zobacz [drzewa WPF](~/add/includes/ajax-current-ext-md.md) uzyskać więcej informacji o przechodzenie drzewa logiczne oraz scenariusze, gdy biorąc to podejście do elementu odnajdywania jest odpowiedni.       System właściwości potencjalnie ponownych wszystkich wartości właściwości elementu po jego pokrewnym, ponieważ niektóre właściwości dziedziczenia wartości za pośrednictwem drzewa logicznego. <xref:System.Windows.FrameworkContentElement.DataContext%2A>Dotyczący dla powiązania można również zmienić, gdy elementy są pokrewnym.</xref:System.Windows.FrameworkContentElement.DataContext%2A>       Zmienianie elementu nadrzędnego zwykle tylko odbywa się za pośrednictwem manipulowania kolekcje, za pomocą dedykowanego metod dodawania i usuwania, lub przez ustawienie właściwości elementów zawartości.       Najbardziej typowym scenariuszem przy użyciu właściwości nadrzędny ma otrzymać odwołanie, a następnie zachęcić różnych <xref:System.Windows.FrameworkContentElement>wartości właściwości z obiektu nadrzędnego.</xref:System.Windows.FrameworkContentElement> Dla szablonów, będzie nadrzędnego szablonu ostatecznie `null`. Aby uzyskać po tym punkcie i rozszerzyć w drzewie logicznym, w której faktycznie zastosować ten szablon, użyj <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>.</xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>"
  example:
  - "The following example checks to see whether the Parent of a <xref:System.Windows.Documents.TextPointer> is of a particular type.  \n  \n [!code-cs[TextPointer_snippets#FCEParent](~/add/codesnippet/csharp/TextPointer_Snippets/Window1.xaml.cs#fceparent)]\n [!code-vb[TextPointer_snippets#FCEParent](~/add/codesnippet/visualbasic/textpointer_snippets/window1.xaml.vb#fceparent)]"
  syntax:
    content: public System.Windows.DependencyObject Parent { get; }
    return:
      type: System.Windows.DependencyObject
      description: "Element nadrzędny logicznego dla tego elementu."
  overload: System.Windows.FrameworkContentElement.Parent*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  id: PredictFocus(System.Windows.Input.FocusNavigationDirection)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: PredictFocus(FocusNavigationDirection)
  nameWithType: FrameworkContentElement.PredictFocus(FocusNavigationDirection)
  fullName: System.Windows.FrameworkContentElement.PredictFocus(FocusNavigationDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Określa następnego elementu, który może odbierać fokus względem tego elementu dla kierunku przepływu podana fokus, ale faktycznie nie przenosi fokus. Ta metoda jest zapieczętowany i nie może zostać zastąpiona."
  remarks: "<xref:System.Windows.FrameworkContentElement.MoveFocus%2A>jest to metoda pokrewne faktycznie Przenieś fokus.</xref:System.Windows.FrameworkContentElement.MoveFocus%2A>"
  syntax:
    content: public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Input.FocusNavigationDirection
      description: "Kierunek, dla której można ustalić zmiany potencjalnego fokus."
    return:
      type: System.Windows.DependencyObject
      description: "Następny element, który skupić się były przenoszone do, jeśli faktycznie był przekształcić fokus. Może zwrócić <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Jeśli fokus nie można przenieść względem tego elementu dla podanego kierunku."
  overload: System.Windows.FrameworkContentElement.PredictFocus*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: 'Specified one of the following directions in the <xref href=&quot;System.Windows.Input.TraversalRequest&quot;></xref>: <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>. Te kroki są niedozwolone dla PredictFocus (ale dozwolony dla <xref:System.Windows.FrameworkContentElement.MoveFocus*>).</xref:System.Windows.FrameworkContentElement.MoveFocus*>'
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)
  id: RegisterName(System.String,System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: RegisterName(String,Object)
  nameWithType: FrameworkContentElement.RegisterName(String,Object)
  fullName: System.Windows.FrameworkContentElement.RegisterName(String,Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Udostępnia metody dostępu, które ułatwiają dostęp do <xref:System.Windows.NameScope>Metoda rejestracji.</xref:System.Windows.NameScope>"
  remarks: "Ta metoda jest metodą wygody wywoływania <xref:System.Windows.NameScope.RegisterName%2A>.</xref:System.Windows.NameScope.RegisterName%2A> Implementacja będzie sprawdzać elementy nadrzędne kolejnych, aż do znalezienia odpowiednich <xref:System.Windows.NameScope>implementację, która została odnaleziona przez wyszukiwanie elementu, który implementuje <xref:System.Windows.Markup.INameScope>.</xref:System.Windows.Markup.INameScope> </xref:System.Windows.NameScope> Aby uzyskać więcej informacji o namescopes, zobacz [WPF XAML Namescopes](~/add/includes/ajax-current-ext-md.md).       Wywoływanie RegisterName jest potrzebne do poprawnie Połącz scenorys animacji dla aplikacji, podczas tworzenia w kodzie. Jest to spowodowane jedną klucza scenorysu właściwości <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, używa środowiska wykonawczego nazw wyszukiwania zamiast możliwość odwołania do elementu docelowego.</xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> Dotyczy to nawet, jeśli ten element jest dostępny przez odwołanie z kodu. Aby uzyskać więcej informacji na czego potrzebujesz do rejestracji nazw dla celów scenorysu, zobacz [omówienie Scenorys](~/add/includes/ajax-current-ext-md.md). Animacji dla elementów zawartości są mniej typowe niż animacji na formanty, [omówienie Scenorys](../Topic/Storyboards%20Overview.md) koncentruje się na scenariuszach kontroli."
  syntax:
    content: public void RegisterName (string name, object scopedElement);
    parameters:
    - id: name
      type: System.String
      description: "Nazwa do użycia dla określonego mapowania nazwy obiektu."
    - id: scopedElement
      type: System.Object
      description: "Obiekt do mapowania."
  overload: System.Windows.FrameworkContentElement.RegisterName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)
  id: RemoveLogicalChild(System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: RemoveLogicalChild(Object)
  nameWithType: FrameworkContentElement.RemoveLogicalChild(Object)
  fullName: System.Windows.FrameworkContentElement.RemoveLogicalChild(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Usuwa określony element z drzewa logicznego dla tego elementu."
  remarks: "To [!INCLUDE[TLA#tla_api](~/add/includes/tlasharptla-api-md.md)] dotyczy głównie klasy wywodzące scenariuszy, podczas dodawania obsługi dla kolekcji podrzędnych.       Większość <xref:System.Windows.FrameworkContentElement>pochodnej klasy Uwidacznianie dedykowanego kolekcje, które są odpowiedzialne za zawierania (na przykład <xref:System.Windows.Documents.Span.Inlines%2A>w klasie <xref:System.Windows.Documents.Span>; <xref:System.Windows.Documents.Section.Blocks%2A>na <xref:System.Windows.Documents.Section>klasy).</xref:System.Windows.Documents.Section> </xref:System.Windows.Documents.Section.Blocks%2A> </xref:System.Windows.Documents.Span> </xref:System.Windows.Documents.Span.Inlines%2A> </xref:System.Windows.FrameworkContentElement> Wyprowadzanie z klas takich zazwyczaj można uniknąć konieczności modyfikowania drzewa logicznego bezpośrednio."
  syntax:
    content: protected void RemoveLogicalChild (object child);
    parameters:
    - id: child
      type: System.Object
      description: "Element do usunięcia."
  overload: System.Windows.FrameworkContentElement.RemoveLogicalChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Resources
  id: Resources
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Resources
  nameWithType: FrameworkContentElement.Resources
  fullName: System.Windows.FrameworkContentElement.Resources
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Pobiera lub ustawia bieżący słownik zasobów zdefiniowane lokalnie."
  remarks: "Słowniki zasobów, które mogą być definiowane w całości lub częściowo w [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] są zazwyczaj tworzone jako elementu właściwości i są zwykle w elemencie głównym dla dowolnego pojedynczej strony lub aplikacji. Wprowadzenie do słownika zasobów na tym poziomie ułatwia odnaleźć podrzędne poszczególnych elementów na stronie (lub z dowolnej strony w przypadku aplikacji). W większości scenariuszy aplikacji, firma Microsoft zaleca, że style można zdefiniować jako elementy obiekt słownika zasobów lub zdefiniowane jako zasobów zewnętrznych, aby umożliwić zasób stylu całej niezależne (to rozwiązanie pomaga oddzielić projektanta obowiązki związane z obowiązki developer, oddziel pliki fizyczne, które powinny być edytowane).       Należy pamiętać, że ta właściwość zwraca tylko słownik zasobów zadeklarowany bezpośrednio z poziomu tego elementu. To jest inny niż proces wyszukiwania zasobów rzeczywistych, umożliwiający elementu podrzędnego dostęp do dowolnych zasobów zdefiniowane w każdy element nadrzędny, wyszukiwanie rekursywnie w górę.       Zasoby mogą się też odwoływać przez kod kolekcji, ale należy pamiętać, że zasoby są tworzone w [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] ostatecznie nie będzie dostępny dopiero po <xref:System.Windows.FrameworkContentElement.Loaded>zostanie wywołane przez element, który deklaruje słownika.</xref:System.Windows.FrameworkContentElement.Loaded> W rzeczywistości zasoby są parsowane asynchronicznie, a nie nawet <xref:System.Windows.FrameworkContentElement.Loaded>zdarzenie jest zapewnienie, że można się odwołać [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] zdefiniowanych zasobów.</xref:System.Windows.FrameworkContentElement.Loaded> Z tego powodu należy zwykle tylko dostęp [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] zdefiniowane jako część kodu w czasie wykonywania, lub za pośrednictwem innych zasobów [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] technik, takich jak style lub odwołania do rozszerzenia zasobu dla wartości atrybutu. Gdy uzyskujesz dostęp do zasobów przy użyciu kodu jest zasadniczo odpowiednikiem odniesienia z [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)].       Podstawowa <xref:System.Windows.ResourceDictionary>obsługuje metody wymagane do dodawania, usuwania lub zbadać zasobów w w kolekcji przy użyciu kodu.</xref:System.Windows.ResourceDictionary> Właściwości zasobów nie można ustawić na potrzeby scenariusza całkowicie zastąpienia kolekcji zasobów elementu jako nowy lub różnych <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>       Zwróć uwagę, że [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] składni pokazano nie zawiera elementu dla <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary> Jest to przykład składni niejawnej kolekcji; Znacznik reprezentujący element kolekcji można pominąć. Zamiast tego określono elementy, które są dodawane jako elementy w kolekcji. Aby uzyskać więcej informacji o kolekcjach niejawne i [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], zobacz [szczegółów w składni języka XAML](~/add/includes/ajax-current-ext-md.md). Jeden przypadek, w przypadku, gdy <xref:System.Windows.ResourceDictionary>nadal jest określone jawnie, ponieważ element jest, jeśli udostępniono scalonych słownika, w tym przypadku są zwykle żadnych elementów podrzędnych dla tego <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary> </xref:System.Windows.ResourceDictionary> Aby uzyskać więcej informacji, zobacz [scalić słowniki zasobów](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;xamlPropertyElementUsage_Resources&quot;></a>## Użycie elementu właściwości języka XAML ```   <object>     <object.Resources>       oneOrMoreResourceElements     </object.Resources>   </object>   ``` <a name=&quot;xamlValues_Resources&quot;> </a> ## wartości XAML *oneOrMoreResourceElements* elementów obiektu, z których każdy definiuje zasób.       Każdy element właściwości zasobów w ramach każdej <xref:System.Windows.ResourceDictionary>musi mieć unikatową wartość [dyrektywy x: Key](~/add/includes/ajax-current-ext-md.md), która służy jako unikatowy klucz, gdy są one pobierane <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary> </xref:System.Windows.ResourceDictionary>"
  example:
  - "The following example establishes a Resources collection on a <xref:System.Windows.Documents.FlowDocument> root element. <xref:System.Windows.Documents.FlowDocument> is a typical choice because it is one of the few <xref:System.Windows.FrameworkContentElement> classes that make sense as a root element, and resources are generally stored at the page root or at even higher levels such as in the application.  \n  \n [!code-xml[ContentElementsSmorgasbord#FCEResources](~/add/codesnippet/xaml/ContentElementsSmorgasbord/page2.xaml#fceresources)]"
  syntax:
    content: public System.Windows.ResourceDictionary Resources { get; set; }
    return:
      type: System.Windows.ResourceDictionary
      description: "Bieżące zasoby zdefiniowane lokalnie. Jest to słownik zasobów, w którym dostęp do zasobów w słowniku według klucza."
  overload: System.Windows.FrameworkContentElement.Resources*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)
  id: SetBinding(System.Windows.DependencyProperty,System.String)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: SetBinding(DependencyProperty,String)
  nameWithType: FrameworkContentElement.SetBinding(DependencyProperty,String)
  fullName: System.Windows.FrameworkContentElement.SetBinding(DependencyProperty,String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Dołącza powiązanie do tego elementu, na podstawie podanego źródła właściwości nazwy jako kwalifikacji ścieżki do źródła danych."
  remarks: "Ta metoda jest metodą wygody wywoływania <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>, która przechodzi bieżącego wystąpienia jako <xref:System.Windows.DependencyObject>i tworzy nowy <xref:System.Windows.Data.Binding>na podstawie udostępnionych `path` parametru.</xref:System.Windows.Data.Binding> </xref:System.Windows.DependencyObject> </xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName> Podpis jest wygodniejsze podczas ustanawiania domyślne proste powiązania. Jeśli trzeba określić żadnych właściwości powiązania do warunków innych niż domyślne lub chcesz użyć <xref:System.Windows.Data.MultiBinding>lub <xref:System.Windows.Data.PriorityBinding>, należy użyć <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29>podpisu.</xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> </xref:System.Windows.Data.PriorityBinding> </xref:System.Windows.Data.MultiBinding>"
  example:
  - "The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as <xref:System.Windows.FrameworkContentElement.DataContext%2A>, and setting the binding path to a property within it.  \n  \n [!code-cs[ContentElementsSmorgasbord#DataContext](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#datacontext)]\n [!code-vb[ContentElementsSmorgasbord#DataContext](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#datacontext)]"
  syntax:
    content: public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "Identyfikuje właściwość powiązania."
    - id: path
      type: System.String
      description: "Nazwa właściwości źródła lub ścieżka do właściwości używane dla wiązania."
    return:
      type: System.Windows.Data.BindingExpression
      description: "Rejestruje warunków powiązania. Zwrócona wartość może być przydatne do kontroli błędów."
  overload: System.Windows.FrameworkContentElement.SetBinding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  id: SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: SetBinding(DependencyProperty,BindingBase)
  nameWithType: FrameworkContentElement.SetBinding(DependencyProperty,BindingBase)
  fullName: System.Windows.FrameworkContentElement.SetBinding(DependencyProperty,BindingBase)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Dołącza powiązanie do tego elementu, oparte na obiekt podana powiązania."
  remarks: "Ta metoda jest metodą wygody wywoływania <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>, która przechodzi bieżącego wystąpienia jako <xref:System.Windows.DependencyObject>.</xref:System.Windows.DependencyObject> </xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>"
  example:
  - "The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new <xref:System.Windows.Data.Binding> and setting the source to a newly built `DateTime` object.  \n  \n [!code-cs[ContentElementsSmorgasbord#SetBinding](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#setbinding)]\n [!code-vb[ContentElementsSmorgasbord#SetBinding](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#setbinding)]"
  syntax:
    content: public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "Identyfikuje właściwość powiązania."
    - id: binding
      type: System.Windows.Data.BindingBase
      description: "Reprezentuje powiązanie danych."
    return:
      type: System.Windows.Data.BindingExpressionBase
      description: "Rejestruje warunków powiązania. Zwrócona wartość może być przydatne do kontroli błędów."
  overload: System.Windows.FrameworkContentElement.SetBinding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  id: SetResourceReference(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: SetResourceReference(DependencyProperty,Object)
  nameWithType: FrameworkContentElement.SetResourceReference(DependencyProperty,Object)
  fullName: System.Windows.FrameworkContentElement.SetResourceReference(DependencyProperty,Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Wyszukuje zasób o określonej nazwie i konfiguruje zasobów odwołanie do niej dla określonej właściwości."
  remarks: "Odwołanie do zasobu jest podobny do stosowania [DynamicResource — rozszerzenie znaczników](~/add/includes/ajax-current-ext-md.md) w znaczniku. Odwołanie do zasobu tworzy wyrażenie wewnętrznego, które dostarcza wartość określonej właściwości na podstawie odroczonego czasu wykonywania. Wyrażenie będą ponownie oceniane po każdym słownika zasobów wskazuje zmienione za pośrednictwem wewnętrznego zdarzenia lub gdy pokrewnym bieżącego elementu (Zmiana nadrzędnej zmieniłby słownika ścieżki wyszukiwania)."
  syntax:
    content: public void SetResourceReference (System.Windows.DependencyProperty dp, object name);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "Właściwość, z którym powiązany jest zasobu."
    - id: name
      type: System.Object
      description: "Nazwa zasobu."
  overload: System.Windows.FrameworkContentElement.SetResourceReference*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ShouldSerializeResources
  id: ShouldSerializeResources
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ShouldSerializeResources()
  nameWithType: FrameworkContentElement.ShouldSerializeResources()
  fullName: System.Windows.FrameworkContentElement.ShouldSerializeResources()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Zwraca czy procesy serializacji powinny serializować zawartości <xref:System.Windows.FrameworkContentElement.Resources*>właściwości wystąpienia tej klasy.</xref:System.Windows.FrameworkContentElement.Resources*>"
  remarks: "Spowoduje to zwrócenie `true` tak długo, jak istnieje co najmniej jeden zasób z kluczem lokalnego <xref:System.Windows.FrameworkContentElement.Resources%2A>.</xref:System.Windows.FrameworkContentElement.Resources%2A>"
  syntax:
    content: public bool ShouldSerializeResources ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli <xref:System.Windows.FrameworkContentElement.Resources*>wartość właściwości powinny być serializowane; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkContentElement.Resources*>"
  overload: System.Windows.FrameworkContentElement.ShouldSerializeResources*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ShouldSerializeStyle
  id: ShouldSerializeStyle
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ShouldSerializeStyle()
  nameWithType: FrameworkContentElement.ShouldSerializeStyle()
  fullName: System.Windows.FrameworkContentElement.ShouldSerializeStyle()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Zwraca czy procesy serializacji powinny serializować zawartości <xref:System.Windows.FrameworkContentElement.Style*>właściwości wystąpienia tej klasy.</xref:System.Windows.FrameworkContentElement.Style*>"
  remarks: "Spowoduje to zwrócenie `true` Jeśli <xref:System.Windows.Style>lokalnie jest ustawiona.</xref:System.Windows.Style>"
  syntax:
    content: public bool ShouldSerializeStyle ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli <xref:System.Windows.FrameworkContentElement.Style*>wartość właściwości powinny być serializowane; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkContentElement.Style*>"
  overload: System.Windows.FrameworkContentElement.ShouldSerializeStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.SourceUpdated
  id: SourceUpdated
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: SourceUpdated
  nameWithType: FrameworkContentElement.SourceUpdated
  fullName: System.Windows.FrameworkContentElement.SourceUpdated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Występuje, gdy dowolne skojarzone źródło danych uczestniczącej w powiązaniu na zmiany tego elementu."
  remarks: "Powierzchnie tego zdarzenia <xref:System.Windows.Data.Binding.SourceUpdated>zdarzenie, które jest wywoływane przez żadną <xref:System.Windows.Data.Binding>skojarzony z tym elementem.</xref:System.Windows.Data.Binding> </xref:System.Windows.Data.Binding.SourceUpdated>      <a name=&quot;xamlAttributeUsage_SourceUpdated&quot;></a>## Użycie atrybutu XAML```   <object SourceUpdated=&quot;EventHandler&quot;/>   ```"
  syntax:
    content: public event EventHandler<System.Windows.Data.DataTransferEventArgs> SourceUpdated;
    return:
      type: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Style
  id: Style
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Style
  nameWithType: FrameworkContentElement.Style
  fullName: System.Windows.FrameworkContentElement.Style
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Pobiera lub ustawia styl, który ma być używany przez ten element."
  remarks: "Bieżący styl często są udostępniane przez domyślny styl z motywów lub style zazwyczaj stosowane do obiektów tego typu przez zasobów na poziomie strony lub aplikacji (styl niejawne). Ta właściwość jest nie ustawiona lub jest zwracany domyślny styl (motywu), ale zwrócony niejawne stylu lub jawna. W przypadku bezpośredniego lub pośredniego style nie ma znaczenia, czy styl jest dostępne jako zasób zdefiniowany lokalnie.       Ustawianie stylów ma pewne ograniczenia. Możesz przywrócić cały właściwości stylu nowy <xref:System.Windows.Style>w dowolnym momencie, która wymusi recomposition układu.</xref:System.Windows.Style> Jednak niezwłocznie po stylu jest umieszczona używany przez element załadować <xref:System.Windows.Style>należy traktować jako sealed.</xref:System.Windows.Style> Podjęto próbę dokonania zmiany do żadnej poszczególnych właściwości stylu w użyciu (np. wszystkich elementów w kolekcji <xref:System.Windows.Style.Setters%2A>) powoduje, że wyjątków.</xref:System.Windows.Style.Setters%2A> Styl, który jest zdefiniowany w znaczniku jest uznawany za będzie używana natychmiast po załadowaniu go ze słownika zasobów (dla zasobów) lub załadowanej strony, który jest zawarty w (dla style wbudowane).       Styl jest właściwością zależności o priorytecie specjalnych. Lokalnie ustawiony styl zazwyczaj operuje na najwyższy priorytet w systemie właściwości. Jeżeli styl jest w tym momencie wartość null, podczas ładowania właściwości system sprawdza niejawne style jako zdefiniowanych zasoby, które określają tego typu. Jeżeli styl jest nadal null po wykonaniu tego kroku, następnie styl pochodzi z styl domyślny (motywu), ale domyślnym stylu nie są zwracane w wartości właściwości stylu. Zobacz [pierwszeństwo wartość właściwości zależności](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;xamlAttributeUsage_Style&quot;></a>## Użycie atrybutu XAML ```   <object Style=&quot;{resourceExtension StyleResourceKey}&quot;/>   ``` <a name=&quot;xamlValues_Style&quot;> </a> ## wartości XAML *resourceExtension* jedną z następujących:, lub.       Zobacz [zasobów XAML](~/add/includes/ajax-current-ext-md.md).       *styleResourceKey* klucz identyfikujący styl żądanej. Klucz odnosi się do istniejącego zasobu w <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>      > [!NOTE] > Składni elementu właściwości jest technicznie możliwe, ale nie jest zalecane. Zobacz [style wbudowane i szablony](~/add/includes/ajax-current-ext-md.md).  Odwołanie do wiązania za pomocą lub <xref:System.Windows.Data.Binding>jest także możliwe, ale rzadko.</xref:System.Windows.Data.Binding>      <a name=&quot;dependencyPropertyInfo_Style&quot;></a>## Informacje dotyczące właściwości zależności |||   |-|-|   | Pole identyfikatora | <xref:System.Windows.FrameworkContentElement.StyleProperty>|   | Wartość właściwości metadanych `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkContentElement.StyleProperty>"
  example:
  - "The following example establishes a <xref:System.Windows.FrameworkContentElement.Resources%2A> collection on a <xref:System.Windows.Documents.FlowDocument> root element and then references it as a resource as a specific style for a <xref:System.Windows.Documents.Paragraph>.  \n  \n [!code-xml[ContentElementsSmorgasbord#FCEResources](~/add/codesnippet/xaml/ContentElementsSmorgasbord/page2.xaml#fceresources)]"
  syntax:
    content: public System.Windows.Style Style { get; set; }
    return:
      type: System.Windows.Style
      description: "Styl niestandardowy zastosowane, dla elementu, jeśli jest obecny. W przeciwnym razie <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>. Wartością domyślną skonstruowany domyślne <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref> jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkContentElement.Style*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.StyleProperty
  id: StyleProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: StyleProperty
  nameWithType: FrameworkContentElement.StyleProperty
  fullName: System.Windows.FrameworkContentElement.StyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identyfikuje <xref:System.Windows.FrameworkContentElement.Style*>Właściwości zależności.</xref:System.Windows.FrameworkContentElement.Style*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty StyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  id: System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  isEii: true
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: FrameworkContentElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.FrameworkContentElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Opis tego elementu członkowskiego, zobacz <xref:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable*>metody.</xref:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable*>"
  remarks: "Ten element jest jawną implementacją elementu interfejsu. Można go używać tylko wtedy, gdy <xref:System.Windows.FrameworkContentElement>wystąpienia jest rzutowane na <xref:System.Windows.Markup.IQueryAmbient>interfejsu.</xref:System.Windows.Markup.IQueryAmbient> </xref:System.Windows.FrameworkContentElement>"
  syntax:
    content: bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);
    parameters:
    - id: propertyName
      type: System.String
      description: "Nazwa żądanej właściwości otoczenia."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli <code> propertyName </code> są dostępne, a w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Tag
  id: Tag
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Tag
  nameWithType: FrameworkContentElement.Tag
  fullName: System.Windows.FrameworkContentElement.Tag
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Pobiera lub ustawia wartość dowolnego obiektu, który może służyć do przechowywania informacji niestandardowych o tym elemencie."
  remarks: "Ta właściwość jest odpowiednikiem właściwości znacznika w innych [!INCLUDE[TLA#tla_ms](~/add/includes/tlasharptla-ms-md.md)] programowania modeli, takie jak [!INCLUDE[TLA#tla_vba](~/add/includes/ajax-current-ext-md.md)] lub [!INCLUDE[TLA#tla_winforms](~/add/includes/ajax-current-ext-md.md)]. Jest on przeznaczony do istniejącego miejsca do przechowywania kilku podstawowych informacji niestandardowych o dowolnym elemencie bez wymuszania deweloperzy aplikacji do podklasy.      <a name=&quot;xamlValues_Tag&quot;></a>## Wartości XAML ponieważ ta właściwość ma obiekt, konieczne będzie użycie właściwości elementu było ustawić właściwości Tag [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] na inny niż obiekt, za pomocą konwertera typu znane i wbudowane, takiego jak ciąg. Obiekty używane w ten sposób nie są zwykle w ramach standardowego [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] obszary nazw i w związku z tym mogą wymagać mapowania przestrzeni nazw do zewnętrznego przestrzeni nazw, aby wprowadzić jako [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] elementów.      <a name=&quot;dependencyPropertyInfo_Tag&quot;></a>## Informacje dotyczące właściwości zależności |||   |-|-|   | Pole identyfikatora | <xref:System.Windows.FrameworkContentElement.TagProperty>|   | Wartość właściwości metadanych `true`| None |</xref:System.Windows.FrameworkContentElement.TagProperty>"
  syntax:
    content: public object Tag { get; set; }
    return:
      type: System.Object
      description: "Wartość docelowa. Ta właściwość nie ma wartości domyślnej."
  overload: System.Windows.FrameworkContentElement.Tag*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.TagProperty
  id: TagProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: TagProperty
  nameWithType: FrameworkContentElement.TagProperty
  fullName: System.Windows.FrameworkContentElement.TagProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identyfikuje <xref:System.Windows.FrameworkContentElement.Tag*>Właściwości zależności.</xref:System.Windows.FrameworkContentElement.Tag*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty TagProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.TargetUpdated
  id: TargetUpdated
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: TargetUpdated
  nameWithType: FrameworkContentElement.TargetUpdated
  fullName: System.Windows.FrameworkContentElement.TargetUpdated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Występuje, gdy dowolnej skojarzonej właściwości docelowej uczestniczącej w powiązaniu zmian tego elementu."
  remarks: "Powierzchnie tego zdarzenia <xref:System.Windows.Data.Binding.TargetUpdated>zdarzenie, które jest wywoływane przez żadną <xref:System.Windows.Data.Binding>skojarzony z tym elementem.</xref:System.Windows.Data.Binding> </xref:System.Windows.Data.Binding.TargetUpdated> Zwykle oznacza to, że powiązanie zagrożona jest powiązanie dwukierunkowe i potwierdza, że właściwości zależności powiązane unieważniania poprzedniej wartości właściwości dla dowolnego sprawdzania poprawności lub schemat buforowania, że właściwość obsługuje.       Argumenty zdarzeń tego zdarzenia informuje, które powiązane właściwości zostało zmienione.      <a name=&quot;xamlAttributeUsage_TargetUpdated&quot;></a>## Użycie atrybutu XAML```   <object TargetUpdated=&quot;EventHandler&quot;/>   ```"
  syntax:
    content: public event EventHandler<System.Windows.Data.DataTransferEventArgs> TargetUpdated;
    return:
      type: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.TemplatedParent
  id: TemplatedParent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: TemplatedParent
  nameWithType: FrameworkContentElement.TemplatedParent
  fullName: System.Windows.FrameworkContentElement.TemplatedParent
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Pobiera odwołanie do szablonu elementu nadrzędnego tego elementu. Ta właściwość nie jest ważna, jeśli element nie został utworzony za pomocą szablonu."
  remarks: "Szablony są faktycznie udostępnionych obiektów, których zawartość szablonu są tworzone tylko raz. W związku z tym po uzyskaniu odwołania do obiektu do elementu, który pochodzi z szablonu, może się okazać, że jawnego drzewa logicznego nie dotrze do strony głównej. Aby można było połączyć szablonu odniesienie do drzewa logicznego strony, należy uzyskać wartość TemplatedParent i kontynuować tree elementu zgodnie z potrzebami.       Często będą TemplatedParent `null` dla wspólnych obiektów, ponieważ Jeśli uzyskasz spoza stroną odwołanie do obiektu w aplikacji w typowy sposób, że element prawdopodobnie nie utworzono z szablonu. Przypadkach, gdy nie jest TemplatedParent `null` obejmują operacje takie jak zdarzenia testowania trafień obsługi dla niektórych niskiego poziomu zdarzenia wejściowe lub Praca z wyliczenia, które mogą zwrócone elementy, które nadeszły z szablonów."
  syntax:
    content: public System.Windows.DependencyObject TemplatedParent { get; }
    return:
      type: System.Windows.DependencyObject
      description: "Element których <xref href=&quot;System.Windows.FrameworkTemplate&quot;> </xref> <xref:System.Windows.FrameworkTemplate.VisualTree*>spowodował ten element ma zostać utworzony.</xref:System.Windows.FrameworkTemplate.VisualTree*> Ta wartość jest często <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>; zobacz uwagi."
  overload: System.Windows.FrameworkContentElement.TemplatedParent*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTip
  id: ToolTip
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTip
  nameWithType: FrameworkContentElement.ToolTip
  fullName: System.Windows.FrameworkContentElement.ToolTip
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Pobiera lub ustawia obiekt etykietki narzędzia, która jest wyświetlana dla tego elementu w [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]."
  remarks: "Jeśli wartość tej właściwości jest typu <xref:System.Windows.Controls.ToolTip>, następnie jest etykietka narzędzia używanego w [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)].</xref:System.Windows.Controls.ToolTip>  Jeśli wartość jest innego typu, a następnie ta wartość będzie służyć jako *zawartości* dla <xref:System.Windows.Controls.ToolTip>podane (skonstruowany) przez system.</xref:System.Windows.Controls.ToolTip> Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Controls.ToolTipService>.</xref:System.Windows.Controls.ToolTipService> Klasa usługi zawiera dołączone właściwości, które można dostosować etykietka narzędzia.      <a name=&quot;xamlAttributeUsage_ToolTip&quot;></a>## Użycie atrybutu XAML ```   <object ToolTip=&quot;toolTipContent&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_ToolTip&quot;> </a> ## użycie elementu właściwości XAML ```   <object>     <object.ToolTip>       <ToolTip .../>     </object.ToolTip>   </object>   - or -   <object>     <object.ToolTip>       toolTipObjectContent     </object.ToolTip>   </object>   ``` <a name=&quot;xamlValues_ToolTip&quot;> </a> ## wartości XAML *toolTipContent* ciąg, który staje się tekst wyświetlany na elemencie ToolTip.                   *toolTipObjectContent* niektórych obiektów w formularzu elementu obiektów, które mają być używane jako zawartość dla <xref:System.Windows.FrameworkContentElement>.</xref:System.Windows.FrameworkContentElement> Zazwyczaj powinien to być <xref:System.Windows.FrameworkElement>lub innego elementu tworzy składania układu dla etykietki narzędzia, po pewnym czasie zawierającej tekst zawartości w ramach składania.</xref:System.Windows.FrameworkElement> W ten sposób użycia <xref:System.Windows.Controls.ToolTip>utworzyć elementu niejawnie z przeanalizowany [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]i *toolTipObjectContent* zawartości jest ustawiony jako jego <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=fullName>Właściwości.</xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=fullName> </xref:System.Windows.Controls.ToolTip>       `ToolTip`.../>    See <xref:System.Windows.Controls.ToolTip>.</xref:System.Windows.Controls.ToolTip>      <a name=&quot;dependencyPropertyInfo_ToolTip&quot;></a>## Informacje dotyczące właściwości zależności |||   |-|-|   | Pole identyfikatora | <xref:System.Windows.FrameworkContentElement.ToolTipProperty>|   | Wartość właściwości metadanych `true`| None |</xref:System.Windows.FrameworkContentElement.ToolTipProperty>"
  example:
  - "The following example sets the value of the <xref:System.Windows.FrameworkElement.ToolTip%2A> property directly to a string.  \n  \n [!code-cs[TableSnippets2#_Table_RowGroups_ManipRows](~/add/codesnippet/csharp/TableSnippets2/Window1.xaml.cs#_table_rowgroups_maniprows)]\n [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/add/codesnippet/visualbasic/tablesnippets2/window1.xaml.vb#_table_rowgroups_maniprows)]"
  syntax:
    content: public object ToolTip { get; set; }
    return:
      type: System.Object
      description: "Obiekt etykietki narzędzia. Zobacz uwagi poniżej szczegółowe informacje na temat przyczyny tego parametru nie jest silnie typu."
  overload: System.Windows.FrameworkContentElement.ToolTip*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTipClosing
  id: ToolTipClosing
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTipClosing
  nameWithType: FrameworkContentElement.ToolTipClosing
  fullName: System.Windows.FrameworkContentElement.ToolTipClosing
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Występuje zaraz przed zamknięciem dowolnej etykietki narzędzia w elemencie."
  remarks: "Aby pominąć zamknięcia etykietka narzędzia, obsługi zdarzenia należy oznaczyć go jako obsługi.       To zdarzenie nie może być <xref:System.Windows.EventTrigger>w stylu.</xref:System.Windows.EventTrigger> Jest to spowodowane pola Identyfikator zdarzenia wykorzystuje ponownie implementacja z usługą, która nie ujawnia metody dodawania/usuwania na zdarzenia.      <a name=&quot;routedEventInfo_ToolTipClosing&quot;></a>## Przesyłane informacje o zdarzeniach |||   |-|-|   | Pole identyfikatora | <xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|   | Strategii routingu | Bezpośrednie |   | Delegat | <xref:System.Windows.Controls.ToolTipEventHandler>|</xref:System.Windows.Controls.ToolTipEventHandler></xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>"
  syntax:
    content: public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;
    return:
      type: System.Windows.Controls.ToolTipEventHandler
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTipClosingEvent
  id: ToolTipClosingEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTipClosingEvent
  nameWithType: FrameworkContentElement.ToolTipClosingEvent
  fullName: System.Windows.FrameworkContentElement.ToolTipClosingEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identyfikuje <xref href=&quot;System.Windows.FrameworkContentElement.ToolTipClosing&quot;> </xref> [kierowane Przegląd zdarzeń](~/add/includes/ajax-current-ext-md.md)."
  remarks: "Obiekty identyfikator zdarzenia są tworzone podczas kierowane zdarzenia są rejestrowane (zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>), a następnie można dodać obsługę klas (zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> Identyfikator obiekty zawierają nazwę identyfikującą, typ właściciela typ obsługi, strategii routingu i metodę narzędzia na potrzeby dodawania właścicieli dla zdarzenia."
  syntax:
    content: public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTipOpening
  id: ToolTipOpening
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTipOpening
  nameWithType: FrameworkContentElement.ToolTipOpening
  fullName: System.Windows.FrameworkContentElement.ToolTipOpening
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Występuje po otwarciu dowolnej etykietki narzędzia w elemencie."
  remarks: "Można ręcznie otworzyć etykietki narzędzi, programy obsługi zdarzeń należy oznaczyć dane zdarzenie jako obsłużone. W przeciwnym razie wartość <xref:System.Windows.FrameworkContentElement.ToolTip%2A>Właściwości będzie można użyć do automatycznego otwierania menu kontekstowego.</xref:System.Windows.FrameworkContentElement.ToolTip%2A> Oznaczenie zdarzenia obsługiwane skutecznie spowoduje anulowanie domyślne działanie i może być możliwość Resetuj wartość <xref:System.Windows.FrameworkContentElement.ToolTip%2A>Właściwości, a następnie otwórz nowe <xref:System.Windows.Controls.ContextMenu>.</xref:System.Windows.Controls.ContextMenu> </xref:System.Windows.FrameworkContentElement.ToolTip%2A> Należy pamiętać, że to zdarzenie nie będą zgłaszane Jeśli <xref:System.Windows.FrameworkContentElement.ToolTip%2A>jest odwołanie o wartości null lub w inny sposób nie ustawiono.</xref:System.Windows.FrameworkContentElement.ToolTip%2A>       To zdarzenie nie może być <xref:System.Windows.EventTrigger>w stylu.</xref:System.Windows.EventTrigger> Jest to spowodowane pola Identyfikator zdarzenia wykorzystuje ponownie implementacja z usługą, która nie ujawnia metody dodawania/usuwania na zdarzenia.      <a name=&quot;routedEventInfo_ToolTipOpening&quot;></a>## Przesyłane informacje o zdarzeniach |||   |-|-|   | Pole identyfikatora | <xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|   | Strategii routingu | Bezpośrednie |   | Delegat | <xref:System.Windows.Controls.ToolTipEventHandler>|</xref:System.Windows.Controls.ToolTipEventHandler></xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>"
  syntax:
    content: public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;
    return:
      type: System.Windows.Controls.ToolTipEventHandler
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTipOpeningEvent
  id: ToolTipOpeningEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTipOpeningEvent
  nameWithType: FrameworkContentElement.ToolTipOpeningEvent
  fullName: System.Windows.FrameworkContentElement.ToolTipOpeningEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identyfikuje <xref href=&quot;System.Windows.FrameworkContentElement.ToolTipOpening&quot;> </xref> [kierowane Przegląd zdarzeń](~/add/includes/ajax-current-ext-md.md)."
  remarks: "Obiekty identyfikator zdarzenia są tworzone podczas kierowane zdarzenia są rejestrowane (zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>), a następnie można dodać obsługę klas (zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> Identyfikator obiekty zawierają nazwę identyfikującą, typ właściciela typ obsługi, strategii routingu i metodę narzędzia na potrzeby dodawania właścicieli dla zdarzenia."
  syntax:
    content: public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTipProperty
  id: ToolTipProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTipProperty
  nameWithType: FrameworkContentElement.ToolTipProperty
  fullName: System.Windows.FrameworkContentElement.ToolTipProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identyfikuje <xref:System.Windows.FrameworkContentElement.ToolTip*>Właściwości zależności.</xref:System.Windows.FrameworkContentElement.ToolTip*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ToolTipProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.TryFindResource(System.Object)
  id: TryFindResource(System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: TryFindResource(Object)
  nameWithType: FrameworkContentElement.TryFindResource(Object)
  fullName: System.Windows.FrameworkContentElement.TryFindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Wyszukuje zasób z określonym kluczem, a zwraca tego zasobu, jeśli znaleziono."
  remarks: "Jeśli zasób nie zostanie znaleziony w elemencie wywołującym, drzewa nadrzędnego jest przeszukiwana przy użyciu drzewa logicznego w taki sam sposób jak drzewo będzie przeszukiwana, jeśli odwołaniem zasobu dynamicznego prosili klucza w czasie wykonywania.       Zwykle będzie natychmiast rzutowania wartości zwracanej typu właściwości, którą próbujesz ustawić o wartości zwracane zasobów.       <xref:System.Windows.FrameworkContentElement.FindResource%2A>Metody zachowanie jest podobne, z tą różnicą, że spowoduje zgłoszenie wyjątku w przypadku nie możesz znaleźć zasobu z podanego klucza.</xref:System.Windows.FrameworkContentElement.FindResource%2A>"
  example:
  - "The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.  \n  \n [!code-cs[ContentElementsSmorgasbord#TryFindResource](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#tryfindresource)]\n [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#tryfindresource)]"
  syntax:
    content: public object TryFindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "Identyfikator klucza zasobu, który ma zostać odnaleziona."
    return:
      type: System.Object
      description: "Znaleziono zasobu. Jeśli nie znaleziono zasobu, <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> jest zwracany."
  overload: System.Windows.FrameworkContentElement.TryFindResource*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Unloaded
  id: Unloaded
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Unloaded
  nameWithType: FrameworkContentElement.Unloaded
  fullName: System.Windows.FrameworkContentElement.Unloaded
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Występuje, gdy element zostanie usunięty z drzewa elementów załadowanych elementów."
  remarks: "Bezpośrednie kierowane zdarzenia nie wykonuj trasy, są obsługiwane tylko w obrębie tego samego elementu, na którym jest uruchamiany. Bezpośrednie kierowane zdarzenia obsługuje inne zachowanie kierowanego zdarzenia: obsługują dostępny obsługi kolekcji i mogą być używane jako <xref:System.Windows.EventTrigger>w stylu.</xref:System.Windows.EventTrigger>      <a name=&quot;routedEventInfo_Unloaded&quot;></a>## Przesyłane informacje o zdarzeniach |||   |-|-|   | Pole identyfikatora | <xref:System.Windows.FrameworkContentElement.UnloadedEvent>|   | Strategii routingu | Bezpośrednie |   | Delegat | <xref:System.Windows.RoutedEventHandler>|</xref:System.Windows.RoutedEventHandler></xref:System.Windows.FrameworkContentElement.UnloadedEvent>"
  syntax:
    content: public event System.Windows.RoutedEventHandler Unloaded;
    return:
      type: System.Windows.RoutedEventHandler
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.UnloadedEvent
  id: UnloadedEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: UnloadedEvent
  nameWithType: FrameworkContentElement.UnloadedEvent
  fullName: System.Windows.FrameworkContentElement.UnloadedEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Identyfikuje <xref href=&quot;System.Windows.FrameworkContentElement.Unloaded&quot;> </xref> [kierowane Przegląd zdarzeń](~/add/includes/ajax-current-ext-md.md)."
  remarks: "Obiekty identyfikator zdarzenia są tworzone podczas kierowane zdarzenia są rejestrowane (zobacz <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>), a następnie można dodać obsługę klas (zobacz <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> Identyfikator obiekty zawierają nazwę identyfikującą, typ właściciela typ obsługi, strategii routingu i metodę narzędzia na potrzeby dodawania właścicieli dla zdarzenia."
  syntax:
    content: public static readonly System.Windows.RoutedEvent UnloadedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.UnregisterName(System.String)
  id: UnregisterName(System.String)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: UnregisterName(String)
  nameWithType: FrameworkContentElement.UnregisterName(String)
  fullName: System.Windows.FrameworkContentElement.UnregisterName(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ułatwiają dostęp do <xref:System.Windows.NameScope>Dezaktywowanie rejestracji metody.</xref:System.Windows.NameScope>"
  remarks: "Wystarczy wyrejestrować nazwy Jeśli chcesz ponownie zarejestrować inny element o takiej samej nazwie."
  syntax:
    content: public void UnregisterName (string name);
    parameters:
    - id: name
      type: System.String
      description: "Nazwa pary nazwa obiektu do usunięcia z bieżącego zakresu."
  overload: System.Windows.FrameworkContentElement.UnregisterName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.UpdateDefaultStyle
  id: UpdateDefaultStyle
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: UpdateDefaultStyle()
  nameWithType: FrameworkContentElement.UpdateDefaultStyle()
  fullName: System.Windows.FrameworkContentElement.UpdateDefaultStyle()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Przywrócenie styl domyślny do bieżącego <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref>."
  syntax:
    content: public void UpdateDefaultStyle ();
    parameters: []
  overload: System.Windows.FrameworkContentElement.UpdateDefaultStyle*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.ContentElement
  isExternal: false
  name: System.Windows.ContentElement
- uid: System.Windows.ResourceReferenceKeyNotFoundException
  parent: System.Windows
  isExternal: false
  name: ResourceReferenceKeyNotFoundException
  nameWithType: ResourceReferenceKeyNotFoundException
  fullName: System.Windows.ResourceReferenceKeyNotFoundException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.Windows.FrameworkContentElement.#ctor
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FrameworkContentElement()
  nameWithType: FrameworkContentElement.FrameworkContentElement()
  fullName: System.Windows.FrameworkContentElement.FrameworkContentElement()
- uid: System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: AddLogicalChild(Object)
  nameWithType: FrameworkContentElement.AddLogicalChild(Object)
  fullName: System.Windows.FrameworkContentElement.AddLogicalChild(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.FrameworkContentElement.BeginInit
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginInit()
  nameWithType: FrameworkContentElement.BeginInit()
  fullName: System.Windows.FrameworkContentElement.BeginInit()
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginStoryboard(Storyboard)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard)
- uid: System.Windows.Media.Animation.Storyboard
  parent: System.Windows.Media.Animation
  isExternal: false
  name: Storyboard
  nameWithType: Storyboard
  fullName: System.Windows.Media.Animation.Storyboard
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginStoryboard(Storyboard,HandoffBehavior)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior)
- uid: System.Windows.Media.Animation.HandoffBehavior
  parent: System.Windows.Media.Animation
  isExternal: false
  name: HandoffBehavior
  nameWithType: HandoffBehavior
  fullName: System.Windows.Media.Animation.HandoffBehavior
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.FrameworkContentElement.BindingGroup
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BindingGroup
  nameWithType: FrameworkContentElement.BindingGroup
  fullName: System.Windows.FrameworkContentElement.BindingGroup
- uid: System.Windows.Data.BindingGroup
  parent: System.Windows.Data
  isExternal: false
  name: BindingGroup
  nameWithType: BindingGroup
  fullName: System.Windows.Data.BindingGroup
- uid: System.Windows.FrameworkContentElement.BindingGroupProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BindingGroupProperty
  nameWithType: FrameworkContentElement.BindingGroupProperty
  fullName: System.Windows.FrameworkContentElement.BindingGroupProperty
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Windows.FrameworkContentElement.BringIntoView
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BringIntoView()
  nameWithType: FrameworkContentElement.BringIntoView()
  fullName: System.Windows.FrameworkContentElement.BringIntoView()
- uid: System.Windows.FrameworkContentElement.ContextMenu
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenu
  nameWithType: FrameworkContentElement.ContextMenu
  fullName: System.Windows.FrameworkContentElement.ContextMenu
- uid: System.Windows.Controls.ContextMenu
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenu
  nameWithType: ContextMenu
  fullName: System.Windows.Controls.ContextMenu
- uid: System.Windows.FrameworkContentElement.ContextMenuClosing
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenuClosing
  nameWithType: FrameworkContentElement.ContextMenuClosing
  fullName: System.Windows.FrameworkContentElement.ContextMenuClosing
- uid: System.Windows.Controls.ContextMenuEventHandler
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenuEventHandler
  nameWithType: ContextMenuEventHandler
  fullName: System.Windows.Controls.ContextMenuEventHandler
- uid: System.Windows.FrameworkContentElement.ContextMenuClosingEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenuClosingEvent
  nameWithType: FrameworkContentElement.ContextMenuClosingEvent
  fullName: System.Windows.FrameworkContentElement.ContextMenuClosingEvent
- uid: System.Windows.RoutedEvent
  parent: System.Windows
  isExternal: false
  name: RoutedEvent
  nameWithType: RoutedEvent
  fullName: System.Windows.RoutedEvent
- uid: System.Windows.FrameworkContentElement.ContextMenuOpening
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenuOpening
  nameWithType: FrameworkContentElement.ContextMenuOpening
  fullName: System.Windows.FrameworkContentElement.ContextMenuOpening
- uid: System.Windows.FrameworkContentElement.ContextMenuOpeningEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenuOpeningEvent
  nameWithType: FrameworkContentElement.ContextMenuOpeningEvent
  fullName: System.Windows.FrameworkContentElement.ContextMenuOpeningEvent
- uid: System.Windows.FrameworkContentElement.ContextMenuProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenuProperty
  nameWithType: FrameworkContentElement.ContextMenuProperty
  fullName: System.Windows.FrameworkContentElement.ContextMenuProperty
- uid: System.Windows.FrameworkContentElement.Cursor
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Cursor
  nameWithType: FrameworkContentElement.Cursor
  fullName: System.Windows.FrameworkContentElement.Cursor
- uid: System.Windows.Input.Cursor
  parent: System.Windows.Input
  isExternal: false
  name: Cursor
  nameWithType: Cursor
  fullName: System.Windows.Input.Cursor
- uid: System.Windows.FrameworkContentElement.CursorProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: CursorProperty
  nameWithType: FrameworkContentElement.CursorProperty
  fullName: System.Windows.FrameworkContentElement.CursorProperty
- uid: System.Windows.FrameworkContentElement.DataContext
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DataContext
  nameWithType: FrameworkContentElement.DataContext
  fullName: System.Windows.FrameworkContentElement.DataContext
- uid: System.Windows.FrameworkContentElement.DataContextChanged
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DataContextChanged
  nameWithType: FrameworkContentElement.DataContextChanged
  fullName: System.Windows.FrameworkContentElement.DataContextChanged
- uid: System.Windows.DependencyPropertyChangedEventHandler
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventHandler
  nameWithType: DependencyPropertyChangedEventHandler
  fullName: System.Windows.DependencyPropertyChangedEventHandler
- uid: System.Windows.FrameworkContentElement.DataContextProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DataContextProperty
  nameWithType: FrameworkContentElement.DataContextProperty
  fullName: System.Windows.FrameworkContentElement.DataContextProperty
- uid: System.Windows.FrameworkContentElement.DefaultStyleKey
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DefaultStyleKey
  nameWithType: FrameworkContentElement.DefaultStyleKey
  fullName: System.Windows.FrameworkContentElement.DefaultStyleKey
- uid: System.Windows.FrameworkContentElement.DefaultStyleKeyProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DefaultStyleKeyProperty
  nameWithType: FrameworkContentElement.DefaultStyleKeyProperty
  fullName: System.Windows.FrameworkContentElement.DefaultStyleKeyProperty
- uid: System.Windows.FrameworkContentElement.EndInit
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: EndInit()
  nameWithType: FrameworkContentElement.EndInit()
  fullName: System.Windows.FrameworkContentElement.EndInit()
- uid: System.Windows.FrameworkContentElement.FindName(System.String)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FindName(String)
  nameWithType: FrameworkContentElement.FindName(String)
  fullName: System.Windows.FrameworkContentElement.FindName(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.FrameworkContentElement.FindResource(System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FindResource(Object)
  nameWithType: FrameworkContentElement.FindResource(Object)
  fullName: System.Windows.FrameworkContentElement.FindResource(Object)
- uid: System.Windows.FrameworkContentElement.FocusVisualStyle
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FocusVisualStyle
  nameWithType: FrameworkContentElement.FocusVisualStyle
  fullName: System.Windows.FrameworkContentElement.FocusVisualStyle
- uid: System.Windows.Style
  parent: System.Windows
  isExternal: false
  name: Style
  nameWithType: Style
  fullName: System.Windows.Style
- uid: System.Windows.FrameworkContentElement.FocusVisualStyleProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FocusVisualStyleProperty
  nameWithType: FrameworkContentElement.FocusVisualStyleProperty
  fullName: System.Windows.FrameworkContentElement.FocusVisualStyleProperty
- uid: System.Windows.FrameworkContentElement.ForceCursor
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ForceCursor
  nameWithType: FrameworkContentElement.ForceCursor
  fullName: System.Windows.FrameworkContentElement.ForceCursor
- uid: System.Windows.FrameworkContentElement.ForceCursorProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ForceCursorProperty
  nameWithType: FrameworkContentElement.ForceCursorProperty
  fullName: System.Windows.FrameworkContentElement.ForceCursorProperty
- uid: System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: GetBindingExpression(DependencyProperty)
  nameWithType: FrameworkContentElement.GetBindingExpression(DependencyProperty)
  fullName: System.Windows.FrameworkContentElement.GetBindingExpression(DependencyProperty)
- uid: System.Windows.Data.BindingExpression
  parent: System.Windows.Data
  isExternal: false
  name: BindingExpression
  nameWithType: BindingExpression
  fullName: System.Windows.Data.BindingExpression
- uid: System.Windows.FrameworkContentElement.GetUIParentCore
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: GetUIParentCore()
  nameWithType: FrameworkContentElement.GetUIParentCore()
  fullName: System.Windows.FrameworkContentElement.GetUIParentCore()
- uid: System.Windows.DependencyObject
  parent: System.Windows
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
- uid: System.Windows.FrameworkContentElement.Initialized
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Initialized
  nameWithType: FrameworkContentElement.Initialized
  fullName: System.Windows.FrameworkContentElement.Initialized
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Windows.FrameworkContentElement.InputScope
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: InputScope
  nameWithType: FrameworkContentElement.InputScope
  fullName: System.Windows.FrameworkContentElement.InputScope
- uid: System.Windows.Input.InputScope
  parent: System.Windows.Input
  isExternal: false
  name: InputScope
  nameWithType: InputScope
  fullName: System.Windows.Input.InputScope
- uid: System.Windows.FrameworkContentElement.InputScopeProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: InputScopeProperty
  nameWithType: FrameworkContentElement.InputScopeProperty
  fullName: System.Windows.FrameworkContentElement.InputScopeProperty
- uid: System.Windows.FrameworkContentElement.IsInitialized
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: IsInitialized
  nameWithType: FrameworkContentElement.IsInitialized
  fullName: System.Windows.FrameworkContentElement.IsInitialized
- uid: System.Windows.FrameworkContentElement.IsLoaded
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: IsLoaded
  nameWithType: FrameworkContentElement.IsLoaded
  fullName: System.Windows.FrameworkContentElement.IsLoaded
- uid: System.Windows.FrameworkContentElement.Language
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Language
  nameWithType: FrameworkContentElement.Language
  fullName: System.Windows.FrameworkContentElement.Language
- uid: System.Windows.Markup.XmlLanguage
  parent: System.Windows.Markup
  isExternal: false
  name: XmlLanguage
  nameWithType: XmlLanguage
  fullName: System.Windows.Markup.XmlLanguage
- uid: System.Windows.FrameworkContentElement.LanguageProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: LanguageProperty
  nameWithType: FrameworkContentElement.LanguageProperty
  fullName: System.Windows.FrameworkContentElement.LanguageProperty
- uid: System.Windows.FrameworkContentElement.Loaded
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Loaded
  nameWithType: FrameworkContentElement.Loaded
  fullName: System.Windows.FrameworkContentElement.Loaded
- uid: System.Windows.RoutedEventHandler
  parent: System.Windows
  isExternal: false
  name: RoutedEventHandler
  nameWithType: RoutedEventHandler
  fullName: System.Windows.RoutedEventHandler
- uid: System.Windows.FrameworkContentElement.LoadedEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: LoadedEvent
  nameWithType: FrameworkContentElement.LoadedEvent
  fullName: System.Windows.FrameworkContentElement.LoadedEvent
- uid: System.Windows.FrameworkContentElement.LogicalChildren
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: LogicalChildren
  nameWithType: FrameworkContentElement.LogicalChildren
  fullName: System.Windows.FrameworkContentElement.LogicalChildren
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: MoveFocus(TraversalRequest)
  nameWithType: FrameworkContentElement.MoveFocus(TraversalRequest)
  fullName: System.Windows.FrameworkContentElement.MoveFocus(TraversalRequest)
- uid: System.Windows.Input.TraversalRequest
  parent: System.Windows.Input
  isExternal: false
  name: TraversalRequest
  nameWithType: TraversalRequest
  fullName: System.Windows.Input.TraversalRequest
- uid: System.Windows.FrameworkContentElement.Name
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Name
  nameWithType: FrameworkContentElement.Name
  fullName: System.Windows.FrameworkContentElement.Name
- uid: System.Windows.FrameworkContentElement.NameProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: NameProperty
  nameWithType: FrameworkContentElement.NameProperty
  fullName: System.Windows.FrameworkContentElement.NameProperty
- uid: System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnContextMenuClosing(ContextMenuEventArgs)
  nameWithType: FrameworkContentElement.OnContextMenuClosing(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnContextMenuClosing(ContextMenuEventArgs)
- uid: System.Windows.Controls.ContextMenuEventArgs
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenuEventArgs
  nameWithType: ContextMenuEventArgs
  fullName: System.Windows.Controls.ContextMenuEventArgs
- uid: System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnContextMenuOpening(ContextMenuEventArgs)
  nameWithType: FrameworkContentElement.OnContextMenuOpening(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnContextMenuOpening(ContextMenuEventArgs)
- uid: System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnGotFocus(RoutedEventArgs)
  nameWithType: FrameworkContentElement.OnGotFocus(RoutedEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnGotFocus(RoutedEventArgs)
- uid: System.Windows.RoutedEventArgs
  parent: System.Windows
  isExternal: false
  name: RoutedEventArgs
  nameWithType: RoutedEventArgs
  fullName: System.Windows.RoutedEventArgs
- uid: System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnInitialized(EventArgs)
  nameWithType: FrameworkContentElement.OnInitialized(EventArgs)
  fullName: System.Windows.FrameworkContentElement.OnInitialized(EventArgs)
- uid: System.EventArgs
  parent: System
  isExternal: true
  name: EventArgs
  nameWithType: EventArgs
  fullName: System.EventArgs
- uid: System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnPropertyChanged(DependencyPropertyChangedEventArgs)
  nameWithType: FrameworkContentElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.DependencyPropertyChangedEventArgs
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventArgs
  nameWithType: DependencyPropertyChangedEventArgs
  fullName: System.Windows.DependencyPropertyChangedEventArgs
- uid: System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnStyleChanged(Style,Style)
  nameWithType: FrameworkContentElement.OnStyleChanged(Style,Style)
  fullName: System.Windows.FrameworkContentElement.OnStyleChanged(Style,Style)
- uid: System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnToolTipClosing(ToolTipEventArgs)
  nameWithType: FrameworkContentElement.OnToolTipClosing(ToolTipEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnToolTipClosing(ToolTipEventArgs)
- uid: System.Windows.Controls.ToolTipEventArgs
  parent: System.Windows.Controls
  isExternal: false
  name: ToolTipEventArgs
  nameWithType: ToolTipEventArgs
  fullName: System.Windows.Controls.ToolTipEventArgs
- uid: System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnToolTipOpening(ToolTipEventArgs)
  nameWithType: FrameworkContentElement.OnToolTipOpening(ToolTipEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnToolTipOpening(ToolTipEventArgs)
- uid: System.Windows.FrameworkContentElement.OverridesDefaultStyle
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OverridesDefaultStyle
  nameWithType: FrameworkContentElement.OverridesDefaultStyle
  fullName: System.Windows.FrameworkContentElement.OverridesDefaultStyle
- uid: System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OverridesDefaultStyleProperty
  nameWithType: FrameworkContentElement.OverridesDefaultStyleProperty
  fullName: System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty
- uid: System.Windows.FrameworkContentElement.Parent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Parent
  nameWithType: FrameworkContentElement.Parent
  fullName: System.Windows.FrameworkContentElement.Parent
- uid: System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: PredictFocus(FocusNavigationDirection)
  nameWithType: FrameworkContentElement.PredictFocus(FocusNavigationDirection)
  fullName: System.Windows.FrameworkContentElement.PredictFocus(FocusNavigationDirection)
- uid: System.Windows.Input.FocusNavigationDirection
  parent: System.Windows.Input
  isExternal: false
  name: FocusNavigationDirection
  nameWithType: FocusNavigationDirection
  fullName: System.Windows.Input.FocusNavigationDirection
- uid: System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: RegisterName(String,Object)
  nameWithType: FrameworkContentElement.RegisterName(String,Object)
  fullName: System.Windows.FrameworkContentElement.RegisterName(String,Object)
- uid: System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: RemoveLogicalChild(Object)
  nameWithType: FrameworkContentElement.RemoveLogicalChild(Object)
  fullName: System.Windows.FrameworkContentElement.RemoveLogicalChild(Object)
- uid: System.Windows.FrameworkContentElement.Resources
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Resources
  nameWithType: FrameworkContentElement.Resources
  fullName: System.Windows.FrameworkContentElement.Resources
- uid: System.Windows.ResourceDictionary
  parent: System.Windows
  isExternal: false
  name: ResourceDictionary
  nameWithType: ResourceDictionary
  fullName: System.Windows.ResourceDictionary
- uid: System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SetBinding(DependencyProperty,String)
  nameWithType: FrameworkContentElement.SetBinding(DependencyProperty,String)
  fullName: System.Windows.FrameworkContentElement.SetBinding(DependencyProperty,String)
- uid: System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SetBinding(DependencyProperty,BindingBase)
  nameWithType: FrameworkContentElement.SetBinding(DependencyProperty,BindingBase)
  fullName: System.Windows.FrameworkContentElement.SetBinding(DependencyProperty,BindingBase)
- uid: System.Windows.Data.BindingExpressionBase
  parent: System.Windows.Data
  isExternal: false
  name: BindingExpressionBase
  nameWithType: BindingExpressionBase
  fullName: System.Windows.Data.BindingExpressionBase
- uid: System.Windows.Data.BindingBase
  parent: System.Windows.Data
  isExternal: false
  name: BindingBase
  nameWithType: BindingBase
  fullName: System.Windows.Data.BindingBase
- uid: System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SetResourceReference(DependencyProperty,Object)
  nameWithType: FrameworkContentElement.SetResourceReference(DependencyProperty,Object)
  fullName: System.Windows.FrameworkContentElement.SetResourceReference(DependencyProperty,Object)
- uid: System.Windows.FrameworkContentElement.ShouldSerializeResources
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ShouldSerializeResources()
  nameWithType: FrameworkContentElement.ShouldSerializeResources()
  fullName: System.Windows.FrameworkContentElement.ShouldSerializeResources()
- uid: System.Windows.FrameworkContentElement.ShouldSerializeStyle
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ShouldSerializeStyle()
  nameWithType: FrameworkContentElement.ShouldSerializeStyle()
  fullName: System.Windows.FrameworkContentElement.ShouldSerializeStyle()
- uid: System.Windows.FrameworkContentElement.SourceUpdated
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SourceUpdated
  nameWithType: FrameworkContentElement.SourceUpdated
  fullName: System.Windows.FrameworkContentElement.SourceUpdated
- uid: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<DataTransferEventArgs>
  nameWithType: EventHandler<DataTransferEventArgs>
  fullName: System.EventHandler<System.Windows.Data.DataTransferEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Windows.Data.DataTransferEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Windows.Data.DataTransferEventArgs
    name: DataTransferEventArgs
    nameWithType: DataTransferEventArgs
    fullName: DataTransferEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.FrameworkContentElement.Style
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Style
  nameWithType: FrameworkContentElement.Style
  fullName: System.Windows.FrameworkContentElement.Style
- uid: System.Windows.FrameworkContentElement.StyleProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: StyleProperty
  nameWithType: FrameworkContentElement.StyleProperty
  fullName: System.Windows.FrameworkContentElement.StyleProperty
- uid: System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: FrameworkContentElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.FrameworkContentElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
- uid: System.Windows.FrameworkContentElement.Tag
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Tag
  nameWithType: FrameworkContentElement.Tag
  fullName: System.Windows.FrameworkContentElement.Tag
- uid: System.Windows.FrameworkContentElement.TagProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TagProperty
  nameWithType: FrameworkContentElement.TagProperty
  fullName: System.Windows.FrameworkContentElement.TagProperty
- uid: System.Windows.FrameworkContentElement.TargetUpdated
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TargetUpdated
  nameWithType: FrameworkContentElement.TargetUpdated
  fullName: System.Windows.FrameworkContentElement.TargetUpdated
- uid: System.Windows.FrameworkContentElement.TemplatedParent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TemplatedParent
  nameWithType: FrameworkContentElement.TemplatedParent
  fullName: System.Windows.FrameworkContentElement.TemplatedParent
- uid: System.Windows.FrameworkContentElement.ToolTip
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTip
  nameWithType: FrameworkContentElement.ToolTip
  fullName: System.Windows.FrameworkContentElement.ToolTip
- uid: System.Windows.FrameworkContentElement.ToolTipClosing
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTipClosing
  nameWithType: FrameworkContentElement.ToolTipClosing
  fullName: System.Windows.FrameworkContentElement.ToolTipClosing
- uid: System.Windows.Controls.ToolTipEventHandler
  parent: System.Windows.Controls
  isExternal: false
  name: ToolTipEventHandler
  nameWithType: ToolTipEventHandler
  fullName: System.Windows.Controls.ToolTipEventHandler
- uid: System.Windows.FrameworkContentElement.ToolTipClosingEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTipClosingEvent
  nameWithType: FrameworkContentElement.ToolTipClosingEvent
  fullName: System.Windows.FrameworkContentElement.ToolTipClosingEvent
- uid: System.Windows.FrameworkContentElement.ToolTipOpening
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTipOpening
  nameWithType: FrameworkContentElement.ToolTipOpening
  fullName: System.Windows.FrameworkContentElement.ToolTipOpening
- uid: System.Windows.FrameworkContentElement.ToolTipOpeningEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTipOpeningEvent
  nameWithType: FrameworkContentElement.ToolTipOpeningEvent
  fullName: System.Windows.FrameworkContentElement.ToolTipOpeningEvent
- uid: System.Windows.FrameworkContentElement.ToolTipProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTipProperty
  nameWithType: FrameworkContentElement.ToolTipProperty
  fullName: System.Windows.FrameworkContentElement.ToolTipProperty
- uid: System.Windows.FrameworkContentElement.TryFindResource(System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TryFindResource(Object)
  nameWithType: FrameworkContentElement.TryFindResource(Object)
  fullName: System.Windows.FrameworkContentElement.TryFindResource(Object)
- uid: System.Windows.FrameworkContentElement.Unloaded
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Unloaded
  nameWithType: FrameworkContentElement.Unloaded
  fullName: System.Windows.FrameworkContentElement.Unloaded
- uid: System.Windows.FrameworkContentElement.UnloadedEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: UnloadedEvent
  nameWithType: FrameworkContentElement.UnloadedEvent
  fullName: System.Windows.FrameworkContentElement.UnloadedEvent
- uid: System.Windows.FrameworkContentElement.UnregisterName(System.String)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: UnregisterName(String)
  nameWithType: FrameworkContentElement.UnregisterName(String)
  fullName: System.Windows.FrameworkContentElement.UnregisterName(String)
- uid: System.Windows.FrameworkContentElement.UpdateDefaultStyle
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: UpdateDefaultStyle()
  nameWithType: FrameworkContentElement.UpdateDefaultStyle()
  fullName: System.Windows.FrameworkContentElement.UpdateDefaultStyle()
- uid: System.Windows.FrameworkContentElement.#ctor*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FrameworkContentElement
  nameWithType: FrameworkContentElement.FrameworkContentElement
- uid: System.Windows.FrameworkContentElement.AddLogicalChild*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: AddLogicalChild
  nameWithType: FrameworkContentElement.AddLogicalChild
- uid: System.Windows.FrameworkContentElement.BeginInit*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginInit
  nameWithType: FrameworkContentElement.BeginInit
- uid: System.Windows.FrameworkContentElement.BeginStoryboard*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginStoryboard
  nameWithType: FrameworkContentElement.BeginStoryboard
- uid: System.Windows.FrameworkContentElement.BindingGroup*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BindingGroup
  nameWithType: FrameworkContentElement.BindingGroup
- uid: System.Windows.FrameworkContentElement.BringIntoView*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BringIntoView
  nameWithType: FrameworkContentElement.BringIntoView
- uid: System.Windows.FrameworkContentElement.ContextMenu*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenu
  nameWithType: FrameworkContentElement.ContextMenu
- uid: System.Windows.FrameworkContentElement.Cursor*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Cursor
  nameWithType: FrameworkContentElement.Cursor
- uid: System.Windows.FrameworkContentElement.DataContext*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DataContext
  nameWithType: FrameworkContentElement.DataContext
- uid: System.Windows.FrameworkContentElement.DefaultStyleKey*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DefaultStyleKey
  nameWithType: FrameworkContentElement.DefaultStyleKey
- uid: System.Windows.FrameworkContentElement.EndInit*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: EndInit
  nameWithType: FrameworkContentElement.EndInit
- uid: System.Windows.FrameworkContentElement.FindName*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FindName
  nameWithType: FrameworkContentElement.FindName
- uid: System.Windows.FrameworkContentElement.FindResource*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FindResource
  nameWithType: FrameworkContentElement.FindResource
- uid: System.Windows.FrameworkContentElement.FocusVisualStyle*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FocusVisualStyle
  nameWithType: FrameworkContentElement.FocusVisualStyle
- uid: System.Windows.FrameworkContentElement.ForceCursor*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ForceCursor
  nameWithType: FrameworkContentElement.ForceCursor
- uid: System.Windows.FrameworkContentElement.GetBindingExpression*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: GetBindingExpression
  nameWithType: FrameworkContentElement.GetBindingExpression
- uid: System.Windows.FrameworkContentElement.GetUIParentCore*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: GetUIParentCore
  nameWithType: FrameworkContentElement.GetUIParentCore
- uid: System.Windows.FrameworkContentElement.InputScope*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: InputScope
  nameWithType: FrameworkContentElement.InputScope
- uid: System.Windows.FrameworkContentElement.IsInitialized*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: IsInitialized
  nameWithType: FrameworkContentElement.IsInitialized
- uid: System.Windows.FrameworkContentElement.IsLoaded*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: IsLoaded
  nameWithType: FrameworkContentElement.IsLoaded
- uid: System.Windows.FrameworkContentElement.Language*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Language
  nameWithType: FrameworkContentElement.Language
- uid: System.Windows.FrameworkContentElement.LogicalChildren*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: LogicalChildren
  nameWithType: FrameworkContentElement.LogicalChildren
- uid: System.Windows.FrameworkContentElement.MoveFocus*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: MoveFocus
  nameWithType: FrameworkContentElement.MoveFocus
- uid: System.Windows.FrameworkContentElement.Name*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Name
  nameWithType: FrameworkContentElement.Name
- uid: System.Windows.FrameworkContentElement.OnContextMenuClosing*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnContextMenuClosing
  nameWithType: FrameworkContentElement.OnContextMenuClosing
- uid: System.Windows.FrameworkContentElement.OnContextMenuOpening*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnContextMenuOpening
  nameWithType: FrameworkContentElement.OnContextMenuOpening
- uid: System.Windows.FrameworkContentElement.OnGotFocus*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnGotFocus
  nameWithType: FrameworkContentElement.OnGotFocus
- uid: System.Windows.FrameworkContentElement.OnInitialized*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnInitialized
  nameWithType: FrameworkContentElement.OnInitialized
- uid: System.Windows.FrameworkContentElement.OnPropertyChanged*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnPropertyChanged
  nameWithType: FrameworkContentElement.OnPropertyChanged
- uid: System.Windows.FrameworkContentElement.OnStyleChanged*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnStyleChanged
  nameWithType: FrameworkContentElement.OnStyleChanged
- uid: System.Windows.FrameworkContentElement.OnToolTipClosing*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnToolTipClosing
  nameWithType: FrameworkContentElement.OnToolTipClosing
- uid: System.Windows.FrameworkContentElement.OnToolTipOpening*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnToolTipOpening
  nameWithType: FrameworkContentElement.OnToolTipOpening
- uid: System.Windows.FrameworkContentElement.OverridesDefaultStyle*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OverridesDefaultStyle
  nameWithType: FrameworkContentElement.OverridesDefaultStyle
- uid: System.Windows.FrameworkContentElement.Parent*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Parent
  nameWithType: FrameworkContentElement.Parent
- uid: System.Windows.FrameworkContentElement.PredictFocus*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: PredictFocus
  nameWithType: FrameworkContentElement.PredictFocus
- uid: System.Windows.FrameworkContentElement.RegisterName*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: RegisterName
  nameWithType: FrameworkContentElement.RegisterName
- uid: System.Windows.FrameworkContentElement.RemoveLogicalChild*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: RemoveLogicalChild
  nameWithType: FrameworkContentElement.RemoveLogicalChild
- uid: System.Windows.FrameworkContentElement.Resources*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Resources
  nameWithType: FrameworkContentElement.Resources
- uid: System.Windows.FrameworkContentElement.SetBinding*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SetBinding
  nameWithType: FrameworkContentElement.SetBinding
- uid: System.Windows.FrameworkContentElement.SetResourceReference*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SetResourceReference
  nameWithType: FrameworkContentElement.SetResourceReference
- uid: System.Windows.FrameworkContentElement.ShouldSerializeResources*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ShouldSerializeResources
  nameWithType: FrameworkContentElement.ShouldSerializeResources
- uid: System.Windows.FrameworkContentElement.ShouldSerializeStyle*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ShouldSerializeStyle
  nameWithType: FrameworkContentElement.ShouldSerializeStyle
- uid: System.Windows.FrameworkContentElement.Style*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Style
  nameWithType: FrameworkContentElement.Style
- uid: System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
  nameWithType: FrameworkContentElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
- uid: System.Windows.FrameworkContentElement.Tag*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Tag
  nameWithType: FrameworkContentElement.Tag
- uid: System.Windows.FrameworkContentElement.TemplatedParent*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TemplatedParent
  nameWithType: FrameworkContentElement.TemplatedParent
- uid: System.Windows.FrameworkContentElement.ToolTip*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTip
  nameWithType: FrameworkContentElement.ToolTip
- uid: System.Windows.FrameworkContentElement.TryFindResource*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TryFindResource
  nameWithType: FrameworkContentElement.TryFindResource
- uid: System.Windows.FrameworkContentElement.UnregisterName*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: UnregisterName
  nameWithType: FrameworkContentElement.UnregisterName
- uid: System.Windows.FrameworkContentElement.UpdateDefaultStyle*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: UpdateDefaultStyle
  nameWithType: FrameworkContentElement.UpdateDefaultStyle
