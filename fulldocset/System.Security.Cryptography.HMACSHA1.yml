### YamlMime:ManagedReference
items:
- uid: System.Security.Cryptography.HMACSHA1
  id: HMACSHA1
  children:
  - System.Security.Cryptography.HMACSHA1.#ctor
  - System.Security.Cryptography.HMACSHA1.#ctor(System.Byte[])
  - System.Security.Cryptography.HMACSHA1.#ctor(System.Byte[],System.Boolean)
  langs:
  - csharp
  name: HMACSHA1
  nameWithType: HMACSHA1
  fullName: System.Security.Cryptography.HMACSHA1
  type: Class
  summary: "Hash-based oblicza kod uwierzytelniania wiadomości (HMAC) przy użyciu <xref href=&quot;System.Security.Cryptography.SHA1&quot;> </xref> funkcji generowania skrótów."
  remarks: "HMACSHA1 jest typem algorytm skrótu z kluczem jest utworzone na podstawie funkcji skrótu SHA1, używane jako HMAC lub kod uwierzytelniania wiadomości oparty na wyznaczania wartości skrótu. Proces HMAC łączy klucz tajny z danymi wiadomości, tworzy skrót wyniku przy użyciu funkcji skrótu, łączy skrót z kluczem tajnym ponownie, a następnie stosuje funkcję skrótu po raz drugi. Wynikowy skrót ma długość 160 bitów.       HMAC może służyć do określenia, czy została naruszona komunikatu wysłanego za pośrednictwem niezabezpieczonego kanału, pod warunkiem, że nadawca i odbiorca udostępnić klucz tajny. Nadawca oblicza wartość skrótu dla oryginalnych danych i wysyła oryginalnych danych i wartości skrótu jako pojedynczej wiadomości. Odbiornik ponownie oblicza wartość skrótu dla odebranego komunikatu i sprawdza, czy obliczona HMAC zgodny przesyłane HMAC.       Każda zmiana danych lub wartość skrótu powoduje niezgodność, ponieważ wiedzy tajny klucz jest wymagany do zmienić komunikat i Odtwórz wartość skrótu poprawne. W związku z tym jeśli wartości skrótu oryginalny i obliczona zgodne, wiadomość została uwierzytelniona.       SHA-1 (Secure Hash Algorithm, nazywany również SHS Secure Hash standardowe) jest algorytm skrótu kryptograficznego opublikowanych przez Rząd Stanów Zjednoczonych. Generuje wartość skrótu 160-bitowy z dowolnej długości ciągu.       HMACSHA1 akceptuje klucze o dowolnym rozmiarze i tworzy sekwencję wyznaczania wartości skrótu, która jest 160 bitów długości."
  example:
  - "The following code example shows how to sign a file by using the HMACSHA1 object and then how to verify the file.  \n  \n [!code-cs[HMACSHA1#1](~/add/codesnippet/csharp/t-system.security.crypto_82_1.cs)]\n [!code-cpp[HMACSHA1#1](~/add/codesnippet/cpp/t-system.security.crypto_82_1.cpp)]\n [!code-vb[HMACSHA1#1](~/add/codesnippet/visualbasic/t-system.security.crypto_82_1.vb)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public class HMACSHA1 : System.Security.Cryptography.HMAC
  inheritance:
  - System.Object
  - System.Security.Cryptography.HashAlgorithm
  - System.Security.Cryptography.KeyedHashAlgorithm
  - System.Security.Cryptography.HMAC
  implements: []
  inheritedMembers:
  - System.Security.Cryptography.HashAlgorithm.CanReuseTransform
  - System.Security.Cryptography.HashAlgorithm.CanTransformMultipleBlocks
  - System.Security.Cryptography.HashAlgorithm.Clear
  - System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[])
  - System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[],System.Int32,System.Int32)
  - System.Security.Cryptography.HashAlgorithm.ComputeHash(System.IO.Stream)
  - System.Security.Cryptography.HashAlgorithm.Dispose
  - System.Security.Cryptography.HashAlgorithm.Hash
  - System.Security.Cryptography.HashAlgorithm.HashSize
  - System.Security.Cryptography.HashAlgorithm.HashSizeValue
  - System.Security.Cryptography.HashAlgorithm.HashValue
  - System.Security.Cryptography.HashAlgorithm.InputBlockSize
  - System.Security.Cryptography.HashAlgorithm.OutputBlockSize
  - System.Security.Cryptography.HashAlgorithm.State
  - System.Security.Cryptography.HashAlgorithm.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)
  - System.Security.Cryptography.HashAlgorithm.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)
  - System.Security.Cryptography.HMAC.BlockSizeValue
  - System.Security.Cryptography.HMAC.Create
  - System.Security.Cryptography.HMAC.Create(System.String)
  - System.Security.Cryptography.HMAC.Dispose(System.Boolean)
  - System.Security.Cryptography.HMAC.HashCore(System.Byte[],System.Int32,System.Int32)
  - System.Security.Cryptography.HMAC.HashFinal
  - System.Security.Cryptography.HMAC.HashName
  - System.Security.Cryptography.HMAC.Initialize
  - System.Security.Cryptography.HMAC.Key
  - System.Security.Cryptography.KeyedHashAlgorithm.KeyValue
  platform:
  - net462
- uid: System.Security.Cryptography.HMACSHA1.#ctor
  id: '#ctor'
  parent: System.Security.Cryptography.HMACSHA1
  langs:
  - csharp
  name: HMACSHA1()
  nameWithType: HMACSHA1.HMACSHA1()
  fullName: System.Security.Cryptography.HMACSHA1.HMACSHA1()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Security.Cryptography.HMACSHA1&quot;> </xref> klasy z losowo wygenerowany klucz."
  remarks: "<xref:System.Security.Cryptography.HMACSHA1>jest typem algorytm skrótu z kluczem jest utworzone na podstawie funkcji skrótu SHA1, używane jako HMAC lub kod uwierzytelniania wiadomości oparty na wyznaczania wartości skrótu.</xref:System.Security.Cryptography.HMACSHA1> Proces HMAC łączy klucz tajny z danymi wiadomości, tworzy skrót wyniku przy użyciu funkcji skrótu, łączy skrót z kluczem tajnym ponownie, a następnie stosuje funkcję skrótu po raz drugi. Wynikowy skrót ma długość 160 bitów (20 bajtów).       Ten konstruktor korzysta z 64-bajtowych, losowo wygenerowany klucz."
  syntax:
    content: public HMACSHA1 ();
    parameters: []
  overload: System.Security.Cryptography.HMACSHA1.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Cryptography.HMACSHA1.#ctor(System.Byte[])
  id: '#ctor(System.Byte[])'
  parent: System.Security.Cryptography.HMACSHA1
  langs:
  - csharp
  name: HMACSHA1(Byte[])
  nameWithType: HMACSHA1.HMACSHA1(Byte[])
  fullName: System.Security.Cryptography.HMACSHA1.HMACSHA1(Byte[])
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Security.Cryptography.HMACSHA1&quot;> </xref> klasy z określonymi danymi klucza."
  remarks: "<xref:System.Security.Cryptography.HMACSHA1>jest typem algorytm skrótu z kluczem jest utworzone na podstawie funkcji skrótu SHA1, używane jako HMAC lub kod uwierzytelniania wiadomości oparty na wyznaczania wartości skrótu.</xref:System.Security.Cryptography.HMACSHA1> Proces HMAC łączy klucz tajny z danymi wiadomości, tworzy skrót wyniku przy użyciu funkcji skrótu, łączy skrót z kluczem tajnym ponownie, a następnie stosuje funkcję skrótu po raz drugi. Wynikowy skrót ma długość 160 bitów (20 bajtów).      > [!NOTE] > Ten konstruktor tworzy wystąpienie niezarządzane algorytmu przy użyciu <xref:System.Security.Cryptography.SHA1CryptoServiceProvider>klasy.</xref:System.Security.Cryptography.SHA1CryptoServiceProvider>"
  example:
  - For an example of how to use this constructor, see the <xref:System.Security.Cryptography.HMACSHA1> class.
  syntax:
    content: public HMACSHA1 (byte[] key);
    parameters:
    - id: key
      type: System.Byte[]
      description: "Klucz tajny dla <xref href=&quot;System.Security.Cryptography.HMACSHA1&quot;> </xref> szyfrowania. Klucz może być dowolną długość, ale jeśli jest więcej niż 64 bajtów jego skrót jest tworzony (przy użyciu algorytmu SHA-1) do uzyskania klucza 64 bajtów. W związku z tym zalecany rozmiar klucz tajny jest 64 bajtów."
  overload: System.Security.Cryptography.HMACSHA1.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>key</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.Cryptography.HMACSHA1.#ctor(System.Byte[],System.Boolean)
  id: '#ctor(System.Byte[],System.Boolean)'
  parent: System.Security.Cryptography.HMACSHA1
  langs:
  - csharp
  name: HMACSHA1(Byte[],Boolean)
  nameWithType: HMACSHA1.HMACSHA1(Byte[],Boolean)
  fullName: System.Security.Cryptography.HMACSHA1.HMACSHA1(Byte[],Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Cryptography
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Security.Cryptography.HMACSHA1&quot;> </xref> z określonych danych klucza i wartość, która określa, czy użyć wersji zarządzanych algorytmu SHA1."
  syntax:
    content: public HMACSHA1 (byte[] key, bool useManagedSha1);
    parameters:
    - id: key
      type: System.Byte[]
      description: "Klucz tajny dla <xref href=&quot;System.Security.Cryptography.HMACSHA1&quot;> </xref> szyfrowania. Klucz może być dowolną długość, ale jeśli jest więcej niż 64 bajtów, jego skrót jest tworzony (przy użyciu algorytmu SHA-1) do uzyskania klucza 64 bajtów. W związku z tym zalecany rozmiar klucz tajny jest 64 bajtów."
    - id: useManagedSha1
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby użyć zarządzaną implementację algorytmu SHA1 ( <xref href=&quot;System.Security.Cryptography.SHA1Managed&quot;> </xref> klasy); <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> można użyć implementacji niezarządzane ( <xref href=&quot;System.Security.Cryptography.SHA1CryptoServiceProvider&quot;> </xref> klasy)."
  overload: System.Security.Cryptography.HMACSHA1.#ctor*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Security.Cryptography.HMAC
  isExternal: false
  name: System.Security.Cryptography.HMAC
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.Security.Cryptography.HMACSHA1.#ctor
  parent: System.Security.Cryptography.HMACSHA1
  isExternal: false
  name: HMACSHA1()
  nameWithType: HMACSHA1.HMACSHA1()
  fullName: System.Security.Cryptography.HMACSHA1.HMACSHA1()
- uid: System.Security.Cryptography.HMACSHA1.#ctor(System.Byte[])
  parent: System.Security.Cryptography.HMACSHA1
  isExternal: false
  name: HMACSHA1(Byte[])
  nameWithType: HMACSHA1.HMACSHA1(Byte[])
  fullName: System.Security.Cryptography.HMACSHA1.HMACSHA1(Byte[])
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Security.Cryptography.HMACSHA1.#ctor(System.Byte[],System.Boolean)
  parent: System.Security.Cryptography.HMACSHA1
  isExternal: false
  name: HMACSHA1(Byte[],Boolean)
  nameWithType: HMACSHA1.HMACSHA1(Byte[],Boolean)
  fullName: System.Security.Cryptography.HMACSHA1.HMACSHA1(Byte[],Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Security.Cryptography.HMACSHA1.#ctor*
  parent: System.Security.Cryptography.HMACSHA1
  isExternal: false
  name: HMACSHA1
  nameWithType: HMACSHA1.HMACSHA1
