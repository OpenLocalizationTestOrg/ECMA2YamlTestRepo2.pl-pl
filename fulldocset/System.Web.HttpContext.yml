### YamlMime:ManagedReference
items:
- uid: System.Web.HttpContext
  id: HttpContext
  children:
  - System.Web.HttpContext.#ctor(System.Web.HttpWorkerRequest)
  - System.Web.HttpContext.#ctor(System.Web.HttpRequest,System.Web.HttpResponse)
  - System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})
  - System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)
  - System.Web.HttpContext.AddError(System.Exception)
  - System.Web.HttpContext.AddOnRequestCompleted(System.Action{System.Web.HttpContext})
  - System.Web.HttpContext.AllErrors
  - System.Web.HttpContext.AllowAsyncDuringSyncStages
  - System.Web.HttpContext.Application
  - System.Web.HttpContext.ApplicationInstance
  - System.Web.HttpContext.AsyncPreloadMode
  - System.Web.HttpContext.Cache
  - System.Web.HttpContext.ClearError
  - System.Web.HttpContext.Current
  - System.Web.HttpContext.CurrentHandler
  - System.Web.HttpContext.CurrentNotification
  - System.Web.HttpContext.DisposeOnPipelineCompleted(System.IDisposable)
  - System.Web.HttpContext.Error
  - System.Web.HttpContext.GetAppConfig(System.String)
  - System.Web.HttpContext.GetConfig(System.String)
  - System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String)
  - System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)
  - System.Web.HttpContext.GetLocalResourceObject(System.String,System.String)
  - System.Web.HttpContext.GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)
  - System.Web.HttpContext.GetSection(System.String)
  - System.Web.HttpContext.Handler
  - System.Web.HttpContext.IsCustomErrorEnabled
  - System.Web.HttpContext.IsDebuggingEnabled
  - System.Web.HttpContext.IsPostNotification
  - System.Web.HttpContext.IsWebSocketRequest
  - System.Web.HttpContext.IsWebSocketRequestUpgrading
  - System.Web.HttpContext.Items
  - System.Web.HttpContext.PageInstrumentation
  - System.Web.HttpContext.PreviousHandler
  - System.Web.HttpContext.Profile
  - System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)
  - System.Web.HttpContext.Request
  - System.Web.HttpContext.Response
  - System.Web.HttpContext.RewritePath(System.String)
  - System.Web.HttpContext.RewritePath(System.String,System.Boolean)
  - System.Web.HttpContext.RewritePath(System.String,System.String,System.String)
  - System.Web.HttpContext.RewritePath(System.String,System.String,System.String,System.Boolean)
  - System.Web.HttpContext.Server
  - System.Web.HttpContext.Session
  - System.Web.HttpContext.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)
  - System.Web.HttpContext.SkipAuthorization
  - System.Web.HttpContext.System#IServiceProvider#GetService(System.Type)
  - System.Web.HttpContext.ThreadAbortOnTimeout
  - System.Web.HttpContext.Timestamp
  - System.Web.HttpContext.Trace
  - System.Web.HttpContext.User
  - System.Web.HttpContext.WebSocketNegotiatedProtocol
  - System.Web.HttpContext.WebSocketRequestedProtocols
  langs:
  - csharp
  name: HttpContext
  nameWithType: HttpContext
  fullName: System.Web.HttpContext
  type: Class
  summary: "Hermetyzuje wszystkie informacje specyficzne dla protokołu HTTP dotyczące indywidualnego żądania HTTP."
  remarks: "Klasy, które dziedziczą <xref:System.Web.IHttpModule>i <xref:System.Web.IHttpHandler>interfejsy odwołanie do obiektu element HttpContext dla bieżącego żądania HTTP.</xref:System.Web.IHttpHandler> </xref:System.Web.IHttpModule> Obiekt zapewnia dostęp do wewnętrznych <xref:System.Web.HttpContext.Request%2A>, <xref:System.Web.HttpContext.Response%2A>, i <xref:System.Web.HttpContext.Server%2A>Właściwości dla żądania.</xref:System.Web.HttpContext.Server%2A> </xref:System.Web.HttpContext.Response%2A> </xref:System.Web.HttpContext.Request%2A>"
  example:
  - "A Visual Studio Web site project with source code is available to accompany this topic: [Download](http://go.microsoft.com/fwlink/?LinkId=192422).  \n  \n The following example demonstrates how to access and display properties of the HttpContext object. The context of the current HTTP request is accessed by using the <xref:System.Web.UI.Page.Context%2A> property of the <xref:System.Web.UI.Page> object.  \n  \n [!code-vb[System.Web.HttpContext#1](~/add/codesnippet/visualbasic/t-system.web.httpcontext_1.aspx)]\n [!code-cs[System.Web.HttpContext#1](~/add/codesnippet/csharp/t-system.web.httpcontext_1.aspx)]"
  syntax:
    content: 'public sealed class HttpContext : IServiceProvider'
  inheritance:
  - System.Object
  implements:
  - System.IServiceProvider
  inheritedMembers: []
  platform:
  - net462
- uid: System.Web.HttpContext.#ctor(System.Web.HttpWorkerRequest)
  id: '#ctor(System.Web.HttpWorkerRequest)'
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: HttpContext(HttpWorkerRequest)
  nameWithType: HttpContext.HttpContext(HttpWorkerRequest)
  fullName: System.Web.HttpContext.HttpContext(HttpWorkerRequest)
  type: Constructor
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Web.HttpContext&quot;> </xref> klasy, która używa obiektu określonego żądania procesu roboczego."
  syntax:
    content: public HttpContext (System.Web.HttpWorkerRequest wr);
    parameters:
    - id: wr
      type: System.Web.HttpWorkerRequest
      description: "<xref href=&quot;System.Web.HttpWorkerRequest&quot;> </xref> Dla bieżącego żądania HTTP."
  overload: System.Web.HttpContext.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.#ctor(System.Web.HttpRequest,System.Web.HttpResponse)
  id: '#ctor(System.Web.HttpRequest,System.Web.HttpResponse)'
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: HttpContext(HttpRequest,HttpResponse)
  nameWithType: HttpContext.HttpContext(HttpRequest,HttpResponse)
  fullName: System.Web.HttpContext.HttpContext(HttpRequest,HttpResponse)
  type: Constructor
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Web.HttpContext&quot;> </xref> przy użyciu określonych obiektów żądania i odpowiedzi."
  syntax:
    content: public HttpContext (System.Web.HttpRequest request, System.Web.HttpResponse response);
    parameters:
    - id: request
      type: System.Web.HttpRequest
      description: "<xref href=&quot;System.Web.HttpRequest&quot;> </xref> Dla bieżącego żądania HTTP."
    - id: response
      type: System.Web.HttpResponse
      description: "<xref href=&quot;System.Web.HttpResponse&quot;> </xref> Dla bieżącego żądania HTTP."
  overload: System.Web.HttpContext.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})
  id: AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: AcceptWebSocketRequest(Func<AspNetWebSocketContext,Task>)
  nameWithType: HttpContext.AcceptWebSocketRequest(Func<AspNetWebSocketContext,Task>)
  fullName: System.Web.HttpContext.AcceptWebSocketRequest(Func<AspNetWebSocketContext,Task>)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Akceptuje <xref href=&quot;System.Web.WebSockets.AspNetWebSocket&quot;> </xref> żądania przy użyciu określonej funkcji użytkownika."
  remarks: "Wywołanie tej metody jest odpowiednikiem wywołania <xref:System.Web.HttpContext.AcceptWebSocketRequest%2A>przeciążenie metody i przekazywanie `null` dla `options` parametru.</xref:System.Web.HttpContext.AcceptWebSocketRequest%2A>"
  syntax:
    content: public void AcceptWebSocketRequest (Func<System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task> userFunc);
    parameters:
    - id: userFunc
      type: System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task}
      description: "Funkcja użytkownika."
  overload: System.Web.HttpContext.AcceptWebSocketRequest*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>userFunc</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Żądanie nie jest <xref href=&quot;System.Web.WebSockets.AspNetWebSocket&quot;> </xref> żądania."
  platform:
  - net462
- uid: System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)
  id: AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: AcceptWebSocketRequest(Func<AspNetWebSocketContext,Task>,AspNetWebSocketOptions)
  nameWithType: HttpContext.AcceptWebSocketRequest(Func<AspNetWebSocketContext,Task>,AspNetWebSocketOptions)
  fullName: System.Web.HttpContext.AcceptWebSocketRequest(Func<AspNetWebSocketContext,Task>,AspNetWebSocketOptions)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Akceptuje <xref href=&quot;System.Web.WebSockets.AspNetWebSocket&quot;> </xref> żądania przy użyciu funkcji i opcje obiektu określonego użytkownika."
  syntax:
    content: public void AcceptWebSocketRequest (Func<System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task> userFunc, System.Web.WebSockets.AspNetWebSocketOptions options);
    parameters:
    - id: userFunc
      type: System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task}
      description: "Funkcja użytkownika."
    - id: options
      type: System.Web.WebSockets.AspNetWebSocketOptions
      description: "Obiekt opcje."
  overload: System.Web.HttpContext.AcceptWebSocketRequest*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>userFunc</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Żądanie nie jest <xref href=&quot;System.Web.WebSockets.AspNetWebSocket&quot;> </xref> żądania."
  platform:
  - net462
- uid: System.Web.HttpContext.AddError(System.Exception)
  id: AddError(System.Exception)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: AddError(Exception)
  nameWithType: HttpContext.AddError(Exception)
  fullName: System.Web.HttpContext.AddError(Exception)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Dodaje wyjątek do zbierania wyjątków dla bieżącego żądania HTTP."
  syntax:
    content: public void AddError (Exception errorInfo);
    parameters:
    - id: errorInfo
      type: System.Exception
      description: "<xref:System.Exception>Do dodania do kolekcji wyjątek.</xref:System.Exception>"
  overload: System.Web.HttpContext.AddError*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.AddOnRequestCompleted(System.Action{System.Web.HttpContext})
  id: AddOnRequestCompleted(System.Action{System.Web.HttpContext})
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: AddOnRequestCompleted(Action<HttpContext>)
  nameWithType: HttpContext.AddOnRequestCompleted(Action<HttpContext>)
  fullName: System.Web.HttpContext.AddOnRequestCompleted(Action<HttpContext>)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Zgłasza zdarzenie wirtualny, który występuje, gdy kończy się części HTTP żądania."
  remarks: "To zdarzenie występuje przed <xref:System.Web.WebSockets.AspNetWebSocket>rozpoczęciu połączenia.</xref:System.Web.WebSockets.AspNetWebSocket>"
  syntax:
    content: public System.Web.ISubscriptionToken AddOnRequestCompleted (Action<System.Web.HttpContext> callback);
    parameters:
    - id: callback
      type: System.Action{System.Web.HttpContext}
      description: "Obiekt kontekstu HTTP."
    return:
      type: System.Web.ISubscriptionToken
      description: "Token subskrypcji."
  overload: System.Web.HttpContext.AddOnRequestCompleted*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>callback</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Web.HttpContext.AllErrors
  id: AllErrors
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: AllErrors
  nameWithType: HttpContext.AllErrors
  fullName: System.Web.HttpContext.AllErrors
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera tablicę błędy zebranych podczas przetwarzania żądania HTTP."
  syntax:
    content: public Exception[] AllErrors { get; }
    return:
      type: System.Exception[]
      description: "Tablica <xref:System.Exception>obiekty dla bieżącego żądania HTTP.</xref:System.Exception>"
  overload: System.Web.HttpContext.AllErrors*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.AllowAsyncDuringSyncStages
  id: AllowAsyncDuringSyncStages
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: AllowAsyncDuringSyncStages
  nameWithType: HttpContext.AllowAsyncDuringSyncStages
  fullName: System.Web.HttpContext.AllowAsyncDuringSyncStages
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera lub ustawia wartość wskazującą, czy operacje asynchroniczne są dozwolone podczas części, gdy nie są oczekiwane przetwarzania żądań ASP.NET."
  remarks: "Jeśli ta flaga nie jest równa `true`, ASP.NET spowoduje zgłoszenie wyjątku, po wykryciu aplikacji niewłaściwie korzysta z asynchronicznego interfejsu API. Nastąpi próba wywołania metody asynchronicznej w części żądanie przetwarzania potoku, gdzie operacje asynchroniczne nie powinny, czy jest nadal zaległe asynchroniczne podczas asynchronicznego modułu lub asynchronicznej obsługi sygnały ukończenia. To zachowanie jest przeznaczona zabezpieczenie na wczesnym etapie informujący, jeśli pisania async kod, który nie mieści się oczekiwano wzorców i może mieć ujemnej skutki uboczne."
  syntax:
    content: public bool AllowAsyncDuringSyncStages { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>Jeśli program ASP.NET spowoduje zgłoszenie wyjątku podczas asynchronicznego interfejsu API jest używany w czasie, gdy nie jest oczekiwane; w przeciwnym razie <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>. Wartość domyślna to <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Web.HttpContext.AllowAsyncDuringSyncStages*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.Application
  id: Application
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: Application
  nameWithType: HttpContext.Application
  fullName: System.Web.HttpContext.Application
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera <xref href=&quot;System.Web.HttpApplicationState&quot;> </xref> dla bieżącego żądania HTTP."
  syntax:
    content: public System.Web.HttpApplicationState Application { get; }
    return:
      type: System.Web.HttpApplicationState
      description: "<xref href=&quot;System.Web.HttpApplicationState&quot;> </xref> Dla bieżącego żądania HTTP.       Aby uzyskać <xref href=&quot;System.Web.HttpApplication&quot;> </xref> obiektu dla bieżącego żądania HTTP, użyj <xref:System.Web.HttpContext.ApplicationInstance*>.</xref:System.Web.HttpContext.ApplicationInstance*> (Program ASP.NET używa <xref uid=&quot;langword_csharp_ApplicationInstance&quot; name=&quot;ApplicationInstance&quot; href=&quot;&quot;> </xref> zamiast <xref uid=&quot;langword_csharp_Application&quot; name=&quot;Application&quot; href=&quot;&quot;> </xref> jako nazwa właściwości do odwoływania się do bieżącego <xref href=&quot;System.Web.HttpApplication&quot;> </xref> wystąpienia, aby uniknąć pomylenia ASP.NET i classic ASP. W klasycznym ASP <xref uid=&quot;langword_csharp_Application&quot; name=&quot;Application&quot; href=&quot;&quot;> </xref> odwołuje się do słownika stanów globalnych aplikacji.)"
  overload: System.Web.HttpContext.Application*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.ApplicationInstance
  id: ApplicationInstance
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: ApplicationInstance
  nameWithType: HttpContext.ApplicationInstance
  fullName: System.Web.HttpContext.ApplicationInstance
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera lub ustawia <xref href=&quot;System.Web.HttpApplication&quot;> </xref> dla bieżącego żądania HTTP."
  syntax:
    content: public System.Web.HttpApplication ApplicationInstance { get; set; }
    return:
      type: System.Web.HttpApplication
      description: "<xref href=&quot;System.Web.HttpApplication&quot;> </xref> Dla bieżącego żądania HTTP.       Program ASP.NET używa <xref uid=&quot;langword_csharp_ApplicationInstance&quot; name=&quot;ApplicationInstance&quot; href=&quot;&quot;> </xref> zamiast <xref uid=&quot;langword_csharp_Application&quot; name=&quot;Application&quot; href=&quot;&quot;> </xref> jako nazwa właściwości do odwoływania się do bieżącego <xref href=&quot;System.Web.HttpApplication&quot;> </xref> wystąpienia, aby uniknąć pomylenia ASP.NET i classic ASP. W klasycznym ASP <xref uid=&quot;langword_csharp_Application&quot; name=&quot;Application&quot; href=&quot;&quot;> </xref> odwołuje się do słownika stanów globalnych aplikacji."
  overload: System.Web.HttpContext.ApplicationInstance*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Aplikacja sieci Web działa w ramach usług IIS 7.0 w trybie zintegrowanym i podjęto próbę zmiany wartości właściwości z wartość inną niż null do <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Web.HttpContext.AsyncPreloadMode
  id: AsyncPreloadMode
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: AsyncPreloadMode
  nameWithType: HttpContext.AsyncPreloadMode
  fullName: System.Web.HttpContext.AsyncPreloadMode
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera lub ustawia obiekt, który zawiera flagi, które występują w trybie asynchronicznym wstępnego ładowania."
  remarks: "Ta właściwość jest dostępny, po raz pierwszy obiekt, który zawiera flagi trybie asynchronicznym wstępnego ładowania jest ładowany z <xref:System.Web.Configuration.HttpRuntimeSection.AsyncPreloadMode%2A>Ustawienia w pliku konfiguracji.</xref:System.Web.Configuration.HttpRuntimeSection.AsyncPreloadMode%2A>       Mimo że tę właściwość można ustawić programowo, zmiana wartości właściwości ma znaczenie tylko wtedy, jeśli właściwość jest ustawiona przed `ExecuteRequestHandler` krok w potoku żądania ASP.NET."
  syntax:
    content: public System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode { get; set; }
    return:
      type: System.Web.Configuration.AsyncPreloadModeFlags
      description: "Obiekt, który zawiera flagi, które występują w trybie asynchronicznym wstępnego ładowania."
  overload: System.Web.HttpContext.AsyncPreloadMode*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.Cache
  id: Cache
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: Cache
  nameWithType: HttpContext.Cache
  fullName: System.Web.HttpContext.Cache
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera <xref href=&quot;System.Web.Caching.Cache&quot;> </xref> obiekt bieżącej domeny aplikacji."
  remarks: "Istnieje jedno wystąpienie <xref:System.Web.Caching.Cache>klasy w każdej domenie aplikacji.</xref:System.Web.Caching.Cache> W związku z tym <xref:System.Web.Caching.Cache>obiekt, który jest zwracany za pomocą właściwości pamięci podręcznej jest <xref:System.Web.Caching.Cache>obiektu dla wszystkich żądań w domenie aplikacji.</xref:System.Web.Caching.Cache> </xref:System.Web.Caching.Cache>"
  syntax:
    content: public System.Web.Caching.Cache Cache { get; }
    return:
      type: System.Web.Caching.Cache
      description: "<xref href=&quot;System.Web.Caching.Cache&quot;> </xref> Dla bieżącej domeny aplikacji."
  overload: System.Web.HttpContext.Cache*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.ClearError
  id: ClearError
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: ClearError()
  nameWithType: HttpContext.ClearError()
  fullName: System.Web.HttpContext.ClearError()
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Usuwa wszystkich błędów dla bieżącego żądania HTTP."
  syntax:
    content: public void ClearError ();
    parameters: []
  overload: System.Web.HttpContext.ClearError*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.Current
  id: Current
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: Current
  nameWithType: HttpContext.Current
  fullName: System.Web.HttpContext.Current
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera lub ustawia <xref href=&quot;System.Web.HttpContext&quot;> </xref> dla bieżącego żądania HTTP."
  remarks: "Ta właściwość jest właściwość statyczna <xref:System.Web.HttpContext>klasy.</xref:System.Web.HttpContext> Magazyny właściwości <xref:System.Web.HttpContext>wystąpienia, która ma zastosowanie do bieżącego żądania.</xref:System.Web.HttpContext> Właściwości tego wystąpienia są niestatycznej właściwości <xref:System.Web.HttpContext>klasy.</xref:System.Web.HttpContext>       Można również użyć <xref:System.Web.UI.Page.Context%2A?displayProperty=fullName>Właściwości, aby uzyskać dostęp do <xref:System.Web.HttpContext>dla bieżącego żądania HTTP.</xref:System.Web.HttpContext> </xref:System.Web.UI.Page.Context%2A?displayProperty=fullName>"
  example:
  - "The following code example uses the Current property to access the <xref:System.Web.HttpContext.AddError%2A?displayProperty=fullName> and <xref:System.Web.HttpContext.ClearError%2A?displayProperty=fullName> methods and the <xref:System.Web.HttpContext.AllErrors%2A?displayProperty=fullName> property. The example creates three custom exceptions using the <xref:System.Web.HttpContext.AddError%2A> method and uses the <xref:System.Web.HttpContext.AllErrors%2A> property to load these exceptions to an array. It then writes the array to the containing page and uses the <xref:System.Web.HttpContext.ClearError%2A> method to clear all the errors from the <xref:System.Web.UI.Page.Context%2A> property.  \n  \n```c#  \nprotected void Page_Load(object sender, EventArgs e)  \n{  \n    HttpContext context = HttpContext.Current;  \n    Response.Write(\"<p>HttpContext.Current Example:</p>\");  \n  \n    // Add three custom exceptions.  \n    context.AddError(new Exception(\"New Exception #1\"));  \n    context.AddError(new Exception(\"New Exception #2\"));  \n    context.AddError(new Exception(\"New Exception #3\"));  \n  \n    // Capture all the new Exceptions in an array.  \n    Exception[] errs = context.AllErrors;  \n  \n    foreach (Exception ex in errs)  \n    {  \n        Response.Write(\"<p>\" + Server.HtmlEncode(ex.ToString()) + \"</p>\");  \n    }  \n  \n    // Clear the exceptions so ASP.NET won't handle them.  \n    context.ClearError();  \n}  \n```  \n  \n```vb  \nProtected Sub Page_Load(sender As Object, e As EventArgs)  \nDim context As HttpContext = HttpContext.Current  \nResponse.Write(\"<p>HttpContext.Current Example:</p>\")  \n  \n' Add three custom exceptions.  \ncontext.AddError(New Exception(\"New Exception #1\"))  \ncontext.AddError(New Exception(\"New Exception #2\"))  \ncontext.AddError(New Exception(\"New Exception #3\"))  \n  \n' Capture all the new Exceptions in an array.  \nDim errs As Exception() = context.AllErrors  \n  \nFor Each ex As Exception In errs  \nResponse.Write(\"<p>\" & Server.HtmlEncode(ex.ToString()) & \"</p>\")  \nNext  \n  \n' Clear the exceptions so ASP.NET won't handle them.  \ncontext.ClearError()  \nEnd Sub  \n  \n```"
  syntax:
    content: public static System.Web.HttpContext Current { get; set; }
    return:
      type: System.Web.HttpContext
      description: "<xref href=&quot;System.Web.HttpContext&quot;> </xref> Wystąpienia dla bieżącego żądania HTTP."
  overload: System.Web.HttpContext.Current*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.CurrentHandler
  id: CurrentHandler
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: CurrentHandler
  nameWithType: HttpContext.CurrentHandler
  fullName: System.Web.HttpContext.CurrentHandler
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera <xref href=&quot;System.Web.IHttpHandler&quot;> </xref> obiekt, który reprezentuje program obsługi aktualnie wykonywane."
  remarks: "Aktualnie wykonywane program obsługi, który odwołuje się właściwość CurrentHandler może różnić się od obsługi, która odwołuje się do niego <xref:System.Web.HttpContext.Handler%2A>Właściwości.</xref:System.Web.HttpContext.Handler%2A> Taka sytuacja może wystąpić, gdy zażądano inny program obsługi przy użyciu <xref:System.Web.HttpServerUtility.Execute%2A>metody lub <xref:System.Web.HttpServerUtility.Transfer%2A>metody.</xref:System.Web.HttpServerUtility.Transfer%2A> </xref:System.Web.HttpServerUtility.Execute%2A> Po zakończeniu przetwarzania obsługi aktualnie wykonywane wcześniej określony program obsługi został przywrócony."
  syntax:
    content: public System.Web.IHttpHandler CurrentHandler { get; }
    return:
      type: System.Web.IHttpHandler
      description: "<xref href=&quot;System.Web.IHttpHandler&quot;> </xref> Reprezentujący aktualnie wykonywanego programu obsługi."
  overload: System.Web.HttpContext.CurrentHandler*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.CurrentNotification
  id: CurrentNotification
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: CurrentNotification
  nameWithType: HttpContext.CurrentNotification
  fullName: System.Web.HttpContext.CurrentNotification
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera <xref href=&quot;System.Web.RequestNotification&quot;> </xref> wartość, która wskazuje bieżący <xref href=&quot;System.Web.HttpApplication&quot;> </xref> zdarzenie, które są przetwarzane."
  remarks: "Właściwość CurrentNotification wymaga trybu zintegrowanego potoku w [!INCLUDE[iisver](~/add/includes/ajax-current-ext-md.md)] i co najmniej programu .NET Framework w wersji 3.0 lub nowszej. Jeśli jest dostępna, właściwość zwraca <xref:System.Web.RequestNotification>wartość.</xref:System.Web.RequestNotification> Wartość właściwości CurrentNotification wskazuje zdarzenie (event) w <xref:System.Web.HttpApplication>wystąpienie aktualnie przetwarza żądania.</xref:System.Web.HttpApplication>       Właściwość CurrentNotification nie jest przeznaczony do ustawienia. Zamiast tego jest ustawiana przez [!INCLUDE[iisver](~/add/includes/ajax-current-ext-md.md)] podczas przetwarzania żądania w potoku ASP.NET. Ustawienie właściwości CurrentNotification spowoduje błąd kompilacji.       CurrentNotification wprowadzono w programie .NET Framework w wersji 3.5.  Aby uzyskać więcej informacji, zobacz [wersje i zależności](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example demonstrates how to use the CurrentNotification property to determine what event of the <xref:System.Web.HttpApplication> object that is handling the current request is being processed. In the example, the event handler handles several events of the <xref:System.Web.HttpApplication> object, and the CurrentNotification property determines what code is invoked for each event being handled.  \n  \n [!code-cs[System.Web.HttpResponse.IsPostNotification#1](~/add/codesnippet/csharp/p-system.web.httpcontext_0_1.cs)]\n [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/add/codesnippet/visualbasic/p-system.web.httpcontext_0_1.vb)]"
  syntax:
    content: public System.Web.RequestNotification CurrentNotification { get; }
    return:
      type: System.Web.RequestNotification
      description: "Jeden z <xref href=&quot;System.Web.RequestNotification&quot;> </xref> wartości."
  overload: System.Web.HttpContext.CurrentNotification*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Operacja wymaga trybu zintegrowanego potoku w [!INCLUDE[iisver](~/add/includes/ajax-current-ext-md.md)] i co najmniej programu .NET Framework w wersji 3.0 lub nowszej."
  platform:
  - net462
- uid: System.Web.HttpContext.DisposeOnPipelineCompleted(System.IDisposable)
  id: DisposeOnPipelineCompleted(System.IDisposable)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: DisposeOnPipelineCompleted(IDisposable)
  nameWithType: HttpContext.DisposeOnPipelineCompleted(IDisposable)
  fullName: System.Web.HttpContext.DisposeOnPipelineCompleted(IDisposable)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Włącza obiektu <xref:System.IDisposable.Dispose*>Metoda wywoływana, gdy <xref href=&quot;System.Web.WebSockets.AspNetWebSocket&quot;> </xref> połączenia częścią tego żądania zostało zakończone.</xref:System.IDisposable.Dispose*>"
  remarks: "<xref:System.IDisposable.Dispose%2A>Metoda obiektu docelowego jest wywoływana po części HTTP żądania i <xref:System.Web.WebSockets.AspNetWebSocket>zakończył połączenie.</xref:System.Web.WebSockets.AspNetWebSocket> </xref:System.IDisposable.Dispose%2A> <xref:System.Web.HttpContext>Obiekt nie jest dostępny dla kontroli.</xref:System.Web.HttpContext>"
  syntax:
    content: public System.Web.ISubscriptionToken DisposeOnPipelineCompleted (IDisposable target);
    parameters:
    - id: target
      type: System.IDisposable
      description: "Obiekt których <xref:System.IDisposable.Dispose*>Metoda musi zostać wywołana podczas <xref href=&quot;System.Web.WebSockets.AspNetWebSocket&quot;> </xref> części żądanie połączenia zostało zakończone.</xref:System.IDisposable.Dispose*>"
    return:
      type: System.Web.ISubscriptionToken
      description: "Token subskrypcji."
  overload: System.Web.HttpContext.DisposeOnPipelineCompleted*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.Error
  id: Error
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: Error
  nameWithType: HttpContext.Error
  fullName: System.Web.HttpContext.Error
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera pierwszego błędu (jeśli istnieją) zebranych podczas HTTP przetwarzanie żądania."
  syntax:
    content: public Exception Error { get; }
    return:
      type: System.Exception
      description: "Pierwszy <xref:System.Exception>dla bieżącego żądania HTTP/odpowiedzi procesu; w przeciwnym razie <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Jeśli żadne błędy zostały zebranych podczas przetwarzania żądania HTTP.</xref:System.Exception> Wartość domyślna to <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Web.HttpContext.Error*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.GetAppConfig(System.String)
  id: GetAppConfig(System.String)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: GetAppConfig(String)
  nameWithType: HttpContext.GetAppConfig(String)
  fullName: System.Web.HttpContext.GetAppConfig(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Zwraca wymagane informacje konfiguracji dla bieżącej aplikacji."
  remarks: "Metoda GetAppConfig jest przestarzała. Użyj <xref:System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection%2A>metody <xref:System.Web.Configuration.WebConfigurationManager>klasy, aby uzyskać informacje o konfiguracji dla bieżącej aplikacji.</xref:System.Web.Configuration.WebConfigurationManager> </xref:System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection%2A>"
  syntax:
    content: public static object GetAppConfig (string name);
    parameters:
    - id: name
      type: System.String
      description: "Tag konfiguracji aplikacji, dla których jest wymagane informacje."
    return:
      type: System.Object
      description: "Obiekt zawierający informacje o konfiguracji. (Rzutować sekcji konfiguracji zwrócony typ prawidłowej konfiguracji przed użyciem)."
  overload: System.Web.HttpContext.GetAppConfig*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.GetConfig(System.String)
  id: GetConfig(System.String)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: GetConfig(String)
  nameWithType: HttpContext.GetConfig(String)
  fullName: System.Web.HttpContext.GetConfig(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Zwraca wymagane informacje konfiguracji dla bieżącego żądania HTTP."
  remarks: "Metoda GetConfig jest przestarzała. Użyj <xref:System.Web.HttpContext.GetSection%2A>metody, aby uzyskać informacje o konfiguracji dla bieżącego żądania HTTP.</xref:System.Web.HttpContext.GetSection%2A>"
  syntax:
    content: public object GetConfig (string name);
    parameters:
    - id: name
      type: System.String
      description: "Tag konfiguracji, dla których jest wymagane informacje."
    return:
      type: System.Object
      description: "Określony <xref href=&quot;System.Configuration.ConfigurationSection&quot;> </xref>, <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Jeśli sekcja nie istnieje, lub wewnętrzny obiekt, jeśli sekcji nie jest dostępny w czasie wykonywania. (Rzutować zwróconego obiektu na typ prawidłowej konfiguracji przed użyciem)."
  overload: System.Web.HttpContext.GetConfig*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String)
  id: GetGlobalResourceObject(System.String,System.String)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: GetGlobalResourceObject(String,String)
  nameWithType: HttpContext.GetGlobalResourceObject(String,String)
  fullName: System.Web.HttpContext.GetGlobalResourceObject(String,String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera obiekt zasobów na poziomie aplikacji oparte na określony <> </> *> i <> </> *> właściwości."
  remarks: "Metoda GetGlobalResourceObject zwraca zasób globalny przy użyciu kultura, która została określona w <xref:System.Globalization.CultureInfo.CurrentUICulture%2A>Właściwości.</xref:System.Globalization.CultureInfo.CurrentUICulture%2A>      > [!NOTE] > W niektórych edycji środowiskach, takich jak [!INCLUDE[vwprvw](~/add/includes/vwprvw-md.md)], edytor może zgłosić czasu projektowania <xref:System.Resources.MissingManifestResourceException>wyjątek, jeśli używasz kropki (.) w nazwie klucz zasobu globalnego.</xref:System.Resources.MissingManifestResourceException> Jednak nie ma to wpływu na możliwość edycji lub Zapisz plik i można zignorować ten błąd."
  syntax:
    content: public static object GetGlobalResourceObject (string classKey, string resourceKey);
    parameters:
    - id: classKey
      type: System.String
      description: "Ciąg reprezentujący <xref:System.Web.Compilation.ResourceExpressionFields.ClassKey*>Właściwości obiektu żądanego zasobu.</xref:System.Web.Compilation.ResourceExpressionFields.ClassKey*>"
    - id: resourceKey
      type: System.String
      description: "Ciąg reprezentujący <xref:System.Web.Compilation.ResourceExpressionFields.ResourceKey*>Właściwości obiektu żądanego zasobu.</xref:System.Web.Compilation.ResourceExpressionFields.ResourceKey*>"
    return:
      type: System.Object
      description: "<xref:System.Object>Reprezentujący obiekt żądanego zasobu na poziomie aplikacji; w przeciwnym razie wartość null, jeśli nie znaleziono obiektu zasobu lub jeśli zostanie znaleziony obiektu zasobów, ale go nie ma wymaganej właściwości.</xref:System.Object>"
  overload: System.Web.HttpContext.GetGlobalResourceObject*
  exceptions:
  - type: System.Resources.MissingManifestResourceException
    commentId: T:System.Resources.MissingManifestResourceException
    description: "A resource object with the specified <code>classKey</code> parameter was not found.  \n  \n \\- or -  \n  \n The main assembly does not contain the resources for the neutral culture, and these resources are required because the appropriate satellite assembly is missing."
  platform:
  - net462
- uid: System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)
  id: GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: GetGlobalResourceObject(String,String,CultureInfo)
  nameWithType: HttpContext.GetGlobalResourceObject(String,String,CultureInfo)
  fullName: System.Web.HttpContext.GetGlobalResourceObject(String,String,CultureInfo)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera obiekt zasobów na poziomie aplikacji oparte na określony <> </> *> i <> </> *> właściwości oraz na <xref:System.Globalization.CultureInfo>obiektu.</xref:System.Globalization.CultureInfo>"
  remarks: "<xref:System.Globalization.CultureInfo>Obiekt reprezentuje kultury, dla którego został zlokalizowany zasób.</xref:System.Globalization.CultureInfo> Jeśli zasobu nie jest lokalizowany tej kultury, wyszukiwanie będzie występować proces rezerwowy, aby zlokalizować odpowiedni zasób. Aby uzyskać więcej informacji, zobacz [pakowanie i wdrażanie zasobów](~/add/includes/ajax-current-ext-md.md).      > [!NOTE] > W niektórych środowiskach edycji, na przykład Visual Web Developer, edytor może zgłosić czasu projektowania <xref:System.Resources.MissingManifestResourceException>wyjątek, jeśli używasz kropki (.) w nazwie klucz zasobu globalnego.</xref:System.Resources.MissingManifestResourceException> Jednak nie ma to wpływu na możliwość edycji lub Zapisz plik i można zignorować ten błąd."
  syntax:
    content: public static object GetGlobalResourceObject (string classKey, string resourceKey, System.Globalization.CultureInfo culture);
    parameters:
    - id: classKey
      type: System.String
      description: "Ciąg reprezentujący <xref:System.Web.Compilation.ResourceExpressionFields.ClassKey*>Właściwości obiektu żądanego zasobu.</xref:System.Web.Compilation.ResourceExpressionFields.ClassKey*>"
    - id: resourceKey
      type: System.String
      description: "Ciąg reprezentujący <xref:System.Web.Compilation.ResourceExpressionFields.ResourceKey*>Właściwości obiektu żądanego zasobu.</xref:System.Web.Compilation.ResourceExpressionFields.ResourceKey*>"
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Ciąg reprezentujący <xref:System.Globalization.CultureInfo>obiektu żądanego zasobu.</xref:System.Globalization.CultureInfo>"
    return:
      type: System.Object
      description: "<xref:System.Object>Reprezentujący obiekt żądanego zasobu na poziomie aplikacji, który jest zlokalizowane dla określonej kultury; w przeciwnym razie, <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> , jeśli nie znaleziono obiektu zasobu lub obiektu zasobów został znaleziony, lecz nie ma wymaganej właściwości.</xref:System.Object>"
  overload: System.Web.HttpContext.GetGlobalResourceObject*
  exceptions:
  - type: System.Resources.MissingManifestResourceException
    commentId: T:System.Resources.MissingManifestResourceException
    description: "A resource object for which the specified <code>classKey</code> parameter was not found.  \n  \n \\- or -  \n  \n The main assembly does not contain the resources for the neutral culture, and these resources are required because the appropriate satellite assembly is missing."
  platform:
  - net462
- uid: System.Web.HttpContext.GetLocalResourceObject(System.String,System.String)
  id: GetLocalResourceObject(System.String,System.String)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: GetLocalResourceObject(String,String)
  nameWithType: HttpContext.GetLocalResourceObject(String,String)
  fullName: System.Web.HttpContext.GetLocalResourceObject(String,String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera obiektu zasobów na poziomie strony oparte na określony <> </> *> i <> </> *> właściwości."
  remarks: "Metoda GetLocalResourceObject zwraca zasobów lokalnych za pomocą kultura, która została określona w <xref:System.Globalization.CultureInfo.CurrentUICulture%2A>Właściwości.</xref:System.Globalization.CultureInfo.CurrentUICulture%2A>"
  syntax:
    content: public static object GetLocalResourceObject (string virtualPath, string resourceKey);
    parameters:
    - id: virtualPath
      type: System.String
      description: "<xref:System.Web.Compilation.ExpressionBuilderContext.VirtualPath*>Właściwość w obiekcie zasobu lokalnego.</xref:System.Web.Compilation.ExpressionBuilderContext.VirtualPath*>"
    - id: resourceKey
      type: System.String
      description: "Ciąg, który reprezentuje <xref:System.Web.Compilation.ResourceExpressionFields.ResourceKey*>właściwość obiektu żądanego zasobu</xref:System.Web.Compilation.ResourceExpressionFields.ResourceKey*>"
    return:
      type: System.Object
      description: "<xref:System.Object>Reprezentujący obiekt żądanego zasobu z poziomu strony; w przeciwnym razie <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Jeśli, ale nie odnaleziono zgodnego obiektu zasobów <code> resourceKey </code> parametru.</xref:System.Object>"
  overload: System.Web.HttpContext.GetLocalResourceObject*
  exceptions:
  - type: System.Resources.MissingManifestResourceException
    commentId: T:System.Resources.MissingManifestResourceException
    description: "Nie znaleziono obiektu zasobu dla określonego <code> virtualPath </code> parametru."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Określony <code> virtualPath </code> parametru nie znajduje się w katalogu głównym bieżącej aplikacji."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nie znaleziono klasy zasobu strony."
  platform:
  - net462
- uid: System.Web.HttpContext.GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)
  id: GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: GetLocalResourceObject(String,String,CultureInfo)
  nameWithType: HttpContext.GetLocalResourceObject(String,String,CultureInfo)
  fullName: System.Web.HttpContext.GetLocalResourceObject(String,String,CultureInfo)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera obiektu zasobów na poziomie strony oparte na określony <> </> *> i <> </> *> właściwości oraz na <xref:System.Globalization.CultureInfo>obiektu.</xref:System.Globalization.CultureInfo>"
  remarks: "Jeśli zasobu nie jest lokalizowany tej kultury, wyszukiwanie będzie występować proces rezerwowy, aby zlokalizować odpowiedni zasób. Aby uzyskać więcej informacji, zobacz [pakowanie i wdrażanie zasobów](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static object GetLocalResourceObject (string virtualPath, string resourceKey, System.Globalization.CultureInfo culture);
    parameters:
    - id: virtualPath
      type: System.String
      description: "<xref:System.Web.Compilation.ExpressionBuilderContext.VirtualPath*>Właściwość w obiekcie zasobu lokalnego.</xref:System.Web.Compilation.ExpressionBuilderContext.VirtualPath*>"
    - id: resourceKey
      type: System.String
      description: "Ciąg reprezentujący <xref:System.Web.Compilation.ResourceExpressionFields.ResourceKey*>Właściwości obiektu żądanego zasobu.</xref:System.Web.Compilation.ResourceExpressionFields.ResourceKey*>"
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Ciąg reprezentujący <xref:System.Globalization.CultureInfo>obiektu żądanego zasobu.</xref:System.Globalization.CultureInfo>"
    return:
      type: System.Object
      description: "<xref:System.Object>Reprezentujący obiekt żądany zasób lokalny, który jest zlokalizowane dla określonej kultury; w przeciwnym razie <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Jeśli, ale nie odnaleziono zgodnego obiektu zasobów <code> resourceKey </code> parametru.</xref:System.Object>"
  overload: System.Web.HttpContext.GetLocalResourceObject*
  exceptions:
  - type: System.Resources.MissingManifestResourceException
    commentId: T:System.Resources.MissingManifestResourceException
    description: "Nie znaleziono obiektu zasobu dla określonego <code> virtualPath </code> parametru."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Określony <code> virtualPath </code> parametru nie znajduje się w katalogu głównym bieżącej aplikacji."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nie znaleziono klasy zasobu strony."
  platform:
  - net462
- uid: System.Web.HttpContext.GetSection(System.String)
  id: GetSection(System.String)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: GetSection(String)
  nameWithType: HttpContext.GetSection(String)
  fullName: System.Web.HttpContext.GetSection(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera sekcji określonej konfiguracji dla konfiguracji domyślnej bieżącej aplikacji."
  syntax:
    content: public object GetSection (string sectionName);
    parameters:
    - id: sectionName
      type: System.String
      description: "Ścieżka do sekcji konfiguracji (w formacie XPath) i nazwę elementu konfiguracji."
    return:
      type: System.Object
      description: "Określony <xref href=&quot;System.Configuration.ConfigurationSection&quot;> </xref>, <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Jeśli sekcja nie istnieje, lub wewnętrzny obiekt, jeśli sekcji nie jest dostępny w czasie wykonywania."
  overload: System.Web.HttpContext.GetSection*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.Handler
  id: Handler
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: Handler
  nameWithType: HttpContext.Handler
  fullName: System.Web.HttpContext.Handler
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera lub ustawia <xref href=&quot;System.Web.IHttpHandler&quot;> </xref> obiektu odpowiedzialna za przetwarzanie żądania HTTP."
  remarks: "Właściwość obsługi zawiera odwołanie do programu obsługi, który przetwarza żądania HTTP. Program obsługi można określić za pomocą elementu lub przy użyciu niestandardowego programu obsługi, zdefiniowane w kodzie użytkownika. Aby uzyskać więcej informacji na temat obsługi, zobacz [omówienie moduły HTTP i programów obsługi HTTP](~/add/includes/ajax-current-ext-md.md).       Odwołanie do właściwości obsługi jest taka sama nawet po bieżącej strony został zmieniony przez metodę po stronie serwera, takie jak <xref:System.Web.HttpServerUtility.Execute%2A>metody lub <xref:System.Web.HttpServerUtility.Transfer%2A>metody.</xref:System.Web.HttpServerUtility.Transfer%2A> </xref:System.Web.HttpServerUtility.Execute%2A>"
  syntax:
    content: public System.Web.IHttpHandler Handler { get; set; }
    return:
      type: System.Web.IHttpHandler
      description: "<xref href=&quot;System.Web.IHttpHandler&quot;> </xref> Odpowiedzialna za przetwarzanie żądania HTTP."
  overload: System.Web.HttpContext.Handler*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.IsCustomErrorEnabled
  id: IsCustomErrorEnabled
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: IsCustomErrorEnabled
  nameWithType: HttpContext.IsCustomErrorEnabled
  fullName: System.Web.HttpContext.IsCustomErrorEnabled
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera wartość wskazującą, czy błędy niestandardowe są włączone dla bieżącego żądania HTTP."
  syntax:
    content: public bool IsCustomErrorEnabled { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli błędy niestandardowe są włączone; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Web.HttpContext.IsCustomErrorEnabled*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.IsDebuggingEnabled
  id: IsDebuggingEnabled
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: IsDebuggingEnabled
  nameWithType: HttpContext.IsDebuggingEnabled
  fullName: System.Web.HttpContext.IsDebuggingEnabled
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera wartość wskazującą, czy bieżące żądanie HTTP jest w trybie debugowania."
  syntax:
    content: public bool IsDebuggingEnabled { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli żądanie jest w trybie debugowania; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Web.HttpContext.IsDebuggingEnabled*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.IsPostNotification
  id: IsPostNotification
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: IsPostNotification
  nameWithType: HttpContext.IsPostNotification
  fullName: System.Web.HttpContext.IsPostNotification
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera wartość, która jest bieżącą przetwarzania punktu w ASP.NET potoku tuż po <xref href=&quot;System.Web.HttpApplication&quot;> </xref> zakończeniu przetwarzania zdarzeń."
  remarks: "Właściwość IsPostNotification jest obsługiwana tylko w trybie zintegrowanym [!INCLUDE[iisver](~/add/includes/ajax-current-ext-md.md)] i co najmniej środowiska .NET Framework 3.0. Jeśli jest dostępna, właściwość zwraca wartość logiczną, wskazującą, czy zdarzenie w <xref:System.Web.HttpApplication>zakończeniu przetwarzania obiektu.</xref:System.Web.HttpApplication>       Właściwość IsPostNotification nie jest przeznaczony do ustawienia. Zamiast tego są dostarczane przez [!INCLUDE[iisver](~/add/includes/ajax-current-ext-md.md)] do środowiska wykonawczego platformy ASP.NET dla każdego powiadomienia. Ustawienie właściwości IsPostNotification spowoduje błąd kompilacji.       W scenariuszach, w której wiele zdarzeń <xref:System.Web.HttpApplication>obiektu są obsługiwane przez jedna procedura obsługi zdarzeń, można użyć właściwości IsPostNotification w połączeniu z <xref:System.Web.RequestNotification>wyliczeniu, aby precyzyjnie określić, gdzie w cyklu życia aplikacji bieżącego żądania jest zapieczętowany.</xref:System.Web.RequestNotification> </xref:System.Web.HttpApplication>       IsPostNotification wprowadzono w programie .NET Framework w wersji 3.5.  Aby uzyskać więcej informacji, zobacz [wersje i zależności](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example demonstrates how to use the IsPostNotification property to determine when an event of the <xref:System.Web.HttpApplication> object has finished processing all the associated event handlers. The custom event handler in this example handles several events of the <xref:System.Web.HttpApplication> object, and the IsPostNotification property is used to determine what code is invoked after a specific event is handled.  \n  \n [!code-cs[System.Web.HttpResponse.IsPostNotification#1](~/add/codesnippet/csharp/p-system.web.httpcontext_2_1.cs)]\n [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/add/codesnippet/visualbasic/p-system.web.httpcontext_2_1.vb)]"
  syntax:
    content: public bool IsPostNotification { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli błędy niestandardowe są włączone; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Web.HttpContext.IsPostNotification*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Operacja wymaga trybu zintegrowanego potoku w [!INCLUDE[iisver](~/add/includes/ajax-current-ext-md.md)] i co najmniej środowiska .NET Framework 3.0."
  platform:
  - net462
- uid: System.Web.HttpContext.IsWebSocketRequest
  id: IsWebSocketRequest
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: IsWebSocketRequest
  nameWithType: HttpContext.IsWebSocketRequest
  fullName: System.Web.HttpContext.IsWebSocketRequest
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera wartość wskazującą, czy żądanie jest <xref href=&quot;System.Web.WebSockets.AspNetWebSocket&quot;> </xref> żądania."
  remarks: "Ta metoda zwraca `true` Jeśli żądanie zawiera początkowe <xref:System.Web.WebSockets.AspNetWebSocket>Uzgadnianie i `WebSocket` modułu IIS jest aktywna.</xref:System.Web.WebSockets.AspNetWebSocket>"
  syntax:
    content: public bool IsWebSocketRequest { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli żądanie jest <xref href=&quot;System.Web.WebSockets.AspNetWebSocket&quot;> </xref> żądania; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Web.HttpContext.IsWebSocketRequest*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.IsWebSocketRequestUpgrading
  id: IsWebSocketRequestUpgrading
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: IsWebSocketRequestUpgrading
  nameWithType: HttpContext.IsWebSocketRequestUpgrading
  fullName: System.Web.HttpContext.IsWebSocketRequestUpgrading
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera wartość wskazującą, czy połączenie jest uaktualniana połączenie HTTP <xref href=&quot;System.Web.WebSockets.AspNetWebSocket&quot;> </xref> połączenia."
  syntax:
    content: public bool IsWebSocketRequestUpgrading { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli połączenie jest uaktualnienie; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Web.HttpContext.IsWebSocketRequestUpgrading*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.Items
  id: Items
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: Items
  nameWithType: HttpContext.Items
  fullName: System.Web.HttpContext.Items
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera kolekcję kluczy i wartości, która może być używany do organizowania i udostępniać dane między <xref href=&quot;System.Web.IHttpModule&quot;> </xref> interfejsu i <xref href=&quot;System.Web.IHttpHandler&quot;> </xref> interfejsu podczas żądania HTTP."
  syntax:
    content: public System.Collections.IDictionary Items { get; }
    return:
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>Klucza i wartości kolekcji, która zapewnia dostęp do poszczególnych wartości w kolekcji przy użyciu określonego klucza.</xref:System.Collections.IDictionary>"
  overload: System.Web.HttpContext.Items*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.PageInstrumentation
  id: PageInstrumentation
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: PageInstrumentation
  nameWithType: HttpContext.PageInstrumentation
  fullName: System.Web.HttpContext.PageInstrumentation
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera odwołanie do wystąpienia usługi Instrumentacji strony dla tego żądania."
  syntax:
    content: public System.Web.Instrumentation.PageInstrumentationService PageInstrumentation { get; }
    return:
      type: System.Web.Instrumentation.PageInstrumentationService
      description: "Wystąpienie usługi Instrumentacji strony dla tego żądania."
  overload: System.Web.HttpContext.PageInstrumentation*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.PreviousHandler
  id: PreviousHandler
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: PreviousHandler
  nameWithType: HttpContext.PreviousHandler
  fullName: System.Web.HttpContext.PreviousHandler
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera <xref href=&quot;System.Web.IHttpHandler&quot;> </xref> obiektu nadrzędnego obsługi."
  remarks: "Właściwość PreviousHandler odnosi się do ostatniego obsługi przed bieżące żądanie zostało wykonane."
  syntax:
    content: public System.Web.IHttpHandler PreviousHandler { get; }
    return:
      type: System.Web.IHttpHandler
      description: "<xref href=&quot;System.Web.IHttpHandler&quot;> </xref> Wystąpienia, lub <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Jeśli nie poprzedniej znaleziono programów obsługi."
  overload: System.Web.HttpContext.PreviousHandler*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.Profile
  id: Profile
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: Profile
  nameWithType: HttpContext.Profile
  fullName: System.Web.HttpContext.Profile
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera <xref href=&quot;System.Web.Profile.ProfileBase&quot;> </xref> obiektu dla bieżącego profilu użytkownika."
  remarks: "Właściwość profilu służy do magazynu trwałego danych strukturalnych za pomocą API bezpieczne. Po uzyskaniu dostępu do właściwości profilu, ale wartości nie jest obecny, zwracany jest puste wystąpienie; `null` nie są zwracane."
  syntax:
    content: public System.Web.Profile.ProfileBase Profile { get; }
    return:
      type: System.Web.Profile.ProfileBase
      description: "A <xref href=&quot;System.Web.Profile.ProfileBase&quot;> </xref> Jeśli pliku konfiguracji aplikacji zawiera definicję dla właściwości profilu; w przeciwnym razie <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Web.HttpContext.Profile*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)
  id: RemapHandler(System.Web.IHttpHandler)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: RemapHandler(IHttpHandler)
  nameWithType: HttpContext.RemapHandler(IHttpHandler)
  fullName: System.Web.HttpContext.RemapHandler(IHttpHandler)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Umożliwia określenie obsługi żądania."
  remarks: "Jeśli ustawisz `handler` do `null`, domyślny program obsługi jest używane do przetwarzania żądania. Można ustawić `handler` asynchronicznej obsługi lub synchroniczne obsługi. Program obsługi musi implementować <xref:System.Web.IHttpHandler>interfejsu.</xref:System.Web.IHttpHandler>"
  syntax:
    content: public void RemapHandler (System.Web.IHttpHandler handler);
    parameters:
    - id: handler
      type: System.Web.IHttpHandler
      description: "Obiekt, który należy przetworzyć żądania."
  overload: System.Web.HttpContext.RemapHandler*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Po wywołaniu metody RemapHandler <xref href=&quot;System.Web.HttpApplication.MapRequestHandler&quot;> </xref> wystąpiło zdarzenie."
  platform:
  - net462
- uid: System.Web.HttpContext.Request
  id: Request
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: Request
  nameWithType: HttpContext.Request
  fullName: System.Web.HttpContext.Request
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera <xref href=&quot;System.Web.HttpRequest&quot;> </xref> dla bieżącego żądania HTTP."
  remarks: "Właściwość Request zapewnia dostęp programistyczny do właściwości i metody <xref:System.Web.HttpRequest>klasy.</xref:System.Web.HttpRequest> Ponieważ stron ASP.NET zawiera domyślne odwołanie do <xref:System.Web>przestrzeni nazw (która zawiera <xref:System.Web.HttpContext>klasy), możesz odwoływać się do elementów członkowskich <xref:System.Web.HttpRequest>na stronę .aspx, bez korzystania z klasy w pełni kwalifikowane odwołanie do <xref:System.Web.HttpContext>.</xref:System.Web.HttpContext> </xref:System.Web.HttpRequest> </xref:System.Web.HttpContext> </xref:System.Web> Na przykład można użyć `Request.Browser` uzyskanie możliwości przeglądarki klienta. Jednak jeśli chcesz używać elementów członkowskich <xref:System.Web.HttpRequest>z modułu CodeBehind ASP.NET musi zawierać odwołanie do <xref:System.Web>przestrzeni nazw w moduł i w pełni kwalifikowane odwołanie do zarówno kontekst aktualnie aktywne żądanie/odpowiedź, jak i klasy w <xref:System.Web>, który ma być używany.</xref:System.Web> </xref:System.Web> </xref:System.Web.HttpRequest> Na przykład na stronie CodeBehind należy określić w pełni kwalifikowana nazwa `HttpContext.Current.Request.Browser`.      > [!NOTE] > ASP.NET spowoduje zgłoszenie wyjątku, Jeśli spróbujesz użyć tej właściwości po <xref:System.Web.HttpRequest>obiekt nie jest dostępny.</xref:System.Web.HttpRequest> Na przykład będzie to wartość równa true, w pliku Global.asax metody Application_Start lub metodę, która jest wywoływana z metody Application_Start. W tym czasie nie żądania HTTP został jeszcze utworzony."
  syntax:
    content: public System.Web.HttpRequest Request { get; }
    return:
      type: System.Web.HttpRequest
      description: "<xref href=&quot;System.Web.HttpRequest&quot;> </xref> Dla bieżącego żądania HTTP."
  overload: System.Web.HttpContext.Request*
  exceptions:
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "Aplikacja sieci Web działa w ramach usług IIS 7 w trybie zintegrowanym."
  platform:
  - net462
- uid: System.Web.HttpContext.Response
  id: Response
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: Response
  nameWithType: HttpContext.Response
  fullName: System.Web.HttpContext.Response
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera <xref href=&quot;System.Web.HttpResponse&quot;> </xref> obiektu dla bieżącej odpowiedzi HTTP."
  remarks: "Właściwość Response zapewnia dostęp programistyczny do właściwości i metody <xref:System.Web.HttpResponse>klasy.</xref:System.Web.HttpResponse> Ponieważ stron ASP.NET zawiera domyślne odwołanie do <xref:System.Web>przestrzeni nazw (która zawiera <xref:System.Web.HttpContext>klasy), możesz odwoływać się do elementów członkowskich <xref:System.Web.HttpContext>na stronę .aspx, bez korzystania z klasy w pełni kwalifikowane odwołanie do <xref:System.Web.HttpContext>.</xref:System.Web.HttpContext> </xref:System.Web.HttpContext> </xref:System.Web.HttpContext> </xref:System.Web> Na przykład można użyć `Response.Write(&quot;some output&quot;)` do zapisywania danych wyjściowych w strumieniu wyjściowym HTTP. Jednak jeśli chcesz używać elementów członkowskich <xref:System.Web.HttpResponse>z modułu CodeBehind ASP.NET musi zawierać odwołanie do <xref:System.Web>przestrzeni nazw w moduł i w pełni kwalifikowane odwołanie do kontekst aktualnie aktywne żądanie/odpowiedź, jak i klasy w <xref:System.Web>, który ma być używany.</xref:System.Web> </xref:System.Web> </xref:System.Web.HttpResponse> Na przykład na stronie CodeBehind należy określić w pełni kwalifikowana nazwa `HttpContext.Current.Response.Write(&quot;some output&quot;)`."
  syntax:
    content: public System.Web.HttpResponse Response { get; }
    return:
      type: System.Web.HttpResponse
      description: "<xref href=&quot;System.Web.HttpResponse&quot;> </xref> Dla bieżącej odpowiedzi HTTP."
  overload: System.Web.HttpContext.Response*
  exceptions:
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "Aplikacja sieci Web działa w ramach usług IIS 7 w trybie zintegrowanym."
  platform:
  - net462
- uid: System.Web.HttpContext.RewritePath(System.String)
  id: RewritePath(System.String)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: RewritePath(String)
  nameWithType: HttpContext.RewritePath(String)
  fullName: System.Web.HttpContext.RewritePath(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Ponownie zapisuje adres URL, używając podanej ścieżce."
  remarks: "Metoda RewritePath przekierowuje żądanie do zasobu z inną ścieżką niż ten, który jest wskazywany przez żądanego adresu URL. Jeśli masz zresetować ścieżki wirtualnej, tak aby żądania od klienta dla zasobów serwera rozpoznawane poprawnie, użyj przeciążenia tej metody pobierającej `rebaseClientPath` parametru i ustaw dla parametru `false`.       Ponowne zapisywanie adresów URL jest przydatne, gdy chcesz restrukturyzacji na stronach w aplikacji sieci Web i chce mieć pewność, że osoby, które zakładki stare adresy URL można nadal używać je po przesunięciu stron. Ponowne zapisywanie adresów URL umożliwia niewidocznie przekazywania żądań do nowej lokalizacji strony.       Jeśli chcesz umożliwić lokacji do używania adresów URL, które są bardziej przyjazny dla użytkownika i są optymalizowane dla aparatów wyszukiwania, bardziej niezawodne alternatywą jest korzystać z routingu platformy ASP.NET. Aby uzyskać więcej informacji, zobacz [routingu platformy ASP.NET](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example shows how to use the RewritePath method to enable a Web site to respond to URLs that do not reflect the file structure in the Web site. The first block of code is an ASP.NET Web page that is named RewritePath.aspx. It requires a query string. If the name of your site is WebSite1, the URL `http://localhost/WebSite1/RewritePath.aspx?page=1` displays \"Page 1\" in the browser. The block of code that follows the Web page is the `Application_BeginRequest` event handler in the Global.asax file. This code intercepts requests for URLs such as `http://localhost/WebSite1/page1` and converts them to the form that is required for RewritePath.aspx before they are processed. Therefore, the URL `http://localhost/WebSite1/page1` invokes RewritePath.aspx with the query-string parameter that displays \"Page 1\" in the browser. If a URL such as `http://localhost/WebSite1/page1` is received, an overload of RewritePath is invoked that enables you to provide a value for the <xref:System.Web.HttpRequest.PathInfo%2A> property as well as a query string parameter.  \n  \n [!code-cs[HttpContext_RewritePath#2](~/add/codesnippet/csharp/m-system.web.httpcontext_1.aspx)]\n [!code-vb[HttpContext_RewritePath#2](~/add/codesnippet/visualbasic/m-system.web.httpcontext_1.aspx)]  \n  \n [!code-vb[HttpContext_RewritePath#1](~/add/codesnippet/visualbasic/m-system.web.httpcontext_2.asax)]\n [!code-cs[HttpContext_RewritePath#1](~/add/codesnippet/csharp/m-system.web.httpcontext_2.asax)]"
  syntax:
    content: public void RewritePath (string path);
    parameters:
    - id: path
      type: System.String
      description: "Ścieżki wewnętrznego ponownego zapisywania."
  overload: System.Web.HttpContext.RewritePath*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "<code> path </code> Parametru nie znajduje się w katalogu głównym bieżącej aplikacji."
  platform:
  - net462
- uid: System.Web.HttpContext.RewritePath(System.String,System.Boolean)
  id: RewritePath(System.String,System.Boolean)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: RewritePath(String,Boolean)
  nameWithType: HttpContext.RewritePath(String,Boolean)
  fullName: System.Web.HttpContext.RewritePath(String,Boolean)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Ponownie zapisuje adres URL, używając podanej ścieżce, a wartość logiczna, która określa, czy ścieżka wirtualna dla zasobów serwera jest modyfikowana."
  remarks: "Metoda RewritePath jest wywoływana przez <xref:System.Web.HttpContext.RewritePath%28System.String%29?displayProperty=fullName>metody z `rebaseClientPath` ustawiona `true`.</xref:System.Web.HttpContext.RewritePath%28System.String%29?displayProperty=fullName> Aby upewnić się, że ścieżki wirtualnej, który jest używany do tworzenia ścieżek do zasobów nie jest modyfikowany, ustaw `rebaseClientPath` parametr `false`. Typowy scenariusz, w którym można ustawić `rebaseClientPath` do `false` jest, gdy konieczne ponowne zapisywanie adresów URL i użytkownik korzysta z tematów i przekierowywanie adresu URL do zasobu, znajdującej się w innym folderze niż żądany zasób.       Ponowne zapisywanie adresów URL jest przydatne, gdy chcesz restrukturyzacji na stronach w aplikacji sieci Web i chce mieć pewność, że osoby, które zakładki stare adresy URL można nadal używać je po przesunięciu stron. Ponowne zapisywanie adresów URL umożliwia niewidocznie przekazywania żądań do nowej lokalizacji strony.       Jeśli chcesz umożliwić lokacji do używania adresów URL, które są bardziej przyjazny dla użytkownika i są optymalizowane dla aparatów wyszukiwania, bardziej niezawodne alternatywą jest korzystać z routingu platformy ASP.NET. Aby uzyskać więcej informacji, zobacz [routingu platformy ASP.NET](~/add/includes/ajax-current-ext-md.md)."
  example:
  - For a code example, see the <xref:System.Web.HttpContext.RewritePath%28System.String%29> method overload.
  syntax:
    content: public void RewritePath (string path, bool rebaseClientPath);
    parameters:
    - id: path
      type: System.String
      description: "Ścieżki wewnętrznego ponownego zapisywania."
    - id: rebaseClientPath
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby zresetować ścieżki wirtualnej; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> do zachowania ścieżki wirtualnej bez zmian."
  overload: System.Web.HttpContext.RewritePath*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "<code> path </code> Parametru nie znajduje się w katalogu głównym bieżącej aplikacji."
  platform:
  - net462
- uid: System.Web.HttpContext.RewritePath(System.String,System.String,System.String)
  id: RewritePath(System.String,System.String,System.String)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: RewritePath(String,String,String)
  nameWithType: HttpContext.RewritePath(String,String,String)
  fullName: System.Web.HttpContext.RewritePath(String,String,String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Ponownie zapisuje adres URL przy użyciu podanej ścieżce, informacje o ścieżce i informacji o ciągu zapytania."
  remarks: "Metoda RewritePath przekierowuje żądanie do zasobu do innego zasobu bez zmiany adresu URL.       `filePath` Nie ma parametru `pathInfo` zawartość parametru. Dla http://www.microsoft.com/virdir/page.html/tail adres URL `filePath` parametr jest http://www.microsoft.com/virdir/page.html i `pathInfo` parametr jest tail.       Ponowne zapisywanie adresów URL jest przydatne, gdy chcesz restrukturyzacji na stronach w aplikacji sieci Web i chce mieć pewność, że osoby, które zakładki stare adresy URL można nadal używać je po przesunięciu stron. Ponowne zapisywanie adresów URL umożliwia niewidocznie przekazywania żądań do nowej lokalizacji strony.       Jeśli chcesz umożliwić lokacji do używania adresów URL, które są bardziej przyjazny dla użytkownika i są optymalizowane dla aparatów wyszukiwania, bardziej niezawodne alternatywą jest korzystać z routingu platformy ASP.NET. Aby uzyskać więcej informacji, zobacz [routingu platformy ASP.NET](~/add/includes/ajax-current-ext-md.md)."
  example:
  - For a code example, including an example of this method overload, see the <xref:System.Web.HttpContext.RewritePath%28System.String%29> method overload.
  syntax:
    content: public void RewritePath (string filePath, string pathInfo, string queryString);
    parameters:
    - id: filePath
      type: System.String
      description: "Ścieżki wewnętrznego ponownego zapisywania."
    - id: pathInfo
      type: System.String
      description: "Dodatkowe informacje o ścieżce dla zasobu. Aby uzyskać więcej informacji zobacz <xref:System.Web.HttpRequest.PathInfo*>.</xref:System.Web.HttpRequest.PathInfo*>"
    - id: queryString
      type: System.String
      description: "Ciąg zapytania żądania."
  overload: System.Web.HttpContext.RewritePath*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code> path </code> Parametru nie znajduje się w katalogu głównym bieżącej aplikacji."
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "<code> filePath </code> Parametru nie znajduje się w katalogu głównym bieżącej aplikacji."
  platform:
  - net462
- uid: System.Web.HttpContext.RewritePath(System.String,System.String,System.String,System.Boolean)
  id: RewritePath(System.String,System.String,System.String,System.Boolean)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: RewritePath(String,String,String,Boolean)
  nameWithType: HttpContext.RewritePath(String,String,String,Boolean)
  fullName: System.Web.HttpContext.RewritePath(String,String,String,Boolean)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Ponownie zapisuje adres URL, używając podanej ścieżki wirtualnej, informacje o ścieżce informacji o ciągu zapytania i wartość logiczna określająca, czy ścieżka pliku klienta jest ustawiony na ścieżkę ponownego zapisywania."
  remarks: "`filePath` Parametru nie ma zawartości `pathInfo` parametru. Dla http://www.microsoft.com/virdir/page.html/tail adres URL `filePath` parametr jest http://www.microsoft.com/virdir/page.html i `pathInfo` parametr jest tail.       Aby upewnić się, że ścieżki wirtualnej, który jest używany do tworzenia ścieżek do zasobów nie jest modyfikowany, ustaw `setClientFilePath` parametr `false`. Typowy scenariusz, w którym można ustawić `setClientFilePath` do `false` jest, gdy konieczne ponowne zapisywanie adresów URL i użytkownik korzysta z tematów i przekierowywanie adresu URL do zasobu, znajdującej się w innym folderze niż żądany zasób.       Ponowne zapisywanie adresów URL jest przydatne, gdy chcesz restrukturyzacji na stronach w aplikacji sieci Web i chce mieć pewność, że osoby, które zakładki stare adresy URL można nadal używać je po przesunięciu stron. Ponowne zapisywanie adresów URL umożliwia niewidocznie przekazywania żądań do nowej lokalizacji strony.       Jeśli chcesz umożliwić lokacji do używania adresów URL, które są bardziej przyjazny dla użytkownika i są optymalizowane dla aparatów wyszukiwania, bardziej niezawodne alternatywą jest korzystać z routingu platformy ASP.NET. Aby uzyskać więcej informacji, zobacz [routingu platformy ASP.NET](~/add/includes/ajax-current-ext-md.md)."
  example:
  - For a code example, see the <xref:System.Web.HttpContext.RewritePath%28System.String%29> method overload.
  syntax:
    content: public void RewritePath (string filePath, string pathInfo, string queryString, bool setClientFilePath);
    parameters:
    - id: filePath
      type: System.String
      description: "Ścieżka wirtualna do zasobu, która obsługuje żądania."
    - id: pathInfo
      type: System.String
      description: "Dodatkowe informacje o ścieżce dla adresu URL przekierowania. Aby uzyskać więcej informacji zobacz <xref:System.Web.HttpRequest.PathInfo*>.</xref:System.Web.HttpRequest.PathInfo*>"
    - id: queryString
      type: System.String
      description: "Ciąg zapytania żądania dla adresu URL przekierowania."
    - id: setClientFilePath
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby ustawić ścieżka plików używana dla zasobów klienta do wartości `filePath` parametru; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Web.HttpContext.RewritePath*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code> path </code> Parametru nie znajduje się w katalogu głównym bieżącej aplikacji."
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "<code> filePath </code> Parametru nie znajduje się w katalogu głównym bieżącej aplikacji."
  platform:
  - net462
- uid: System.Web.HttpContext.Server
  id: Server
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: Server
  nameWithType: HttpContext.Server
  fullName: System.Web.HttpContext.Server
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera <xref href=&quot;System.Web.HttpServerUtility&quot;> </xref> obiekt, który udostępnia metody używane podczas przetwarzania żądania sieci Web."
  remarks: "Właściwość serwera zapewnia dostęp programistyczny do właściwości i metody <xref:System.Web.HttpServerUtility>klasy.</xref:System.Web.HttpServerUtility> Ponieważ stron ASP.NET zawiera domyślne odwołanie do <xref:System.Web>przestrzeni nazw (która zawiera <xref:System.Web.HttpContext>klasy), możesz odwoływać się do elementów członkowskich <xref:System.Web.HttpContext>na stronę .aspx, bez korzystania z klasy w pełni kwalifikowane odwołanie do <xref:System.Web.HttpContext>.</xref:System.Web.HttpContext> </xref:System.Web.HttpContext> </xref:System.Web.HttpContext> </xref:System.Web> Na przykład można użyć `Server.CreateObject(&quot;MyCOMComponent&quot;)` można utworzyć wystąpienia obiektu modelu COM na serwerze. Jednak jeśli chcesz używać elementów członkowskich <xref:System.Web.HttpServerUtility>z modułu CodeBehind ASP.NET musi zawierać odwołanie do <xref:System.Web>przestrzeni nazw w moduł i w pełni kwalifikowane odwołanie do zarówno kontekst aktualnie aktywne żądanie/odpowiedź, jak i klasy w <xref:System.Web>, który ma być używany.</xref:System.Web> </xref:System.Web> </xref:System.Web.HttpServerUtility> Na przykład na stronie CodeBehind należy określić w pełni kwalifikowana nazwa `HttpContext.Current.Server.CreateObject(&quot;MyCOMComponent&quot;)`."
  syntax:
    content: public System.Web.HttpServerUtility Server { get; }
    return:
      type: System.Web.HttpServerUtility
      description: "<xref href=&quot;System.Web.HttpServerUtility&quot;> </xref> Dla bieżącego żądania HTTP."
  overload: System.Web.HttpContext.Server*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.Session
  id: Session
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: Session
  nameWithType: HttpContext.Session
  fullName: System.Web.HttpContext.Session
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera <xref href=&quot;System.Web.SessionState.HttpSessionState&quot;> </xref> dla bieżącego żądania HTTP."
  remarks: "Właściwości sesji zapewnia dostęp programistyczny do właściwości i metody <xref:System.Web.SessionState.HttpSessionState>klasy.</xref:System.Web.SessionState.HttpSessionState>       Aby można było używać stanu sesji, należy ją włączyć. Aby uzyskać informacje o sposobie włączania stanu sesji, zobacz **stanu sesji Konfigurowanie** w [przegląd stanu sesji ASP.NET](~/add/includes/ajax-current-ext-md.md).       Aby uzyskać informacje o tym, jak można zapisać wartości w stanie sesji, zobacz [jak: Zapisz wartości stanu sesji](~/add/includes/ajax-current-ext-md.md). Informacje o tym, jak można odczytać wartości z stanu sesji, zobacz [porady: odczyt wartości ze stanu sesji](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following examples show how to save values in session state and how to read values from session state.  \n  \n These examples require:  \n  \n-   An ASP.NET application that has session state enabled.  \n  \n-   A Web Forms page class that has access to the <xref:System.Web.UI.Page.Session%2A?displayProperty=fullName> property, or any class that has access to the <xref:System.Web.HttpContext.Current%2A?displayProperty=fullName> property.  \n  \n```c#  \nstring firstName = \"Jeff\";  \nstring lastName = \"Smith\";  \nstring city = \"Seattle\";  \n  \n// Save to session state in a Web Forms page class.  \nSession[\"FirstName\"] = firstName;  \nSession[\"LastName\"] = lastName;  \nSession[\"City\"] = city;  \n  \n// Read from session state in a Web Forms page class.  \nfirstName = (string)(Session[\"FirstName\"]);  \nlastName = (string)(Session[\"LastName\"]);  \ncity = (string)(Session[\"City\"]);  \n  \n// Outside of Web Forms page class, use HttpContext.Current.  \nHttpContext context = HttpContext.Current;  \ncontext.Session[\"FirstName\"] = firstName;  \nfirstName = (string)(context.Session[\"FirstName\"]);  \n  \n```  \n  \n```vb#  \nDim firstName As String = \"Jeff\"  \nDim lastName As String = \"Smith\"  \nDim city As String = \"Seattle\"  \n  \n' Save to session state in a Web Forms page class.  \nSession(\"FirstName\") = firstName  \nSession(\"LastName\") = lastName  \nSession(\"City\") = city  \n  \n' Read from session state in a Web Forms page class.  \nfirstName = DirectCast(Session(\"FirstName\"), String)  \nlastName = DirectCast(Session(\"LastName\"), String)  \ncity = DirectCast(Session(\"City\"), String)  \n  \n' Outside of Web Forms page class, use HttpContext.Current.  \nDim context As HttpContext = HttpContext.Current  \ncontext.Session(\"FirstName\") = firstName  \nfirstName = DirectCast(context.Session(\"FirstName\"), String)  \n  \n```"
  syntax:
    content: public System.Web.SessionState.HttpSessionState Session { get; }
    return:
      type: System.Web.SessionState.HttpSessionState
      description: "<xref href=&quot;System.Web.SessionState.HttpSessionState&quot;> </xref> Dla bieżącego żądania HTTP."
  overload: System.Web.HttpContext.Session*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)
  id: SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: SetSessionStateBehavior(SessionStateBehavior)
  nameWithType: HttpContext.SetSessionStateBehavior(SessionStateBehavior)
  fullName: System.Web.HttpContext.SetSessionStateBehavior(SessionStateBehavior)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Ustawia typ zachowania stanu sesji, który jest wymagany w celu obsługi żądań HTTP."
  remarks: "W ASP.NET domyślną implementację programu obsługi żądań HTTP wskazuje, czy wymaga stanu sesji dzięki implementacji <xref:System.Web.SessionState.IRequiresSessionState>interfejsu lub <xref:System.Web.SessionState.IReadOnlySessionState>interfejsu.</xref:System.Web.SessionState.IReadOnlySessionState> </xref:System.Web.SessionState.IRequiresSessionState> Metoda SetSessionStateBehavior i <xref:System.Web.SessionState.SessionStateBehavior>Wyliczenie umożliwiają zapewnienie więcej szczegółów na temat rodzaju obsługi stanu sesji jest wymagane do obsługi żądania.</xref:System.Web.SessionState.SessionStateBehavior> Aby uzyskać więcej informacji, zobacz <xref:System.Web.SessionState.SessionStateBehavior>wyliczenie.</xref:System.Web.SessionState.SessionStateBehavior>       Metoda SetSessionStateBehavior musi zostać wywołana przed <xref:System.Web.HttpApplication.AcquireRequestState>potoku zdarzeń.</xref:System.Web.HttpApplication.AcquireRequestState> Wywołania występujących podczas lub po tym zdarzeniu spowoduje, że <xref:System.InvalidOperationException>wyjątek.</xref:System.InvalidOperationException>"
  syntax:
    content: public void SetSessionStateBehavior (System.Web.SessionState.SessionStateBehavior sessionStateBehavior);
    parameters:
    - id: sessionStateBehavior
      type: System.Web.SessionState.SessionStateBehavior
      description: "Jedną z wartości wyliczenia, które określa, jaki typ zachowania stanu sesji jest wymagana."
  overload: System.Web.HttpContext.SetSessionStateBehavior*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Po wywołaniu metody <xref href=&quot;System.Web.HttpApplication.AcquireRequestState&quot;> </xref> wywołano zdarzenie."
  platform:
  - net462
- uid: System.Web.HttpContext.SkipAuthorization
  id: SkipAuthorization
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: SkipAuthorization
  nameWithType: HttpContext.SkipAuthorization
  fullName: System.Web.HttpContext.SkipAuthorization
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera lub ustawia wartość określającą czy <xref href=&quot;System.Web.Security.UrlAuthorizationModule&quot;> </xref> obiektu należy pominąć sprawdzanie autoryzacji dla bieżącego żądania."
  remarks: "Właściwość SkipAuthorization jest przeznaczony do użycia w zaawansowanych przez moduły uwierzytelniania, które trzeba przekierowanie do strony, który zezwala na połączenia anonimowe. Moduł uwierzytelniania formularzy i moduł uwierzytelniania usługi Passport ustawione SkipAuthorization, gdy przekierowanie do strony logowania skonfigurowany. Ustawienie SkipAuthorization wymaga `ControlPrincipal` flagi. Aby uzyskać informacje o `ControlPrincipal` Flaga, zobacz <xref:System.Security.Permissions.SecurityPermissionFlag>.</xref:System.Security.Permissions.SecurityPermissionFlag>"
  syntax:
    content: public bool SkipAuthorization { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli <xref href=&quot;System.Web.Security.UrlAuthorizationModule&quot;> </xref> należy pominąć sprawdzanie autoryzacji; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Wartość domyślna to <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Web.HttpContext.SkipAuthorization*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.System#IServiceProvider#GetService(System.Type)
  id: System#IServiceProvider#GetService(System.Type)
  isEii: true
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: System.IServiceProvider.GetService(Type)
  nameWithType: HttpContext.System.IServiceProvider.GetService(Type)
  fullName: System.Web.HttpContext.System.IServiceProvider.GetService(Type)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Zwraca obiekt dla bieżącego typu usługi."
  remarks: "Ta metoda jest przydatna do uzyskiwania dostępu do odpowiadającego <xref:System.Web.HttpWorkerRequest>obiektu.</xref:System.Web.HttpWorkerRequest>"
  syntax:
    content: object IServiceProvider.GetService (Type service);
    parameters:
    - id: service
      type: System.Type
      description: "Typ <xref href=&quot;System.Web.HttpContext&quot;> </xref> usługi, aby ustawić dostawcy usług."
    return:
      type: System.Object
      description: "A <xref href=&quot;System.Web.HttpContext&quot;> </xref>; w przeciwnym razie <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Jeśli usługa nie zostanie znaleziony."
  overload: System.Web.HttpContext.System#IServiceProvider#GetService*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.ThreadAbortOnTimeout
  id: ThreadAbortOnTimeout
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: ThreadAbortOnTimeout
  nameWithType: HttpContext.ThreadAbortOnTimeout
  fullName: System.Web.HttpContext.ThreadAbortOnTimeout
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera lub ustawia wartość określającą, czy środowiska uruchomieniowego ASP.NET powinny wywoływać &lt;xref:System.Threading.Thread.Abort%2A?displayProperty=fullName&gt; w wątku, który jest obsługi tego żądania, gdy upłynie limit czasu żądania."
  remarks: "Programy obsługi i modułów, które korzystają z <xref:System.Web.HttpRequest.TimedOutToken%2A?displayProperty=fullName>właściwości do zaimplementowania wspólne anulowanie ma zostać wyłączone <xref:System.Threading.Thread.Abort%2A?displayProperty=fullName>zachowanie ASP.NET sprawdza domyślnie, gdy upłynie limit czasu żądania.</xref:System.Threading.Thread.Abort%2A?displayProperty=fullName> </xref:System.Web.HttpRequest.TimedOutToken%2A?displayProperty=fullName> Ustawienie tej właściwości na `false` może pomóc upewnić się, że procedury anulowania oraz podczas oczyszczania będzie działać bez przez program ASP.NET.       Jeśli ta właściwość jest ustawiona na `false`, program ASP.NET nie automatycznie wyświetlają stronę błędu &quot;Upłynął limit czasu żądania&quot;, gdy zostanie przekroczony limit czasu. Aplikacja jest odpowiedzialny za ustawianie odpowiednio zawartości odpowiedzi."
  syntax:
    content: public bool ThreadAbortOnTimeout { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli &lt;xref:System.Threading.Thread.Abort%2A?displayProperty=fullName&gt; będzie wywoływany, gdy wątek razy; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Wartość domyślna to <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Web.HttpContext.ThreadAbortOnTimeout*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.Timestamp
  id: Timestamp
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: Timestamp
  nameWithType: HttpContext.Timestamp
  fullName: System.Web.HttpContext.Timestamp
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera początkowy sygnatury czasowej bieżącego żądania HTTP."
  remarks: "Sygnatura czasowa zwrócone przez właściwość sygnatury czasowej czasu lokalnego serwera, a jest ustawiana podczas tworzenia wystąpienia elementu <xref:System.Web.HttpContext>obiektu.</xref:System.Web.HttpContext> Czas lokalny jest równa czas UTC oraz przesunięcie czasu UTC."
  syntax:
    content: public DateTime Timestamp { get; }
    return:
      type: System.DateTime
      description: "Sygnatura czasowa bieżącego żądania HTTP."
  overload: System.Web.HttpContext.Timestamp*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.Trace
  id: Trace
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: Trace
  nameWithType: HttpContext.Trace
  fullName: System.Web.HttpContext.Trace
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera <xref href=&quot;System.Web.TraceContext&quot;> </xref> obiektu dla bieżącej odpowiedzi HTTP."
  syntax:
    content: public System.Web.TraceContext Trace { get; }
    return:
      type: System.Web.TraceContext
      description: "<xref href=&quot;System.Web.TraceContext&quot;> </xref> Dla bieżącej odpowiedzi HTTP."
  overload: System.Web.HttpContext.Trace*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.User
  id: User
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: User
  nameWithType: HttpContext.User
  fullName: System.Web.HttpContext.User
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera lub ustawia informacje dotyczące zabezpieczeń dla bieżącego żądania HTTP."
  remarks: "Właściwości użytkownika zapewnia dostęp programistyczny do właściwości i metod <xref:System.Security.Principal.IPrincipal>interfejsu.</xref:System.Security.Principal.IPrincipal>       Ponieważ stron ASP.NET zawiera domyślne odwołanie do <xref:System.Web>przestrzeni nazw (która zawiera <xref:System.Web.HttpContext>klasy), możesz odwoływać się do elementów członkowskich <xref:System.Web.HttpContext>na stronę .aspx, bez korzystania z klasy w pełni kwalifikowane odwołanie do <xref:System.Web.HttpContext>.</xref:System.Web.HttpContext> </xref:System.Web.HttpContext> </xref:System.Web.HttpContext> </xref:System.Web> Na przykład można użyć `User.Identity.Name` uzyskać nazwy użytkownika w imieniu którego bieżący proces jest uruchomiony. Jednak jeśli chcesz używać elementów członkowskich <xref:System.Security.Principal.IPrincipal>z modułu CodeBehind ASP.NET musi zawierać odwołanie do <xref:System.Web>przestrzeni nazw w moduł i w pełni kwalifikowane odwołanie do zarówno kontekst aktualnie aktywne żądanie/odpowiedź, jak i klasy w <xref:System.Web>, który ma być używany.</xref:System.Web> </xref:System.Web> </xref:System.Security.Principal.IPrincipal> Na przykład na stronie CodeBehind należy określić w pełni kwalifikowana nazwa `HttpContext.Current.User.Identity.Name`."
  example:
  - "The following example shows how to access properties of the current user through the User property. Those properties are used to set the title of the Web page.  \n  \n If the application uses Windows authentication, the user name includes the domain. For example, the page title would be “Home page for DOMAIN\\username”.  \n  \n [!code-cs[System.Web.HttpContext.User#1](~/add/codesnippet/csharp/p-system.web.httpcontext_1_1.cs)]\n [!code-vb[System.Web.HttpContext.User#1](~/add/codesnippet/visualbasic/p-system.web.httpcontext_1_1.vb)]"
  syntax:
    content: public System.Security.Principal.IPrincipal User { get; set; }
    return:
      type: System.Security.Principal.IPrincipal
      description: "Informacje o zabezpieczeniach dla bieżącego żądania HTTP."
  overload: System.Web.HttpContext.User*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.WebSocketNegotiatedProtocol
  id: WebSocketNegotiatedProtocol
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: WebSocketNegotiatedProtocol
  nameWithType: HttpContext.WebSocketNegotiatedProtocol
  fullName: System.Web.HttpContext.WebSocketNegotiatedProtocol
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera wynegocjowanym protokołem przesłanym z serwera do klienta dla <xref href=&quot;System.Web.WebSockets.AspNetWebSocket&quot;> </xref> połączenia."
  syntax:
    content: public string WebSocketNegotiatedProtocol { get; }
    return:
      type: System.String
      description: "Wynegocjowanym protokołem."
  overload: System.Web.HttpContext.WebSocketNegotiatedProtocol*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.WebSocketRequestedProtocols
  id: WebSocketRequestedProtocols
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: WebSocketRequestedProtocols
  nameWithType: HttpContext.WebSocketRequestedProtocols
  fullName: System.Web.HttpContext.WebSocketRequestedProtocols
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "Pobiera uporządkowaną listę protokołów żądanego przez klienta."
  syntax:
    content: public System.Collections.Generic.IList<string> WebSocketRequestedProtocols { get; }
    return:
      type: System.Collections.Generic.IList{System.String}
      description: "Żądane protokoły lub <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Jeśli nie jest to <xref href=&quot;System.Web.WebSockets.AspNetWebSocket&quot;> </xref> żądania albo jeśli brak listy nie jest obecny."
  overload: System.Web.HttpContext.WebSocketRequestedProtocols*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.Resources.MissingManifestResourceException
  isExternal: true
  name: System.Resources.MissingManifestResourceException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Web.HttpException
  parent: System.Web
  isExternal: false
  name: HttpException
  nameWithType: HttpException
  fullName: System.Web.HttpException
- uid: System.Web.HttpContext.#ctor(System.Web.HttpWorkerRequest)
  parent: System.Web.HttpContext
  isExternal: false
  name: HttpContext(HttpWorkerRequest)
  nameWithType: HttpContext.HttpContext(HttpWorkerRequest)
  fullName: System.Web.HttpContext.HttpContext(HttpWorkerRequest)
- uid: System.Web.HttpWorkerRequest
  parent: System.Web
  isExternal: false
  name: HttpWorkerRequest
  nameWithType: HttpWorkerRequest
  fullName: System.Web.HttpWorkerRequest
- uid: System.Web.HttpContext.#ctor(System.Web.HttpRequest,System.Web.HttpResponse)
  parent: System.Web.HttpContext
  isExternal: false
  name: HttpContext(HttpRequest,HttpResponse)
  nameWithType: HttpContext.HttpContext(HttpRequest,HttpResponse)
  fullName: System.Web.HttpContext.HttpContext(HttpRequest,HttpResponse)
- uid: System.Web.HttpRequest
  parent: System.Web
  isExternal: false
  name: HttpRequest
  nameWithType: HttpRequest
  fullName: System.Web.HttpRequest
- uid: System.Web.HttpResponse
  parent: System.Web
  isExternal: false
  name: HttpResponse
  nameWithType: HttpResponse
  fullName: System.Web.HttpResponse
- uid: System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})
  parent: System.Web.HttpContext
  isExternal: false
  name: AcceptWebSocketRequest(Func<AspNetWebSocketContext,Task>)
  nameWithType: HttpContext.AcceptWebSocketRequest(Func<AspNetWebSocketContext,Task>)
  fullName: System.Web.HttpContext.AcceptWebSocketRequest(Func<AspNetWebSocketContext,Task>)
- uid: System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task}
  parent: System
  isExternal: true
  name: Func<AspNetWebSocketContext,Task>
  nameWithType: Func<AspNetWebSocketContext,Task>
  fullName: System.Func<System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task>
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: Func<System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Web.WebSockets.AspNetWebSocketContext
    name: AspNetWebSocketContext
    nameWithType: AspNetWebSocketContext
    fullName: AspNetWebSocketContext
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: Task
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)
  parent: System.Web.HttpContext
  isExternal: false
  name: AcceptWebSocketRequest(Func<AspNetWebSocketContext,Task>,AspNetWebSocketOptions)
  nameWithType: HttpContext.AcceptWebSocketRequest(Func<AspNetWebSocketContext,Task>,AspNetWebSocketOptions)
  fullName: System.Web.HttpContext.AcceptWebSocketRequest(Func<AspNetWebSocketContext,Task>,AspNetWebSocketOptions)
- uid: System.Web.WebSockets.AspNetWebSocketOptions
  parent: System.Web.WebSockets
  isExternal: false
  name: AspNetWebSocketOptions
  nameWithType: AspNetWebSocketOptions
  fullName: System.Web.WebSockets.AspNetWebSocketOptions
- uid: System.Web.HttpContext.AddError(System.Exception)
  parent: System.Web.HttpContext
  isExternal: false
  name: AddError(Exception)
  nameWithType: HttpContext.AddError(Exception)
  fullName: System.Web.HttpContext.AddError(Exception)
- uid: System.Exception
  parent: System
  isExternal: true
  name: Exception
  nameWithType: Exception
  fullName: System.Exception
- uid: System.Web.HttpContext.AddOnRequestCompleted(System.Action{System.Web.HttpContext})
  parent: System.Web.HttpContext
  isExternal: false
  name: AddOnRequestCompleted(Action<HttpContext>)
  nameWithType: HttpContext.AddOnRequestCompleted(Action<HttpContext>)
  fullName: System.Web.HttpContext.AddOnRequestCompleted(Action<HttpContext>)
- uid: System.Web.ISubscriptionToken
  parent: System.Web
  isExternal: false
  name: ISubscriptionToken
  nameWithType: ISubscriptionToken
  fullName: System.Web.ISubscriptionToken
- uid: System.Action{System.Web.HttpContext}
  parent: System
  isExternal: true
  name: Action<HttpContext>
  nameWithType: Action<HttpContext>
  fullName: System.Action<System.Web.HttpContext>
  spec.csharp:
  - uid: System.Action`1
    name: Action
    nameWithType: Action
    fullName: Action<System.Web.HttpContext>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Web.HttpContext
    name: HttpContext
    nameWithType: HttpContext
    fullName: HttpContext
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Web.HttpContext.AllErrors
  parent: System.Web.HttpContext
  isExternal: false
  name: AllErrors
  nameWithType: HttpContext.AllErrors
  fullName: System.Web.HttpContext.AllErrors
- uid: System.Exception[]
  parent: System
  isExternal: true
  name: Exception
  nameWithType: Exception
  fullName: System.Exception[]
  spec.csharp:
  - uid: System.Exception
    name: Exception
    nameWithType: Exception
    fullName: Exception[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Web.HttpContext.AllowAsyncDuringSyncStages
  parent: System.Web.HttpContext
  isExternal: false
  name: AllowAsyncDuringSyncStages
  nameWithType: HttpContext.AllowAsyncDuringSyncStages
  fullName: System.Web.HttpContext.AllowAsyncDuringSyncStages
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Web.HttpContext.Application
  parent: System.Web.HttpContext
  isExternal: false
  name: Application
  nameWithType: HttpContext.Application
  fullName: System.Web.HttpContext.Application
- uid: System.Web.HttpApplicationState
  parent: System.Web
  isExternal: false
  name: HttpApplicationState
  nameWithType: HttpApplicationState
  fullName: System.Web.HttpApplicationState
- uid: System.Web.HttpContext.ApplicationInstance
  parent: System.Web.HttpContext
  isExternal: false
  name: ApplicationInstance
  nameWithType: HttpContext.ApplicationInstance
  fullName: System.Web.HttpContext.ApplicationInstance
- uid: System.Web.HttpApplication
  parent: System.Web
  isExternal: false
  name: HttpApplication
  nameWithType: HttpApplication
  fullName: System.Web.HttpApplication
- uid: System.Web.HttpContext.AsyncPreloadMode
  parent: System.Web.HttpContext
  isExternal: false
  name: AsyncPreloadMode
  nameWithType: HttpContext.AsyncPreloadMode
  fullName: System.Web.HttpContext.AsyncPreloadMode
- uid: System.Web.Configuration.AsyncPreloadModeFlags
  parent: System.Web.Configuration
  isExternal: false
  name: AsyncPreloadModeFlags
  nameWithType: AsyncPreloadModeFlags
  fullName: System.Web.Configuration.AsyncPreloadModeFlags
- uid: System.Web.HttpContext.Cache
  parent: System.Web.HttpContext
  isExternal: false
  name: Cache
  nameWithType: HttpContext.Cache
  fullName: System.Web.HttpContext.Cache
- uid: System.Web.Caching.Cache
  parent: System.Web.Caching
  isExternal: false
  name: Cache
  nameWithType: Cache
  fullName: System.Web.Caching.Cache
- uid: System.Web.HttpContext.ClearError
  parent: System.Web.HttpContext
  isExternal: false
  name: ClearError()
  nameWithType: HttpContext.ClearError()
  fullName: System.Web.HttpContext.ClearError()
- uid: System.Web.HttpContext.Current
  parent: System.Web.HttpContext
  isExternal: false
  name: Current
  nameWithType: HttpContext.Current
  fullName: System.Web.HttpContext.Current
- uid: System.Web.HttpContext
  parent: System.Web
  isExternal: false
  name: HttpContext
  nameWithType: HttpContext
  fullName: System.Web.HttpContext
- uid: System.Web.HttpContext.CurrentHandler
  parent: System.Web.HttpContext
  isExternal: false
  name: CurrentHandler
  nameWithType: HttpContext.CurrentHandler
  fullName: System.Web.HttpContext.CurrentHandler
- uid: System.Web.IHttpHandler
  parent: System.Web
  isExternal: false
  name: IHttpHandler
  nameWithType: IHttpHandler
  fullName: System.Web.IHttpHandler
- uid: System.Web.HttpContext.CurrentNotification
  parent: System.Web.HttpContext
  isExternal: false
  name: CurrentNotification
  nameWithType: HttpContext.CurrentNotification
  fullName: System.Web.HttpContext.CurrentNotification
- uid: System.Web.RequestNotification
  parent: System.Web
  isExternal: false
  name: RequestNotification
  nameWithType: RequestNotification
  fullName: System.Web.RequestNotification
- uid: System.Web.HttpContext.DisposeOnPipelineCompleted(System.IDisposable)
  parent: System.Web.HttpContext
  isExternal: false
  name: DisposeOnPipelineCompleted(IDisposable)
  nameWithType: HttpContext.DisposeOnPipelineCompleted(IDisposable)
  fullName: System.Web.HttpContext.DisposeOnPipelineCompleted(IDisposable)
- uid: System.IDisposable
  parent: System
  isExternal: true
  name: IDisposable
  nameWithType: IDisposable
  fullName: System.IDisposable
- uid: System.Web.HttpContext.Error
  parent: System.Web.HttpContext
  isExternal: false
  name: Error
  nameWithType: HttpContext.Error
  fullName: System.Web.HttpContext.Error
- uid: System.Web.HttpContext.GetAppConfig(System.String)
  parent: System.Web.HttpContext
  isExternal: false
  name: GetAppConfig(String)
  nameWithType: HttpContext.GetAppConfig(String)
  fullName: System.Web.HttpContext.GetAppConfig(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Web.HttpContext.GetConfig(System.String)
  parent: System.Web.HttpContext
  isExternal: false
  name: GetConfig(String)
  nameWithType: HttpContext.GetConfig(String)
  fullName: System.Web.HttpContext.GetConfig(String)
- uid: System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String)
  parent: System.Web.HttpContext
  isExternal: false
  name: GetGlobalResourceObject(String,String)
  nameWithType: HttpContext.GetGlobalResourceObject(String,String)
  fullName: System.Web.HttpContext.GetGlobalResourceObject(String,String)
- uid: System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)
  parent: System.Web.HttpContext
  isExternal: false
  name: GetGlobalResourceObject(String,String,CultureInfo)
  nameWithType: HttpContext.GetGlobalResourceObject(String,String,CultureInfo)
  fullName: System.Web.HttpContext.GetGlobalResourceObject(String,String,CultureInfo)
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.Web.HttpContext.GetLocalResourceObject(System.String,System.String)
  parent: System.Web.HttpContext
  isExternal: false
  name: GetLocalResourceObject(String,String)
  nameWithType: HttpContext.GetLocalResourceObject(String,String)
  fullName: System.Web.HttpContext.GetLocalResourceObject(String,String)
- uid: System.Web.HttpContext.GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)
  parent: System.Web.HttpContext
  isExternal: false
  name: GetLocalResourceObject(String,String,CultureInfo)
  nameWithType: HttpContext.GetLocalResourceObject(String,String,CultureInfo)
  fullName: System.Web.HttpContext.GetLocalResourceObject(String,String,CultureInfo)
- uid: System.Web.HttpContext.GetSection(System.String)
  parent: System.Web.HttpContext
  isExternal: false
  name: GetSection(String)
  nameWithType: HttpContext.GetSection(String)
  fullName: System.Web.HttpContext.GetSection(String)
- uid: System.Web.HttpContext.Handler
  parent: System.Web.HttpContext
  isExternal: false
  name: Handler
  nameWithType: HttpContext.Handler
  fullName: System.Web.HttpContext.Handler
- uid: System.Web.HttpContext.IsCustomErrorEnabled
  parent: System.Web.HttpContext
  isExternal: false
  name: IsCustomErrorEnabled
  nameWithType: HttpContext.IsCustomErrorEnabled
  fullName: System.Web.HttpContext.IsCustomErrorEnabled
- uid: System.Web.HttpContext.IsDebuggingEnabled
  parent: System.Web.HttpContext
  isExternal: false
  name: IsDebuggingEnabled
  nameWithType: HttpContext.IsDebuggingEnabled
  fullName: System.Web.HttpContext.IsDebuggingEnabled
- uid: System.Web.HttpContext.IsPostNotification
  parent: System.Web.HttpContext
  isExternal: false
  name: IsPostNotification
  nameWithType: HttpContext.IsPostNotification
  fullName: System.Web.HttpContext.IsPostNotification
- uid: System.Web.HttpContext.IsWebSocketRequest
  parent: System.Web.HttpContext
  isExternal: false
  name: IsWebSocketRequest
  nameWithType: HttpContext.IsWebSocketRequest
  fullName: System.Web.HttpContext.IsWebSocketRequest
- uid: System.Web.HttpContext.IsWebSocketRequestUpgrading
  parent: System.Web.HttpContext
  isExternal: false
  name: IsWebSocketRequestUpgrading
  nameWithType: HttpContext.IsWebSocketRequestUpgrading
  fullName: System.Web.HttpContext.IsWebSocketRequestUpgrading
- uid: System.Web.HttpContext.Items
  parent: System.Web.HttpContext
  isExternal: false
  name: Items
  nameWithType: HttpContext.Items
  fullName: System.Web.HttpContext.Items
- uid: System.Collections.IDictionary
  parent: System.Collections
  isExternal: true
  name: IDictionary
  nameWithType: IDictionary
  fullName: System.Collections.IDictionary
- uid: System.Web.HttpContext.PageInstrumentation
  parent: System.Web.HttpContext
  isExternal: false
  name: PageInstrumentation
  nameWithType: HttpContext.PageInstrumentation
  fullName: System.Web.HttpContext.PageInstrumentation
- uid: System.Web.Instrumentation.PageInstrumentationService
  parent: System.Web.Instrumentation
  isExternal: false
  name: PageInstrumentationService
  nameWithType: PageInstrumentationService
  fullName: System.Web.Instrumentation.PageInstrumentationService
- uid: System.Web.HttpContext.PreviousHandler
  parent: System.Web.HttpContext
  isExternal: false
  name: PreviousHandler
  nameWithType: HttpContext.PreviousHandler
  fullName: System.Web.HttpContext.PreviousHandler
- uid: System.Web.HttpContext.Profile
  parent: System.Web.HttpContext
  isExternal: false
  name: Profile
  nameWithType: HttpContext.Profile
  fullName: System.Web.HttpContext.Profile
- uid: System.Web.Profile.ProfileBase
  parent: System.Web.Profile
  isExternal: false
  name: ProfileBase
  nameWithType: ProfileBase
  fullName: System.Web.Profile.ProfileBase
- uid: System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)
  parent: System.Web.HttpContext
  isExternal: false
  name: RemapHandler(IHttpHandler)
  nameWithType: HttpContext.RemapHandler(IHttpHandler)
  fullName: System.Web.HttpContext.RemapHandler(IHttpHandler)
- uid: System.Web.HttpContext.Request
  parent: System.Web.HttpContext
  isExternal: false
  name: Request
  nameWithType: HttpContext.Request
  fullName: System.Web.HttpContext.Request
- uid: System.Web.HttpContext.Response
  parent: System.Web.HttpContext
  isExternal: false
  name: Response
  nameWithType: HttpContext.Response
  fullName: System.Web.HttpContext.Response
- uid: System.Web.HttpContext.RewritePath(System.String)
  parent: System.Web.HttpContext
  isExternal: false
  name: RewritePath(String)
  nameWithType: HttpContext.RewritePath(String)
  fullName: System.Web.HttpContext.RewritePath(String)
- uid: System.Web.HttpContext.RewritePath(System.String,System.Boolean)
  parent: System.Web.HttpContext
  isExternal: false
  name: RewritePath(String,Boolean)
  nameWithType: HttpContext.RewritePath(String,Boolean)
  fullName: System.Web.HttpContext.RewritePath(String,Boolean)
- uid: System.Web.HttpContext.RewritePath(System.String,System.String,System.String)
  parent: System.Web.HttpContext
  isExternal: false
  name: RewritePath(String,String,String)
  nameWithType: HttpContext.RewritePath(String,String,String)
  fullName: System.Web.HttpContext.RewritePath(String,String,String)
- uid: System.Web.HttpContext.RewritePath(System.String,System.String,System.String,System.Boolean)
  parent: System.Web.HttpContext
  isExternal: false
  name: RewritePath(String,String,String,Boolean)
  nameWithType: HttpContext.RewritePath(String,String,String,Boolean)
  fullName: System.Web.HttpContext.RewritePath(String,String,String,Boolean)
- uid: System.Web.HttpContext.Server
  parent: System.Web.HttpContext
  isExternal: false
  name: Server
  nameWithType: HttpContext.Server
  fullName: System.Web.HttpContext.Server
- uid: System.Web.HttpServerUtility
  parent: System.Web
  isExternal: false
  name: HttpServerUtility
  nameWithType: HttpServerUtility
  fullName: System.Web.HttpServerUtility
- uid: System.Web.HttpContext.Session
  parent: System.Web.HttpContext
  isExternal: false
  name: Session
  nameWithType: HttpContext.Session
  fullName: System.Web.HttpContext.Session
- uid: System.Web.SessionState.HttpSessionState
  parent: System.Web.SessionState
  isExternal: false
  name: HttpSessionState
  nameWithType: HttpSessionState
  fullName: System.Web.SessionState.HttpSessionState
- uid: System.Web.HttpContext.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)
  parent: System.Web.HttpContext
  isExternal: false
  name: SetSessionStateBehavior(SessionStateBehavior)
  nameWithType: HttpContext.SetSessionStateBehavior(SessionStateBehavior)
  fullName: System.Web.HttpContext.SetSessionStateBehavior(SessionStateBehavior)
- uid: System.Web.SessionState.SessionStateBehavior
  parent: System.Web.SessionState
  isExternal: false
  name: SessionStateBehavior
  nameWithType: SessionStateBehavior
  fullName: System.Web.SessionState.SessionStateBehavior
- uid: System.Web.HttpContext.SkipAuthorization
  parent: System.Web.HttpContext
  isExternal: false
  name: SkipAuthorization
  nameWithType: HttpContext.SkipAuthorization
  fullName: System.Web.HttpContext.SkipAuthorization
- uid: System.Web.HttpContext.System#IServiceProvider#GetService(System.Type)
  parent: System.Web.HttpContext
  isExternal: false
  name: System.IServiceProvider.GetService(Type)
  nameWithType: HttpContext.System.IServiceProvider.GetService(Type)
  fullName: System.Web.HttpContext.System.IServiceProvider.GetService(Type)
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Web.HttpContext.ThreadAbortOnTimeout
  parent: System.Web.HttpContext
  isExternal: false
  name: ThreadAbortOnTimeout
  nameWithType: HttpContext.ThreadAbortOnTimeout
  fullName: System.Web.HttpContext.ThreadAbortOnTimeout
- uid: System.Web.HttpContext.Timestamp
  parent: System.Web.HttpContext
  isExternal: false
  name: Timestamp
  nameWithType: HttpContext.Timestamp
  fullName: System.Web.HttpContext.Timestamp
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: System.Web.HttpContext.Trace
  parent: System.Web.HttpContext
  isExternal: false
  name: Trace
  nameWithType: HttpContext.Trace
  fullName: System.Web.HttpContext.Trace
- uid: System.Web.TraceContext
  parent: System.Web
  isExternal: false
  name: TraceContext
  nameWithType: TraceContext
  fullName: System.Web.TraceContext
- uid: System.Web.HttpContext.User
  parent: System.Web.HttpContext
  isExternal: false
  name: User
  nameWithType: HttpContext.User
  fullName: System.Web.HttpContext.User
- uid: System.Security.Principal.IPrincipal
  parent: System.Security.Principal
  isExternal: true
  name: IPrincipal
  nameWithType: IPrincipal
  fullName: System.Security.Principal.IPrincipal
- uid: System.Web.HttpContext.WebSocketNegotiatedProtocol
  parent: System.Web.HttpContext
  isExternal: false
  name: WebSocketNegotiatedProtocol
  nameWithType: HttpContext.WebSocketNegotiatedProtocol
  fullName: System.Web.HttpContext.WebSocketNegotiatedProtocol
- uid: System.Web.HttpContext.WebSocketRequestedProtocols
  parent: System.Web.HttpContext
  isExternal: false
  name: WebSocketRequestedProtocols
  nameWithType: HttpContext.WebSocketRequestedProtocols
  fullName: System.Web.HttpContext.WebSocketRequestedProtocols
- uid: System.Collections.Generic.IList{System.String}
  parent: System.Collections.Generic
  isExternal: true
  name: IList<String>
  nameWithType: IList<String>
  fullName: System.Collections.Generic.IList<System.String>
  spec.csharp:
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: IList<System.String>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Web.HttpContext.#ctor*
  parent: System.Web.HttpContext
  isExternal: false
  name: HttpContext
  nameWithType: HttpContext.HttpContext
- uid: System.Web.HttpContext.AcceptWebSocketRequest*
  parent: System.Web.HttpContext
  isExternal: false
  name: AcceptWebSocketRequest
  nameWithType: HttpContext.AcceptWebSocketRequest
- uid: System.Web.HttpContext.AddError*
  parent: System.Web.HttpContext
  isExternal: false
  name: AddError
  nameWithType: HttpContext.AddError
- uid: System.Web.HttpContext.AddOnRequestCompleted*
  parent: System.Web.HttpContext
  isExternal: false
  name: AddOnRequestCompleted
  nameWithType: HttpContext.AddOnRequestCompleted
- uid: System.Web.HttpContext.AllErrors*
  parent: System.Web.HttpContext
  isExternal: false
  name: AllErrors
  nameWithType: HttpContext.AllErrors
- uid: System.Web.HttpContext.AllowAsyncDuringSyncStages*
  parent: System.Web.HttpContext
  isExternal: false
  name: AllowAsyncDuringSyncStages
  nameWithType: HttpContext.AllowAsyncDuringSyncStages
- uid: System.Web.HttpContext.Application*
  parent: System.Web.HttpContext
  isExternal: false
  name: Application
  nameWithType: HttpContext.Application
- uid: System.Web.HttpContext.ApplicationInstance*
  parent: System.Web.HttpContext
  isExternal: false
  name: ApplicationInstance
  nameWithType: HttpContext.ApplicationInstance
- uid: System.Web.HttpContext.AsyncPreloadMode*
  parent: System.Web.HttpContext
  isExternal: false
  name: AsyncPreloadMode
  nameWithType: HttpContext.AsyncPreloadMode
- uid: System.Web.HttpContext.Cache*
  parent: System.Web.HttpContext
  isExternal: false
  name: Cache
  nameWithType: HttpContext.Cache
- uid: System.Web.HttpContext.ClearError*
  parent: System.Web.HttpContext
  isExternal: false
  name: ClearError
  nameWithType: HttpContext.ClearError
- uid: System.Web.HttpContext.Current*
  parent: System.Web.HttpContext
  isExternal: false
  name: Current
  nameWithType: HttpContext.Current
- uid: System.Web.HttpContext.CurrentHandler*
  parent: System.Web.HttpContext
  isExternal: false
  name: CurrentHandler
  nameWithType: HttpContext.CurrentHandler
- uid: System.Web.HttpContext.CurrentNotification*
  parent: System.Web.HttpContext
  isExternal: false
  name: CurrentNotification
  nameWithType: HttpContext.CurrentNotification
- uid: System.Web.HttpContext.DisposeOnPipelineCompleted*
  parent: System.Web.HttpContext
  isExternal: false
  name: DisposeOnPipelineCompleted
  nameWithType: HttpContext.DisposeOnPipelineCompleted
- uid: System.Web.HttpContext.Error*
  parent: System.Web.HttpContext
  isExternal: false
  name: Error
  nameWithType: HttpContext.Error
- uid: System.Web.HttpContext.GetAppConfig*
  parent: System.Web.HttpContext
  isExternal: false
  name: GetAppConfig
  nameWithType: HttpContext.GetAppConfig
- uid: System.Web.HttpContext.GetConfig*
  parent: System.Web.HttpContext
  isExternal: false
  name: GetConfig
  nameWithType: HttpContext.GetConfig
- uid: System.Web.HttpContext.GetGlobalResourceObject*
  parent: System.Web.HttpContext
  isExternal: false
  name: GetGlobalResourceObject
  nameWithType: HttpContext.GetGlobalResourceObject
- uid: System.Web.HttpContext.GetLocalResourceObject*
  parent: System.Web.HttpContext
  isExternal: false
  name: GetLocalResourceObject
  nameWithType: HttpContext.GetLocalResourceObject
- uid: System.Web.HttpContext.GetSection*
  parent: System.Web.HttpContext
  isExternal: false
  name: GetSection
  nameWithType: HttpContext.GetSection
- uid: System.Web.HttpContext.Handler*
  parent: System.Web.HttpContext
  isExternal: false
  name: Handler
  nameWithType: HttpContext.Handler
- uid: System.Web.HttpContext.IsCustomErrorEnabled*
  parent: System.Web.HttpContext
  isExternal: false
  name: IsCustomErrorEnabled
  nameWithType: HttpContext.IsCustomErrorEnabled
- uid: System.Web.HttpContext.IsDebuggingEnabled*
  parent: System.Web.HttpContext
  isExternal: false
  name: IsDebuggingEnabled
  nameWithType: HttpContext.IsDebuggingEnabled
- uid: System.Web.HttpContext.IsPostNotification*
  parent: System.Web.HttpContext
  isExternal: false
  name: IsPostNotification
  nameWithType: HttpContext.IsPostNotification
- uid: System.Web.HttpContext.IsWebSocketRequest*
  parent: System.Web.HttpContext
  isExternal: false
  name: IsWebSocketRequest
  nameWithType: HttpContext.IsWebSocketRequest
- uid: System.Web.HttpContext.IsWebSocketRequestUpgrading*
  parent: System.Web.HttpContext
  isExternal: false
  name: IsWebSocketRequestUpgrading
  nameWithType: HttpContext.IsWebSocketRequestUpgrading
- uid: System.Web.HttpContext.Items*
  parent: System.Web.HttpContext
  isExternal: false
  name: Items
  nameWithType: HttpContext.Items
- uid: System.Web.HttpContext.PageInstrumentation*
  parent: System.Web.HttpContext
  isExternal: false
  name: PageInstrumentation
  nameWithType: HttpContext.PageInstrumentation
- uid: System.Web.HttpContext.PreviousHandler*
  parent: System.Web.HttpContext
  isExternal: false
  name: PreviousHandler
  nameWithType: HttpContext.PreviousHandler
- uid: System.Web.HttpContext.Profile*
  parent: System.Web.HttpContext
  isExternal: false
  name: Profile
  nameWithType: HttpContext.Profile
- uid: System.Web.HttpContext.RemapHandler*
  parent: System.Web.HttpContext
  isExternal: false
  name: RemapHandler
  nameWithType: HttpContext.RemapHandler
- uid: System.Web.HttpContext.Request*
  parent: System.Web.HttpContext
  isExternal: false
  name: Request
  nameWithType: HttpContext.Request
- uid: System.Web.HttpContext.Response*
  parent: System.Web.HttpContext
  isExternal: false
  name: Response
  nameWithType: HttpContext.Response
- uid: System.Web.HttpContext.RewritePath*
  parent: System.Web.HttpContext
  isExternal: false
  name: RewritePath
  nameWithType: HttpContext.RewritePath
- uid: System.Web.HttpContext.Server*
  parent: System.Web.HttpContext
  isExternal: false
  name: Server
  nameWithType: HttpContext.Server
- uid: System.Web.HttpContext.Session*
  parent: System.Web.HttpContext
  isExternal: false
  name: Session
  nameWithType: HttpContext.Session
- uid: System.Web.HttpContext.SetSessionStateBehavior*
  parent: System.Web.HttpContext
  isExternal: false
  name: SetSessionStateBehavior
  nameWithType: HttpContext.SetSessionStateBehavior
- uid: System.Web.HttpContext.SkipAuthorization*
  parent: System.Web.HttpContext
  isExternal: false
  name: SkipAuthorization
  nameWithType: HttpContext.SkipAuthorization
- uid: System.Web.HttpContext.System#IServiceProvider#GetService*
  parent: System.Web.HttpContext
  isExternal: false
  name: System.IServiceProvider.GetService
  nameWithType: HttpContext.System.IServiceProvider.GetService
- uid: System.Web.HttpContext.ThreadAbortOnTimeout*
  parent: System.Web.HttpContext
  isExternal: false
  name: ThreadAbortOnTimeout
  nameWithType: HttpContext.ThreadAbortOnTimeout
- uid: System.Web.HttpContext.Timestamp*
  parent: System.Web.HttpContext
  isExternal: false
  name: Timestamp
  nameWithType: HttpContext.Timestamp
- uid: System.Web.HttpContext.Trace*
  parent: System.Web.HttpContext
  isExternal: false
  name: Trace
  nameWithType: HttpContext.Trace
- uid: System.Web.HttpContext.User*
  parent: System.Web.HttpContext
  isExternal: false
  name: User
  nameWithType: HttpContext.User
- uid: System.Web.HttpContext.WebSocketNegotiatedProtocol*
  parent: System.Web.HttpContext
  isExternal: false
  name: WebSocketNegotiatedProtocol
  nameWithType: HttpContext.WebSocketNegotiatedProtocol
- uid: System.Web.HttpContext.WebSocketRequestedProtocols*
  parent: System.Web.HttpContext
  isExternal: false
  name: WebSocketRequestedProtocols
  nameWithType: HttpContext.WebSocketRequestedProtocols
