### YamlMime:ManagedReference
items:
- uid: System.Messaging.MessageEnumerator
  id: MessageEnumerator
  children:
  - System.Messaging.MessageEnumerator.Close
  - System.Messaging.MessageEnumerator.Current
  - System.Messaging.MessageEnumerator.CursorHandle
  - System.Messaging.MessageEnumerator.Dispose
  - System.Messaging.MessageEnumerator.Dispose(System.Boolean)
  - System.Messaging.MessageEnumerator.MoveNext
  - System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)
  - System.Messaging.MessageEnumerator.RemoveCurrent
  - System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)
  - System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)
  - System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)
  - System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)
  - System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)
  - System.Messaging.MessageEnumerator.Reset
  - System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current
  langs:
  - csharp
  name: MessageEnumerator
  nameWithType: MessageEnumerator
  fullName: System.Messaging.MessageEnumerator
  type: Class
  summary: "Zawiera tylko do przodu kursora do sortowania wiadomości z kolejki wiadomości."
  remarks: "MessageEnumerator na użytek dynamicznej interakcji z wiadomości w kolejce. Dostępne za pośrednictwem metody <xref:System.Messaging.MessageQueue>klasy może zwrócić albo MessageEnumerator wskazuje dynamiczną listę wiadomości w kolejce lub tablicę, która zawiera kopię w danej chwili - migawki - kolejki w czasie określonym metoda została wywołana.</xref:System.Messaging.MessageQueue>       W odróżnieniu od statycznej migawki moduł wyliczający umożliwia modyfikowanie kolekcji. Przy użyciu MessageEnumerator, można usunąć wiadomości z kolejki i natychmiast znajduje odzwierciedlenie w kolejce.       Moduł wyliczający nie powoduje usunięcia wiadomości z kolejki, gdy wysyła zapytanie kolejki. Zwraca informacje o komunikacie w bieżącym położeniu kursora, ale pozostawia wiadomości w kolejce.       MessageEnumerator jest kursora, zainicjować nagłówek listy dynamicznych. Na liście jest taka sama jak kolejność wiadomości w kolejce, zgodnie z priorytet wiadomości. Kursor można przenieść do pierwszej wiadomości w kolejce, wywołując <xref:System.Messaging.MessageEnumerator.MoveNext%2A>.</xref:System.Messaging.MessageEnumerator.MoveNext%2A> Po zainicjowaniu modułu wyliczającego można użyć <xref:System.Messaging.MessageEnumerator.MoveNext%2A>do krok do przodu w pozostałych wiadomości.</xref:System.Messaging.MessageEnumerator.MoveNext%2A> Można określić, czy oczekiwania na udostępnienie przez przekazanie przekroczenie limitu czasu w wiadomości <xref:System.Messaging.MessageEnumerator.MoveNext%2A>metody.</xref:System.Messaging.MessageEnumerator.MoveNext%2A>       Ponieważ moduł wyliczający jest dynamiczny, komunikat, który jest dołączany poza bieżącej pozycji kursora (na przykład ze względu na niski priorytet), są dostępne przez moduł wyliczający. Komunikat, który zostanie wstawiony przed nie można uzyskać dostępu do bieżącego położenia kursora. Nie jest możliwe krok wstecz z MessageEnumerator. Kursor umożliwia przenoszenie tylko do przodu. <xref:System.Messaging.MessageEnumerator.Reset%2A>Metoda umożliwia umieść kursor wstecz na początek kolejki.</xref:System.Messaging.MessageEnumerator.Reset%2A>       Wystąpienia MessageEnumerator do danej kolejki działać niezależnie. Możesz utworzyć dwa wystąpienia MessageEnumerator, które mają zastosowanie do tej samej kolejki. Jeśli drugi moduł wyliczający jest umieszczony przed pierwszą zmiany, które MessageEnumerator co sprawia, że do wiadomości w kolejce zostaną natychmiast odzwierciedlone w drugim modułu wyliczającego. Jednak jeśli dwa moduły wyliczające mieć to samo położenie i jeden z nich usuwa komunikat na tej pozycji, jest zwracany wyjątek, jeśli inne modułu wyliczającego próbuje pobrać wartość <xref:System.Messaging.MessageEnumerator.Current%2A>Właściwości wiadomości usunięty teraz.</xref:System.Messaging.MessageEnumerator.Current%2A>      > [!NOTE] > W przypadku utworzenia wystąpienia <xref:System.Messaging.MessageQueue>z <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=fullName>ustawioną `true`, żadna inna aplikacja nie mogą modyfikować wiadomości w sieci modułu wyliczającego, gdy masz połączenie z kolejki.</xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=fullName> </xref:System.Messaging.MessageQueue>"
  example:
  - "The following example gets a dynamic list of messages in a queue and counts all messages with the <xref:System.Messaging.Message.Priority%2A> property set to <xref:System.Messaging.MessagePriority?displayProperty=fullName>.  \n  \n [!code-cs[MessageQueue.GetMessageEnumerator#1](~/add/codesnippet/csharp/t-system.messaging.messa_2_1.cs)]\n [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/add/codesnippet/cpp/t-system.messaging.messa_2_1.cpp)]\n [!code-vb[MessageQueue.GetMessageEnumerator#1](~/add/codesnippet/visualbasic/t-system.messaging.messa_2_1.vb)]"
  syntax:
    content: 'public class MessageEnumerator : MarshalByRefObject, IDisposable, System.Collections.IEnumerator'
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  implements:
  - System.Collections.IEnumerator
  - System.IDisposable
  inheritedMembers:
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.Close
  id: Close
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: Close()
  nameWithType: MessageEnumerator.Close()
  fullName: System.Messaging.MessageEnumerator.Close()
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Zwalnia zasoby skojarzone z modułu wyliczającego."
  remarks: "System operacyjny zachowuje otwarte dojście do kolejki przez cały okres istnienia kursora. Po zakończeniu pracy z modułu wyliczającego wywołania Zamknij, aby zwolnić zasoby skojarzone z dojścia."
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Messaging.MessageEnumerator.Close*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.Current
  id: Current
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: Current
  nameWithType: MessageEnumerator.Current
  fullName: System.Messaging.MessageEnumerator.Current
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera bieżący <xref href=&quot;System.Messaging.Message&quot;> </xref> wskazuje dla tego modułu wyliczającego."
  remarks: "Po utworzeniu modułu wyliczającego wskazuje head kolejki, w miejscu przed pierwszą wiadomością. W takim przypadku bieżące jest nieprawidłowy i zgłosi wyjątek, jeśli jest on dostępny. Należy wywołać <xref:System.Messaging.MessageEnumerator.MoveNext%2A>Aby umieść kursor wglądu do pierwszej wiadomości w kolejce.</xref:System.Messaging.MessageEnumerator.MoveNext%2A>"
  syntax:
    content: public System.Messaging.Message Current { get; }
    return:
      type: System.Messaging.Message
      description: "Bieżący komunikat."
  overload: System.Messaging.MessageEnumerator.Current*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Bieżąca jest wywoływana przed pierwszym wywołaniu <> </> *>. Kursor znajduje się przed pierwszym elementem wyliczenia wiadomości.       - lub - bieżącego jest wywoływana po wywołaniu <> </> *> zwrócił <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (wskazująca, gdy kursor znajduje się za ostatnim elementem wyliczenia komunikat.)"
  - type: System.Messaging.MessageQueueException
    commentId: T:System.Messaging.MessageQueueException
    description: "Komunikat, który moduł wyliczający aktualnie wskazuje już istnieje. Być może został usunięty."
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.CursorHandle
  id: CursorHandle
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: CursorHandle
  nameWithType: MessageEnumerator.CursorHandle
  fullName: System.Messaging.MessageEnumerator.CursorHandle
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Pobiera usługę kolejkowania komunikatów kursora uchwyt macierzysty używany do przeglądania wiadomości w kolejce."
  remarks: "Ta właściwość zawiera uchwyt macierzysty do wyliczenia. Po zakończeniu pracy z modułu wyliczającego wywołać <xref:System.Messaging.MessageEnumerator.Close%2A>zwolnienia tego zasobu.</xref:System.Messaging.MessageEnumerator.Close%2A>"
  syntax:
    content: public IntPtr CursorHandle { get; }
    return:
      type: System.IntPtr
      description: "Uchwyt macierzysty kursora."
  overload: System.Messaging.MessageEnumerator.CursorHandle*
  exceptions:
  - type: System.Messaging.MessageQueueException
    commentId: T:System.Messaging.MessageQueueException
    description: "Dojście nie istnieje."
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.Dispose
  id: Dispose
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: Dispose()
  nameWithType: MessageEnumerator.Dispose()
  fullName: System.Messaging.MessageEnumerator.Dispose()
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Zwalnia wszelkie zasoby używane przez <xref href=&quot;System.Messaging.MessageEnumerator&quot;> </xref>."
  remarks: "Wywołanie metody Dispose umożliwia zasoby używane przez <xref:System.Messaging.MessageEnumerator>odbiorczego do innych celów.</xref:System.Messaging.MessageEnumerator> Aby uzyskać więcej informacji na temat usuwania, zobacz [czyszczenie zasobów niezarządzanych](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: System.Messaging.MessageEnumerator.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: MessageEnumerator.Dispose(Boolean)
  fullName: System.Messaging.MessageEnumerator.Dispose(Boolean)
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Zwalnia zasoby niezarządzane używane przez <xref href=&quot;System.Messaging.MessageEnumerator&quot;> </xref> i opcjonalnie zwalnia zasoby zarządzane."
  remarks: "Ta metoda jest wywoływana przez metodę publiczną <xref:System.Messaging.MessageEnumerator.Dispose%2A>— Metoda i <xref:System.Object.Finalize%2A>metody.</xref:System.Object.Finalize%2A> </xref:System.Messaging.MessageEnumerator.Dispose%2A> `Dispose()`wywołuje chronioną metodę `Dispose(Boolean)` metody z `disposing` ustawiona `true`. <xref:System.Object.Finalize%2A>wywołuje `Dispose` z `disposing` ustawioną `false`.</xref:System.Object.Finalize%2A>       Gdy `disposing` parametr jest `true`, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane przez to <xref:System.Messaging.MessageEnumerator>odwołań.</xref:System.Messaging.MessageEnumerator> Ta metoda wywołuje `Dispose()` metody każdego odwołuje się do obiektu."
  syntax:
    content: protected virtual void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby zwolnić zasoby zarządzane i niezarządzane; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> aby zwolnić tylko zasoby niezarządzane."
  overload: System.Messaging.MessageEnumerator.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.MoveNext
  id: MoveNext
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: MoveNext()
  nameWithType: MessageEnumerator.MoveNext()
  fullName: System.Messaging.MessageEnumerator.MoveNext()
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Przechodzi do następnej wiadomości w kolejce modułu wyliczającego, jeśli jest obecnie dostępny."
  remarks: "To przeciążenie zwraca natychmiast, jeśli nie ma w kolejce. Brak innego przeciążenia, które oczekuje określonej <xref:System.TimeSpan>na odbierane wiadomości.</xref:System.TimeSpan>       Jeśli wiadomość nie jest dostępna, ponieważ kolejka jest pusta lub został przeniesiony poza ostatniego elementu w kolekcji, zwraca MoveNext `false` do wywoływania metody.       Po utworzeniu moduł wyliczający jest koncepcyjnie umieszczony przed pierwszą wiadomość z kolejki, a w pierwszym wywołaniu MoveNext pierwszą wiadomość z kolejki do widoku."
  syntax:
    content: public bool MoveNext ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli moduł wyliczający został pomyślnie zaawansowane do następnej wiadomości; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Jeśli moduł wyliczający osiągnął koniec kolejki."
  overload: System.Messaging.MessageEnumerator.MoveNext*
  exceptions:
  - type: System.Messaging.MessageQueueException
    commentId: T:System.Messaging.MessageQueueException
    description: "Zgłoszono wyjątek specyficzne dla usługi kolejkowania komunikatów."
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)
  id: MoveNext(System.TimeSpan)
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: MoveNext(TimeSpan)
  nameWithType: MessageEnumerator.MoveNext(TimeSpan)
  fullName: System.Messaging.MessageEnumerator.MoveNext(TimeSpan)
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Moduł wyliczający należy przechodzi do następnej wiadomości w kolejce. Jeśli moduł wyliczający jest umieszczony na końcu kolejki <xref:System.Messaging.MessageEnumerator.MoveNext*>czeka, aż wiadomości jest dostępna lub danego limitu czasu wygaśnięcia.</xref:System.Messaging.MessageEnumerator.MoveNext*>"
  remarks: "To przeciążenie czeka, jeśli nie ma w kolejce lub kursor osiągnął koniec kolejki. Jeśli wiadomość nie jest obecnie dostępna, ponieważ kolejka jest pusta lub został przeniesiony poza ostatniego elementu w kolekcji, <xref:System.Messaging.MessageEnumerator.MoveNext%2A>określony limit czasu oczekiwania.</xref:System.Messaging.MessageEnumerator.MoveNext%2A>       Jeśli kursor znajduje się już na końcu kolejki <xref:System.Messaging.MessageEnumerator.MoveNext%2A>zwraca tylko `true` Jeśli nowy komunikat w określonym czasie, aktualnie ma niższy priorytet niż wszystkie wiadomości w kolejce i znajduje się na końcu kolejki.</xref:System.Messaging.MessageEnumerator.MoveNext%2A> Przeciążenia z parametrem nie zwraca natychmiast, jeżeli w kolejce znajdują się dalsze komunikaty.       Po utworzeniu, moduł wyliczający jest koncepcyjnie umieszczony przed pierwszą wiadomością wyliczenia i w pierwszym wywołaniu <xref:System.Messaging.MessageEnumerator.MoveNext%2A>Przełącza pierwszą wiadomością wyliczenie do widoku.</xref:System.Messaging.MessageEnumerator.MoveNext%2A>"
  syntax:
    content: public bool MoveNext (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "<xref:System.TimeSpan>Oczekiwania na jest dostępny, gdy moduł wyliczający jest umieszczony na końcu kolejki wiadomości.</xref:System.TimeSpan>"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli moduł wyliczający pomyślnie poprawionym do następnej wiadomości; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Jeśli moduł wyliczający osiągnął koniec kolejki wiadomości nie są dostępne w czasie określonym przez <code> timeout </code> parametru."
  overload: System.Messaging.MessageEnumerator.MoveNext*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Wartość określona dla parametru limitu czasu jest nieprawidłowa. Ten element reprezentuje może być liczbą ujemną."
  - type: System.Messaging.MessageQueueException
    commentId: T:System.Messaging.MessageQueueException
    description: "Zgłoszono wyjątek specyficzne dla usługi kolejkowania komunikatów.       - lub - upłynął limit czasu."
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.RemoveCurrent
  id: RemoveCurrent
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: RemoveCurrent()
  nameWithType: MessageEnumerator.RemoveCurrent()
  fullName: System.Messaging.MessageEnumerator.RemoveCurrent()
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Usuwa bieżący komunikat z kolejki transakcyjnej lub nietransakcyjna i zwraca komunikat do aplikacji wywołującej. Nie ma limitu czasu określona dla wiadomości w kolejce."
  remarks: "RemoveCurrent usuwa i zwraca komunikat w bieżącej lokalizacji kursora.       Jeśli używasz rejestrowanie kolejki usuwając wiadomość powoduje, że kopia mają być przechowywane w kolejce dziennika, podobnie jak <xref:System.Messaging.MessageQueue>klasy <xref:System.Messaging.MessageQueue.Receive%2A>Metoda wykonuje.</xref:System.Messaging.MessageQueue.Receive%2A> </xref:System.Messaging.MessageQueue>       Po usunięciu bieżącego komunikatu, kursor jest przenoszony do następnej wiadomości. Nie trzeba wywołać <xref:System.Messaging.MessageEnumerator.MoveNext%2A>po wywołaniu metody RemoveCurrent.</xref:System.Messaging.MessageEnumerator.MoveNext%2A>       Można wywołać tego przeciążenia na kolejką transakcyjną, usługi kolejkowania komunikatów tworzy pojedynczy wewnętrzną transakcję."
  syntax:
    content: public System.Messaging.Message RemoveCurrent ();
    parameters: []
    return:
      type: System.Messaging.Message
      description: "A <xref href=&quot;System.Messaging.Message&quot;> </xref> który odwołuje się do pierwszej wiadomości w kolejce dostępne."
  overload: System.Messaging.MessageEnumerator.RemoveCurrent*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)
  id: RemoveCurrent(System.Messaging.MessageQueueTransaction)
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: RemoveCurrent(MessageQueueTransaction)
  nameWithType: MessageEnumerator.RemoveCurrent(MessageQueueTransaction)
  fullName: System.Messaging.MessageEnumerator.RemoveCurrent(MessageQueueTransaction)
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Usuwa bieżący komunikat z kolejką transakcyjną i zwraca komunikat do aplikacji wywołującej. Nie ma limitu czasu określona dla wiadomości w kolejce."
  remarks: "<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>Usuwa i zwraca komunikat w bieżącej lokalizacji kursora, przy użyciu kontekstu wewnętrzną transakcję zdefiniowane przez `transaction` parametru.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>       Jeśli używasz rejestrowanie kolejki usuwając wiadomość powoduje, że kopia mają być przechowywane w kolejce dziennika, podobnie jak <xref:System.Messaging.MessageQueue>klasy <xref:System.Messaging.MessageQueue.Receive%2A>Metoda wykonuje.</xref:System.Messaging.MessageQueue.Receive%2A> </xref:System.Messaging.MessageQueue>       Podczas pracy z kolejek transakcyjnych, wycofywania transakcji powoduje, że wszystkie komunikaty usunięte przez wywołanie do <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>ma zostać zwrócona do kolejki.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Usuwanie nie jest nieodwracalne, dopóki transakcja została przekazana.       Po usunięciu bieżącego komunikatu, kursor jest przenoszony do następnej wiadomości. Nie masz do wywołania <xref:System.Messaging.MessageEnumerator.MoveNext%2A>po wywołaniu metody <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> </xref:System.Messaging.MessageEnumerator.MoveNext%2A>"
  syntax:
    content: public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransaction transaction);
    parameters:
    - id: transaction
      type: System.Messaging.MessageQueueTransaction
      description: "<xref href=&quot;System.Messaging.MessageQueueTransaction&quot;> </xref> Obiekt, który określa transakcji, w którym zostaną usunięte wiadomości."
    return:
      type: System.Messaging.Message
      description: "A <xref href=&quot;System.Messaging.Message&quot;> </xref> który odwołuje się do pierwszej wiadomości w kolejce dostępne."
  overload: System.Messaging.MessageEnumerator.RemoveCurrent*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>transaction</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)
  id: RemoveCurrent(System.Messaging.MessageQueueTransactionType)
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: RemoveCurrent(MessageQueueTransactionType)
  nameWithType: MessageEnumerator.RemoveCurrent(MessageQueueTransactionType)
  fullName: System.Messaging.MessageEnumerator.RemoveCurrent(MessageQueueTransactionType)
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Usuwa bieżący komunikat z kolejki i zwraca komunikat do aplikacji wywołującej. Nie ma limitu czasu określona dla wiadomości w kolejce."
  remarks: "<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>Usuwa i zwraca komunikat w bieżącej lokalizacji kursora, w kontekście transakcji zdefiniowanych przez `transactionType` parametru.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>       Określ `Automatic` dla `transactionType` parametru, jeśli istnieje już w kontekście transakcji zewnętrznej dołączony do wątku, który ma być używany do odbierania wiadomości. Określ `Single` Jeśli chcesz otrzymywać wiadomości jako jedna transakcja wewnętrzna. Można określić `None` Jeśli chcesz otrzymywać wiadomość z kolejki transakcyjnej poza kontekstem transakcji.       Jeśli używasz rejestrowanie kolejki usuwając wiadomość powoduje, że kopia mają być przechowywane w kolejce dziennika, podobnie jak <xref:System.Messaging.MessageQueue>klasy <xref:System.Messaging.MessageQueue.Receive%2A>Metoda wykonuje.</xref:System.Messaging.MessageQueue.Receive%2A> </xref:System.Messaging.MessageQueue>       Podczas pracy z kolejek transakcyjnych, wycofywania transakcji powoduje, że wszystkie komunikaty usunięte przez wywołanie do <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>ma zostać zwrócona do kolejki.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Usuwanie nie jest nieodwracalne, dopóki transakcja została przekazana.       Po usunięciu bieżącego komunikatu, kursor jest przenoszony do następnej wiadomości. Nie masz do wywołania <xref:System.Messaging.MessageEnumerator.MoveNext%2A>po wywołaniu metody <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> </xref:System.Messaging.MessageEnumerator.MoveNext%2A>"
  syntax:
    content: public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransactionType transactionType);
    parameters:
    - id: transactionType
      type: System.Messaging.MessageQueueTransactionType
      description: "Jeden z <xref href=&quot;System.Messaging.MessageQueueTransactionType&quot;> </xref> wartości opisujące typ kontekstu transakcji do skojarzenia z komunikatem."
    return:
      type: System.Messaging.Message
      description: "A <xref href=&quot;System.Messaging.Message&quot;> </xref> który odwołuje się do pierwszej wiadomości w kolejce dostępne."
  overload: System.Messaging.MessageEnumerator.RemoveCurrent*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code> transactionType </code> Parametru nie jest jednym z <xref href=&quot;System.Messaging.MessageQueueTransactionType&quot;> </xref> elementów członkowskich."
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)
  id: RemoveCurrent(System.TimeSpan)
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: RemoveCurrent(TimeSpan)
  nameWithType: MessageEnumerator.RemoveCurrent(TimeSpan)
  fullName: System.Messaging.MessageEnumerator.RemoveCurrent(TimeSpan)
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Usuwa bieżący komunikat z kolejki i zwraca komunikat do aplikacji wywołującej. Jeśli istnieje komunikat do usunięcia, metoda zwraca go bezpośrednio. W przeciwnym razie metoda oczekuje określony limit czasu dla nowej wiadomości do odbierania."
  remarks: "<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>Usuwa i zwraca komunikat w bieżącej lokalizacji kursora.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Jeśli kursor znajduje się na końcu kolejki, to przeciążenie metody czeka, aż wiadomości jest dostępna lub interwału określonego przez `timeout` parametru utracił ważność.       Jeśli używasz rejestrowanie kolejki usuwając wiadomość powoduje, że kopia mają być przechowywane w kolejce dziennika, podobnie jak <xref:System.Messaging.MessageQueue>klasy <xref:System.Messaging.MessageQueue.Receive%2A>Metoda wykonuje.</xref:System.Messaging.MessageQueue.Receive%2A> </xref:System.Messaging.MessageQueue>       Po usunięciu bieżącego komunikatu, kursor jest przenoszony do następnej wiadomości. Nie masz do wywołania <xref:System.Messaging.MessageEnumerator.MoveNext%2A>po wywołaniu metody <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> </xref:System.Messaging.MessageEnumerator.MoveNext%2A>       Można wywołać tego przeciążenia na kolejką transakcyjną, usługi kolejkowania komunikatów tworzy pojedynczy wewnętrzną transakcję."
  syntax:
    content: public System.Messaging.Message RemoveCurrent (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "Interwał czasu oczekiwania na wiadomość w kolejce."
    return:
      type: System.Messaging.Message
      description: "A <xref href=&quot;System.Messaging.Message&quot;> </xref> który odwołuje się do pierwszej wiadomości w kolejce dostępne."
  overload: System.Messaging.MessageEnumerator.RemoveCurrent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Wartość określona dla <code> timeout </code> parametr jest nieprawidłowy."
  - type: System.Messaging.MessageQueueException
    commentId: T:System.Messaging.MessageQueueException
    description: "Upłynął limit czasu."
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)
  id: RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: RemoveCurrent(TimeSpan,MessageQueueTransaction)
  nameWithType: MessageEnumerator.RemoveCurrent(TimeSpan,MessageQueueTransaction)
  fullName: System.Messaging.MessageEnumerator.RemoveCurrent(TimeSpan,MessageQueueTransaction)
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Usuwa bieżący komunikat z kolejką transakcyjną i zwraca komunikat do aplikacji wywołującej. Jeśli istnieje komunikat do usunięcia, metoda zwraca go bezpośrednio. W przeciwnym razie metoda oczekuje określony limit czasu dla nowej wiadomości do odbierania."
  remarks: "<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>Usuwa i zwraca komunikat w bieżącej lokalizacji kursora.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Jeśli kursor znajduje się na końcu kolejki, to przeciążenie metody czeka, aż wiadomości jest dostępna lub interwału określonego przez `timeout` parametru utracił ważność.       Podczas pracy z kolejek transakcyjnych, wycofywania transakcji powoduje, że wszystkie komunikaty usunięte przez wywołanie do <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>ma zostać zwrócona do kolejki.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Usuwanie nie jest nieodwracalne, dopóki transakcja została przekazana.       Jeśli używasz rejestrowanie kolejki usuwając wiadomość powoduje, że kopia mają być przechowywane w kolejce dziennika, podobnie jak <xref:System.Messaging.MessageQueue>klasy <xref:System.Messaging.MessageQueue.Receive%2A>Metoda wykonuje.</xref:System.Messaging.MessageQueue.Receive%2A> </xref:System.Messaging.MessageQueue>       Po usunięciu bieżącego komunikatu, kursor jest przenoszony do następnej wiadomości. Nie masz do wywołania <xref:System.Messaging.MessageEnumerator.MoveNext%2A>po wywołaniu metody <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> </xref:System.Messaging.MessageEnumerator.MoveNext%2A>"
  syntax:
    content: public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "Interwał czasu oczekiwania na wiadomość do usunięcia."
    - id: transaction
      type: System.Messaging.MessageQueueTransaction
      description: "<xref href=&quot;System.Messaging.MessageQueueTransaction&quot;> </xref> Obiekt, który określa kontekst transakcji dla wiadomości."
    return:
      type: System.Messaging.Message
      description: "A <xref href=&quot;System.Messaging.Message&quot;> </xref> który odwołuje się do pierwszej wiadomości w kolejce dostępne."
  overload: System.Messaging.MessageEnumerator.RemoveCurrent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Wartość określona dla <code> timeout </code> parametr jest nieprawidłowy."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>transaction</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Messaging.MessageQueueException
    commentId: T:System.Messaging.MessageQueueException
    description: "Upłynął limit czasu."
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)
  id: RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: RemoveCurrent(TimeSpan,MessageQueueTransactionType)
  nameWithType: MessageEnumerator.RemoveCurrent(TimeSpan,MessageQueueTransactionType)
  fullName: System.Messaging.MessageEnumerator.RemoveCurrent(TimeSpan,MessageQueueTransactionType)
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Usuwa bieżący komunikat z kolejki i zwraca komunikat do aplikacji wywołującej. Jeśli istnieje komunikat do usunięcia, metoda zwraca go bezpośrednio. W przeciwnym razie metoda oczekuje określony limit czasu dla nowej wiadomości do odbierania."
  remarks: "<xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>Usuwa i zwraca komunikat w bieżącej lokalizacji kursora, w kontekście transakcji zdefiniowanych przez `transactionType` parametru.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Jeśli kursor znajduje się na końcu kolejki, to przeciążenie metody czeka, aż wiadomości jest dostępna lub interwału określonego przez `timeout` parametru utracił ważność.       Określ `Automatic` dla `transactionType` parametru, jeśli istnieje już w kontekście transakcji zewnętrznej dołączony do wątku, który ma być używany do odbierania wiadomości. Określ `Single` Jeśli chcesz otrzymywać wiadomości jako jedna transakcja wewnętrzna. Można określić `None` Jeśli chcesz otrzymywać wiadomość z kolejki transakcyjnej poza kontekstem transakcji.       Jeśli używasz rejestrowanie kolejki usuwając wiadomość powoduje, że kopia mają być przechowywane w kolejce dziennika, podobnie jak <xref:System.Messaging.MessageQueue>klasy <xref:System.Messaging.MessageQueue.Receive%2A>Metoda wykonuje.</xref:System.Messaging.MessageQueue.Receive%2A> </xref:System.Messaging.MessageQueue>       Podczas pracy z kolejek transakcyjnych, wycofywania transakcji powoduje, że wszystkie komunikaty usunięte przez wywołanie do <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>ma zostać zwrócona do kolejki.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Usuwanie nie jest nieodwracalne, dopóki transakcja została przekazana.       Po usunięciu bieżącego komunikatu, kursor jest przenoszony do następnej wiadomości. Nie masz do wywołania <xref:System.Messaging.MessageEnumerator.MoveNext%2A>po wywołaniu metody <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> </xref:System.Messaging.MessageEnumerator.MoveNext%2A>"
  syntax:
    content: public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "Interwał czasu oczekiwania na wiadomość do usunięcia."
    - id: transactionType
      type: System.Messaging.MessageQueueTransactionType
      description: "Jeden z <xref href=&quot;System.Messaging.MessageQueueTransactionType&quot;> </xref> wartości opisujące typ kontekstu transakcji do skojarzenia z komunikatem."
    return:
      type: System.Messaging.Message
      description: "A <xref href=&quot;System.Messaging.Message&quot;> </xref> który odwołuje się do pierwszej wiadomości w kolejce dostępne."
  overload: System.Messaging.MessageEnumerator.RemoveCurrent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Wartość określona dla <code> timeout </code> parametr jest nieprawidłowy."
  - type: System.Messaging.MessageQueueException
    commentId: T:System.Messaging.MessageQueueException
    description: "Upłynął limit czasu."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code> transactionType </code> Parametru nie jest jednym z <xref href=&quot;System.Messaging.MessageQueueTransactionType&quot;> </xref> elementów członkowskich."
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.Reset
  id: Reset
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: Reset()
  nameWithType: MessageEnumerator.Reset()
  fullName: System.Messaging.MessageEnumerator.Reset()
  type: Method
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Resetuje bieżącego modułu wyliczającego, więc wskazuje head kolejki."
  remarks: "Moduł wyliczający można przenieść tylko w kierunku do przodu. Użyj tej metody, aby rozpocząć od początku na początek kolejki.       Po wywołaniu metody resetowania, kursor wskazuje pierwszego komunikatu. Nie należy wywołać <xref:System.Messaging.MessageEnumerator.MoveNext%2A>po wywołaniu metody resetowania, aby przesunąć kursor przekazywania do pierwszej wiadomości w kolejce.</xref:System.Messaging.MessageEnumerator.MoveNext%2A>"
  syntax:
    content: public void Reset ();
    parameters: []
  overload: System.Messaging.MessageEnumerator.Reset*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current
  id: System#Collections#IEnumerator#Current
  isEii: true
  parent: System.Messaging.MessageEnumerator
  langs:
  - csharp
  name: System.Collections.IEnumerator.Current
  nameWithType: MessageEnumerator.System.Collections.IEnumerator.Current
  fullName: System.Messaging.MessageEnumerator.System.Collections.IEnumerator.Current
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Zwraca <xref href=&quot;System.Messaging.Message&quot;> </xref> , która odwołuje się komunikat w bieżącym położeniu kursora."
  syntax:
    content: object System.Collections.IEnumerator.Current { get; }
    return:
      type: System.Object
      description: "A <xref href=&quot;System.Messaging.Message&quot;> </xref> , która odwołuje się komunikat w bieżącym położeniu kursora."
  overload: System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current*
  exceptions: []
  platform:
  - net462
references:
- uid: System.MarshalByRefObject
  isExternal: false
  name: System.MarshalByRefObject
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Messaging.MessageQueueException
  parent: System.Messaging
  isExternal: false
  name: MessageQueueException
  nameWithType: MessageQueueException
  fullName: System.Messaging.MessageQueueException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.Messaging.MessageEnumerator.Close
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: Close()
  nameWithType: MessageEnumerator.Close()
  fullName: System.Messaging.MessageEnumerator.Close()
- uid: System.Messaging.MessageEnumerator.Current
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: Current
  nameWithType: MessageEnumerator.Current
  fullName: System.Messaging.MessageEnumerator.Current
- uid: System.Messaging.Message
  parent: System.Messaging
  isExternal: false
  name: Message
  nameWithType: Message
  fullName: System.Messaging.Message
- uid: System.Messaging.MessageEnumerator.CursorHandle
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: CursorHandle
  nameWithType: MessageEnumerator.CursorHandle
  fullName: System.Messaging.MessageEnumerator.CursorHandle
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Messaging.MessageEnumerator.Dispose
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: Dispose()
  nameWithType: MessageEnumerator.Dispose()
  fullName: System.Messaging.MessageEnumerator.Dispose()
- uid: System.Messaging.MessageEnumerator.Dispose(System.Boolean)
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: MessageEnumerator.Dispose(Boolean)
  fullName: System.Messaging.MessageEnumerator.Dispose(Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Messaging.MessageEnumerator.MoveNext
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: MoveNext()
  nameWithType: MessageEnumerator.MoveNext()
  fullName: System.Messaging.MessageEnumerator.MoveNext()
- uid: System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: MoveNext(TimeSpan)
  nameWithType: MessageEnumerator.MoveNext(TimeSpan)
  fullName: System.Messaging.MessageEnumerator.MoveNext(TimeSpan)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Messaging.MessageEnumerator.RemoveCurrent
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: RemoveCurrent()
  nameWithType: MessageEnumerator.RemoveCurrent()
  fullName: System.Messaging.MessageEnumerator.RemoveCurrent()
- uid: System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: RemoveCurrent(MessageQueueTransaction)
  nameWithType: MessageEnumerator.RemoveCurrent(MessageQueueTransaction)
  fullName: System.Messaging.MessageEnumerator.RemoveCurrent(MessageQueueTransaction)
- uid: System.Messaging.MessageQueueTransaction
  parent: System.Messaging
  isExternal: false
  name: MessageQueueTransaction
  nameWithType: MessageQueueTransaction
  fullName: System.Messaging.MessageQueueTransaction
- uid: System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: RemoveCurrent(MessageQueueTransactionType)
  nameWithType: MessageEnumerator.RemoveCurrent(MessageQueueTransactionType)
  fullName: System.Messaging.MessageEnumerator.RemoveCurrent(MessageQueueTransactionType)
- uid: System.Messaging.MessageQueueTransactionType
  parent: System.Messaging
  isExternal: false
  name: MessageQueueTransactionType
  nameWithType: MessageQueueTransactionType
  fullName: System.Messaging.MessageQueueTransactionType
- uid: System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: RemoveCurrent(TimeSpan)
  nameWithType: MessageEnumerator.RemoveCurrent(TimeSpan)
  fullName: System.Messaging.MessageEnumerator.RemoveCurrent(TimeSpan)
- uid: System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: RemoveCurrent(TimeSpan,MessageQueueTransaction)
  nameWithType: MessageEnumerator.RemoveCurrent(TimeSpan,MessageQueueTransaction)
  fullName: System.Messaging.MessageEnumerator.RemoveCurrent(TimeSpan,MessageQueueTransaction)
- uid: System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: RemoveCurrent(TimeSpan,MessageQueueTransactionType)
  nameWithType: MessageEnumerator.RemoveCurrent(TimeSpan,MessageQueueTransactionType)
  fullName: System.Messaging.MessageEnumerator.RemoveCurrent(TimeSpan,MessageQueueTransactionType)
- uid: System.Messaging.MessageEnumerator.Reset
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: Reset()
  nameWithType: MessageEnumerator.Reset()
  fullName: System.Messaging.MessageEnumerator.Reset()
- uid: System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: System.Collections.IEnumerator.Current
  nameWithType: MessageEnumerator.System.Collections.IEnumerator.Current
  fullName: System.Messaging.MessageEnumerator.System.Collections.IEnumerator.Current
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Messaging.MessageEnumerator.Close*
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: Close
  nameWithType: MessageEnumerator.Close
- uid: System.Messaging.MessageEnumerator.Current*
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: Current
  nameWithType: MessageEnumerator.Current
- uid: System.Messaging.MessageEnumerator.CursorHandle*
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: CursorHandle
  nameWithType: MessageEnumerator.CursorHandle
- uid: System.Messaging.MessageEnumerator.Dispose*
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: Dispose
  nameWithType: MessageEnumerator.Dispose
- uid: System.Messaging.MessageEnumerator.MoveNext*
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: MoveNext
  nameWithType: MessageEnumerator.MoveNext
- uid: System.Messaging.MessageEnumerator.RemoveCurrent*
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: RemoveCurrent
  nameWithType: MessageEnumerator.RemoveCurrent
- uid: System.Messaging.MessageEnumerator.Reset*
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: Reset
  nameWithType: MessageEnumerator.Reset
- uid: System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current*
  parent: System.Messaging.MessageEnumerator
  isExternal: false
  name: System.Collections.IEnumerator.Current
  nameWithType: MessageEnumerator.System.Collections.IEnumerator.Current
