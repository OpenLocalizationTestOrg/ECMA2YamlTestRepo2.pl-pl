### YamlMime:ManagedReference
items:
- uid: System.Net.Sockets.NetworkStream
  id: NetworkStream
  children:
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
  - System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.Net.Sockets.NetworkStream.CanRead
  - System.Net.Sockets.NetworkStream.CanSeek
  - System.Net.Sockets.NetworkStream.CanTimeout
  - System.Net.Sockets.NetworkStream.CanWrite
  - System.Net.Sockets.NetworkStream.Close(System.Int32)
  - System.Net.Sockets.NetworkStream.DataAvailable
  - System.Net.Sockets.NetworkStream.Dispose(System.Boolean)
  - System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
  - System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
  - System.Net.Sockets.NetworkStream.Finalize
  - System.Net.Sockets.NetworkStream.Flush
  - System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
  - System.Net.Sockets.NetworkStream.Length
  - System.Net.Sockets.NetworkStream.Position
  - System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.Net.Sockets.NetworkStream.Readable
  - System.Net.Sockets.NetworkStream.ReadTimeout
  - System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.Net.Sockets.NetworkStream.SetLength(System.Int64)
  - System.Net.Sockets.NetworkStream.Socket
  - System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.Net.Sockets.NetworkStream.Writeable
  - System.Net.Sockets.NetworkStream.WriteTimeout
  langs:
  - csharp
  name: NetworkStream
  nameWithType: NetworkStream
  fullName: System.Net.Sockets.NetworkStream
  type: Class
  summary: "Zasadniczy strumień danych zapewnia dostęp do sieci."
  remarks: "Klasa Strumień NetworkStream udostępnia metody do wysyłania i odbierania danych za pośrednictwem <xref:System.Net.Sockets.SocketType>gniazda w trybie blokowania.</xref:System.Net.Sockets.SocketType> Aby uzyskać więcej informacji na temat blokowania i nieblokujących <xref:System.Net.Sockets.Socket>s, zobacz [przy użyciu asynchronicznej gniazdo klienta](~/add/includes/ajax-current-ext-md.md).</xref:System.Net.Sockets.Socket> Klasa Strumień NetworkStream służy do obu transferu danych synchroniczne i asynchroniczne. Aby uzyskać więcej informacji dotyczących komunikacji synchroniczne i asynchroniczne, zobacz [Sockets](~/add/includes/ajax-current-ext-md.md).       Aby utworzyć Strumień NetworkStream, należy podać połączonych <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> Można również określić, jakie <xref:System.IO.FileAccess>ma uprawnienia Strumień NetworkStream przez podany <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.IO.FileAccess> Domyślnie zamknięcie Strumień NetworkStream nie zamknięcia podana <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> Jeśli chcesz, aby Strumień NetworkStream mają uprawnienia do zamykania dostarczonych <xref:System.Net.Sockets.Socket>, należy określić `true` dla wartości `ownsSocket` parametru.</xref:System.Net.Sockets.Socket>       Użyj <xref:System.Net.Sockets.NetworkStream.Write%2A>i <xref:System.Net.Sockets.NetworkStream.Read%2A>metody prostego pojedynczego wątku synchroniczne blokowania We/Wy.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream.Write%2A> Do przetworzenia z operacji We/Wy przy użyciu oddzielnych wątkach, należy rozważyć użycie <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>i <xref:System.Net.Sockets.NetworkStream.EndWrite%2A>metody, lub <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>i <xref:System.Net.Sockets.NetworkStream.EndRead%2A>metody komunikacji.</xref:System.Net.Sockets.NetworkStream.EndRead%2A> </xref:System.Net.Sockets.NetworkStream.BeginRead%2A> </xref:System.Net.Sockets.NetworkStream.EndWrite%2A> </xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>       Strumień NetworkStream nie obsługuje losowe dostęp do strumienia danych sieciowych. Wartość <xref:System.Net.Sockets.NetworkStream.CanSeek%2A>właściwość, która wskazuje, czy strumień obsługuje operacji wyszukiwania, jest zawsze `false`; odczytywania <xref:System.Net.Sockets.NetworkStream.Position%2A>Właściwości odczytu <xref:System.Net.Sockets.NetworkStream.Length%2A>Właściwość lub wywołanie <xref:System.Net.Sockets.NetworkStream.Seek%2A>metody spowoduje zgłoszenie <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.Net.Sockets.NetworkStream.Seek%2A> </xref:System.Net.Sockets.NetworkStream.Length%2A> </xref:System.Net.Sockets.NetworkStream.Position%2A> </xref:System.Net.Sockets.NetworkStream.CanSeek%2A>       Operacje odczytu i zapisu mogą być wykonywane jednocześnie na wystąpienie klasy Strumień NetworkStream bez konieczności synchronizacji. Tak długo, jak jest jeden wątek unikatowy dla operacji zapisu i jeden wątek unikatowy dla operacji odczytu, nie będą bez zakłóceń między między odczytu i zapisu wątków i synchronizacja nie jest wymagana."
  example:
  - "The following code example demonstrates how to create a NetworkStream from a connected <xref:System.Net.Sockets.SocketType><xref:System.Net.Sockets.Socket> and perform basic synchronous blocking I/O.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/t-system.net.sockets.net_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/t-system.net.sockets.net_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/t-system.net.sockets.net_1.cs)]"
  syntax:
    content: 'public class NetworkStream : System.IO.Stream'
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
  id: '#ctor(System.Net.Sockets.Socket)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket)
  nameWithType: NetworkStream.NetworkStream(Socket)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Tworzy nowe wystąpienie klasy <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> dla określonego <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> — klasa"
  remarks: "<xref:System.Net.Sockets.NetworkStream>Jest tworzony z dostępem do odczytu i zapisu do określonego <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream> <xref:System.Net.Sockets.NetworkStream>Nie jest właścicielem podstawowej <xref:System.Net.Sockets.Socket>Dlatego wywołanie <xref:System.Net.Sockets.NetworkStream.Close%2A>metody nie zamyka <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example illustrates how to create a <xref:System.Net.Sockets.NetworkStream> with a <xref:System.Net.Sockets.Socket>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/m-system.net.sockets.net_0_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/m-system.net.sockets.net_0_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/m-system.net.sockets.net_0_1.cs)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "<xref:System.Net.Sockets.Socket>Który <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> będzie używany do wysyłania i odbierania danych.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code> socket </code> Parametru nie jest połączona.       - lub - <xref:System.Net.Sockets.Socket.SocketType*>Właściwość <code> socket </code> parametr nie jest &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - lub - <code> socket </code> parametr jest w stanie nieblokujących."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
  id: '#ctor(System.Net.Sockets.Socket,System.Boolean)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,Boolean)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> klasy dla określonego <xref:System.Net.Sockets.Socket>z określonym <xref:System.Net.Sockets.Socket>własność.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>Jest tworzony z dostępem do odczytu i zapisu do określonego <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream> Jeśli wartość `ownsSocket` parametr jest `true`, <xref:System.Net.Sockets.NetworkStream>przejmuje podstawowych <xref:System.Net.Sockets.Socket>i wywołanie <xref:System.Net.Sockets.NetworkStream.Close%2A>metody powoduje zamknięcie podstawowej <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.NetworkStream> with ownership of the <xref:System.Net.Sockets.Socket>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/59c93a1c-9c9b-46b2-a872-_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/59c93a1c-9c9b-46b2-a872-_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/59c93a1c-9c9b-46b2-a872-_1.cs)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket, bool ownsSocket);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "<xref:System.Net.Sockets.Socket>Który <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> będzie używany do wysyłania i odbierania danych.</xref:System.Net.Sockets.Socket>"
    - id: ownsSocket
      type: System.Boolean
      description: "Ustaw <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> z informacją, że <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> będzie przejąć na własność <xref:System.Net.Sockets.Socket>; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code> socket </code> Parametru nie jest połączona.       - lub - wartość <xref:System.Net.Sockets.Socket.SocketType*>Właściwość <code> socket </code> parametr nie jest &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - lub - <code> socket </code> parametr jest w stanie nieblokujących."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
  id: '#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket,FileAccess)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Tworzy nowe wystąpienie klasy <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> klasy dla określonego <xref:System.Net.Sockets.Socket>z prawami dostępu określonego.</xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>Zostanie utworzona z określonego dostępu do określonego <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream> W tym konstruktorze <xref:System.Net.Sockets.NetworkStream>nie jest właścicielem podstawowym <xref:System.Net.Sockets.Socket>więc wywołanie <xref:System.Net.Sockets.NetworkStream.Close%2A>metody nie zamyka podstawowej <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>       `access` Zestawy parametrów <xref:System.Net.Sockets.NetworkStream.CanRead%2A>i <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>właściwości <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream.CanRead%2A> Jeśli określisz <xref:System.IO.FileAccess>, a następnie <xref:System.Net.Sockets.NetworkStream>umożliwia wywoływanie <xref:System.Net.Sockets.NetworkStream.Write%2A>metody.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> Jeśli określisz <xref:System.IO.FileAccess>, a następnie <xref:System.Net.Sockets.NetworkStream>umożliwia wywoływanie <xref:System.Net.Sockets.NetworkStream.Read%2A>metody.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> Jeśli określisz <xref:System.IO.FileAccess>, zarówno wywołania metody są dozwolone.</xref:System.IO.FileAccess>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.NetworkStream> with the ability to read and write to the <xref:System.Net.Sockets.Socket>.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/visualbasic/586c6962-cd9c-4b70-aa3e-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/csharp/586c6962-cd9c-4b70-aa3e-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/cpp/586c6962-cd9c-4b70-aa3e-_1.cpp)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "<xref:System.Net.Sockets.Socket>Który <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> będzie używany do wysyłania i odbierania danych.</xref:System.Net.Sockets.Socket>"
    - id: access
      type: System.IO.FileAccess
      description: "Bitowe połączenie <xref href=&quot;System.IO.FileAccess&quot;> </xref> wartości, które określają typ dostępu do <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> za pośrednictwem dostarczonego <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code> socket </code> Parametru nie jest połączona.       - lub - <xref:System.Net.Sockets.Socket.SocketType*>Właściwość <code> socket </code> parametr nie jest &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - lub - <code> socket </code> parametr jest w stanie nieblokujących."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
  id: '#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket,FileAccess,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Tworzy nowe wystąpienie klasy <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> klasy dla określonego <xref:System.Net.Sockets.Socket>prawa dostępu określonego i określonego <xref:System.Net.Sockets.Socket>własność.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>Jest tworzony z dostępem do odczytu i zapisu do określonego <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream> Jeśli wartość `ownsSocket` parametr jest `true`, <xref:System.Net.Sockets.NetworkStream>przejmuje podstawowych <xref:System.Net.Sockets.Socket>i wywołanie <xref:System.Net.Sockets.NetworkStream.Close%2A>metody powoduje zamknięcie podstawowej <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>       `access` Zestawy parametrów <xref:System.Net.Sockets.NetworkStream.CanRead%2A>i <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>właściwości <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream.CanRead%2A> Jeśli określisz <xref:System.IO.FileAccess>, a następnie <xref:System.Net.Sockets.NetworkStream>umożliwia wywoływanie <xref:System.Net.Sockets.NetworkStream.Write%2A>metody.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> Jeśli określisz <xref:System.IO.FileAccess>, a następnie <xref:System.Net.Sockets.NetworkStream>umożliwia wywoływanie <xref:System.Net.Sockets.NetworkStream.Read%2A>metody.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> Jeśli określisz <xref:System.IO.FileAccess>, zarówno wywołania metody są dozwolone.</xref:System.IO.FileAccess>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.NetworkStream> with the ability to read and write to the <xref:System.Net.Sockets.Socket>. Ownership of the <xref:System.Net.Sockets.Socket> is given to this <xref:System.Net.Sockets.NetworkStream> by specifying `true` for the `ownsSocket` parameter.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/visualbasic/db34d484-28c0-47ef-b5ca-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/csharp/db34d484-28c0-47ef-b5ca-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/cpp/db34d484-28c0-47ef-b5ca-_1.cpp)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access, bool ownsSocket);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "<xref:System.Net.Sockets.Socket>Który <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> będzie używany do wysyłania i odbierania danych.</xref:System.Net.Sockets.Socket>"
    - id: access
      type: System.IO.FileAccess
      description: "Bitowe połączenie <xref href=&quot;System.IO.FileAccess&quot;> </xref> wartości, które określają typ dostępu do <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> za pośrednictwem dostarczonego <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
    - id: ownsSocket
      type: System.Boolean
      description: "Ustaw <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> z informacją, że <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> będzie przejąć na własność <xref:System.Net.Sockets.Socket>; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code> socket </code> Parametru nie jest połączona.       - lub - <xref:System.Net.Sockets.Socket.SocketType*>Właściwość <code> socket </code> parametr nie jest &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - lub - <code> socket </code> parametr jest w stanie nieblokujących."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Rozpoczyna się asynchroniczny odczyt z <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Metoda BeginRead uruchamia asynchronicznie odczytywania danych z przychodzącego buforów sieciowych. Wywołanie metody BeginRead daje możliwość odbierania danych w oddzielnych wykonanie wątku.       Należy utworzyć metody wywołania zwrotnego, który implementuje <xref:System.AsyncCallback>delegować i przekaż jej nazwę metody BeginRead.</xref:System.AsyncCallback> W bardzo minimalna sieci `state` parametr może zawierać <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> Ponieważ można uzyskać odebranych danych w ramach wybranej metody wywołania zwrotnego, należy utworzyć małych klasę lub strukturę do przechowywania buforu odczytu i inne przydatne informacje. Przekaż wystąpienie struktury lub klasy do metody BeginRead za pośrednictwem `state` parametru.       Należy wywołać metodę wywołania zwrotnego <xref:System.Net.Sockets.NetworkStream.EndRead%2A>metody.</xref:System.Net.Sockets.NetworkStream.EndRead%2A> Gdy aplikacja wywołuje BeginRead, system będzie oczekiwał aż odbierania danych lub występuje błąd, a następnie system użyje oddzielnym wątku do wykonania metody wywołania zwrotnego określonego i bloki na <xref:System.Net.Sockets.NetworkStream.EndRead%2A>do dostarczonego <xref:System.Net.Sockets.NetworkStream>odczytuje dane lub zgłasza wyjątek.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.EndRead%2A> Oryginalnego wątku, aby zablokować po wywołaniu metody BeginRead, należy użyć <xref:System.Threading.WaitHandle.WaitOne%2A>metody.</xref:System.Threading.WaitHandle.WaitOne%2A> Wywołanie <xref:System.Threading.EventWaitHandle.Set%2A>w metody wywołania zwrotnego, jeśli chcesz oryginalnego wątku, aby kontynuować wykonywanie.</xref:System.Threading.EventWaitHandle.Set%2A> Aby uzyskać dodatkowe informacje na temat pisania metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/add/includes/ajax-current-ext-md.md).       BeginRead metoda odczytuje jak najwięcej danych, ponieważ są dostępne do liczby bajtów określona przez `size` parametru.      > [!NOTE] > Jeśli zostanie wyświetlony <xref:System.IO.IOException>Sprawdź <xref:System.Exception.InnerException%2A>Właściwości, aby określić, czy został spowodowany przez <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> Jeśli tak, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A>właściwość, aby otrzymać kod błędu i zapoznaj się z usługi Windows Sockets w wersji 2 dokumentacją interfejsu API błąd kodu w bibliotece MSDN szczegółowy opis błędu.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>       Odczyt i zapis operacje mogą być wykonywane równocześnie w wystąpieniu <xref:System.Net.Sockets.NetworkStream>klasy bez konieczności synchronizacji.</xref:System.Net.Sockets.NetworkStream> Tak długo, jak jest jeden wątek unikatowy dla operacji zapisu i jeden wątek unikatowy dla operacji odczytu, nie będą bez zakłóceń między między odczytu i zapisu wątków i synchronizacja nie jest wymagana."
  example:
  - "The following code example uses BeginRead to read data asynchronously from the network stream. The `myReadCallBack` method implements the <xref:System.AsyncCallback> delegate and is called by the system when BeginRead returns.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/visualbasic/b2716ae9-7520-4d87-8b97-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/csharp/b2716ae9-7520-4d87-8b97-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/cpp/b2716ae9-7520-4d87-8b97-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Tablica typu <xref:System.Byte>oznacza to lokalizacja w pamięci, aby przechowywać dane odczytane ze <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "Lokalizacja w `buffer` do rozpoczęcia przechowywania danych."
    - id: size
      type: System.Int32
      description: "Liczba bajtów do odczytu z <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
    - id: callback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>Delegata, który zostanie wykonany po zakończeniu BeginRead.</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "Obiekt, który zawiera wszelkie dodatkowe dane zdefiniowane przez użytkownika."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Reprezentujący wywołanie asynchroniczne.</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.NetworkStream.BeginRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> offset </code> Parametru jest mniejszy niż 0.       - lub - <code> offset </code> parametru jest większa niż długość <code> buffer </code> parametr.       - lub - <code> size </code> jest mniejszy niż 0.       - lub - <code> size </code> jest większa niż długość <code> buffer </code> minus wartość <code> offset </code> parametru."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Podstawowa <xref:System.Net.Sockets.Socket>jest zamknięty.</xref:System.Net.Sockets.Socket>       - lub - wystąpił błąd podczas odczytu z sieci.       - lub - wystąpił błąd podczas uzyskiwania dostępu do gniazda. Zobacz sekcję uwag, aby uzyskać więcej informacji."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> Jest zamknięty."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Rozpoczyna zapis asynchroniczny w strumieniu."
  remarks: "Metoda BeginWrite uruchamia operacja asynchronicznego wysyłania do hosta zdalnego. Wywołanie metody BeginWrite daje możliwość wysyłania danych w ramach oddzielnego wykonanie wątku.       Należy utworzyć metody wywołania zwrotnego, który implementuje <xref:System.AsyncCallback>delegować i przekaż jej nazwę metody BeginWrite.</xref:System.AsyncCallback> W bardzo minimalna sieci `state` parametr może zawierać <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> Jeśli wywołanie zwrotne wymaga więcej informacji, można utworzyć małych klasę lub strukturę do przechowywania <xref:System.Net.Sockets.NetworkStream>i inne wymagane informacje.</xref:System.Net.Sockets.NetworkStream> Przekaż wystąpienie struktury lub klasy do metody BeginWrite za pośrednictwem `state` parametru.       Należy zaimplementować metodę wywołania zwrotnego <xref:System.Net.Sockets.NetworkStream.EndWrite%2A>metody.</xref:System.Net.Sockets.NetworkStream.EndWrite%2A> Gdy aplikacja wywołuje BeginWrite, system używa oddzielnym wątku wykonania metody wywołania zwrotnego określonego i blokuje na <xref:System.Net.Sockets.NetworkStream.EndWrite%2A>do momentu <xref:System.Net.Sockets.NetworkStream>wysyła żądana liczba bajtów lub zgłasza wyjątek.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.EndWrite%2A> Oryginalnego wątku, aby zablokować po wywołaniu metody BeginWrite, należy użyć <xref:System.Threading.WaitHandle.WaitOne%2A>metody.</xref:System.Threading.WaitHandle.WaitOne%2A> Wywołanie <xref:System.Threading.EventWaitHandle.Set%2A>w metody wywołania zwrotnego, jeśli chcesz oryginalnego wątku, aby kontynuować wykonywanie.</xref:System.Threading.EventWaitHandle.Set%2A> Aby uzyskać dodatkowe informacje na temat pisania metody wywołania zwrotnego, zobacz [Marshaling delegata jako metoda wywołania zwrotnego](~/add/includes/ajax-current-ext-md.md).      > [!NOTE] > Jeśli zostanie wyświetlony <xref:System.IO.IOException>Sprawdź <xref:System.Exception.InnerException%2A>Właściwości, aby określić, czy został spowodowany przez <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> Jeśli tak, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A>właściwość, aby otrzymać kod błędu i zapoznaj się z usługi Windows Sockets w wersji 2 dokumentacją interfejsu API błąd kodu w bibliotece MSDN szczegółowy opis błędu.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>       Odczyt i zapis operacje mogą być wykonywane równocześnie w wystąpieniu <xref:System.Net.Sockets.NetworkStream>klasy bez konieczności synchronizacji.</xref:System.Net.Sockets.NetworkStream> Tak długo, jak jest jeden wątek unikatowy dla operacji zapisu i jeden wątek unikatowy dla operacji odczytu, nie będą bez zakłóceń między między odczytu i zapisu wątków i synchronizacja nie jest wymagana."
  example:
  - "The following code example uses BeginWrite to write data asynchronously to a network stream. The `myWriteCallBack` method implements the <xref:System.AsyncCallback> delegate and is called by the system when BeginWrite returns.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/visualbasic/d3b03755-0183-42fc-98c1-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/csharp/d3b03755-0183-42fc-98c1-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/cpp/d3b03755-0183-42fc-98c1-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Tablica typu <xref:System.Byte>zawierający dane do zapisania <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "Lokalizacja w `buffer` aby rozpocząć wysyłanie danych."
    - id: size
      type: System.Int32
      description: "Liczba bajtów do zapisania do <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
    - id: callback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>Delegata, który zostanie wykonany po zakończeniu BeginWrite.</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "Obiekt, który zawiera wszelkie dodatkowe dane zdefiniowane przez użytkownika."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Reprezentujący wywołanie asynchroniczne.</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.NetworkStream.BeginWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> offset </code> Parametru jest mniejszy niż 0.       - lub - <code> offset </code> parametru jest większa niż długość <code> buffer </code>.       - lub - <code> size </code> parametru jest mniejszy niż 0.       - lub - <code> size </code> parametru jest większa niż długość <code> buffer </code> minus wartość <code> offset </code> parametru."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Podstawowa <xref:System.Net.Sockets.Socket>jest zamknięty.</xref:System.Net.Sockets.Socket>       - lub - wystąpił błąd podczas zapisywania do sieci.       - lub - wystąpił błąd podczas uzyskiwania dostępu do gniazda. Zobacz sekcję uwag, aby uzyskać więcej informacji."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> Jest zamknięty."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanRead
  id: CanRead
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanRead
  nameWithType: NetworkStream.CanRead
  fullName: System.Net.Sockets.NetworkStream.CanRead
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Pobiera wartość wskazującą, czy <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> obsługuje odczytu."
  remarks: "Jeśli właściwość CanRead ma `true`, <xref:System.Net.Sockets.NetworkStream>umożliwia wywoływanie <xref:System.Net.Sockets.NetworkStream.Read%2A>metody.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> Podaj odpowiednie <xref:System.IO.FileAccess>wartości w konstruktorze, aby ustawić zwiększyć czytelność, a writability <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> wyliczyć</xref:System.IO.FileAccess> Właściwość CanRead jest ustawiane podczas <xref:System.Net.Sockets.NetworkStream>został zainicjowany.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example checks CanRead to verify that the <xref:System.Net.Sockets.NetworkStream> is readable. It then performs a read operation on the <xref:System.Net.Sockets.NetworkStream>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/p-system.net.sockets.net_6_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/p-system.net.sockets.net_6_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/p-system.net.sockets.net_6_1.cs)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli dane mogą zostać odczytane ze strumienia; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Wartość domyślna to <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanSeek
  id: CanSeek
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: NetworkStream.CanSeek
  fullName: System.Net.Sockets.NetworkStream.CanSeek
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Pobiera wartość wskazującą, czy strumień obsługuje operacji wyszukiwania. Ta właściwość nie jest obecnie obsługiwana. Ta właściwość zawsze zwraca <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>we wszystkich przypadkach w celu wskazania, że <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> nie można przejść do określonej lokalizacji w strumieniu."
  overload: System.Net.Sockets.NetworkStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanTimeout
  id: CanTimeout
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanTimeout
  nameWithType: NetworkStream.CanTimeout
  fullName: System.Net.Sockets.NetworkStream.CanTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Wskazuje, czy właściwości timeout są użyteczne do <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Ta właściwość jest obecny, ponieważ został on odziedziczony po <xref:System.IO.Stream>.</xref:System.IO.Stream>"
  syntax:
    content: public override bool CanTimeout { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>we wszystkich przypadkach."
  overload: System.Net.Sockets.NetworkStream.CanTimeout*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanWrite
  id: CanWrite
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: NetworkStream.CanWrite
  fullName: System.Net.Sockets.NetworkStream.CanWrite
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Pobiera wartość wskazującą, czy <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> obsługuje zapis."
  remarks: "Jeśli właściwość CanWrite `true`, <xref:System.Net.Sockets.NetworkStream>umożliwia wywoływanie <xref:System.Net.Sockets.NetworkStream.Write%2A>metody.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> Podaj odpowiednie <xref:System.IO.FileAccess>wartości w konstruktorze, aby ustawić zwiększyć czytelność, a writability <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> wyliczyć</xref:System.IO.FileAccess> Ustawiono właściwość CanWrite, kiedy <xref:System.Net.Sockets.NetworkStream>został zainicjowany.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example checks CanWrite to verify that the <xref:System.Net.Sockets.NetworkStream> is writable. It then performs a write operation on the <xref:System.Net.Sockets.NetworkStream>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/visualbasic/p-system.net.sockets.net_0_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/cpp/p-system.net.sockets.net_0_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/csharp/p-system.net.sockets.net_0_1.cs)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli dane mogą być zapisywane na <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Wartość domyślna to <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Close(System.Int32)
  id: Close(System.Int32)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Close(Int32)
  nameWithType: NetworkStream.Close(Int32)
  fullName: System.Net.Sockets.NetworkStream.Close(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Zamyka <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> po upływie określonego czasu, aby umożliwić wysyłanie danych."
  remarks: "Close — metoda zwalnia zarówno niezarządzane i zarządzane zasoby skojarzone z <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> Jeśli <xref:System.Net.Sockets.NetworkStream>jest właścicielem odpowiadającego <xref:System.Net.Sockets.Socket>, jest również zamknięte.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>       Jeśli <xref:System.Net.Sockets.NetworkStream>został skojarzony z <xref:System.Net.Sockets.TcpClient>metody Close zamknie połączenie TCP, ale nie dispose skojarzone <xref:System.Net.Sockets.TcpClient>.</xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.NetworkStream>"
  syntax:
    content: public void Close (int timeout);
    parameters:
    - id: timeout
      type: System.Int32
      description: "32-bitowe całkowita określająca liczbę milisekund do wysyłania pozostałe dane przed zamknięciem."
  overload: System.Net.Sockets.NetworkStream.Close*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> timeout </code> Parametr jest mniejsza niż -1."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.DataAvailable
  id: DataAvailable
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: DataAvailable
  nameWithType: NetworkStream.DataAvailable
  fullName: System.Net.Sockets.NetworkStream.DataAvailable
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Pobiera wartość wskazującą, czy dane są dostępne na <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> do odczytu."
  remarks: "Właściwość DataAvailable służy do ustalenia, czy data jest gotowy do odczytu. Jeśli jest DataAvailable `true`, wywołanie <xref:System.Net.Sockets.NetworkStream.Read%2A>natychmiast zwraca.</xref:System.Net.Sockets.NetworkStream.Read%2A> Jeśli host zdalny wyłączania lub zamyka połączenie, DataAvailable może zgłaszać <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException>"
  example:
  - "The following code example reads from the <xref:System.Net.Sockets.NetworkStream> as long as data is available.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/p-system.net.sockets.net_2_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/p-system.net.sockets.net_2_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/p-system.net.sockets.net_2_1.cs)]"
  syntax:
    content: public virtual bool DataAvailable { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli dane są dostępne na strumień do odczytu; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.DataAvailable*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> Jest zamknięty."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Podstawowa <xref:System.Net.Sockets.Socket>jest zamknięty.</xref:System.Net.Sockets.Socket>"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "Użyj &lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt; właściwość, aby otrzymać kod błędu i zapoznaj się z usługi Windows Sockets w wersji 2 dokumentacją interfejsu API błąd kodu w bibliotece MSDN szczegółowy opis błędu."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: NetworkStream.Dispose(Boolean)
  fullName: System.Net.Sockets.NetworkStream.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Zwalnia zasoby niezarządzane używane przez <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> i opcjonalnie zwalnia zasoby zarządzane."
  remarks: "Ta metoda jest wywoływana przez metodę publiczną `Dispose` — metoda i <xref:System.Object.Finalize%2A>metody.</xref:System.Object.Finalize%2A> `Dispose`wywołuje chronioną metodę `Dispose(Boolean)` metody z `disposing` ustawiono parametr `true`. <xref:System.Object.Finalize%2A>wywołuje `Dispose` z `disposing` ustawioną `false`.</xref:System.Object.Finalize%2A>       Gdy `disposing` parametr jest `true`, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane przez to <xref:System.Net.Sockets.NetworkStream>odwołań.</xref:System.Net.Sockets.NetworkStream> Ta metoda wywołuje `Dispose` metody każdego odwołuje się do obiektu."
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby zwolnić zasoby zarządzane i niezarządzane; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> aby zwolnić tylko zasoby niezarządzane."
  overload: System.Net.Sockets.NetworkStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: NetworkStream.EndRead(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Obsługuje koniec odczyt asynchroniczny."
  remarks: "Metodę EndRead można wywołać zakończeniu asynchronicznych operacji odczytu w <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>metody.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A>       Przed wywołaniem <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>, należy utworzyć metody wywołania zwrotnego, który implementuje <xref:System.AsyncCallback>delegować.</xref:System.AsyncCallback> </xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Ta metoda wywołania zwrotnego wykonuje w oddzielnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>zwraca.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Metoda wywołania zwrotnego musi obsługiwać <xref:System.IAsyncResult>zwrócony z <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>metody jako parametr.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> </xref:System.IAsyncResult>       W obrębie metody wywołania zwrotnego należy wywołać <xref:System.IAsyncResult.AsyncState%2A>Właściwość <xref:System.IAsyncResult>można uzyskać stanu obiekt przekazany do <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>metody.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> </xref:System.IAsyncResult> </xref:System.IAsyncResult.AsyncState%2A> Wyodrębnij odbieranie <xref:System.Net.Sockets.NetworkStream>z tego stanu obiektu.</xref:System.Net.Sockets.NetworkStream> Po uzyskaniu <xref:System.Net.Sockets.NetworkStream>, wywołaj metodę EndRead można wywołać, aby pomyślnie wykonać operacji odczytu i zwraca liczbę bajtów odczytanych.</xref:System.Net.Sockets.NetworkStream>       Bloki metoda EndRead można wywołać, dopóki dane są dostępne. Metodę EndRead można wywołać odczytuje jak najwięcej danych, ponieważ są dostępne do liczby bajtów określonych w `size` parametr <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>metody.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Jeśli host zdalny wyłączony <xref:System.Net.Sockets.Socket>połączenia i wszystkie dostępne dane zostały odebrane, metoda EndRead można wywołać zakończy się natychmiast i zwraca zero bajtów.</xref:System.Net.Sockets.Socket>       Aby uzyskać odebranych danych, należy wywołać <xref:System.IAsyncResult.AsyncState%2A>Właściwość <xref:System.IAsyncResult>i Wyodrębnij buforu zawarte w powstałym obiekcie stanu.</xref:System.IAsyncResult> </xref:System.IAsyncResult.AsyncState%2A>      > [!NOTE] > Jeśli zostanie wyświetlony <xref:System.IO.IOException>Sprawdź <xref:System.Exception.InnerException%2A>Właściwości, aby określić, czy został spowodowany przez <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> Jeśli tak, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A>właściwość, aby otrzymać kod błędu i zapoznaj się z usługi Windows Sockets w wersji 2 dokumentacją interfejsu API błąd kodu w bibliotece MSDN szczegółowy opis błędu.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>"
  example:
  - "In the following code example, `myReadCallback` is provided to <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> as the callback method. EndRead is implemented in `myReadCallback` to complete the asynchronous read call started by <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/visualbasic/m-system.net.sockets.net_2_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/csharp/m-system.net.sockets.net_2_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/cpp/m-system.net.sockets.net_2_1.cpp)]"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Reprezentujący wywołanie asynchroniczne.</xref:System.IAsyncResult>"
    return:
      type: System.Int32
      description: "Liczba bajtów odczytanych z <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.EndRead*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>asyncResult</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Podstawowa <xref:System.Net.Sockets.Socket>jest zamknięty.</xref:System.Net.Sockets.Socket>       - lub - wystąpił błąd podczas uzyskiwania dostępu do gniazda. Zobacz sekcję uwag, aby uzyskać więcej informacji."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> Jest zamknięty."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: NetworkStream.EndWrite(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Obsługuje koniec zapis asynchroniczny."
  remarks: "Metoda EndWrite zakończeniu asynchronicznego wysyłania rozpoczęto <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>       Przed wywołaniem <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>, należy utworzyć metody wywołania zwrotnego, który implementuje <xref:System.AsyncCallback>delegować.</xref:System.AsyncCallback> </xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> Ta metoda wywołania zwrotnego wykonuje w oddzielnym wątku i jest wywoływana przez system po <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>zwraca.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> Metoda wywołania zwrotnego musi obsługiwać <xref:System.IAsyncResult>zwrócony z <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>metody jako parametr.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> </xref:System.IAsyncResult>       W ramach metody wywołania zwrotnego należy wywołać <xref:System.IAsyncResult.AsyncState%2A>Właściwość `IAsyncResult` parametr, aby uzyskać <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.IAsyncResult.AsyncState%2A> Po uzyskaniu <xref:System.Net.Sockets.NetworkStream>, należy wywołać metodę element EndWrite pomyślnie ukończyć operacji wysyłania i zwraca liczbę bajtów wysłanych.</xref:System.Net.Sockets.NetworkStream>       Metoda EndWrite metody bloki dopóki wysłaniem żądanej liczby bajtów.      > [!NOTE] > Jeśli zostanie wyświetlony <xref:System.IO.IOException>Sprawdź <xref:System.Exception.InnerException%2A>Właściwości, aby określić, czy został spowodowany przez <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> Jeśli tak, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A>właściwość, aby otrzymać kod błędu i zapoznaj się z usługi Windows Sockets w wersji 2 dokumentacją interfejsu API błąd kodu w bibliotece MSDN szczegółowy opis błędu.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>"
  example:
  - "In the following code example, `myWriteCallback` is provided to <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> as the callback method. EndWrite is implemented in `myWriteCallback` to complete the asynchronous write call started by <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/visualbasic/m-system.net.sockets.net_3_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/csharp/m-system.net.sockets.net_3_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/cpp/m-system.net.sockets.net_3_1.cpp)]"
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Reprezentujący wywołanie asynchroniczne.</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.NetworkStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>asyncResult</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Podstawowa <xref:System.Net.Sockets.Socket>jest zamknięty.</xref:System.Net.Sockets.Socket>       - lub - wystąpił błąd podczas zapisywania do sieci.       - lub - wystąpił błąd podczas uzyskiwania dostępu do gniazda. Zobacz sekcję uwag, aby uzyskać więcej informacji."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> Jest zamknięty."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Finalize
  id: Finalize
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Finalize()
  nameWithType: NetworkStream.Finalize()
  fullName: System.Net.Sockets.NetworkStream.Finalize()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Zwalnia wszelkie zasoby używane przez <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Ta metoda zastępuje <xref:System.Object.Finalize%2A?displayProperty=fullName>.</xref:System.Object.Finalize%2A?displayProperty=fullName> Kod aplikacji nie powinny wywoływać tej metody; obiekt <xref:System.Object.Finalize%2A>Metoda jest wywoływana automatycznie podczas wyrzucania elementów bezużytecznych, chyba że finalizacji przez moduł garbage collector została wyłączona przez wywołanie do <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName>metody.</xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> </xref:System.Object.Finalize%2A>       Aby uzyskać więcej informacji na temat korzystania z metody Finalize zobacz [metody Finalize i destruktory](http://msdn.microsoft.com/en-us/fd376774-1643-499b-869e-9546a3aeea70), [czyszczenie zasobów niezarządzanych](~/add/includes/ajax-current-ext-md.md), i [przesłaniania metody Finalize](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)."
  syntax:
    content: ~NetworkStream ();
    parameters: []
  overload: System.Net.Sockets.NetworkStream.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Flush
  id: Flush
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Flush()
  nameWithType: NetworkStream.Flush()
  fullName: System.Net.Sockets.NetworkStream.Flush()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Liczba opróżnień danych ze strumienia. Ta metoda jest zarezerwowana do użytku w przyszłości."
  remarks: "Implementuje metody Flush <xref:System.IO.Stream.Flush%2A?displayProperty=fullName>metody, ale ponieważ <xref:System.Net.Sockets.NetworkStream>jest nie są buforowane, go nie ma wpływu na strumienie sieci.</xref:System.Net.Sockets.NetworkStream> </xref:System.IO.Stream.Flush%2A?displayProperty=fullName> Wywołanie metody Flush nie zgłasza wyjątek."
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.Net.Sockets.NetworkStream.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: NetworkStream.FlushAsync(CancellationToken)
  fullName: System.Net.Sockets.NetworkStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Liczba opróżnień danych ze strumienia jako operację asynchroniczną."
  remarks: "Ta operacja nie powoduje blokowania. Zwrócona <xref:System.Threading.Tasks.Task>obiektu ukończy po został opróżniony danych ze strumienia elementu <xref:System.Net.Sockets.NetworkStream>wystąpienia.</xref:System.Net.Sockets.NetworkStream> </xref:System.Threading.Tasks.Task>"
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Token anulowania, używany do propagowania powiadomienie, że można anulować tej operacji."
    return:
      type: System.Threading.Tasks.Task
      description: "Zwraca <xref:System.Threading.Tasks.Task>.</xref:System.Threading.Tasks.Task>       Obiekt zadania reprezentujący operację asynchroniczną."
  overload: System.Net.Sockets.NetworkStream.FlushAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Length
  id: Length
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Length
  nameWithType: NetworkStream.Length
  fullName: System.Net.Sockets.NetworkStream.Length
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Pobiera długość dostępnych danych ze strumienia. Ta właściwość nie jest obecnie obsługiwany i zawsze zwraca <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "Długość danych ze strumienia."
  overload: System.Net.Sockets.NetworkStream.Length*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Użycie tej właściwości."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Position
  id: Position
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Position
  nameWithType: NetworkStream.Position
  fullName: System.Net.Sockets.NetworkStream.Position
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Pobiera lub ustawia bieżącą pozycję w strumieniu. Ta właściwość nie jest obecnie obsługiwany i zawsze zwraca <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "Bieżąca pozycja w strumieniu."
  overload: System.Net.Sockets.NetworkStream.Position*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Użycie tej właściwości."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Read(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Odczytuje dane z <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Ta metoda odczytuje dane do `buffer` parametrów i zwraca liczbę bajtów odczytanych pomyślnie. Jeśli dane są niedostępne do odczytu, metody Read zwraca wartość 0. Operacja odczytu odczytuje jak najwięcej danych, ponieważ są dostępne do liczby bajtów określona przez `size` parametru. Jeśli host zdalny zamyka połączenie, a wszystkie dostępne dane zostały odebrane, metody Read kończy natychmiast i zwraca zero bajtów.      > [!NOTE] > Wyboru, aby sprawdzić, czy <xref:System.Net.Sockets.NetworkStream>jest możliwy do odczytu przez wywołanie metody <xref:System.Net.Sockets.NetworkStream.CanRead%2A>Właściwości.</xref:System.Net.Sockets.NetworkStream.CanRead%2A> </xref:System.Net.Sockets.NetworkStream> Próba odczytu <xref:System.Net.Sockets.NetworkStream>nie można go odczytać, otrzymasz <xref:System.IO.IOException>.</xref:System.IO.IOException> </xref:System.Net.Sockets.NetworkStream>      > [!NOTE] > Jeśli zostanie wyświetlony <xref:System.IO.IOException>Sprawdź <xref:System.Exception.InnerException%2A>Właściwości, aby określić, czy został spowodowany przez <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> Jeśli tak, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A>właściwość, aby otrzymać kod błędu i zapoznaj się z usługi Windows Sockets w wersji 2 dokumentacją interfejsu API błąd kodu w bibliotece MSDN szczegółowy opis błędu.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>"
  example:
  - "The following code example uses <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> to determine if data is available to be read. If data is available, it reads from the <xref:System.Net.Sockets.NetworkStream>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/m-system.net.sockets.net_1_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/m-system.net.sockets.net_1_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/m-system.net.sockets.net_1_1.cs)]"
  syntax:
    content: public override int Read (byte[] buffer, int offset, int size);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Tablica typu <xref:System.Byte>oznacza to lokalizacja w pamięci, aby przechowywać dane odczytane ze <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "Lokalizacja w `buffer` do rozpoczęcia przechowywania danych."
    - id: size
      type: System.Int32
      description: "Liczba bajtów do odczytu z <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
    return:
      type: System.Int32
      description: "Liczba bajtów odczytanych z <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Read*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> offset </code> Parametru jest mniejszy niż 0.       - lub - <code> offset </code> parametru jest większa niż długość <code> buffer </code>.       - lub - <code> size </code> parametru jest mniejszy niż 0.       - lub - <code> size </code> parametru jest większa niż długość <code> buffer </code> minus wartość <code> offset </code> parametru.       - lub - wystąpił błąd podczas uzyskiwania dostępu do gniazda. Zobacz sekcję uwag, aby uzyskać więcej informacji."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Podstawowa <xref:System.Net.Sockets.Socket>jest zamknięty.</xref:System.Net.Sockets.Socket>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> Jest zamknięty.       - lub - wystąpił błąd podczas odczytywania z sieci."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Readable
  id: Readable
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Readable
  nameWithType: NetworkStream.Readable
  fullName: System.Net.Sockets.NetworkStream.Readable
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Pobiera lub ustawia wartość wskazującą, czy <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> mogą być odczytywane."
  remarks: "Musi pochodzić od <xref:System.Net.Sockets.NetworkStream>klasy użycie właściwości do odczytu.</xref:System.Net.Sockets.NetworkStream> W przypadku elementu Readable `true`, <xref:System.Net.Sockets.NetworkStream>umożliwia wywoływanie <xref:System.Net.Sockets.NetworkStream.Read%2A>metody.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> Można także określić, czy <xref:System.Net.Sockets.NetworkStream>jest możliwy sprawdzana jest dostępny publicznie element <xref:System.Net.Sockets.NetworkStream.CanRead%2A>Właściwości.</xref:System.Net.Sockets.NetworkStream.CanRead%2A> </xref:System.Net.Sockets.NetworkStream>       Właściwość do odczytu jest ustawiona, gdy <xref:System.Net.Sockets.NetworkStream>został zainicjowany.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "In the following code example, the `CanCommunicate` property checks the Readable property to determine if the <xref:System.Net.Sockets.NetworkStream> is readable.  \n  \n [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_7_1.cpp)]\n [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_7_1.cs)]\n [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_7_1.vb)]"
  syntax:
    content: protected bool Readable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby wskazać, że <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> może zostać odczytany; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Wartość domyślna to <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Readable*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.ReadTimeout
  id: ReadTimeout
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: ReadTimeout
  nameWithType: NetworkStream.ReadTimeout
  fullName: System.Net.Sockets.NetworkStream.ReadTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Pobiera lub ustawia czas, przez który bloki operacji odczytu, oczekiwanie na dane."
  remarks: "Jeśli operacja odczytu nie zostanie zakończone w czasie określonym przez tę właściwość, operacji odczytu zgłasza <xref:System.IO.IOException>.</xref:System.IO.IOException>      > [!NOTE] > Ta właściwość dotyczy tylko Synchroniczne odczyty wykonywane przez wywołanie metody <xref:System.Net.Sockets.NetworkStream.Read%2A>metody.</xref:System.Net.Sockets.NetworkStream.Read%2A> Ta właściwość nie ma wpływu na Asynchroniczne odczyty wykonywane przez wywołanie metody <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>metody.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A>"
  example:
  - "The following code example sets the read time-out for a network stream to 10 milliseconds.  \n  \n [!code-cs[NCLTcpClientSync#2](~/add/codesnippet/csharp/p-system.net.sockets.net_4_1.cs)]"
  syntax:
    content: public override int ReadTimeout { get; set; }
    return:
      type: System.Int32
      description: "A <xref:System.Int32>Ilość czasu, który określa w milisekundach, jaki ma upłynąć przed niepowodzenia operacji odczytu.</xref:System.Int32> Wartość domyślna to <xref:System.Threading.Timeout.Infinite>, określa, że operacja odczytu jest nie upłynął limit czasu.</xref:System.Threading.Timeout.Infinite>"
  overload: System.Net.Sockets.NetworkStream.ReadTimeout*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Określona wartość jest mniejsza lub równa zero, a nie <xref:System.Threading.Timeout.Infinite>.</xref:System.Threading.Timeout.Infinite>"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: NetworkStream.Seek(Int64,SeekOrigin)
  fullName: System.Net.Sockets.NetworkStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Ustawia bieżący pozycji strumienia podanej wartości. Ta metoda nie jest obecnie obsługiwany i zawsze zwraca <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "Ten parametr nie jest używany."
    - id: origin
      type: System.IO.SeekOrigin
      description: "Ten parametr nie jest używany."
    return:
      type: System.Int64
      description: "Pozycja w strumieniu."
  overload: System.Net.Sockets.NetworkStream.Seek*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Użycie tej właściwości."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: NetworkStream.SetLength(Int64)
  fullName: System.Net.Sockets.NetworkStream.SetLength(Int64)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Ustawia długość strumienia. Ta metoda zawsze zwraca <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "Ten parametr nie jest używany."
  overload: System.Net.Sockets.NetworkStream.SetLength*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Użycie tej właściwości."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Socket
  id: Socket
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Socket
  nameWithType: NetworkStream.Socket
  fullName: System.Net.Sockets.NetworkStream.Socket
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Pobiera podstawowy <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  remarks: "Klasy wywodzące się z <xref:System.Net.Sockets.NetworkStream>tej właściwości można pobrać podstawowej <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> można użyć</xref:System.Net.Sockets.NetworkStream> Użyj odpowiadającego <xref:System.Net.Sockets.Socket>zwrócił z właściwości gniazda, jeśli wymaga dostępu poza tymi, które <xref:System.Net.Sockets.NetworkStream>zapewnia.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.Socket>      > [!NOTE] > Ta właściwość jest dostępna tylko za pośrednictwem tej klasy lub klasy pochodnej."
  example:
  - "The following code example retrieves the underlying <xref:System.Net.Sockets.Socket> to verify an active connection.  \n  \n [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_3_1.cpp)]\n [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_3_1.cs)]\n [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_3_1.vb)]"
  syntax:
    content: protected System.Net.Sockets.Socket Socket { get; }
    return:
      type: System.Net.Sockets.Socket
      description: "A <xref:System.Net.Sockets.Socket>reprezentujący podstawowe połączenie sieciowe.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.Socket*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Write(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Zapisuje dane do <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Metoda Write rozpoczyna się od określonego `offset` i wysyła `size` bajtów z zawartości `buffer` do sieci. Metoda Write blokuje momentu wysłania żądanej liczby bajtów, czy na <xref:System.Net.Sockets.SocketException>jest generowany.</xref:System.Net.Sockets.SocketException> Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>właściwość, aby otrzymać kod błędu i zapoznaj się z usługi Windows Sockets w wersji 2 dokumentacją interfejsu API błąd kodu w bibliotece MSDN szczegółowy opis błędu.</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException>      > [!NOTE] > Wyboru, aby sprawdzić, czy <xref:System.Net.Sockets.NetworkStream>jest zapisywalny, uzyskując dostęp do <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>Właściwości.</xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream> Próba zapisu do <xref:System.Net.Sockets.NetworkStream>nie zapisywalny, otrzymasz <xref:System.IO.IOException>.</xref:System.IO.IOException> </xref:System.Net.Sockets.NetworkStream> Jeśli zostanie wyświetlony <xref:System.IO.IOException>Sprawdź <xref:System.Exception.InnerException%2A>Właściwości, aby określić, czy został spowodowany przez <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException>"
  example:
  - "The following code example checks to see whether the <xref:System.Net.Sockets.NetworkStream> is writable. If it is, then Write is used to write a small message.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/visualbasic/87c395a5-03ea-4324-8b05-_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/cpp/87c395a5-03ea-4324-8b05-_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/csharp/87c395a5-03ea-4324-8b05-_1.cs)]"
  syntax:
    content: public override void Write (byte[] buffer, int offset, int size);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Tablica typu <xref:System.Byte>zawierający dane do zapisania <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "Lokalizacja w `buffer` z którego chcesz uruchomić zapisywania danych."
    - id: size
      type: System.Int32
      description: "Liczba bajtów do zapisania do <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Write*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> offset </code> Parametru jest mniejszy niż 0.       - lub - <code> offset </code> parametru jest większa niż długość <code> buffer </code>.       - lub - <code> size </code> parametru jest mniejszy niż 0.       - lub - <code> size </code> parametru jest większa niż długość <code> buffer </code> minus wartość <code> offset </code> parametru."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Wystąpił błąd podczas zapisywania do sieci.       - lub - wystąpił błąd podczas uzyskiwania dostępu do gniazda. Zobacz sekcję uwag, aby uzyskać więcej informacji."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> Jest zamknięty.       - lub - wystąpił błąd podczas odczytywania z sieci."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Writeable
  id: Writeable
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Writeable
  nameWithType: NetworkStream.Writeable
  fullName: System.Net.Sockets.NetworkStream.Writeable
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Pobiera wartość wskazującą, czy <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> jest zapisywalna."
  remarks: "Musi pochodzić od <xref:System.Net.Sockets.NetworkStream>klasy użycie właściwości zapisywalny.</xref:System.Net.Sockets.NetworkStream> Jeśli jest Writeable `true`, <xref:System.Net.Sockets.NetworkStream>umożliwia wywoływanie <xref:System.Net.Sockets.NetworkStream.Write%2A>metody.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> Można także określić, czy <xref:System.Net.Sockets.NetworkStream>jest zapisywalny, sprawdzając dostępny publicznie <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>Właściwości.</xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream>       Właściwość Writeable jest ustawiane podczas <xref:System.Net.Sockets.NetworkStream>został zainicjowany.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "In the following code example, the `CanCommunicate` property checks the Writeable property to determine if the <xref:System.Net.Sockets.NetworkStream> is writable.  \n  \n [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_5_1.cpp)]\n [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_5_1.cs)]\n [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_5_1.vb)]"
  syntax:
    content: protected bool Writeable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli dane mogą być zapisywane do strumienia; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Wartość domyślna to <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Writeable*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.WriteTimeout
  id: WriteTimeout
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: WriteTimeout
  nameWithType: NetworkStream.WriteTimeout
  fullName: System.Net.Sockets.NetworkStream.WriteTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Pobiera lub ustawia czas, przez który bloki operacji zapisu, oczekiwanie na dane."
  remarks: "Jeśli operacja zapisu nie zostanie zakończone w czasie określonym przez tę właściwość, operacji zapisu, zgłasza <xref:System.IO.IOException>.</xref:System.IO.IOException>      > [!NOTE] > Ta właściwość ma wpływ na operacje zapisu synchronicznego tylko wykonywane przez wywołanie metody <xref:System.Net.Sockets.NetworkStream.Write%2A>metody.</xref:System.Net.Sockets.NetworkStream.Write%2A> Ta właściwość nie ma wpływu na zapis asynchroniczny wykonywane przez wywołanie metody <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>metody.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>"
  example:
  - "The following code example sets the write time-out for a network stream to 10 milliseconds.  \n  \n [!code-cpp[NCLTcpServerSync#0](~/add/codesnippet/cpp/p-system.net.sockets.net_1_1.cpp)]\n [!code-cs[NCLTcpServerSync#0](~/add/codesnippet/csharp/p-system.net.sockets.net_1_1.cs)]"
  syntax:
    content: public override int WriteTimeout { get; set; }
    return:
      type: System.Int32
      description: "A <xref:System.Int32>Ilość czasu, który określa w milisekundach, jaki ma upłynąć przed operacja zapisu nie powiedzie się.</xref:System.Int32> Wartość domyślna to <xref:System.Threading.Timeout.Infinite>, określa, że operacja zapisu jest nie upłynął limit czasu.</xref:System.Threading.Timeout.Infinite>"
  overload: System.Net.Sockets.NetworkStream.WriteTimeout*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Określona wartość jest mniejsza lub równa zero, a nie <xref:System.Threading.Timeout.Infinite>.</xref:System.Threading.Timeout.Infinite>"
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.Net.Sockets.SocketException
  isExternal: true
  name: System.Net.Sockets.SocketException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket)
  nameWithType: NetworkStream.NetworkStream(Socket)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket)
- uid: System.Net.Sockets.Socket
  parent: System.Net.Sockets
  isExternal: true
  name: Socket
  nameWithType: Socket
  fullName: System.Net.Sockets.Socket
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket,FileAccess)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket,FileAccess,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
- uid: System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.Net.Sockets.NetworkStream.CanRead
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanRead
  nameWithType: NetworkStream.CanRead
  fullName: System.Net.Sockets.NetworkStream.CanRead
- uid: System.Net.Sockets.NetworkStream.CanSeek
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanSeek
  nameWithType: NetworkStream.CanSeek
  fullName: System.Net.Sockets.NetworkStream.CanSeek
- uid: System.Net.Sockets.NetworkStream.CanTimeout
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanTimeout
  nameWithType: NetworkStream.CanTimeout
  fullName: System.Net.Sockets.NetworkStream.CanTimeout
- uid: System.Net.Sockets.NetworkStream.CanWrite
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanWrite
  nameWithType: NetworkStream.CanWrite
  fullName: System.Net.Sockets.NetworkStream.CanWrite
- uid: System.Net.Sockets.NetworkStream.Close(System.Int32)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Close(Int32)
  nameWithType: NetworkStream.Close(Int32)
  fullName: System.Net.Sockets.NetworkStream.Close(Int32)
- uid: System.Net.Sockets.NetworkStream.DataAvailable
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: DataAvailable
  nameWithType: NetworkStream.DataAvailable
  fullName: System.Net.Sockets.NetworkStream.DataAvailable
- uid: System.Net.Sockets.NetworkStream.Dispose(System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: NetworkStream.Dispose(Boolean)
  fullName: System.Net.Sockets.NetworkStream.Dispose(Boolean)
- uid: System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: NetworkStream.EndRead(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndRead(IAsyncResult)
- uid: System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: NetworkStream.EndWrite(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndWrite(IAsyncResult)
- uid: System.Net.Sockets.NetworkStream.Finalize
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Finalize()
  nameWithType: NetworkStream.Finalize()
  fullName: System.Net.Sockets.NetworkStream.Finalize()
- uid: System.Net.Sockets.NetworkStream.Flush
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Flush()
  nameWithType: NetworkStream.Flush()
  fullName: System.Net.Sockets.NetworkStream.Flush()
- uid: System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: NetworkStream.FlushAsync(CancellationToken)
  fullName: System.Net.Sockets.NetworkStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.Net.Sockets.NetworkStream.Length
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Length
  nameWithType: NetworkStream.Length
  fullName: System.Net.Sockets.NetworkStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Net.Sockets.NetworkStream.Position
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Position
  nameWithType: NetworkStream.Position
  fullName: System.Net.Sockets.NetworkStream.Position
- uid: System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Read(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Read(Byte[],Int32,Int32)
- uid: System.Net.Sockets.NetworkStream.Readable
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Readable
  nameWithType: NetworkStream.Readable
  fullName: System.Net.Sockets.NetworkStream.Readable
- uid: System.Net.Sockets.NetworkStream.ReadTimeout
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: ReadTimeout
  nameWithType: NetworkStream.ReadTimeout
  fullName: System.Net.Sockets.NetworkStream.ReadTimeout
- uid: System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: NetworkStream.Seek(Int64,SeekOrigin)
  fullName: System.Net.Sockets.NetworkStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.Net.Sockets.NetworkStream.SetLength(System.Int64)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: NetworkStream.SetLength(Int64)
  fullName: System.Net.Sockets.NetworkStream.SetLength(Int64)
- uid: System.Net.Sockets.NetworkStream.Socket
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Socket
  nameWithType: NetworkStream.Socket
  fullName: System.Net.Sockets.NetworkStream.Socket
- uid: System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Write(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Write(Byte[],Int32,Int32)
- uid: System.Net.Sockets.NetworkStream.Writeable
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Writeable
  nameWithType: NetworkStream.Writeable
  fullName: System.Net.Sockets.NetworkStream.Writeable
- uid: System.Net.Sockets.NetworkStream.WriteTimeout
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: WriteTimeout
  nameWithType: NetworkStream.WriteTimeout
  fullName: System.Net.Sockets.NetworkStream.WriteTimeout
- uid: System.Net.Sockets.NetworkStream.#ctor*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream
  nameWithType: NetworkStream.NetworkStream
- uid: System.Net.Sockets.NetworkStream.BeginRead*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginRead
  nameWithType: NetworkStream.BeginRead
- uid: System.Net.Sockets.NetworkStream.BeginWrite*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginWrite
  nameWithType: NetworkStream.BeginWrite
- uid: System.Net.Sockets.NetworkStream.CanRead*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanRead
  nameWithType: NetworkStream.CanRead
- uid: System.Net.Sockets.NetworkStream.CanSeek*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanSeek
  nameWithType: NetworkStream.CanSeek
- uid: System.Net.Sockets.NetworkStream.CanTimeout*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanTimeout
  nameWithType: NetworkStream.CanTimeout
- uid: System.Net.Sockets.NetworkStream.CanWrite*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanWrite
  nameWithType: NetworkStream.CanWrite
- uid: System.Net.Sockets.NetworkStream.Close*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Close
  nameWithType: NetworkStream.Close
- uid: System.Net.Sockets.NetworkStream.DataAvailable*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: DataAvailable
  nameWithType: NetworkStream.DataAvailable
- uid: System.Net.Sockets.NetworkStream.Dispose*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Dispose
  nameWithType: NetworkStream.Dispose
- uid: System.Net.Sockets.NetworkStream.EndRead*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndRead
  nameWithType: NetworkStream.EndRead
- uid: System.Net.Sockets.NetworkStream.EndWrite*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndWrite
  nameWithType: NetworkStream.EndWrite
- uid: System.Net.Sockets.NetworkStream.Finalize*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Finalize
  nameWithType: NetworkStream.Finalize
- uid: System.Net.Sockets.NetworkStream.Flush*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Flush
  nameWithType: NetworkStream.Flush
- uid: System.Net.Sockets.NetworkStream.FlushAsync*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: FlushAsync
  nameWithType: NetworkStream.FlushAsync
- uid: System.Net.Sockets.NetworkStream.Length*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Length
  nameWithType: NetworkStream.Length
- uid: System.Net.Sockets.NetworkStream.Position*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Position
  nameWithType: NetworkStream.Position
- uid: System.Net.Sockets.NetworkStream.Read*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Read
  nameWithType: NetworkStream.Read
- uid: System.Net.Sockets.NetworkStream.Readable*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Readable
  nameWithType: NetworkStream.Readable
- uid: System.Net.Sockets.NetworkStream.ReadTimeout*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: ReadTimeout
  nameWithType: NetworkStream.ReadTimeout
- uid: System.Net.Sockets.NetworkStream.Seek*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Seek
  nameWithType: NetworkStream.Seek
- uid: System.Net.Sockets.NetworkStream.SetLength*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: SetLength
  nameWithType: NetworkStream.SetLength
- uid: System.Net.Sockets.NetworkStream.Socket*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Socket
  nameWithType: NetworkStream.Socket
- uid: System.Net.Sockets.NetworkStream.Write*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Write
  nameWithType: NetworkStream.Write
- uid: System.Net.Sockets.NetworkStream.Writeable*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Writeable
  nameWithType: NetworkStream.Writeable
- uid: System.Net.Sockets.NetworkStream.WriteTimeout*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: WriteTimeout
  nameWithType: NetworkStream.WriteTimeout
