### YamlMime:ManagedReference
items:
- uid: System.Diagnostics.EventLog
  id: EventLog
  children:
  - System.Diagnostics.EventLog.#ctor
  - System.Diagnostics.EventLog.#ctor(System.String)
  - System.Diagnostics.EventLog.#ctor(System.String,System.String)
  - System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)
  - System.Diagnostics.EventLog.BeginInit
  - System.Diagnostics.EventLog.Clear
  - System.Diagnostics.EventLog.Close
  - System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)
  - System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)
  - System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)
  - System.Diagnostics.EventLog.Delete(System.String)
  - System.Diagnostics.EventLog.Delete(System.String,System.String)
  - System.Diagnostics.EventLog.DeleteEventSource(System.String)
  - System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)
  - System.Diagnostics.EventLog.Dispose(System.Boolean)
  - System.Diagnostics.EventLog.EnableRaisingEvents
  - System.Diagnostics.EventLog.EndInit
  - System.Diagnostics.EventLog.Entries
  - System.Diagnostics.EventLog.EntryWritten
  - System.Diagnostics.EventLog.Exists(System.String)
  - System.Diagnostics.EventLog.Exists(System.String,System.String)
  - System.Diagnostics.EventLog.GetEventLogs
  - System.Diagnostics.EventLog.GetEventLogs(System.String)
  - System.Diagnostics.EventLog.Log
  - System.Diagnostics.EventLog.LogDisplayName
  - System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)
  - System.Diagnostics.EventLog.MachineName
  - System.Diagnostics.EventLog.MaximumKilobytes
  - System.Diagnostics.EventLog.MinimumRetentionDays
  - System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  - System.Diagnostics.EventLog.OverflowAction
  - System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)
  - System.Diagnostics.EventLog.Source
  - System.Diagnostics.EventLog.SourceExists(System.String)
  - System.Diagnostics.EventLog.SourceExists(System.String,System.String)
  - System.Diagnostics.EventLog.SynchronizingObject
  - System.Diagnostics.EventLog.WriteEntry(System.String)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  - System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  - System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  - System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  - System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  langs:
  - csharp
  name: EventLog
  nameWithType: EventLog
  fullName: System.Diagnostics.EventLog
  type: Class
  summary: "Umożliwia interakcję z dziennikami zdarzeń systemu Windows."
  remarks: "Dziennik zdarzeń umożliwia dostęp lub dostosować dzienniki zdarzeń systemu Windows, które rejestrowania informacji o ważnych zdarzeniach oprogramowania lub sprzętu. Przy użyciu dziennika zdarzeń, można odczytać z istniejących dzienników, zapisywanie wpisów dzienników, tworzenia lub usuwania źródła zdarzeń, Usuń dzienniki i odpowiadania na pozycje dziennika. Można również utworzyć nowe dzienniki podczas tworzenia źródła zdarzenia.      > [!IMPORTANT] > Ten typ implementuje <xref:System.IDisposable>interfejsu.</xref:System.IDisposable> Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niego. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A>metody w `try` / `catch` bloku.</xref:System.IDisposable.Dispose%2A> Do usunięcia ich pośrednio, użyj konstrukcji języka takiego jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję &quot;Przy użyciu obiektu który implementuje interfejs IDisposable&quot; w <xref:System.IDisposable>tematu interfejsu.</xref:System.IDisposable>       Oprócz zapewnienia dostępu do poszczególnych dzienniki zdarzeń i ich wpisów, klasa EventLog pozwala uzyskiwać dostęp do kolekcji wszystkie dzienniki zdarzeń. Można użyć `static` członkami dziennika zdarzeń, aby usunąć dzienniki, Pobierz listy dziennika, utworzyć lub usunąć źródła lub ustal, czy komputer zawiera już określonego źródła.       Istnieją trzy dzienniki zdarzeń domyślne: aplikacji, System i zabezpieczenia. Dziennika zabezpieczeń jest tylko do odczytu. Inne aplikacje i usługi, które będą instalowane, takich jak usługi Active Directory, może być dodatkowe dzienniki zdarzeń.       Istnieją zagadnienia dotyczące zabezpieczeń, korzystając z klasy dziennik zdarzeń. Wymaga EventLog <xref:System.Diagnostics.EventLogPermission>uprawnienia dla określonych akcji w programie .NET Framework 2.0 i nowszych wersjach lub pełnego zaufania w .NET Framework 1.0 i 1.1.</xref:System.Diagnostics.EventLogPermission> Zalecamy, aby <xref:System.Diagnostics.EventLogPermission>nie udziela się częściowo zaufanego kodu.</xref:System.Diagnostics.EventLogPermission>  Nigdy nie należy przekazać dowolnego obiektu dziennika zdarzeń, w tym <xref:System.Diagnostics.EventLogEntryCollection>i <xref:System.Diagnostics.EventLogEntry>obiektów do mniej zaufanego kodu.</xref:System.Diagnostics.EventLogEntry> </xref:System.Diagnostics.EventLogEntryCollection> Na przykład tworzenia obiektu dziennika zdarzeń, zapisywania wpisu, a następnie przekazywanie dziennik zdarzeń obiektu do częściowo zaufany kod można utworzyć problem z zabezpieczeniami, ponieważ możliwości odczytu i zapisu w dzienniku zdarzeń umożliwia kod, aby wykonać akcje, takie jak wystawianie komunikaty dziennika zdarzeń w nazwach innej aplikacji.       Począwszy od systemu Windows Vista, Kontrola konta użytkownika (UAC) Określa poświadczenia użytkownika. Jeśli jesteś członkiem grupy Administratorzy wbudowanych, są przypisane dwa tokenów dostępu do środowiska wykonawczego: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie są w roli użytkownika standardowego. Do uruchomienia kodu, który uzyskuje dostęp do dziennika zabezpieczeń, musi najpierw podwyższenie poświadczeń z użytkownika standardowego, do administratora. Można to zrobić, podczas uruchamiania aplikacji przez otwarcie menu skrótów dla aplikacji (Jeśli używasz myszy, kliknij prawym przyciskiem myszy ikonę aplikacji) i wskazujący, że chcesz uruchomić jako administrator.       Dziennik zdarzeń służy do tworzenia niestandardowych dzienników zdarzeń, które mogą być wyświetlane w Podglądzie zdarzeń na serwerze. Użyj <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A>metodę w celu wyświetlenia zlokalizowana nazwa dziennika zdarzeń w Podglądzie zdarzeń.</xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> Użyj <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>metodę, aby skonfigurować działanie dziennika zdarzeń, po osiągnięciu jej maksymalny rozmiar dziennika.</xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>       Aby odczytać z dziennika zdarzeń, określ nazwę dziennika (<xref:System.Diagnostics.EventLog.Log%2A> Właściwości) i nazwę komputera serwera (<xref:System.Diagnostics.EventLog.MachineName%2A> właściwość w dzienniku zdarzeń.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> Jeśli nie zostanie określony z nazwą komputera serwera, komputer lokalny, &quot;.&quot;, zakłada, że. Nie jest konieczne określić źródło zdarzenia (<xref:System.Diagnostics.EventLog.Source%2A> Właściwości), ponieważ źródłem jest wymagana tylko w przypadku zapisywania dzienników.</xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog.Entries%2A>Właściwość jest automatycznie wypełniane przy użyciu listy wpisów dziennika zdarzeń.</xref:System.Diagnostics.EventLog.Entries%2A>       Można zapisać do dziennika zdarzeń, określ lub Utwórz źródło zdarzenia (<xref:System.Diagnostics.EventLog.Source%2A> Właściwości).</xref:System.Diagnostics.EventLog.Source%2A> Musi mieć poświadczenia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń. Źródło zdarzenia rejestruje aplikację z dziennika zdarzeń jako prawidłowe źródło wpisów. Źródło zdarzenia służy do zapisu do dziennika tylko jeden naraz. <xref:System.Diagnostics.EventLog.Source%2A>Właściwość może być dowolnym ciągiem losowych, ale nazwa musi się różnić od innych źródeł na tym komputerze.</xref:System.Diagnostics.EventLog.Source%2A> Źródło zdarzenia jest zwykle nazwa aplikacji lub inny ciąg identyfikacyjny. W trakcie tworzenia duplikat <xref:System.Diagnostics.EventLog.Source%2A>wartość zgłasza wyjątek.</xref:System.Diagnostics.EventLog.Source%2A> Jednak pojedynczy dziennik zdarzeń może być skojarzony z wieloma źródłami.       Jeśli źródło zdarzenia w dzienniku zdarzeń skojarzony z wystąpieniem dziennika zdarzeń nie istnieje, zostanie utworzony nowe źródło zdarzeń. Aby utworzyć źródło zdarzeń w systemie Windows Vista lub nowszym lub Windows Server 2003, należy mieć poświadczenia administracyjne.       To wymaganie dotyczy, ponieważ wszystkie dzienniki zdarzeń, w tym dzienniki zabezpieczeń musi przeszukana w celu określenia, czy źródło zdarzenia jest unikatowa. Począwszy od systemu Windows Vista, użytkownicy nie mają uprawnień do dostępu do dziennika zabezpieczeń; w związku z tym <xref:System.Security.SecurityException>jest generowany.</xref:System.Security.SecurityException>      > [!IMPORTANT] > Tworzenie lub usuwanie źródła zdarzenia wymaga synchronizacji z kodu źródłowego przy użyciu nazwanego obiektu mutex. Jeśli aplikacja wysoko uprzywilejowane blokuje nazwanego obiektu mutex, w trakcie tworzenia lub usuwania źródłem zdarzenia powoduje, że aplikacja przestanie odpowiadać, dopóki nie zostanie zwolniony blokady. Aby uniknąć tego problemu, nigdy nie udzielić <xref:System.Security.Permissions.SecurityPermissionFlag>uprawnienia do kodzie niezaufanym.</xref:System.Security.Permissions.SecurityPermissionFlag> Ponadto <xref:System.Security.Permissions.SecurityPermissionFlag>uprawnienia potencjalnie umożliwia inne uprawnienia do obejścia i tylko powinny być przyznane wysokiej zaufanego kodu.</xref:System.Security.Permissions.SecurityPermissionFlag>       Aplikacje i usługi, należy zapisać do dziennika aplikacji lub dziennik niestandardowy. Sterowniki urządzeń, należy zapisać w dzienniku systemu. Jeśli nie zostanie jawnie ustawiona <xref:System.Diagnostics.EventLog.Log%2A>właściwość, domyślne ustawienia dziennika zdarzeń w dzienniku aplikacji.</xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > Nie ma nic do ochrony aplikacji przed Zapisywanie jako wszelkie zarejestrowane źródło.  Jeśli aplikacja ma przyznane uprawnienia <xref:System.Diagnostics.EventLogPermissionAccess>uprawnienia, może on zapisywać zdarzeń dla dowolnego prawidłowego źródła zarejestrowana na komputerze.</xref:System.Diagnostics.EventLogPermissionAccess>       Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A>i <xref:System.Diagnostics.EventLog.WriteEntry%2A>metod się zapisać zdarzeń do dziennika zdarzeń.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.WriteEvent%2A> Należy określić źródło zdarzenia się zapisać zdarzeń; należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem.       Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżenia listy źródeł zdarzeń i próbie zapisu zdarzenia o nowe źródło operacja zapisu zakończy się niepowodzeniem. Nowe źródło można skonfigurować za pomocą <xref:System.Diagnostics.EventLogInstaller>obiektu lub <xref:System.Diagnostics.EventLog.CreateEventSource%2A>metody.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Musi mieć poświadczenia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.       Każde źródło może zapisywać do dziennika zdarzeń tylko jeden jednocześnie. Jednak aplikacja może używać wielu źródeł do zapisu do wielu dzienników zdarzeń. Na przykład aplikacja może wymagać wielu źródeł skonfigurowane dla różnych dzienników zdarzeń lub innego zasobu plików. Aby zmienić szczegóły konfiguracji istniejącego źródła, możesz usunąć źródło, a następnie utwórz ją przy użyciu nowej konfiguracji. Użycie innych aplikacji lub składników istniejącego źródła, Utwórz nowe źródło z zaktualizowaną konfiguracją zamiast usuwania istniejącego źródła.       Źródło zdarzenia można zarejestrować z zlokalizowanych zasobów dla zdarzeń ciągów Kategoria i komunikatu. Aplikację można pisać wpisy w dzienniku zdarzeń przy użyciu identyfikatorów zasobów zamiast określania wartości rzeczywistych ciągu. Zapoznaj się <xref:System.Diagnostics.EventLogInstaller>i <xref:System.Diagnostics.EventSourceCreationData>klasy, aby uzyskać więcej informacji o konfigurowaniu źródła z plikami zasobów.</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller>       Aplikacja zapisuje wartości ciągu bezpośrednio do dziennika zdarzeń, nie trzeba ustawić zasobu właściwości pliku źródłowego. Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład należy skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A>sposób zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A>metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.</xref:System.Diagnostics.EventLog.WriteEntry%2A>       Podczas zapisywania zdarzeń, użytkownik musi określać co najmniej ciąg komunikatu lub identyfikator zasobu ciąg komunikatu. Inne właściwości zdarzenia są opcjonalne. Przykłady ustawienia opcjonalne zdarzeń są następujące:-można ustawić <xref:System.Diagnostics.EventLogEntryType>określić ikonę, która podglądu zdarzeń wyświetlane wpisu.</xref:System.Diagnostics.EventLogEntryType>      — Można określić identyfikatora kategorii dla zdarzeń, jeśli aplikacja używa kategorii do filtrowania zdarzeń.      — Można dołączyć dane binarne do wpisu zdarzeń, aby skojarzyć dodatkowe informacje z jednego z określonych zdarzeń.      > [!IMPORTANT] > Rejestrowanie zdarzeń zużywa miejsca na dysku, czas procesora i innych zasobów. Należy rejestrować tylko istotne informacje. Zaleca się, że wywołania dziennika zdarzeń w ścieżce błąd, a nie w ścieżce kodu głównego, dlatego ich nie negatywnie wpłynąć na wydajność.       Aby uzyskać listę początkowe wartości właściwości dla wystąpienia w dzienniku zdarzeń, zobacz <xref:System.Diagnostics.EventLog.%23ctor%2A>konstruktora.</xref:System.Diagnostics.EventLog.%23ctor%2A>"
  example:
  - "The following example creates the event source `MySource` if it doesn't already exist, and writes an entry to the event log `MyNewLog`.  \n  \n> [!NOTE]\n>  Starting with Windows Vista, you must run this application as an administrator.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/t-system.diagnostics.eve_0_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/t-system.diagnostics.eve_0_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/t-system.diagnostics.eve_0_1.vb)]"
  syntax:
    content: >-
      [System.ComponentModel.DefaultEvent("EntryWritten")]

      [System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      [System.Diagnostics.MonitoringDescription("EventLogDesc")]

      public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements:
  - System.ComponentModel.ISupportInitialize
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor
  id: '#ctor'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog()
  nameWithType: EventLog.EventLog()
  fullName: System.Diagnostics.EventLog.EventLog()
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> klasy. Wiąże wystąpienie z dowolnego dziennika."
  remarks: "Przed wywołaniem <xref:System.Diagnostics.EventLog.WriteEntry%2A>, określ <xref:System.Diagnostics.EventLog.Source%2A>Właściwość <xref:System.Diagnostics.EventLog>wystąpienia.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> Tylko podczas czytania <xref:System.Diagnostics.EventLog.Entries%2A>z dziennika, można również określić tylko <xref:System.Diagnostics.EventLog.Log%2A>i <xref:System.Diagnostics.EventLog.MachineName%2A>Właściwości.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Entries%2A>      > [!NOTE] > Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>, komputer lokalny (&quot;.&quot;) zakłada, że.</xref:System.Diagnostics.EventLog.MachineName%2A>       W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog>      | Właściwość | Nieprawidłowa wartość |   |--------------|-------------------|   | <xref:System.Diagnostics.EventLog.Source%2A>| Ciąg pusty (&quot;&quot;). | | <xref:System.Diagnostics.EventLog.Log%2A>| Ciąg pusty (&quot;&quot;). | | <xref:System.Diagnostics.EventLog.MachineName%2A>| Komputer lokalny (&quot;.&quot;). |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_9_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_9_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_9_1.vb)]"
  syntax:
    content: public EventLog ();
    parameters: []
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog(String)
  nameWithType: EventLog.EventLog(String)
  fullName: System.Diagnostics.EventLog.EventLog(String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> klasy. Kojarzy wystąpienie z dziennika na komputerze lokalnym."
  remarks: "To przeciążenie ustawia <xref:System.Diagnostics.EventLog.Log%2A>właściwości `logName` parametru.</xref:System.Diagnostics.EventLog.Log%2A> Przed wywołaniem <xref:System.Diagnostics.EventLog.WriteEntry%2A>, określ <xref:System.Diagnostics.EventLog.Source%2A>Właściwość <xref:System.Diagnostics.EventLog>wystąpienia.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> Tylko podczas czytania <xref:System.Diagnostics.EventLog.Entries%2A>z dziennika, można również określić tylko <xref:System.Diagnostics.EventLog.Log%2A>i <xref:System.Diagnostics.EventLog.MachineName%2A>Właściwości.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Entries%2A>      > [!NOTE] > Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>, komputer lokalny (&quot;.&quot;) zakłada, że.</xref:System.Diagnostics.EventLog.MachineName%2A> Określa tego przeciążenia konstruktora <xref:System.Diagnostics.EventLog.Log%2A>Właściwości, ale można go zmienić przed przeczytaniem <xref:System.Diagnostics.EventLog.Entries%2A>Właściwości.</xref:System.Diagnostics.EventLog.Entries%2A> </xref:System.Diagnostics.EventLog.Log%2A>       Źródło, w przypadku określenia w <xref:System.Diagnostics.EventLog.Source%2A>Właściwości jest unikatowa z innych źródeł na komputerze, kolejne wywołanie <xref:System.Diagnostics.EventLog.WriteEntry%2A>tworzy dziennik o określonej nazwie, jeśli jeszcze nie istnieje.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A>       W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog>      | Właściwość | Nieprawidłowa wartość |   |--------------|-------------------|   | <xref:System.Diagnostics.EventLog.Source%2A>| Ciąg pusty (&quot;&quot;). | | <xref:System.Diagnostics.EventLog.Log%2A>| `logName` Parametru. |   | <xref:System.Diagnostics.EventLog.MachineName%2A>| Komputer lokalny (&quot;.&quot;). |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example reads entries in the event log, \"myNewLog\", on the local computer.  \n  \n [!code-cpp[Classic EventLog.EventLog1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_13_1.cpp)]\n [!code-cs[Classic EventLog.EventLog1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_13_1.cs)]\n [!code-vb[Classic EventLog.EventLog1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_13_1.vb)]"
  syntax:
    content: public EventLog (string logName);
    parameters:
    - id: logName
      type: System.String
      description: "Nazwa dziennika na komputerze lokalnym."
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Nazwa dziennika jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Nazwa dziennika jest nieprawidłowa."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String)
  id: '#ctor(System.String,System.String)'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog(String,String)
  nameWithType: EventLog.EventLog(String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> klasy. Kojarzy wystąpienie z dziennika na określonym komputerze."
  remarks: "To przeciążenie ustawia <xref:System.Diagnostics.EventLog.Log%2A>właściwości `logName` parametru i <xref:System.Diagnostics.EventLog.MachineName%2A>właściwości `machineName` parametru.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> Przed wywołaniem <xref:System.Diagnostics.EventLog.WriteEntry%2A>, określ <xref:System.Diagnostics.EventLog.Source%2A>Właściwość <xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> Tylko podczas czytania <xref:System.Diagnostics.EventLog.Entries%2A>z dziennika, można również określić tylko <xref:System.Diagnostics.EventLog.Log%2A>i <xref:System.Diagnostics.EventLog.MachineName%2A>Właściwości.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Entries%2A>      > [!NOTE] > Tego przeciążenia konstruktora Określa <xref:System.Diagnostics.EventLog.Log%2A>i <xref:System.Diagnostics.EventLog.MachineName%2A>Właściwości, ale można zmienić przed odczytu <xref:System.Diagnostics.EventLog.Entries%2A>Właściwości.</xref:System.Diagnostics.EventLog.Entries%2A> </xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A>       W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog>      | Właściwość | Nieprawidłowa wartość |   |--------------|-------------------|   | <xref:System.Diagnostics.EventLog.Source%2A>| Ciąg pusty (&quot;&quot;). | | <xref:System.Diagnostics.EventLog.Log%2A>| `logName` Parametru. |   | <xref:System.Diagnostics.EventLog.MachineName%2A>| `machineName` Parametru. |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example reads entries in the event log, \"myNewLog\", on the computer \"myServer\".  \n  \n [!code-cs[Classic EventLog.EventLog2 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_0_1.cs)]\n [!code-cpp[Classic EventLog.EventLog2 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_0_1.cpp)]\n [!code-vb[Classic EventLog.EventLog2 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_0_1.vb)]"
  syntax:
    content: public EventLog (string logName, string machineName);
    parameters:
    - id: logName
      type: System.String
      description: "Nazwa dziennika na określonym komputerze."
    - id: machineName
      type: System.String
      description: "Komputer, na którym znajduje się dziennik."
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Nazwa dziennika jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Nazwa dziennika jest nieprawidłowa.       - lub - nazwa komputera jest nieprawidłowa."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)
  id: '#ctor(System.String,System.String,System.String)'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog(String,String,String)
  nameWithType: EventLog.EventLog(String,String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String,String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> klasy. Kojarzy wystąpienie z dziennika na określonym komputerze i tworzy lub przypisuje z określonego źródła <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref>."
  remarks: "Ustawia tego konstruktora <xref:System.Diagnostics.EventLog.Log%2A>właściwości `logName` parametru <xref:System.Diagnostics.EventLog.MachineName%2A>właściwości `machineName` parametru i <xref:System.Diagnostics.EventLog.Source%2A>właściwości `source` parametru.</xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> <xref:System.Diagnostics.EventLog.Source%2A>Właściwość jest wymagana podczas zapisywania w dzienniku zdarzeń.</xref:System.Diagnostics.EventLog.Source%2A> Jednak jeśli jest tylko do odczytu z dziennika zdarzeń, tylko <xref:System.Diagnostics.EventLog.Log%2A>i <xref:System.Diagnostics.EventLog.MachineName%2A>Właściwości są wymagane (o ile dziennik zdarzeń na serwerze ma już skojarzony z nim źródła).</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> Jeśli jest tylko do odczytu z dziennika zdarzeń, może być wystarczające innego przeciążenia metody konstruktora.       W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog>      | Właściwość | Nieprawidłowa wartość |   |--------------|-------------------|   | <xref:System.Diagnostics.EventLog.Source%2A>| `source` Parametru. |   | <xref:System.Diagnostics.EventLog.Log%2A>| `logName` Parametru. |   | <xref:System.Diagnostics.EventLog.MachineName%2A>| `machineName` Parametru. |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example writes an entry to an event log, \"MyNewLog\", on the local computer, using the source \"MySource\".  \n  \n [!code-cs[Classic EventLog.EventLog3 Example#1](~/add/codesnippet/csharp/fd99d44e-2d79-45f8-97e3-_1.cs)]\n [!code-cpp[Classic EventLog.EventLog3 Example#1](~/add/codesnippet/cpp/fd99d44e-2d79-45f8-97e3-_1.cpp)]\n [!code-vb[Classic EventLog.EventLog3 Example#1](~/add/codesnippet/visualbasic/fd99d44e-2d79-45f8-97e3-_1.vb)]"
  syntax:
    content: public EventLog (string logName, string machineName, string source);
    parameters:
    - id: logName
      type: System.String
      description: "Nazwa dziennika na określonym komputerze"
    - id: machineName
      type: System.String
      description: "Komputer, na którym znajduje się dziennik."
    - id: source
      type: System.String
      description: "Źródło wpisy w dzienniku zdarzeń."
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Nazwa dziennika jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Nazwa dziennika jest nieprawidłowa.       - lub - nazwa komputera jest nieprawidłowa."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.BeginInit
  id: BeginInit
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: BeginInit()
  nameWithType: EventLog.BeginInit()
  fullName: System.Diagnostics.EventLog.BeginInit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Rozpoczyna inicjowanie <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> używane w formularzu lub używany przez inny składnik. Inicjowanie występuje w czasie wykonywania."
  remarks: "[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] Projekt środowiska korzystania z tej metody można uruchomić inicjowania składnika używanego w formularzu lub przez inny składnik. <xref:System.Diagnostics.EventLog.EndInit%2A>Metoda kończy się inicjowania.</xref:System.Diagnostics.EventLog.EndInit%2A> Przy użyciu BeginInit i <xref:System.Diagnostics.EventLog.EndInit%2A>metody uniemożliwić formantu przed jest w pełni zainicjowany.</xref:System.Diagnostics.EventLog.EndInit%2A>"
  syntax:
    content: public void BeginInit ();
    parameters: []
  overload: System.Diagnostics.EventLog.BeginInit*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>jest już zainicjowany."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Clear
  id: Clear
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Clear()
  nameWithType: EventLog.Clear()
  fullName: System.Diagnostics.EventLog.Clear()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Usuwa wszystkie wpisy z dziennika zdarzeń."
  remarks: "Dzienniki zdarzeń są ustawiane o maksymalnym rozmiarze, który określa liczbę wpisów, które zawierają. Po zapełnieniu dziennika zdarzeń zatrzymuje rejestrowanie nowych zdarzeń informacji lub rozpoczyna się w celu zastąpienia starszych wpisów. Jeśli zatrzymuje rejestrowanie zdarzeń, służy ta metoda aby wyczyścić dziennik istniejące wpisy i umożliwić mu ponownie uruchomić rejestrowanie zdarzeń. Musi mieć uprawnienia administratora na komputerze, na którym znajduje się dziennika, aby wyczyścić wpisy w dzienniku zdarzeń.       Wyczyść zamknięcie dziennika zdarzeń, zwalnia uchwytów zdarzeń pobiera nowe odczytu i zapisu dojść i ponownie otwiera dziennik zdarzeń. Zdarzenia po wywołaniu metody nie zostaną wyczyszczone, wraz z istniejących zdarzeń."
  example:
  - "The following example clears an event log.  \n  \n> [!CAUTION]\n>  Because Application, System, Security, and other non-custom logs can contain crucial information; be sure to specify a custom log before executing this example code. This example deletes the custom log `myNewLog`.  \n  \n [!code-cs[Classic EventLog.Clear Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_11_1.cs)]\n [!code-vb[Classic EventLog.Clear Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_11_1.vb)]\n [!code-cpp[Classic EventLog.Clear Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_11_1.cpp)]"
  syntax:
    content: public void Clear ();
    parameters: []
  overload: System.Diagnostics.EventLog.Clear*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Dziennik zdarzeń nie został wyczyszczony pomyślnie.       - lub - nie można otworzyć dziennika. Kod błędu systemu Windows nie jest dostępna."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Nie określono wartości dla <xref:System.Diagnostics.EventLog.Log*>Właściwości.</xref:System.Diagnostics.EventLog.Log*> Upewnij się, że nazwa dziennika nie jest ciągiem pustym."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Dziennik nie istnieje."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Close
  id: Close
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Close()
  nameWithType: EventLog.Close()
  fullName: System.Diagnostics.EventLog.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Zamyka dziennik zdarzeń i zwalnia odczytu i zapisu uchwytów."
  remarks: "Close — metoda jest wywoływana przez chronionej <xref:System.ComponentModel.Component.Dispose%2A>metody.</xref:System.ComponentModel.Component.Dispose%2A> Nie trzeba wywołać przed wywołaniem <xref:System.ComponentModel.Component.Dispose%2A>.</xref:System.ComponentModel.Component.Dispose%2A> Zamknij"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Diagnostics.EventLog.Close*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Dziennik zdarzeń uchwyt odczytu lub zapisu nie został zwolniony pomyślnie."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)
  id: CreateEventSource(System.Diagnostics.EventSourceCreationData)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: CreateEventSource(EventSourceCreationData)
  nameWithType: EventLog.CreateEventSource(EventSourceCreationData)
  fullName: System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Określa źródło zdarzeń prawidłowe zapiszą zdarzenie zlokalizowanych komunikaty, przy użyciu określonej konfiguracji właściwości źródło zdarzeń i odpowiedniego dziennika zdarzeń."
  remarks: "Use this overload to configure a new source for writing entries to an event log on the local computer or a remote computer. It is not necessary to use this method to read from an event log.  \n  \n The CreateEventSource method uses the input `sourceData`<xref:System.Diagnostics.EventSourceCreationData.Source%2A>, <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> and <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> properties to create registry values on the target computer for the new source and its associated event log. A new source name cannot match an existing source name or an existing event log name on the target computer. If the <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> property is not set, the source is registered for the Application event log. If the <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> is not set, the source is registered on the local computer.  \n  \n> [!NOTE]\n>  To create an event source in Windows Vista and later or Windows Server 2003, you must have administrative privileges.  \n>   \n>  The reason for this requirement is that all event logs, including security, must be searched to determine whether the event source is unique. Starting with Windows Vista, users do not have permission to access the security log; therefore, a <xref:System.Security.SecurityException> is thrown.  \n>   \n>  Starting with Windows Vista, User Account Control (UAC) determines the privileges of a user. If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To execute the code that accesses the security log, you must first elevate your privileges from standard user to administrator. You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.  \n  \n Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> and <xref:System.Diagnostics.EventLog.WriteEntry%2A> to write events to an event log. You must specify an event source to write events; you must create and configure the event source before writing the first entry with the source.  \n  \n Create the new event source during the installation of your application. This allows time for the operating system to refresh its list of registered event sources and their configuration. If the operating system has not refreshed its list of event sources, and you attempt to write an event with the new source, the write operation will fail. You can configure a new source using an <xref:System.Diagnostics.EventLogInstaller>, or using the <xref:System.Diagnostics.EventLog.CreateEventSource%2A> method. You must have administrative rights on the computer to create a new event source.  \n  \n You can create an event source for an existing event log or a new event log. When you create a new source for a new event log, the system registers the source for that log, but the log is not created until the first entry is written to it.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the <xref:System.Diagnostics.EventLog.Log%2A> property with the \".evt\" file name extension.  \n  \n Each source can only write to only one event log at a time; however, your application can use multiple sources to write to multiple event logs. For example, your application might require multiple sources configured for different event logs or different resource files.  \n  \n You can register the event source with localized resource file(s) for your event category and message strings. Your application can write event log entries using resource identifiers, rather than specifying the actual string. The Event Viewer uses the resource identifier to find and display the corresponding string from the localized resource file based on current language settings. You can register a separate file for event categories, messages and parameter insertion strings, or you can register the same resource file for all three types of strings. Use the <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>, <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>, <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>, and <xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A> properties to configure the source to write localized entries to the event log. If your application writes strings values directly to the event log, you do not need to set these properties.  \n  \n The source must be configured either for writing localized entries or for writing direct strings. If your application writes entries using both resource identifiers and string values, you must register two separate sources. For example, configure one source with resource files, and then use that source in the <xref:System.Diagnostics.EventLog.WriteEvent%2A> method to write entries using resource identifiers to the event log. Then create a different source without resource files, and use that source in the <xref:System.Diagnostics.EventLog.WriteEntry%2A> method to write strings directly to the event log using that source.  \n  \n To change the configuration details of an existing source, you must delete the source and then create it with the new configuration. If other applications or components use the existing source, create a new source with the updated configuration rather than deleting the existing source.  \n  \n> [!NOTE]\n>  If a source is configured for an event log, and you reconfigure it for another event log, you must restart the computer for the changes to take effect."
  example:
  - "The following example determines whether the event source named `SampleApplicationSource` is registered on the local computer. If the event source does not exist, the example sets the message resource file for the source and creates the new event source. Finally, the example sets the localized display name for the event log, using the resource identifier value in `DisplayNameMsgId` and the resource file path in `messageFile`.  \n  \n [!code-cpp[EventLog_WriteEvent#6](~/add/codesnippet/cpp/4fd418fb-73e7-42a9-9ba2-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#6](~/add/codesnippet/visualbasic/4fd418fb-73e7-42a9-9ba2-_1.vb)]\n [!code-cs[EventLog_WriteEvent#6](~/add/codesnippet/csharp/4fd418fb-73e7-42a9-9ba2-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings. Specifically, resource identifier 5001 is defined for the localized name of the event log.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);
    parameters:
    - id: sourceData
      type: System.Diagnostics.EventSourceCreationData
      description: "Właściwości konfiguracji dla źródła zdarzenia i jego dziennikiem zdarzeń docelowego."
  overload: System.Diagnostics.EventLog.CreateEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The computer name specified in <code>sourceData</code> is not valid.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The log name specified in <code>sourceData</code> is not valid. Event log names must consist of printable characters and cannot include the characters '*', '?', or '\\\\'.  \n  \n \\- or -  \n  \n The log name specified in <code>sourceData</code> is not valid for user log creation. The Event log names AppEvent, SysEvent, and SecEvent are reserved for system use.  \n  \n \\- or -  \n  \n The log name matches an existing event source name.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> results in a registry key path longer than 254 characters.  \n  \n \\- or -  \n  \n The first 8 characters of the log name specified in <code>sourceData</code> are not unique.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> is already registered.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> matches an existing event log name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nie można otworzyć klucza rejestru dla dziennika zdarzeń."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>sourceData</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)
  id: CreateEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: CreateEventSource(String,String)
  nameWithType: EventLog.CreateEventSource(String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Określa nazwę określonego źródła jako źródło zdarzeń prawidłowe zapisywania wpisów dziennika na komputerze lokalnym. Tej metody można też utworzyć nowy dziennik niestandardowy na komputerze lokalnym."
  remarks: "Use this overload to create a custom log or to create and register a <xref:System.Diagnostics.EventLog.Source%2A> to an existing log on the local computer.  \n  \n If `logName` is `null` or an empty string (\"\") when you call <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, the log defaults to the Application log. If the log does not exist on the local computer, the system creates a custom log and registers your application as a <xref:System.Diagnostics.EventLog.Source%2A> for that log.  \n  \n> [!NOTE]\n>  To create an event source in Windows Vista and later or Windows Server 2003, you must have administrative privileges.  \n>   \n>  The reason for this requirement is that all event logs, including security, must be searched to determine whether the event source is unique. Starting with Windows Vista, users do not have permission to access the security log; therefore, a <xref:System.Security.SecurityException> is thrown.  \n>   \n>  In Windows Vista and later, User Account Control (UAC) determines the privileges of a user. If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To execute the code that accesses the security log, you must first elevate your privileges from standard user to administrator. You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.  \n  \n You only need to create an event source if you are writing to the event log. Before writing an entry to an event log, you must register the event source with the event log as a valid source of events. When you write a log entry, the system uses the <xref:System.Diagnostics.EventLog.Source%2A> to find the appropriate log in which to place your entry. If you are reading the event log, you can either specify the <xref:System.Diagnostics.EventLog.Source%2A>, or a <xref:System.Diagnostics.EventLog.Log%2A> and <xref:System.Diagnostics.EventLog.MachineName%2A>.  \n  \n> [!NOTE]\n>  You are not required to specify the <xref:System.Diagnostics.EventLog.MachineName%2A> if you are connecting to a log on the local computer. If you do not specify the <xref:System.Diagnostics.EventLog.MachineName%2A> when reading from a log, the local computer (\".\") is assumed.  \n  \n Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> and <xref:System.Diagnostics.EventLog.WriteEntry%2A> to write events to an event log. You must specify an event source to write events; you must create and configure the event source before writing the first entry with the source.  \n  \n Create the new event source during the installation of your application. This allows time for the operating system to refresh its list of registered event sources and their configuration. If the operating system has not refreshed its list of event sources, and you attempt to write an event with the new source, the write operation will fail. You can configure a new source using an <xref:System.Diagnostics.EventLogInstaller>, or using the <xref:System.Diagnostics.EventLog.CreateEventSource%2A> method. You must have administrative rights on the computer to create a new event source.  \n  \n You can create an event source for an existing event log or a new event log. When you create a new source for a new event log, the system registers the source for that log, but the log is not created until the first entry is written to it.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the <xref:System.Diagnostics.EventLog.Log%2A> property with the \".evt\" file name extension.  \n  \n The source must be unique on the local computer; a new source name cannot match an existing source name or an existing event log name. Each source can write to only one event log at a time; however, your application can use multiple sources to write to multiple event logs. For example, your application might require multiple sources configured for different event logs or different resource files.  \n  \n The source must be configured either for writing localized entries or for writing direct strings. If your application writes entries using both resource identifiers and string values, you must register two separate sources. For example, configure one source with resource files, and then use that source in the <xref:System.Diagnostics.EventLog.WriteEvent%2A> method to write entries using resource identifiers to the event log. Then create a different source without resource files, and use that source in the <xref:System.Diagnostics.EventLog.WriteEntry%2A> method to write strings directly to the event log using that source.  \n  \n To change the configuration details of an existing source, you must delete the source and then create it with the new configuration. If other applications or components use the existing source, create a new source with the updated configuration rather than deleting the existing source.  \n  \n> [!NOTE]\n>  If a source has already been mapped to a log and you remap it to a new log, you must restart the computer for the changes to take effect."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_15_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_15_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_15_1.vb)]"
  syntax:
    content: public static void CreateEventSource (string source, string logName);
    parameters:
    - id: source
      type: System.String
      description: "Nazwa źródła, według której aplikacja jest zarejestrowana na komputerze lokalnym."
    - id: logName
      type: System.String
      description: "Nazwa dziennika źródła wpisy są zapisywane. Możliwe wartości to aplikacja, System lub niestandardowych dziennika zdarzeń."
  overload: System.Diagnostics.EventLog.CreateEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>source</code> is an empty string (\"\") or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>logName</code> is not a valid event log name. Event log names must consist of printable characters, and cannot include the characters '*', '?', or '\\\\'.  \n  \n \\- or -  \n  \n <code>logName</code> is not valid for user log creation. The event log names AppEvent, SysEvent, and SecEvent are reserved for system use.  \n  \n \\- or -  \n  \n The log name matches an existing event source name.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters.  \n  \n \\- or -  \n  \n The first 8 characters of <code>logName</code> match the first 8 characters of an existing event log name.  \n  \n \\- or -  \n  \n The source cannot be registered because it already exists on the local computer.  \n  \n \\- or -  \n  \n The source name matches an existing event log name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nie można otworzyć klucza rejestru dla dziennika zdarzeń na komputerze lokalnym."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)
  id: CreateEventSource(System.String,System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: CreateEventSource(String,String,String)
  nameWithType: EventLog.CreateEventSource(String,String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Określa nazwę określonego źródła jako źródło zdarzeń prawidłowe zapisywania wpisów dziennika na określonym komputerze. Tej metody można również utworzyć nowy dziennik niestandardowy na określonym komputerze."
  remarks: "Use this overload to create a custom log or to create and register a <xref:System.Diagnostics.EventLog.Source%2A> to an existing log on the specified computer.  \n  \n If `logName` is `null` or an empty string (\"\") when you call <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, the log defaults to the Application log. If the log does not exist on the specified computer, the system creates a custom log and registers your application as a <xref:System.Diagnostics.EventLog.Source%2A> for that log.  \n  \n You only need to create an event source if you are writing to the event log. Before writing an entry to an event log, you must register the event source with the event log as a valid source of events. When you write a log entry, the system uses the <xref:System.Diagnostics.EventLog.Source%2A> to find the appropriate log in which to place your entry. If you are reading the event log, you can either specify the <xref:System.Diagnostics.EventLog.Source%2A>, or a <xref:System.Diagnostics.EventLog.Log%2A> and <xref:System.Diagnostics.EventLog.MachineName%2A>.  \n  \n> [!NOTE]\n>  To create an event source in Windows Vista and later or Windows Server 2003, you must have administrative privileges.  \n>   \n>  The reason for this requirement is that all event logs, including security, must be searched to determine whether the event source is unique. In Windows Vista and later, users do not have permission to access the security log; therefore, a <xref:System.Security.SecurityException> is thrown.  \n>   \n>  In Windows Vista and later, User Account Control (UAC) determines the privileges of a user. If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To execute the code that accesses the security log, you must first elevate your privileges from standard user to administrator. You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.  \n  \n Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> and <xref:System.Diagnostics.EventLog.WriteEntry%2A> to write events to an event log. You must specify an event source to write events; you must create and configure the event source before writing the first entry with the source.  \n  \n Create the new event source during the installation of your application. This allows time for the operating system to refresh its list of registered event sources and their configuration. If the operating system has not refreshed its list of event sources, and you attempt to write an event with the new source, the write operation will fail. You can configure a new source using an <xref:System.Diagnostics.EventLogInstaller>, or using the <xref:System.Diagnostics.EventLog.CreateEventSource%2A> method. You must have administrative rights on the computer to create a new event source.  \n  \n You can create an event source for an existing event log or a new event log. When you create a new source for a new event log, the system registers the source for that log, but the log is not created until the first entry is written to it.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the <xref:System.Diagnostics.EventLog.Log%2A> property with the \".evt\" file name extension.  \n  \n The source must be unique on the local computer; a new source name cannot match an existing source name or an existing event log name. Each source can write to only one event log at a time; however, your application can use multiple sources to write to multiple event logs. For example, your application might require multiple sources configured for different event logs or different resource files.  \n  \n The source must be configured either for writing localized entries or for writing direct strings. If your application writes entries using both resource identifiers and string values, you must register two separate sources. For example, configure one source with resource files, and then use that source in the <xref:System.Diagnostics.EventLog.WriteEvent%2A> method to write entries using resource identifiers to the event log. Then create a different source without resource files, and use that source in the <xref:System.Diagnostics.EventLog.WriteEntry%2A> method to write strings directly to the event log using that source.  \n  \n To change the configuration details of an existing source, you must delete the source and then create it with the new configuration. If other applications or components use the existing source, create a new source with the updated configuration rather than deleting the existing source.  \n  \n> [!NOTE]\n>  If a source has already been mapped to a log and you remap it to a new log, you must restart the computer for the changes to take effect."
  example:
  - "The following example creates the source `MySource` on the computer `MyServer`, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/cpp/86732307-05e6-4c1a-b98e-_1.cpp)]\n [!code-cs[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/csharp/86732307-05e6-4c1a-b98e-_1.cs)]\n [!code-vb[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/visualbasic/86732307-05e6-4c1a-b98e-_1.vb)]"
  syntax:
    content: public static void CreateEventSource (string source, string logName, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "Źródło, za pomocą której aplikacja jest zarejestrowana na określonym komputerze."
    - id: logName
      type: System.String
      description: "Nazwa dziennika źródła wpisy są zapisywane. Możliwe wartości to aplikacja, System lub niestandardowych dziennika zdarzeń. Jeśli nie określisz wartości, `logName` wartości domyślnych do aplikacji."
    - id: machineName
      type: System.String
      description: "Nazwa komputera, aby zarejestrować źródłem tego zdarzenia, lub &quot;.&quot; na komputerze lokalnym."
  overload: System.Diagnostics.EventLog.CreateEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>machineName</code> is not a valid computer name.  \n  \n \\- or -  \n  \n <code>source</code> is an empty string (\"\") or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>logName</code> is not a valid event log name. Event log names must consist of printable characters, and cannot include the characters '*', '?', or '\\\\'.  \n  \n \\- or -  \n  \n <code>logName</code> is not valid for user log creation. The event log names AppEvent, SysEvent, and SecEvent are reserved for system use.  \n  \n \\- or -  \n  \n The log name matches an existing event source name.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters.  \n  \n \\- or -  \n  \n The first 8 characters of <code>logName</code> match the first 8 characters of an existing event log name on the specified computer.  \n  \n \\- or -  \n  \n The source cannot be registered because it already exists on the specified computer.  \n  \n \\- or -  \n  \n The source name matches an existing event source name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nie można otworzyć klucza rejestru dla dziennika zdarzeń na określonym komputerze."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Delete(System.String)
  id: Delete(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Delete(String)
  nameWithType: EventLog.Delete(String)
  fullName: System.Diagnostics.EventLog.Delete(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Usuwa dziennik zdarzeń z komputera lokalnego."
  remarks: "Ta metoda jest dziennik, który chcesz usunąć na komputerze lokalnym. Możesz usunąć wszelkie dziennika na komputerze, pod warunkiem, że odpowiednich uprawnień rejestru.       DELETE usuwa dziennika określony przez `logName` z komputera lokalnego. Jeśli chcesz usunąć źródło zarejestrowane w dzienniku, wywołanie <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Jeśli chcesz usunąć wpisy dziennika, należy wywołać <xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> Usuwanie i <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>są `static` metod, więc można wywołać w samej klasy.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Nie jest konieczne do utworzenia nowego wystąpienia <xref:System.Diagnostics.EventLog>Aby wywołać metodę albo.</xref:System.Diagnostics.EventLog>       Metoda Delete usuwa najpierw plik, w którym jest przechowywana zawartość dziennika. Następnie uzyskuje dostęp do rejestru i usuwa wszystkie źródła zdarzenia zarejestrowane dla tego dziennika. Czy można odtworzyć dziennik w późniejszym czasie, należy zarejestrować źródła zdarzeń ponownie, jeśli mają być ponownie używane. Jeśli nie zarejestrujesz źródła zdarzeń i inni użytkownicy zapisać źródła zdarzenia bez określania nazwy dziennika, zostanie utworzona źródło zdarzenia w dzienniku zdarzeń aplikacji. W związku z tym aplikacje, które wcześniej były możliwość zapisywania wpisów dziennika, należy usunąć i utworzyć ponownie zostaną zapisane w dzienniku aplikacji, ponieważ zawiera teraz źródło zdarzenia.      > [!NOTE] > Ponowne tworzenie dziennika zdarzeń może być trudne procesu. Nie usuwaj żadnego z dzienników zdarzeń utworzonych przez system, takie jak dziennik aplikacji.       Usunięcie dziennika za pomocą wywołania do usunięcia automatycznie powoduje usunięcie źródeł zarejestrowany dla tego dziennika. Ułatwia to inne aplikacje korzystające z tego dziennika niedziałających."
  example:
  - "The following example deletes a log from the local computer. The example determines the log from its source.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_12_1.cpp)]\n [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_12_1.vb)]\n [!code-cs[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_12_1.cs)]"
  syntax:
    content: public static void Delete (string logName);
    parameters:
    - id: logName
      type: System.String
      description: 'Nazwa dziennika do usunięcia. Możliwe wartości: aplikacji, zabezpieczeń, systemu i wszelkie niestandardowe dzienniki zdarzeń na komputerze.'
  overload: System.Diagnostics.EventLog.Delete*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>logName</code>to ciąg pusty (&quot;&quot;) lub <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The registry key for the event log could not be opened on the local computer.  \n  \n \\- or -  \n  \n The log does not exist on the local computer."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Dziennik zdarzeń nie został wyczyszczony pomyślnie.       - lub - nie można otworzyć dziennika. Kod błędu systemu Windows nie jest dostępna."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Delete(System.String,System.String)
  id: Delete(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Delete(String,String)
  nameWithType: EventLog.Delete(String,String)
  fullName: System.Diagnostics.EventLog.Delete(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Usuwa dziennik zdarzeń z określonego komputera."
  remarks: "Ta metoda jest dziennik, który chcesz usunąć z komputera zdalnego. Możesz usunąć wszelkie dziennika na komputerze, pod warunkiem, że odpowiednich uprawnień rejestru.       <xref:System.Diagnostics.EventLog.Delete%2A>Usuwa dziennik określony przez `logName` z komputera określoną przez `machineName`.</xref:System.Diagnostics.EventLog.Delete%2A> Jeśli chcesz usunąć źródło zarejestrowane w dzienniku, wywołanie <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Jeśli chcesz usunąć wpisy dziennika, należy wywołać <xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> <xref:System.Diagnostics.EventLog.Delete%2A>i <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>są `static` metod, więc można wywołać w samej klasy.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A></xref:System.Diagnostics.EventLog.Delete%2A> Nie jest konieczne do utworzenia wystąpienia <xref:System.Diagnostics.EventLog>Aby wywołać metodę albo.</xref:System.Diagnostics.EventLog>       Ta metoda usuwa najpierw plik, w którym jest przechowywana zawartość dziennika. Następnie uzyskuje dostęp do rejestru i usuwa wszystkie źródła zdarzenia zarejestrowane dla tego dziennika. Czy można odtworzyć dziennik w późniejszym czasie, należy zarejestrować źródła zdarzeń ponownie, jeśli mają być ponownie używane. Jeśli nie zarejestrujesz źródła zdarzeń i inni użytkownicy zapisać źródła zdarzenia bez określania nazwy dziennika, zostanie utworzona źródło zdarzenia w dzienniku zdarzeń aplikacji. W związku z tym aplikacje, które wcześniej były możliwość zapisywania wpisów dziennika, należy usunąć i utworzyć ponownie zostaną zapisane w dzienniku aplikacji, ponieważ zawiera teraz źródło zdarzenia.      > [!NOTE] > Ponowne tworzenie dziennika zdarzeń może być trudne procesu. Nie usuwaj żadnego z dzienników zdarzeń utworzonych przez system, takie jak dziennik aplikacji.       Usuwanie dziennika poprzez wywołanie <xref:System.Diagnostics.EventLog.Delete%2A>automatycznie usuwa źródeł zarejestrowany dla tego dziennika.</xref:System.Diagnostics.EventLog.Delete%2A> Ułatwia to inne aplikacje korzystające z tego dziennika niedziałających."
  example:
  - "The following example deletes a log from the specified computer. The example determines the log from its source.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cs[Classic EventLog.Delete1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_17_1.cs)]\n [!code-cpp[Classic EventLog.Delete1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_17_1.cpp)]\n [!code-vb[Classic EventLog.Delete1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_17_1.vb)]"
  syntax:
    content: public static void Delete (string logName, string machineName);
    parameters:
    - id: logName
      type: System.String
      description: 'Nazwa dziennika do usunięcia. Możliwe wartości: aplikacji, zabezpieczeń, systemu i wszelkie niestandardowe dzienniki zdarzeń na określonym komputerze.'
    - id: machineName
      type: System.String
      description: "Nazwa komputera, aby usunąć dziennika, lub &quot;.&quot; na komputerze lokalnym."
  overload: System.Diagnostics.EventLog.Delete*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>logName</code> is an empty string (\"\") or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>machineName</code> is not a valid computer name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The registry key for the event log could not be opened on the specified computer.  \n  \n \\- or -  \n  \n The log does not exist on the specified computer."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Dziennik zdarzeń nie został wyczyszczony pomyślnie.       - lub - nie można otworzyć dziennika. Kod błędu systemu Windows nie jest dostępna."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String)
  id: DeleteEventSource(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: DeleteEventSource(String)
  nameWithType: EventLog.DeleteEventSource(String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Usuwa rejestrację źródła zdarzenia z dziennika zdarzeń komputera lokalnego."
  remarks: "Ta metoda służy do usunięcia rejestracji <xref:System.Diagnostics.EventLog.Source%2A>z komputera lokalnego.</xref:System.Diagnostics.EventLog.Source%2A> DeleteEventSource uzyskuje dostęp do rejestru na komputerze lokalnym i usuwa rejestrację aplikacji jako prawidłowe źródło zdarzeń.       Jeśli nie jest już potrzebna na zapisywanie wpisów w tym dzienniku, należy usunąć składnika jako prawidłowe źródło zdarzeń. Na przykład zrobić to jeśli musisz zmienić składnika z jednego dziennika do innego. Ponieważ źródłem można zarejestrować tylko jeden dziennik w czasie, zmiana w dzienniku wymaga usunięcia bieżącego rejestracji.       DeleteEventSource usuwa tylko źródło, które są zarejestrowane w dzienniku. Jeśli chcesz usunąć samego dziennika, należy wywołać <xref:System.Diagnostics.EventLog.Delete%2A>.</xref:System.Diagnostics.EventLog.Delete%2A> Jeśli chcesz usunąć wpisy dziennika, należy wywołać <xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> <xref:System.Diagnostics.EventLog.Delete%2A>i DeleteEventSource `static` metod, więc można wywołać w samej klasy.</xref:System.Diagnostics.EventLog.Delete%2A> Nie jest konieczne do utworzenia wystąpienia <xref:System.Diagnostics.EventLog>Aby wywołać metodę albo.</xref:System.Diagnostics.EventLog>       Usuwanie dziennika poprzez wywołanie <xref:System.Diagnostics.EventLog.Delete%2A>automatycznie usuwa źródeł zarejestrowany dla tego dziennika.</xref:System.Diagnostics.EventLog.Delete%2A> Ułatwia to inne aplikacje korzystające z tego dziennika niedziałających.      > [!NOTE] > Źródła został już zmapowany do dziennika i ponownie zamapować go do nowego dziennika, należy ponownie uruchomić komputer, aby zmiany zaczęły obowiązywać."
  example:
  - "The following example deletes a source from the local computer. The example determines the log from its source, and then deletes the log.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_8_1.cpp)]\n [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_8_1.vb)]\n [!code-cs[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_8_1.cs)]"
  syntax:
    content: public static void DeleteEventSource (string source);
    parameters:
    - id: source
      type: System.String
      description: "Nazwa, za pomocą której aplikacja jest zarejestrowany w dzienniku zdarzeń systemu."
  overload: System.Diagnostics.EventLog.DeleteEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> parameter does not exist in the registry of the local computer.  \n  \n \\- or -  \n  \n You do not have write access on the registry key for the event log."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)
  id: DeleteEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: DeleteEventSource(String,String)
  nameWithType: EventLog.DeleteEventSource(String,String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Usuwa rejestrację źródła zdarzeń aplikacji z określonego komputera."
  remarks: "Aby usunąć rejestrację, użyj tego przeciążenia <xref:System.Diagnostics.EventLog.Source%2A>z komputera zdalnego.</xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>uzyskuje dostęp do rejestru na komputerze określonym przez `machineName` i usuwa rejestrację aplikacji jako prawidłowe źródło zdarzeń.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A>       Jeśli nie jest już potrzebna na zapisywanie wpisów w tym dzienniku, należy usunąć składnika jako prawidłowe źródło zdarzeń. Na przykład zrobić to jeśli musisz zmienić składnika z jednego dziennika do innego. Ponieważ źródłem można zarejestrować tylko jeden dziennik w czasie, zmiana w dzienniku wymaga usunięcia bieżącego rejestracji.       <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>Usuwa tylko źródło, które są zarejestrowane w dzienniku.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Jeśli chcesz usunąć samego dziennika, należy wywołać <xref:System.Diagnostics.EventLog.Delete%2A>.</xref:System.Diagnostics.EventLog.Delete%2A> Jeśli chcesz usunąć wpisy dziennika, należy wywołać <xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> <xref:System.Diagnostics.EventLog.Delete%2A>i <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>są `static` metod, więc można wywołać w samej klasy.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A></xref:System.Diagnostics.EventLog.Delete%2A> Nie jest konieczne do utworzenia wystąpienia <xref:System.Diagnostics.EventLog>Aby wywołać metodę albo.</xref:System.Diagnostics.EventLog>       Usuwanie dziennika poprzez wywołanie <xref:System.Diagnostics.EventLog.Delete%2A>automatycznie usuwa źródeł zarejestrowany dla tego dziennika.</xref:System.Diagnostics.EventLog.Delete%2A> Ułatwia to inne aplikacje korzystające z tego dziennika niedziałających.      > [!NOTE] > Źródła został już zmapowany do dziennika i ponownie zamapować go do nowego dziennika, należy ponownie uruchomić komputer, aby zmiany zaczęły obowiązywać."
  example:
  - "The following example deletes a source from the specified computer. The example determines the log from its source, and then deletes the log.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cs[Classic EventLog.Delete1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_6_1.cs)]\n [!code-cpp[Classic EventLog.Delete1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_6_1.cpp)]\n [!code-vb[Classic EventLog.Delete1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_6_1.vb)]"
  syntax:
    content: public static void DeleteEventSource (string source, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "Nazwa, za pomocą której aplikacja jest zarejestrowany w dzienniku zdarzeń systemu."
    - id: machineName
      type: System.String
      description: "Nazwa komputera, aby usunąć rejestrację, lub &quot;.&quot; na komputerze lokalnym."
  overload: System.Diagnostics.EventLog.DeleteEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>machineName</code> parameter is invalid.  \n  \n \\- or -  \n  \n The <code>source</code> parameter does not exist in the registry of the specified computer.  \n  \n \\- or -  \n  \n You do not have write access on the registry key for the event log."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>source</code>Nie można usunąć, ponieważ w rejestrze, klucz rejestru nadrzędnej <code>source</code> nie zawiera podklucz o takiej samej nazwie."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: EventLog.Dispose(Boolean)
  fullName: System.Diagnostics.EventLog.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Zwalnia zasoby niezarządzane używane przez <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref>i opcjonalnie zwalnia zasoby zarządzane."
  remarks: "Ta metoda jest wywoływana przez metodę publiczną `Dispose()`— metoda i <xref:System.Object.Finalize%2A>metody.</xref:System.Object.Finalize%2A> `Dispose()`wywołuje chronioną metodę `Dispose(Boolean)` metody z `disposing` ustawiono parametr `true`. <xref:System.Object.Finalize%2A>wywołuje `Dispose` z `disposing` ustawioną `false`.</xref:System.Object.Finalize%2A>       Gdy `disposing` parametr ma wartość true, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane przez to <xref:System.Diagnostics.EventLog>odwołań.</xref:System.Diagnostics.EventLog> Ta metoda wywołuje `Dispose()` metody każdego odwołuje się do obiektu."
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Aby zwolnić zasoby zarządzane i niezarządzane; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> aby zwolnić tylko zasoby niezarządzane."
  overload: System.Diagnostics.EventLog.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.EnableRaisingEvents
  id: EnableRaisingEvents
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EnableRaisingEvents
  nameWithType: EventLog.EnableRaisingEvents
  fullName: System.Diagnostics.EventLog.EnableRaisingEvents
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Pobiera lub ustawia wartość wskazującą czy <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> odbiera <xref href=&quot;System.Diagnostics.EventLog.EntryWritten&quot;> </xref> powiadomienia o zdarzeniach."
  remarks: "Właściwość EnableRaisingEvents Określa, czy <xref:System.Diagnostics.EventLog>informuje o zdarzeniach, gdy wpisy są zapisywane w dzienniku.</xref:System.Diagnostics.EventLog> Gdy ta właściwość jest `true`, składników, które odbierają <xref:System.Diagnostics.EventLog.EntryWritten>zdarzenia będą otrzymywać powiadomienia kiedykolwiek wpis dziennika, który jest określony w <xref:System.Diagnostics.EventLog.Log%2A>Właściwości.</xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.EntryWritten> Jeśli jest EnableRaisingEvents `false`, są zgłaszane żadne zdarzenia.      > [!NOTE] > Możesz otrzymywać powiadomienia o zdarzeniach tylko wtedy, gdy wpisy są zapisywane na komputerze lokalnym. Nie można otrzymywać powiadomienia w nich pozycje zapisane na komputerach zdalnych."
  example:
  - "The following example handles an <xref:System.Diagnostics.EventLog.EntryWritten> event.  \n  \n [!code-cs[Classic EventLog.EnableRaisingEvents Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_32_1.cs)]\n [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_32_1.vb)]\n [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_32_1.cpp)]"
  syntax:
    content: public bool EnableRaisingEvents { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> otrzymuje powiadomienie, gdy wpis jest zapisywane w dzienniku, a w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.EventLog.EnableRaisingEvents*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Dziennik zdarzeń znajduje się na komputerze zdalnym."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.EndInit
  id: EndInit
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EndInit()
  nameWithType: EventLog.EndInit()
  fullName: System.Diagnostics.EventLog.EndInit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Kończy się inicjowanie <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> używane w formularzu lub przez inny składnik. Inicjowanie występuje w czasie wykonywania."
  remarks: "[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] Projekt środowiska korzystania z tej metody do zakończenia inicjowania składnika używanego w formularzu lub przez inny składnik. <xref:System.Diagnostics.EventLog.BeginInit%2A>Metoda uruchamia inicjowania.</xref:System.Diagnostics.EventLog.BeginInit%2A> Przy użyciu <xref:System.Diagnostics.EventLog.BeginInit%2A>i metody EndInit uniemożliwia użycie przed pełnym zainicjowaniem kontrolki.</xref:System.Diagnostics.EventLog.BeginInit%2A>"
  syntax:
    content: public void EndInit ();
    parameters: []
  overload: System.Diagnostics.EventLog.EndInit*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Entries
  id: Entries
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Entries
  nameWithType: EventLog.Entries
  fullName: System.Diagnostics.EventLog.Entries
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Pobiera zawartość dziennika zdarzeń."
  remarks: "Użyj elementu członkowskiego wpisy podczas czytania z dziennika zdarzeń.       Ponieważ ta właściwość jest tylko do odczytu, nie można zmodyfikować wpisu lub zapisu w dzienniku przy użyciu wpisów. Zamiast tego określ <xref:System.Diagnostics.EventLog.Source%2A>i Wywołaj <xref:System.Diagnostics.EventLog.WriteEntry%2A>zapisać nowy wpis dziennika.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A> Użyj wpisów, aby określić liczbę wpisów w dzienniku zdarzeń i wyświetlić każdego <xref:System.Diagnostics.EventLogEntry>w kolekcji.</xref:System.Diagnostics.EventLogEntry> Użyj indeksowanej <xref:System.Diagnostics.EventLogEntryCollection.Item%2A>elementu członkowskiego można pobrać informacji na temat określonego wpisu, takich jak <xref:System.Diagnostics.EventLogEntry.Message%2A>, <xref:System.Diagnostics.EventLogEntry.Category%2A>, <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>, lub <xref:System.Diagnostics.EventLogEntry.EntryType%2A>.</xref:System.Diagnostics.EventLogEntry.EntryType%2A> </xref:System.Diagnostics.EventLogEntry.TimeWritten%2A> </xref:System.Diagnostics.EventLogEntry.Category%2A> </xref:System.Diagnostics.EventLogEntry.Message%2A> </xref:System.Diagnostics.EventLogEntryCollection.Item%2A>       Nie jest konieczne określić, <xref:System.Diagnostics.EventLog.Source%2A>gdy tylko do odczytu z dziennika.</xref:System.Diagnostics.EventLog.Source%2A> Można określić tylko <xref:System.Diagnostics.EventLog.Log%2A>nazwy i <xref:System.Diagnostics.EventLog.MachineName%2A>Właściwości (nazwa komputera serwera) <xref:System.Diagnostics.EventLog>wystąpienia.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> W obu przypadkach wpisy element członkowski jest automatycznie wypełniana listy wpisów dziennika zdarzeń. Możesz wybrać odpowiedni indeks elementu na liście do odczytu poszczególne pozycje.       To ważna różnica między odczytywania i zapisywania wpisów dziennika jest, że nie jest konieczne jawnie wywołać metodę odczytu. Po <xref:System.Diagnostics.EventLog.Log%2A>i <xref:System.Diagnostics.EventLog.MachineName%2A>są określone właściwości wpisów jest automatycznie wypełniane.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> W przypadku zmiany wartości <xref:System.Diagnostics.EventLog.Log%2A>lub <xref:System.Diagnostics.EventLog.MachineName%2A>Właściwości, wpisy właściwości jest zapełnienia przy następnym odczytać go.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > Nie należy określić, <xref:System.Diagnostics.EventLog.MachineName%2A>Jeśli łączysz się z dziennika.</xref:System.Diagnostics.EventLog.MachineName%2A> Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>, komputer lokalny, &quot;.&quot;, zakłada, że.</xref:System.Diagnostics.EventLog.MachineName%2A>"
  example:
  - "The following example reads entries in the event log, \"MyNewLog\", on the local computer.  \n  \n [!code-cs[Classic EventLog.Entries Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_23_1.cs)]\n [!code-cpp[Classic EventLog.Entries Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_23_1.cpp)]\n [!code-vb[Classic EventLog.Entries Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_23_1.vb)]"
  syntax:
    content: public System.Diagnostics.EventLogEntryCollection Entries { get; }
    return:
      type: System.Diagnostics.EventLogEntryCollection
      description: "<xref href=&quot;System.Diagnostics.EventLogEntryCollection&quot;> </xref> Zawierający wpisy w dzienniku zdarzeń. Każdy wpis jest skojarzony z wystąpieniem <xref href=&quot;System.Diagnostics.EventLogEntry&quot;> </xref> klasy."
  overload: System.Diagnostics.EventLog.Entries*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.EntryWritten
  id: EntryWritten
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EntryWritten
  nameWithType: EventLog.EntryWritten
  fullName: System.Diagnostics.EventLog.EntryWritten
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Występuje, gdy wpis dziennika zdarzeń na komputerze lokalnym."
  remarks: "Aby uzyskać powiadomienia o zdarzeniach, należy ustawić <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>do `true`.</xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> Może odbierać powiadomienia o zdarzeniach, gdy wpisy są zapisywane na komputerze lokalnym. Nie można otrzymywać powiadomienia w nich pozycje zapisane na komputerach zdalnych.       Podczas tworzenia obiektu delegowanego EntryWritten, należy określić metodę, która obsłuży zdarzenie. Aby skojarzyć zdarzenie z obsługi zdarzenia, należy dodać wystąpienia delegata zdarzenia. Program obsługi zdarzeń jest wywoływana, gdy wystąpi zdarzenie, przed usunięciem obiektu delegowanego. Aby uzyskać więcej informacji na temat obsługi zdarzeń z delegatów zobacz [zdarzenia](~/add/includes/ajax-current-ext-md.md).       System odpowiada <xref:System.Diagnostics.EventLog.WriteEntry%2A>tylko wtedy, gdy ostatnie zdarzenie zapisu wystąpił co najmniej sześć sekund wcześniej.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Oznacza to, otrzymają tylko jedno powiadomienie zdarzeń EntryWritten w ciągu sekundy sześciu, występuje nawet wtedy, gdy zmiana więcej niż jeden dziennika zdarzeń. Po wstawieniu interwał uśpienia wystarczająco długi (około 10 sekund) między wywołania <xref:System.Diagnostics.EventLog.WriteEntry%2A>, jest mniej prawdopodobne zdarzenie sygnałów.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Jednak jeśli zdarzenia zapisu częściej, może nie odbierać powiadomienie o zdarzeniu do momentu następnym interwale czasowym. Zwykle powiadomienia o zdarzeniach brakujących są nie utracone, ale opóźniona."
  example:
  - "The following example handles an entry written event.  \n  \n [!code-cs[Classic EventLog.EntryWritten Example#1](~/add/codesnippet/csharp/e-system.diagnostics.eve_1.cs)]\n [!code-cpp[Classic EventLog.EntryWritten Example#1](~/add/codesnippet/cpp/e-system.diagnostics.eve_1.cpp)]\n [!code-vb[Classic EventLog.EntryWritten Example#1](~/add/codesnippet/visualbasic/e-system.diagnostics.eve_1.vb)]"
  syntax:
    content: public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;
    return:
      type: System.Diagnostics.EntryWrittenEventHandler
      description: "Do dodania."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Exists(System.String)
  id: Exists(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Exists(String)
  nameWithType: EventLog.Exists(String)
  fullName: System.Diagnostics.EventLog.Exists(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Określa, czy dziennik istnieje na komputerze lokalnym."
  remarks: "Użyj tej metody, aby określić, czy dziennik istnieje na komputerze lokalnym. Jeśli chcesz określić, czy źródło istnieje na komputerze lokalnym, użyj <xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A>       Ponieważ ta metoda uzyskuje dostęp do rejestru, musi mieć odpowiednich uprawnień rejestru na komputerze lokalnym; w przeciwnym razie zwraca `false`.       Ponieważ nowego dziennika nie może zawierać nazwę istniejącego dziennika na tym samym komputerze, ta metoda przed utworzeniem nowego dziennika można określić, czy określony `logName` już istnieje na komputerze lokalnym. `logName` Parametr nie jest uwzględniana wielkość liter.       Istnieje jest `static` metody, więc może ona zostać wywołana w samej klasy. Nie jest konieczne do utworzenia wystąpienia <xref:System.Diagnostics.EventLog>do wywołania Exists.</xref:System.Diagnostics.EventLog>"
  example:
  - >-
    [!code-cpp[EventLog_Exists_1#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_4_1.cpp)]
     [!code-vb[EventLog_Exists_1#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_4_1.vb)]
     [!code-cs[EventLog_Exists_1#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_4_1.cs)]
  syntax:
    content: public static bool Exists (string logName);
    parameters:
    - id: logName
      type: System.String
      description: 'Nazwa dziennika do wyszukania. Możliwe wartości: aplikacji, zabezpieczeń, System, inne dzienniki specyficzne dla aplikacji (takich jak powiązane z usługą Active Directory) lub dowolnego niestandardowego dziennika na komputerze.'
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli dziennik istnieje na komputerze lokalnym; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.EventLog.Exists*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Jest Nazwa_dziennika <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> lub wartość jest pusta."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Exists(System.String,System.String)
  id: Exists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Exists(String,String)
  nameWithType: EventLog.Exists(String,String)
  fullName: System.Diagnostics.EventLog.Exists(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Określa, czy dziennik istnieje na określonym komputerze."
  remarks: "Użyj tej metody, aby określić, czy dziennik istnieje na komputerze zdalnym. Jeśli chcesz określić, czy źródło istnieje na komputerze zdalnym, należy użyć <xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A>       Ponieważ ta metoda uzyskuje dostęp do rejestru, musi mieć odpowiednich uprawnień rejestru na określonym komputerze. w przeciwnym razie zwraca `false`.       Ponieważ nowego dziennika nie może zawierać nazwę istniejącego dziennika na tym samym komputerze, ta metoda przed utworzeniem nowego dziennika można określić, czy jest to jeden z określonym `logName` już istnieje na serwerze określonym przez `machineName` parametru. `logName` i `machineName` parametrów nie jest uwzględniana.       <xref:System.Diagnostics.EventLog.Exists%2A>jest `static` metody, więc może ona zostać wywołana w samej klasy.</xref:System.Diagnostics.EventLog.Exists%2A> Nie jest konieczne do utworzenia nowego wystąpienia <xref:System.Diagnostics.EventLog>wywołać <xref:System.Diagnostics.EventLog.Exists%2A>.</xref:System.Diagnostics.EventLog.Exists%2A> </xref:System.Diagnostics.EventLog>"
  syntax:
    content: public static bool Exists (string logName, string machineName);
    parameters:
    - id: logName
      type: System.String
      description: 'Dziennik do wyszukania. Możliwe wartości: aplikacji, zabezpieczeń, System, inne dzienniki specyficzne dla aplikacji (takich jak powiązane z usługą Active Directory) lub dowolnego niestandardowego dziennika na komputerze.'
    - id: machineName
      type: System.String
      description: "Nazwa komputera, na których będą poszukiwane dziennika, lub &quot;.&quot; na komputerze lokalnym."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli istnieje dziennika na określonym komputerze. w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.EventLog.Exists*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> machineName </code> Parametr ma nieprawidłowy format. Upewnij się, że używasz poprawnej składni dla komputera, na którym wyszukujesz.       - lub - <code> logName </code> jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> lub wartość jest pusta."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.GetEventLogs
  id: GetEventLogs
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: GetEventLogs()
  nameWithType: EventLog.GetEventLogs()
  fullName: System.Diagnostics.EventLog.GetEventLogs()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Przeszukuje wszystkie dzienniki zdarzeń na komputerze lokalnym i tworzy tablicę <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> obiektów, które zawierają listy."
  remarks: "Tablica <xref:System.Diagnostics.EventLog>obiektów jest migawką wszystkie dzienniki zdarzeń na komputerze lokalnym, gdy wywołanie GetEventLogs.</xref:System.Diagnostics.EventLog> Nie jest kolekcją dynamicznych, więc nie odzwierciedla usunięcia lub tworzenia dzienników w czasie rzeczywistym. Należy sprawdzić, czy dziennika w tablicy istnieje przed odczytać lub zapisać go. Tablica zwykle zawiera co najmniej trzy dzienniki: aplikacji, System i zabezpieczenia. Jeśli utworzono niestandardowe dzienniki na komputerze lokalnym, pojawią się również do tablicy.       Aby pobrać listę dzienników zdarzeń, musi mieć odpowiednich uprawnień rejestru. Te uprawnienia są takie same jak wymagane do wywołania <xref:System.Diagnostics.EventLog.Exists%2A>i <xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A> </xref:System.Diagnostics.EventLog.Exists%2A>"
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_10_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/m-system.diagnostics.eve_10_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/m-system.diagnostics.eve_10_1.cs)]"
  syntax:
    content: public static System.Diagnostics.EventLog[] GetEventLogs ();
    parameters: []
    return:
      type: System.Diagnostics.EventLog[]
      description: "Tablica typu <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> reprezentujący dzienniki na komputerze lokalnym."
  overload: System.Diagnostics.EventLog.GetEventLogs*
  exceptions:
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Nie masz dostępu do odczytu do rejestru.       - lub - nie ma usługi dziennika zdarzeń na komputerze."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.GetEventLogs(System.String)
  id: GetEventLogs(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: GetEventLogs(String)
  nameWithType: EventLog.GetEventLogs(String)
  fullName: System.Diagnostics.EventLog.GetEventLogs(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Przeszukuje wszystkie dzienniki zdarzeń na danym komputerze i tworzy tablicę <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> obiektów, które zawierają listy."
  remarks: "Tablica <xref:System.Diagnostics.EventLog>obiektów jest migawką wszystkie dzienniki zdarzeń na komputerze określonym przez `machineName` parametru po wywołaniu <xref:System.Diagnostics.EventLog.GetEventLogs%2A>staje się.</xref:System.Diagnostics.EventLog.GetEventLogs%2A> </xref:System.Diagnostics.EventLog> Nie jest kolekcją dynamicznych, więc nie odzwierciedla usunięcia lub tworzenia dzienników w czasie rzeczywistym. Należy sprawdzić, czy dziennika w tablicy istnieje przed odczytać lub zapisać go. Tablica zwykle zawiera co najmniej trzy dzienniki: aplikacji, System i zabezpieczenia. Jeśli utworzono niestandardowe dzienniki na określonym komputerze pojawią się również do tablicy.       <xref:System.Diagnostics.EventLog.GetEventLogs%2A>jest `static` metody, więc może ona zostać wywołana na <xref:System.Diagnostics.EventLog>samej klasy.</xref:System.Diagnostics.EventLog></xref:System.Diagnostics.EventLog.GetEventLogs%2A> Nie jest konieczne do utworzenia wystąpienia <xref:System.Diagnostics.EventLog>obiekt do wywoływania metody.</xref:System.Diagnostics.EventLog>       Aby pobrać listę dzienników zdarzeń, musi mieć odpowiednich uprawnień rejestru. Te uprawnienia są takie same jak wymagane do wywołania <xref:System.Diagnostics.EventLog.Exists%2A>i <xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A> </xref:System.Diagnostics.EventLog.Exists%2A>"
  example:
  - "The following example gets a list of logs on the computer \"myServer\". It then outputs the name of each log.  \n  \n [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_18_1.cpp)]\n [!code-cs[Classic EventLog.GetEventLogs1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_18_1.cs)]\n [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_18_1.vb)]"
  syntax:
    content: public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);
    parameters:
    - id: machineName
      type: System.String
      description: "Komputer, na których będą poszukiwane dzienników zdarzeń."
    return:
      type: System.Diagnostics.EventLog[]
      description: "Tablica typu <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> reprezentujący dzienniki na danym komputerze."
  overload: System.Diagnostics.EventLog.GetEventLogs*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> machineName </code> Parametr jest prawidłową nazwą komputera."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nie masz dostępu do odczytu do rejestru.       - lub - nie ma usługi dziennika zdarzeń na komputerze."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Log
  id: Log
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Log
  nameWithType: EventLog.Log
  fullName: System.Diagnostics.EventLog.Log
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Pobiera lub ustawia nazwę dziennika do odczytu lub zapisu."
  remarks: "Three log files exist by default on the server: Application, System, and Security. Applications and services use the Application log file. Device drivers use the System log file. The system generates success and failure audit events in the Security log when auditing is turned on. If you have other applications installed, like Active Directory on Windows servers, there might be other default log files. In addition, you can create custom log files on a local or remote computer. Custom logs help organize your entries in a more detailed way than is allowed when your components write events to the default Application log.  \n  \n> [!NOTE]\n>  Log names are limited to eight characters. According to the system, MyLogSample1 and MyLogSample2 are the same log.  \n  \n If you write to an event log, it is not enough to specify the Log property. You must associate a <xref:System.Diagnostics.EventLog.Source%2A> property with your event log resource to connect it to a particular log. It is not necessary to specify a <xref:System.Diagnostics.EventLog.Source%2A> when only reading from a log, but an event source must be associated with the event log resource in the server's registry. You can specify only the Log name and <xref:System.Diagnostics.EventLog.MachineName%2A> (server computer name) to read from it.  \n  \n> [!NOTE]\n>  You are not required to specify the <xref:System.Diagnostics.EventLog.MachineName%2A> if you are connecting to a log. If you do not specify the <xref:System.Diagnostics.EventLog.MachineName%2A>, the local computer (\".\") is assumed.  \n  \n If the <xref:System.Diagnostics.EventLog.Source%2A> property has not been specified, a call to Log returns an empty string if Log has not been explicitly set (by setting the Log property, or through the constructor). If the <xref:System.Diagnostics.EventLog.Source%2A> has been specified, Log returns the name of the log to which that source was registered.  \n  \n A source can only be registered to one log at a time. If the <xref:System.Diagnostics.EventLog.Source%2A> property was set for an instance of <xref:System.Diagnostics.EventLog>, you cannot change the Log property for that <xref:System.Diagnostics.EventLog> without changing the value of <xref:System.Diagnostics.EventLog.Source%2A> or calling <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> first. If you change the Log property after the <xref:System.Diagnostics.EventLog.Source%2A> property has been set, writing a log entry throws an exception.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the Log property with the \".evt\" file name extension.  \n  \n You cannot create a new log using the Log property alone (without specifying a source for the log). You can call <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, passing in a new log name as a parameter, and then call <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. However, the intent is usually either to create (and write entries to) new application-specific logs, or to read from existing logs.  \n  \n If the Log value changes, the event log is closed and all event handles are released.  \n  \n> [!CAUTION]\n>  If you set the Log property to the name of a log that does not exist, the system attaches the <xref:System.Diagnostics.EventLog> to the Application log, but does not warn you that it is using a log other than the one you specified."
  example:
  - "The following example reads entries in the event log, \"NewEventLog\", on the local computer.  \n  \n [!code-cpp[Classic EventLog.Log Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_17_1.cpp)]\n [!code-cs[Classic EventLog.Log Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_17_1.cs)]\n [!code-vb[Classic EventLog.Log Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_17_1.vb)]"
  syntax:
    content: public string Log { get; set; }
    return:
      type: System.String
      description: "Nazwa dziennika. Może to być aplikacji, System, zabezpieczenia lub niestandardowej nazwy dziennika. Wartość domyślna to ciąg pusty (&quot;&quot;)."
  overload: System.Diagnostics.EventLog.Log*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.LogDisplayName
  id: LogDisplayName
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: LogDisplayName
  nameWithType: EventLog.LogDisplayName
  fullName: System.Diagnostics.EventLog.LogDisplayName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Pobiera przyjazną nazwę dziennika zdarzeń."
  remarks: "> [!NOTE]> W systemie Windows Vista lub nowszy użytkownicy nie masz uprawnień do dostępu do dziennika zabezpieczeń. Jeśli używasz systemu Windows Vista lub nowszym jako użytkownik, zostanie wyświetlone <xref:System.Security.SecurityException>podczas próby dostępu wyświetlaną nazwę zdarzenia w dzienniku zabezpieczeń.</xref:System.Security.SecurityException>   >> W systemie Windows Vista lub nowszego oraz kontroli konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem grupy Administratorzy wbudowanych, są przypisane dwa tokenów dostępu do środowiska wykonawczego: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie są w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do dziennika zabezpieczeń, musi najpierw podwyższenie Twoje uprawnienia od użytkownika standardowego do administratora. Można to zrobić, podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator."
  example:
  - "The following example enumerates the event logs defined on the local computer and displays the LogDisplayName for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_29_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_29_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_29_1.cs)]"
  syntax:
    content: public string LogDisplayName { get; }
    return:
      type: System.String
      description: "Nazwa, która reprezentuje dziennika zdarzeń w Podglądzie zdarzeń systemu."
  overload: System.Diagnostics.EventLog.LogDisplayName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Określony <xref:System.Diagnostics.EventLog.Log*>nie istnieje w rejestrze dla tego komputera.</xref:System.Diagnostics.EventLog.Log*>"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)
  id: LogNameFromSourceName(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: LogNameFromSourceName(String,String)
  nameWithType: EventLog.LogNameFromSourceName(String,String)
  fullName: System.Diagnostics.EventLog.LogNameFromSourceName(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Pobiera nazwę dziennika, do którego określone źródło jest zarejestrowany."
  remarks: "Źródło zdarzenia wskazuje co rejestruje zdarzenie. Często jest nazwa aplikacji lub nazwy podskładnika aplikacji, jeśli aplikacja jest duży. Aplikacje i usługi, należy zapisać dziennik aplikacji lub dziennik niestandardowy. Sterowniki urządzeń, należy zapisać w dzienniku systemu.       Podczas tworzenia nowego źródła naraz tylko może zapisywać w jednym dzienniku, system rejestruje aplikację z dziennika zdarzeń jako prawidłowe źródło wpisów. <xref:System.Diagnostics.EventLog.Source%2A>Właściwość może być dowolnym ciągiem, ale nazwa nie może być używane przez inne źródła na komputerze.</xref:System.Diagnostics.EventLog.Source%2A> Próba utworzenia zduplikowanych <xref:System.Diagnostics.EventLog.Source%2A>wartość zgłasza wyjątek.</xref:System.Diagnostics.EventLog.Source%2A> Jednak pojedynczy dziennik zdarzeń może mieć wiele różnych źródeł, zapisywania do niego."
  example:
  - "The following example deletes a source from the local computer. The example determines the log from its source, and then deletes the log.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_2_1.cpp)]\n [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_2_1.vb)]\n [!code-cs[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_2_1.cs)]"
  syntax:
    content: public static string LogNameFromSourceName (string source, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "Nazwa źródła zdarzenia."
    - id: machineName
      type: System.String
      description: "Nazwa komputera, na którym do przeszukania, lub &quot;.&quot; na komputerze lokalnym."
    return:
      type: System.String
      description: "Nazwa dziennika skojarzonych z określonego źródła w rejestrze."
  overload: System.Diagnostics.EventLog.LogNameFromSourceName*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.MachineName
  id: MachineName
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: MachineName
  nameWithType: EventLog.MachineName
  fullName: System.Diagnostics.EventLog.MachineName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Pobiera lub ustawia nazwę komputera, na którym ma być odczytywane lub zapisywane zdarzenia."
  remarks: "Jeśli piszesz do dziennika zdarzeń, należy skojarzyć <xref:System.Diagnostics.EventLog.Source%2A>z obiektem dziennik zdarzeń do połączenia w określonym dzienniku.</xref:System.Diagnostics.EventLog.Source%2A> Nie jest konieczne określić <xref:System.Diagnostics.EventLog.Source%2A>Właściwości, gdy tylko do odczytu z dziennika.</xref:System.Diagnostics.EventLog.Source%2A> Można określić tylko <xref:System.Diagnostics.EventLog.Log%2A>nazwy i MachineName (nazwa komputera serwera).</xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > Nie trzeba określać MachineName, jeśli łączysz się z dziennikiem. Jeśli nie określisz MachineName, komputer lokalny (&quot;.&quot;) zakłada, że.       Źródła można zarejestrować tylko jeden dziennik w czasie. Jeśli <xref:System.Diagnostics.EventLog.Source%2A>właściwość została ustawiona na wystąpienie <xref:System.Diagnostics.EventLog>, nie można zmienić właściwości MachineName, dla którego <xref:System.Diagnostics.EventLog>bez zmiany wartości <xref:System.Diagnostics.EventLog.Source%2A>lub wywoływania <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>pierwszej.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> </xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> Jeśli zmienisz właściwości MachineName <xref:System.Diagnostics.EventLog>zamyka wszystkie dojścia i reattaches do log i source na nowym komputerze.</xref:System.Diagnostics.EventLog>       Wartość MachineName nie może być pustym ciągiem. Jeśli nie jest jawnie ustawiona domyślnie na komputerze lokalnym (&quot;.&quot;)."
  example:
  - "The following example reads entries in the event log, \"NewEventLog\", on a specified computer.  \n  \n [!code-cs[Classic EventLog.MachineName Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_6_1.cs)]\n [!code-vb[Classic EventLog.MachineName Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_6_1.vb)]\n [!code-cpp[Classic EventLog.MachineName Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_6_1.cpp)]"
  syntax:
    content: public string MachineName { get; set; }
    return:
      type: System.String
      description: "Nazwa serwera, na którym znajduje się w dzienniku zdarzeń. Wartość domyślna to komputer lokalny (&quot;.&quot;)."
  overload: System.Diagnostics.EventLog.MachineName*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Nazwa komputera jest nieprawidłowa."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.MaximumKilobytes
  id: MaximumKilobytes
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: MaximumKilobytes
  nameWithType: EventLog.MaximumKilobytes
  fullName: System.Diagnostics.EventLog.MaximumKilobytes
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Pobiera lub ustawia maksymalny rozmiar dziennika zdarzeń w kilobajtach."
  remarks: "Właściwość MaximumKilobytes reprezentuje limit rozmiaru pliku dziennika zdarzeń. Gdy dziennik zdarzeń osiągnie limit rozmiaru skonfigurowanego <xref:System.Diagnostics.EventLog.OverflowAction%2A>wartość określa, czy nowe wpisy zostaną odrzucone lub czy nowe wpisy zastąpić starsze wpisy.</xref:System.Diagnostics.EventLog.OverflowAction%2A>      > [!NOTE] > Ta właściwość reprezentuje ustawienia konfiguracji dziennika zdarzeń reprezentowanym przez to wystąpienie. Jeśli dziennik zdarzeń osiągnie maksymalny rozmiar, ta właściwość określa, jak system operacyjny obsługuje nowe wpisy zarejestrowane w dzienniku zdarzeń wszystkie źródła zdarzeń."
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_15_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_15_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_15_1.cs)]"
  syntax:
    content: public long MaximumKilobytes { get; set; }
    return:
      type: System.Int64
      description: "Maksymalny rozmiar dziennika zdarzeń w kilobajtach. Wartość domyślna to 512 i wskazujący maksymalny rozmiar pliku 512 kilobajtów."
  overload: System.Diagnostics.EventLog.MaximumKilobytes*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Określona wartość jest mniejsza niż 64, lub większa niż 4194240 lub nie jest wielokrotnością 64."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <xref:System.Diagnostics.EventLog.Log*> value is not a valid log name.  \n  \n \\- or -  \n  \n The registry key for the event log could not be opened on the target computer."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.MinimumRetentionDays
  id: MinimumRetentionDays
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: MinimumRetentionDays
  nameWithType: EventLog.MinimumRetentionDays
  fullName: System.Diagnostics.EventLog.MinimumRetentionDays
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Pobiera liczbę dni, aby zachować wpisy w dzienniku zdarzeń."
  remarks: "Użyj właściwości MinimumRetentionDays, aby sprawdzić bieżące ustawienia dla dziennika zdarzeń. Użyj <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>Aby zmienić minimalną liczbę dni, które muszą zostać zachowane każdego wpisu w dzienniku zdarzeń.</xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>       Wartość MinimumRetentionDays zależy od zachowania skonfigurowanych przepełnienia dziennika zdarzeń. Jeśli <xref:System.Diagnostics.OverflowAction>ma ustawioną wartość właściwości dziennika zdarzeń <xref:System.Diagnostics.OverflowAction>, następnie MinimumRetentionDays wartość jest równa 0.</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.OverflowAction> Jeśli <xref:System.Diagnostics.OverflowAction>ma ustawioną wartość właściwości dziennika zdarzeń <xref:System.Diagnostics.OverflowAction>, a następnie wartość MinimumRetentionDays wynosi -1.</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.OverflowAction> Jeśli <xref:System.Diagnostics.OverflowAction>ma ustawioną wartość właściwości dziennika zdarzeń <xref:System.Diagnostics.OverflowAction>, a następnie wartość MinimumRetentionDays jest większa od zera i reprezentuje liczbę dni, aby zachować wpisy w dzienniku zdarzeń po zapełnieniu dziennika zdarzeń.</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.OverflowAction>       Zachowanie przepełnienie tylko występuje, gdy dziennik zdarzeń osiągnie limit rozmiaru. Gdy <xref:System.Diagnostics.EventLog>ma jego <xref:System.Diagnostics.EventLog.OverflowAction%2A>ustawioną <xref:System.Diagnostics.OverflowAction>i dziennik zdarzeń osiągnie maksymalny rozmiar, a następnie nowe wpisy są zapisywane tylko jeśli ich zastąpić wpisów, którego okres ważności przekracza okres MinimumRetentionDays.</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.EventLog.OverflowAction%2A> </xref:System.Diagnostics.EventLog> Zachowywanie wpisy zdarzeń minimalny okres jest odpowiednie, gdy regularnie archiwizacji dziennik zdarzeń. W przeciwnym razie ryzyko utraty nowe wpisy, gdy dziennik zdarzeń osiągnie limit. Aby uniknąć utraty nowych informacji o zdarzeniu, należy ustawić co najmniej dni zdarzeń oparte na harmonogramie archiwum dla określonego dziennika zdarzeń."
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_12_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_12_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_12_1.cs)]"
  syntax:
    content: public int MinimumRetentionDays { get; }
    return:
      type: System.Int32
      description: "Liczba dni, które są przechowywane wpisy w dzienniku zdarzeń. Wartość domyślna to 7."
  overload: System.Diagnostics.EventLog.MinimumRetentionDays*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  id: ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: ModifyOverflowPolicy(OverflowAction,Int32)
  nameWithType: EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
  fullName: System.Diagnostics.EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Zmienia zachowanie skonfigurowanych dla zapisywania nowych wpisów po jego maksymalny rozmiar pliku dziennika zdarzeń."
  remarks: "Zachowanie przepełnienia dziennika zdarzeń określa, co się dzieje, gdy nowe wpisy są zapisywane do dziennika, który osiągnął maksymalny rozmiar.      > [!NOTE] > Zachowanie przepełnienie obowiązuje tylko wtedy, gdy dziennik zdarzeń osiągnie maksymalny rozmiar. Zachowanie przepełnienie nie ma wpływu na zapisywanie nowego wpisu w dzienniku, która może obsłużyć wpisy w dzienniku zdarzeń dodatkowe.       Metoda ModifyOverflowPolicy konfiguruje zachowanie przepełnienia dziennika zdarzeń. <xref:System.Diagnostics.EventLog>wystąpienie.</xref:System.Diagnostics.EventLog> Po wywołaniu tej metody dla dziennika zdarzeń określony przez <xref:System.Diagnostics.EventLog.Log%2A>właściwości <xref:System.Diagnostics.EventLog.OverflowAction%2A>i <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>wartości właściwości odzwierciedlają zachowanie nowo skonfigurowanego przepełnienia.</xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> </xref:System.Diagnostics.EventLog.OverflowAction%2A> </xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > Ta właściwość reprezentuje ustawienia konfiguracji dziennika zdarzeń reprezentowanym przez to wystąpienie. Jeśli dziennik zdarzeń osiągnie maksymalny rozmiar, ta właściwość określa, jak system operacyjny obsługuje nowe wpisy zarejestrowane w dzienniku zdarzeń wszystkie źródła zdarzeń.       Ustaw `action` parametr <xref:System.Diagnostics.OverflowAction>Aby wskazać, że nowy wpis zastępuje najstarszą wpis podczas <xref:System.Diagnostics.EventLog>osiągnie maksymalny rozmiar.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.OverflowAction> Jeśli `action` ustawiono parametr <xref:System.Diagnostics.OverflowAction>, `retentionDays` wartość parametru jest ignorowana.</xref:System.Diagnostics.OverflowAction>       Ustaw `action` parametr <xref:System.Diagnostics.OverflowAction>Aby wskazać, że każdy nowy wpis zastępuje starsze wpisy podczas <xref:System.Diagnostics.EventLog>osiągnie maksymalny rozmiar.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.OverflowAction> Określ liczbę dni, które muszą zostać zachowane zdarzenia w dzienniku przy użyciu `retentionDays` parametru. Zapisywane zakresu przechowywania zdarzenia nie zostaną zastąpione przez nowe wpisy.       Ustaw `action` parametr <xref:System.Diagnostics.OverflowAction>odrzucić nowe zdarzenia po osiągnięciu maksymalnego rozmiaru dziennika.</xref:System.Diagnostics.OverflowAction> Jeśli `action` ustawiono parametr <xref:System.Diagnostics.OverflowAction>, `retentionDays` wartość parametru jest ignorowana.</xref:System.Diagnostics.OverflowAction>      > [!CAUTION] > Ustawienie zasad przepełnienie <xref:System.Diagnostics.OverflowAction>Określa, że nowe wpisy zostaną odrzucone po zapełnieniu dziennika zdarzeń.</xref:System.Diagnostics.OverflowAction> Jeśli używasz tego ustawienia upewnij się, regularnie zarchiwizowane i wyczyszczone, aby uniknąć osiągnięcia limit maksymalnego rozmiaru dziennika zdarzeń."
  example:
  - "The following example displays the configured overflow policy for a specified event log, and allows the user to select a new overflow policy setting for the event log.  \n  \n [!code-vb[EventLogProperties#3](~/add/codesnippet/visualbasic/0b0fc273-a638-4af9-ae99-_1.vb)]\n [!code-cpp[EventLogProperties#3](~/add/codesnippet/cpp/0b0fc273-a638-4af9-ae99-_1.cpp)]\n [!code-cs[EventLogProperties#3](~/add/codesnippet/csharp/0b0fc273-a638-4af9-ae99-_1.cs)]"
  syntax:
    content: public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);
    parameters:
    - id: action
      type: System.Diagnostics.OverflowAction
      description: "Zachowanie przepełnienia dla zapisywania nowych wpisów w dzienniku zdarzeń."
    - id: retentionDays
      type: System.Int32
      description: "Minimalna liczba dni, przez które każdy wpis dziennika zdarzeń jest przechowywane. Ten parametr jest używany tylko wtedy, gdy `action` ustawiono <xref href=&quot;System.Diagnostics.OverflowAction&quot;> </xref>."
  overload: System.Diagnostics.EventLog.ModifyOverflowPolicy*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>action</code>nie jest prawidłową <xref:System.Diagnostics.EventLog.OverflowAction*> wartość."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>retentionDays</code>nie może być większa niż jeden, większy niż 365."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <xref:System.Diagnostics.EventLog.Log*> value is not a valid log name.  \n  \n \\- or -  \n  \n The registry key for the event log could not be opened on the target computer."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.OverflowAction
  id: OverflowAction
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: OverflowAction
  nameWithType: EventLog.OverflowAction
  fullName: System.Diagnostics.EventLog.OverflowAction
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Pobiera zachowanie skonfigurowany do przechowywania nowych wpisów, gdy jego maksymalny rozmiar pliku dziennika osiągnie dziennika zdarzeń."
  remarks: "Dzienniki zdarzeń zwiększa się rozmiar jako nowe zdarzenia są zapisywane do nich. Każdy dziennik zdarzeń ma limit maksymalnego skonfigurowanego rozmiaru; <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>właściwość określa maksymalną liczbę kilobajtów dozwolony rozmiar pliku dziennika zdarzeń.</xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>       Użyj wartości właściwości OverflowAction do sprawdzenia zachowania skonfigurowanych przepełnienia dziennika zdarzeń na maksymalnego rozmiaru. Użyj <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>metody, aby zmienić zachowanie przepełnienia dziennika zdarzeń.</xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>      > [!NOTE] > Zachowanie przepełnienie obowiązuje tylko wtedy, gdy dziennik zdarzeń osiągnie maksymalny rozmiar. Zachowanie przepełnienie nie ma wpływu na zapisywanie nowego wpisu w dzienniku, która może obsłużyć wpisy w dzienniku zdarzeń dodatkowe."
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_28_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_28_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_28_1.cs)]"
  syntax:
    content: public System.Diagnostics.OverflowAction OverflowAction { get; }
    return:
      type: System.Diagnostics.OverflowAction
      description: "<xref href=&quot;System.Diagnostics.OverflowAction&quot;> </xref> Wartość, która określa zachowanie skonfigurowany do przechowywania nowych wpisów, gdy jego maksymalny rozmiar dziennika osiągnie dziennika zdarzeń. Wartość domyślna to <xref href=&quot;System.Diagnostics.OverflowAction&quot;> </xref>."
  overload: System.Diagnostics.EventLog.OverflowAction*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)
  id: RegisterDisplayName(System.String,System.Int64)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: RegisterDisplayName(String,Int64)
  nameWithType: EventLog.RegisterDisplayName(String,Int64)
  fullName: System.Diagnostics.EventLog.RegisterDisplayName(String,Int64)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Zlokalizowana nazwa dziennika zdarzeń, który jest wyświetlany w Podglądzie zdarzeń serwera."
  remarks: "Użyj RegisterDisplayName do rejestracji i do zlokalizowanej nazwy wyświetlanej w Podglądzie zdarzeń niestandardowych dzienników zdarzeń.       Identyfikator określony zasób musi odpowiadać zlokalizowane ciągi zdefiniowane w pliku zasobów. Podgląd zdarzeń wyświetla nazwę dziennika zdarzeń niestandardowych przy użyciu zlokalizowany ciąg i bieżące ustawienia kultury. Na przykład można zdefiniować wiele nazw dziennika zdarzeń zlokalizowane dla innych kultur w pliku zasobów. Podgląd zdarzeń wyświetla zlokalizowany ciąg odpowiadający ustawienia kultury bieżącego użytkownika.       Jeśli podglądu zdarzeń nie może załadować zlokalizowanego ciągu z pliku zasobów lub nazwę wyświetlaną, nie został zarejestrowany do dziennika zdarzeń, następnie Podgląd zdarzeń wyświetla nazwę dziennika zdarzeń zdefiniowanych w <xref:System.Diagnostics.EventLog.Log%2A>.</xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > Nie trzeba zarejestrować nazwę wyświetlaną dla wstępnie zdefiniowanego dzienników zdarzeń. System operacyjny rejestruje nazwy wyświetlane zlokalizowanych dzienniki zdarzeń aplikacji, System i zabezpieczenia."
  example:
  - "The following example determines whether the event source named `SampleApplicationSource` is registered on the local computer. If the event source does not exist, the example sets the message resource file for the source and creates the new event source. Finally, the example sets the localized display name for the event log, using the resource identifier value in `DisplayNameMsgId` and the resource file path in `messageFile`.  \n  \n [!code-cpp[EventLog_WriteEvent#6](~/add/codesnippet/cpp/m-system.diagnostics.eve_1_1.cpp)]\n [!code-vb[EventLog_WriteEvent#6](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_1_1.vb)]\n [!code-cs[EventLog_WriteEvent#6](~/add/codesnippet/csharp/m-system.diagnostics.eve_1_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings. Specifically, resource identifier 5001 is defined for the localized name of the event log.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public void RegisterDisplayName (string resourceFile, long resourceId);
    parameters:
    - id: resourceFile
      type: System.String
      description: "Pełna ścieżka do pliku zlokalizowanych zasobów."
    - id: resourceId
      type: System.Int64
      description: "Identyfikator zasobu indeksujący zlokalizowane ciągi w pliku zasobów."
  overload: System.Diagnostics.EventLog.RegisterDisplayName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <xref:System.Diagnostics.EventLog.Log*> value is not a valid log name.  \n  \n \\- or -  \n  \n The registry key for the event log could not be opened on the target computer."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceFile </code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Source
  id: Source
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Source
  nameWithType: EventLog.Source
  fullName: System.Diagnostics.EventLog.Source
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Pobiera lub ustawia nazwę źródła do rejestracji i używana podczas zapisywania w dzienniku zdarzeń."
  remarks: "Źródło zdarzenia wskazuje co rejestruje zdarzenie. Często jest nazwa aplikacji lub nazwy podskładnika aplikacji, jeśli aplikacja jest duży. Aplikacje i usługi, należy zapisać dziennik aplikacji lub dziennik niestandardowy. Sterowniki urządzeń, należy zapisać w dzienniku systemu.       Należy określić źródło zdarzenia będą zapisywane do dziennika zdarzeń. Przed zapisaniem wpis w dzienniku zdarzeń, należy zarejestrować źródło zdarzenia z dziennika zdarzeń jako prawidłowe źródło zdarzeń. Podczas zapisu dziennika system używa właściwości Source można znaleźć do odpowiedniego dziennika, w którym można umieścić wpis. Podczas czytania dziennika zdarzeń, można określić źródło lub <xref:System.Diagnostics.EventLog.Log%2A>i <xref:System.Diagnostics.EventLog.MachineName%2A>.</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > Nie są wymagane podanie <xref:System.Diagnostics.EventLog.MachineName%2A>Jeśli łączysz się z dziennikiem na komputerze lokalnym.</xref:System.Diagnostics.EventLog.MachineName%2A> Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>, komputer lokalny (&quot;.&quot;) zakłada, że.</xref:System.Diagnostics.EventLog.MachineName%2A>       Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A>i <xref:System.Diagnostics.EventLog.WriteEntry%2A>się zapisać zdarzeń do dziennika zdarzeń.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.WriteEvent%2A> Należy określić źródło zdarzenia się zapisać zdarzeń; należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem.       Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A>metody.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.       Można utworzyć źródła zdarzeń dla istniejącego dziennika zdarzeń lub utworzenie nowego dziennika zdarzeń. Podczas tworzenia nowego źródła dla nowego dziennika zdarzeń systemu rejestruje źródła dla tego dziennika, ale dziennik jest tworzone dopiero po pierwszej pozycji są zapisywane do niego.       Źródło musi być unikatowa na komputerze lokalnym; Nowa nazwa źródła nie może dopasować istniejącej nazwy źródła lub nazwa istniejącego dziennika zdarzeń. Każde źródło może zapisywać do dziennika zdarzeń tylko jeden jednocześnie. Jednak aplikacja może używać wielu źródeł do zapisu do wielu dzienników zdarzeń. Na przykład aplikacja może wymagać wielu źródeł skonfigurowane dla różnych dzienników zdarzeń lub innego zasobu plików.       W przypadku zmiany wartości źródłowej <xref:System.Diagnostics.EventLog>do której został on zarejestrowany zostanie zamknięte, a wszystkie uchwytów zdarzeń są wydawane.</xref:System.Diagnostics.EventLog>       Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład należy skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A>sposób zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A>metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.</xref:System.Diagnostics.EventLog.WriteEntry%2A>       Aby zmienić szczegóły konfiguracji istniejącego źródła, możesz usunąć źródło, a następnie utwórz ją przy użyciu nowej konfiguracji. Użycie innych aplikacji lub składników istniejącego źródła, Utwórz nowe źródło o zaktualizowanej konfiguracji od usunięcie istniejącego źródła.      > [!NOTE] > Źródła został już zmapowany do dziennika i ponownie zamapować go do nowego dziennika, należy ponownie uruchomić komputer, aby zmiany zaczęły obowiązywać."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.Source Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_18_1.cs)]\n [!code-vb[Classic EventLog.Source Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_18_1.vb)]\n [!code-cpp[Classic EventLog.Source Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_18_1.cpp)]"
  syntax:
    content: public string Source { get; set; }
    return:
      type: System.String
      description: "Nazwa zarejestrowany jako źródło wpisów dziennika zdarzeń. Wartość domyślna to ciąg pusty (&quot;&quot;)."
  overload: System.Diagnostics.EventLog.Source*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Nazwa źródła powoduje dłuższe niż 254 znaków ścieżki klucza rejestru."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.SourceExists(System.String)
  id: SourceExists(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: SourceExists(String)
  nameWithType: EventLog.SourceExists(String)
  fullName: System.Diagnostics.EventLog.SourceExists(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Określa, czy źródłem zdarzenia jest zarejestrowana na komputerze lokalnym."
  remarks: "Użyj tej metody, aby określić, czy źródło zdarzenia istnieje na komputerze lokalnym. Jeśli chcesz określić, czy dziennik istnieje na komputerze lokalnym, użyj <xref:System.Diagnostics.EventLog.Exists%2A>.</xref:System.Diagnostics.EventLog.Exists%2A>       Ponieważ ta metoda uzyskuje dostęp do rejestru, musi mieć odpowiednich uprawnień rejestru na komputerze lokalnym; w przeciwnym razie <xref:System.Security.SecurityException>będą zgłaszane.</xref:System.Security.SecurityException>      > [!NOTE] > Aby wyszukiwać źródła zdarzeń w systemie Windows Vista lub nowszym lub Windows Server 2003, musisz mieć uprawnienia administracyjne.   >> Przyczyna to wymaganie to, że wszystkie dzienniki zdarzeń, zabezpieczeń, w tym musi przeszukana w celu określenia, czy źródło zdarzenia jest unikatowa. Począwszy od systemu Windows Vista, użytkownicy nie mają uprawnień do dostępu do dziennika zabezpieczeń; w związku z tym <xref:System.Security.SecurityException>jest generowany.</xref:System.Security.SecurityException>   >> Począwszy od systemu Windows Vista kontroli konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem grupy Administratorzy wbudowanych, są przypisane dwa tokenów dostępu do środowiska wykonawczego: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie są w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musi najpierw podwyższenie Twoje uprawnienia od użytkownika standardowego do administratora. Można to zrobić, podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.      > [!NOTE] > Usługi, który jest wykonywany w obszarze <xref:System.ServiceProcess.ServiceAccount>konto nie ma uprawnienia wymagane do wykonania tej metody.</xref:System.ServiceProcess.ServiceAccount> Rozwiązanie to sprawdź, czy źródło zdarzenia znajduje się w <xref:System.ServiceProcess.ServiceInstaller>, a jeśli on nie istnieje, można utworzyć źródła w Instalatorze.</xref:System.ServiceProcess.ServiceInstaller>       Ponieważ nowe źródło nie może zawierać nazwę istniejącego źródła na tym samym komputerze, ta metoda umożliwia przed podjęciem próby wykonania wywołania <xref:System.Diagnostics.EventLog.CreateEventSource%2A>do zapewnienia, że źródło z nazwą określoną przez `source` jeszcze nie istnieje na komputerze lokalnym.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> `source` Parametr nie jest rozróżniana wielkość liter."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.Source Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_14_1.cs)]\n [!code-vb[Classic EventLog.Source Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_14_1.vb)]\n [!code-cpp[Classic EventLog.Source Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_14_1.cpp)]"
  syntax:
    content: public static bool SourceExists (string source);
    parameters:
    - id: source
      type: System.String
      description: "Nazwa źródła zdarzenia."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli źródło zdarzenia jest zarejestrowana na komputerze lokalnym; w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.EventLog.SourceExists*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<code>source</code>Nie można odnaleźć, ale nie można przeszukać niektórych lub wszystkich dzienników zdarzeń."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.SourceExists(System.String,System.String)
  id: SourceExists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: SourceExists(String,String)
  nameWithType: EventLog.SourceExists(String,String)
  fullName: System.Diagnostics.EventLog.SourceExists(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Określa, czy źródłem zdarzenia jest zarejestrowany na określonym komputerze."
  remarks: "Ta metoda służy do określenia, czy źródło zdarzenia istnieje na komputerze określonym przez `machineName` parametru. Jeśli chcesz określić, czy dziennik istnieje na określonym komputerze, użyj <xref:System.Diagnostics.EventLog.Exists%2A>.</xref:System.Diagnostics.EventLog.Exists%2A>       Ponieważ ta metoda uzyskuje dostęp do rejestru, musi mieć odpowiednich uprawnień rejestru na danym serwerze; w przeciwnym razie <xref:System.Security.SecurityException>będą zgłaszane.</xref:System.Security.SecurityException>      > [!NOTE] > Aby wyszukiwać źródła zdarzeń w systemie Windows Vista lub nowszym lub Windows Server 2003, musisz mieć uprawnienia administracyjne.   >> Przyczyna to wymaganie to, że wszystkie dzienniki zdarzeń, zabezpieczeń, w tym musi przeszukana w celu określenia, czy źródło zdarzenia jest unikatowa. Począwszy od systemu Windows Vista, użytkownicy nie mają uprawnień do dostępu do dziennika zabezpieczeń; w związku z tym <xref:System.Security.SecurityException>jest generowany.</xref:System.Security.SecurityException>   >> Począwszy od systemu Windows Vista kontroli konta użytkownika (UAC) określa uprawnienia użytkownika. Jeśli jesteś członkiem grupy Administratorzy wbudowanych, są przypisane dwa tokenów dostępu do środowiska wykonawczego: token dostępu użytkownika standardowego i token dostępu administratora. Domyślnie są w roli użytkownika standardowego. Do wykonania kodu, który uzyskuje dostęp do liczników wydajności, musi najpierw podwyższenie Twoje uprawnienia od użytkownika standardowego do administratora. Można to zrobić, podczas uruchamiania aplikacji przez kliknięcie prawym przyciskiem myszy ikonę aplikacji i wskazujący, że chcesz uruchomić jako administrator.      > [!NOTE] > Usługi, który jest wykonywany w obszarze <xref:System.ServiceProcess.ServiceAccount>konto nie ma uprawnienia wymagane do wykonania tej metody.</xref:System.ServiceProcess.ServiceAccount> Rozwiązanie to sprawdź, czy źródło zdarzenia znajduje się w <xref:System.ServiceProcess.ServiceInstaller>, a jeśli on nie istnieje, można utworzyć źródła w Instalatorze.</xref:System.ServiceProcess.ServiceInstaller>       Ponieważ nowe źródło nie może zawierać nazwę istniejącego źródła na tym samym komputerze, ta metoda umożliwia przed podjęciem próby wykonania wywołania <xref:System.Diagnostics.EventLog.CreateEventSource%2A>do zapewnienia, że źródło z nazwą określoną przez `source` jeszcze nie istnieje na komputerze.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> `source` i `machineName` parametrów nie jest uwzględniana.       <xref:System.Diagnostics.EventLog.SourceExists%2A>jest `static` metody, więc może ona zostać wywołana w samej klasy.</xref:System.Diagnostics.EventLog.SourceExists%2A> Nie jest konieczne do utworzenia wystąpienia <xref:System.Diagnostics.EventLog>wywołać <xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A> </xref:System.Diagnostics.EventLog>"
  example:
  - "The following example creates the source `MySource` on the computer `MyServer`, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_16_1.cpp)]\n [!code-cs[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_16_1.cs)]\n [!code-vb[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_16_1.vb)]"
  syntax:
    content: public static bool SourceExists (string source, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "Nazwa źródła zdarzenia."
    - id: machineName
      type: System.String
      description: "Nazwa komputera, na którym do przeszukania, lub &quot;.&quot; na komputerze lokalnym."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli źródło zdarzenia jest zarejestrowany na danym komputerze. w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.EventLog.SourceExists*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>machineName</code>jest prawidłową nazwą komputera."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<code>source</code>Nie można odnaleźć, ale nie można przeszukać niektórych lub wszystkich dzienników zdarzeń."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.SynchronizingObject
  id: SynchronizingObject
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: SynchronizingObject
  nameWithType: EventLog.SynchronizingObject
  fullName: System.Diagnostics.EventLog.SynchronizingObject
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Pobiera lub ustawia obiekt używany do organizowania wywołań obsługi zdarzeń, które są wydawane w <xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> wpis zapisywane zdarzenia."
  remarks: "Gdy jest SynchronizingObject `null`, metod obsługi <xref:System.Diagnostics.EventLog.EntryWritten>zdarzenia są wywołany w wątku z puli wątków systemu.</xref:System.Diagnostics.EventLog.EntryWritten> Aby uzyskać więcej informacji na pule wątków systemu zobacz <xref:System.Threading.ThreadPool>.</xref:System.Threading.ThreadPool>       Gdy <xref:System.Diagnostics.EventLog.EntryWritten>zdarzenie jest obsługiwane przez visual formularzy systemu Windows składnika, takiego jak przycisk, dostęp do składnika za pośrednictwem puli wątków systemu mogą nie działać lub może spowodować wyjątek.</xref:System.Diagnostics.EventLog.EntryWritten> Tego uniknąć, ustawiając SynchronizingObject składnika formularzy systemu Windows, co powoduje, że metody obsługi <xref:System.Diagnostics.EventLog.EntryWritten>zdarzeń ma być wywołane na tym samym wątku, w której utworzono składnika.</xref:System.Diagnostics.EventLog.EntryWritten>       Jeśli <xref:System.Diagnostics.EventLog>jest używany wewnątrz [!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] za pomocą projektanta formularzy systemu Windows SynchronizingObject jest automatycznie ustawiana formantu zawierającego <xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog> Na przykład, jeśli zostanie <xref:System.Diagnostics.EventLog>na Projektant Form1 (który dziedziczy z <xref:System.Windows.Forms.Form>) z właściwością SynchronizingObject <xref:System.Diagnostics.EventLog>ustawiono wystąpienie Form1.</xref:System.Diagnostics.EventLog> </xref:System.Windows.Forms.Form> </xref:System.Diagnostics.EventLog>"
  syntax:
    content: public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }
    return:
      type: System.ComponentModel.ISynchronizeInvoke
      description: "<xref href=&quot;System.ComponentModel.ISynchronizeInvoke&quot;> </xref> Używany do organizowania wywołań obsługi zdarzeń utworzony w <xref href=&quot;System.Diagnostics.EventLog.EntryWritten&quot;> </xref> zdarzenia w dzienniku zdarzeń."
  overload: System.Diagnostics.EventLog.SynchronizingObject*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String)
  id: WriteEntry(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String)
  nameWithType: EventLog.WriteEntry(String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Zapisuje wpisu typu informacji z tekstem danej wiadomości w dzienniku zdarzeń."
  remarks: "Ta metoda służy do zapisu w dzienniku zdarzeń skojarzonych z tym informacji <xref:System.Diagnostics.EventLog>wystąpienia.</xref:System.Diagnostics.EventLog> Jeśli chcesz określić wszelkie inne <xref:System.Diagnostics.EventLogEntryType>Użyj innego przeciążenia <xref:System.Diagnostics.EventLog.WriteEntry%2A>.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLogEntryType>      > [!NOTE] > `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartością całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciągu wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to sekwencja znaków, nie możesz zalogować się komunikat zawierający adres IPv6.       Należy ustawić <xref:System.Diagnostics.EventLog.Source%2A>Właściwość <xref:System.Diagnostics.EventLog>składników przed przystąpieniem do napisania wpisy w dzienniku.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem.       Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A>metody.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.       Jeśli źródło jest określone w <xref:System.Diagnostics.EventLog.Source%2A>właściwości tego <xref:System.Diagnostics.EventLog>wystąpienie nie jest zarejestrowane na komputerze, który zapisuje składnika, <xref:System.Diagnostics.EventLog.WriteEntry%2A>wywołania <xref:System.Diagnostics.EventLog.CreateEventSource%2A>i rejestruje źródła.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>dla Twojego <xref:System.Diagnostics.EventLog>wystąpienia przed wywołaniem <xref:System.Diagnostics.EventLog.CreateEventSource%2A>lub <xref:System.Diagnostics.EventLog.WriteEntry%2A>, komputer lokalny (&quot;.&quot;) zakłada, że.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       Jeśli system musi zarejestrować <xref:System.Diagnostics.EventLog.Source%2A>za pomocą wywołania i <xref:System.Diagnostics.EventLog.WriteEntry%2A> <xref:System.Diagnostics.EventLog.Log%2A>właściwość nie została ustawiona na Twoje <xref:System.Diagnostics.EventLog>wystąpienie, domyślnie dziennika w dzienniku aplikacji.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Wiele wyjątków wymienionych powyżej są generowane z powodu błędów wywoływane podczas procesu rejestrowania <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>       Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. <xref:System.Diagnostics.EventLog.WriteEntry%2A>Metoda zapisuje dany ciąg znaków bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów komunikatów lokalizowalny.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A>metodę, aby zapisać zdarzeń przy użyciu pliku zasobów komunikatów zlokalizowanych.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład należy skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A>sposób zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A>metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Jeśli zapisu z komputerem zdalnym, wartość komunikatu (tekst) nie może być oczekiwać Jeśli komputer zdalny nie jest uruchomiony system .NET Framework.      > [!NOTE] > Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_7_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_7_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_7_1.vb)]"
  syntax:
    content: public void WriteEntry (string message);
    parameters:
    - id: message
      type: System.String
      description: "Ciąg do zapisu w dzienniku zdarzeń."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nie można otworzyć klucza rejestru dla dziennika zdarzeń."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Zapisuje błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub wpis inspekcji awarii tekstem danej wiadomości w dzienniku zdarzeń."
  remarks: "Ta metoda służy do zapisu w określonym <xref:System.Diagnostics.EventLogEntryType>dzienniku zdarzeń.</xref:System.Diagnostics.EventLogEntryType> `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podglądzie zdarzeń dziennika.      > [!NOTE] > `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartością całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciągu wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to sekwencja znaków, nie możesz zalogować się komunikat zawierający adres IPv6.       Należy ustawić <xref:System.Diagnostics.EventLog.Source%2A>Właściwość <xref:System.Diagnostics.EventLog>składników przed przystąpieniem do napisania wpisy w dzienniku.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem.       Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A>metody.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.       Jeśli źródło jest określone w <xref:System.Diagnostics.EventLog.Source%2A>właściwości tego <xref:System.Diagnostics.EventLog>wystąpienie nie jest zarejestrowane na komputerze, który zapisuje składnika, <xref:System.Diagnostics.EventLog.WriteEntry%2A>wywołania <xref:System.Diagnostics.EventLog.CreateEventSource%2A>i rejestruje źródła.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>dla Twojego <xref:System.Diagnostics.EventLog>wystąpienia przed wywołaniem <xref:System.Diagnostics.EventLog.CreateEventSource%2A>lub <xref:System.Diagnostics.EventLog.WriteEntry%2A>, komputer lokalny (&quot;.&quot;) zakłada, że.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       Jeśli system musi zarejestrować <xref:System.Diagnostics.EventLog.Source%2A>za pomocą wywołania i <xref:System.Diagnostics.EventLog.WriteEntry%2A> <xref:System.Diagnostics.EventLog.Log%2A>właściwość nie została ustawiona na Twoje <xref:System.Diagnostics.EventLog>wystąpienie, domyślnie dziennika w dzienniku aplikacji.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Wiele wyjątków wymienionych powyżej są generowane z powodu błędów wywoływane podczas procesu rejestrowania <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>       Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. <xref:System.Diagnostics.EventLog.WriteEntry%2A>Metoda zapisuje dany ciąg znaków bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów komunikatów lokalizowalny.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A>metodę, aby zapisać zdarzeń przy użyciu pliku zasobów komunikatów zlokalizowanych.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład należy skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A>sposób zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A>metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Jeśli zapisu z komputerem zdalnym, wartość komunikatu (tekst) nie może być oczekiwać Jeśli komputer zdalny nie jest uruchomiony system .NET Framework.      > [!NOTE] > Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL."
  example:
  - "The following example writes a warning entry to an event log, \"MyNewLog\", on the local computer.  \n  \n [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/add/codesnippet/cpp/19aeba79-224e-4604-90d9-_1.cpp)]\n [!code-cs[Classic EventLog.WriteEntry2 Example#1](~/add/codesnippet/csharp/19aeba79-224e-4604-90d9-_1.cs)]\n [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/add/codesnippet/visualbasic/19aeba79-224e-4604-90d9-_1.vb)]"
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);
    parameters:
    - id: message
      type: System.String
      description: "Ciąg do zapisu w dzienniku zdarzeń."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Jeden z <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> wartości."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>nie jest prawidłową <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nie można otworzyć klucza rejestru dla dziennika zdarzeń."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String)
  id: WriteEntry(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String)
  nameWithType: EventLog.WriteEntry(String,String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Zapisuje wpisu typu informacji o tekst danego komunikatu w dzienniku zdarzeń przy użyciu określonego zdarzenia zarejestrowanego źródła."
  remarks: "Użyj tej metody do zapisu w dzienniku zdarzeń przy użyciu źródła, która jest już zarejestrowany jako źródło zdarzenia w dzienniku odpowiednie informacje. Jeśli chcesz określić wszelkie inne <xref:System.Diagnostics.EventLogEntryType>Użyj innego przeciążenia <xref:System.Diagnostics.EventLog.WriteEntry%2A>.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLogEntryType>       Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem. Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A>metody.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.       Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. <xref:System.Diagnostics.EventLog.WriteEntry%2A>Metoda zapisuje dany ciąg znaków bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów komunikatów lokalizowalny.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A>metodę, aby zapisać zdarzeń przy użyciu pliku zasobów komunikatów zlokalizowanych.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład należy skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A>sposób zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A>metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL.   >> `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartością całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciągu wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to sekwencja znaków, nie możesz zalogować się komunikat zawierający adres IPv6."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_3_1.cpp)]\n [!code-cs[Classic EventLog.WriteEntry1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_3_1.cs)]\n [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_3_1.vb)]"
  syntax:
    content: public static void WriteEntry (string source, string message);
    parameters:
    - id: source
      type: System.String
      description: "Źródło, za pomocą której aplikacja jest zarejestrowana na określonym komputerze."
    - id: message
      type: System.String
      description: "Ciąg do zapisu w dzienniku zdarzeń."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nie można otworzyć klucza rejestru dla dziennika zdarzeń."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Zapisuje wpis z tekstu podanym komunikatem i identyfikator zdefiniowanym przez aplikację zdarzeń w dzienniku zdarzeń."
  remarks: "Ta metoda służy do zapisu z określonym przez aplikację `eventID` w dzienniku zdarzeń. `eventID` Wraz z źródło identyfikują zdarzenia. Każda aplikacja może zdefiniować własne numerem zdarzenia i ciągi opisów, które mapują. Podglądy zdarzeń wyświetlać te wartości ciągu pomóc użytkownikowi zrozumieć, co poszło źle i zaproponuje jakie działania należy podjąć.      > [!NOTE] > `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartością całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciągu wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to sekwencja znaków, nie możesz zalogować się komunikat zawierający adres IPv6.       Oprócz identyfikator zdarzenia można określić <xref:System.Diagnostics.EventLogEntryType>dla zdarzenia zapisywane w dzienniku zdarzeń.</xref:System.Diagnostics.EventLogEntryType> `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podglądzie zdarzeń dziennika. Ten parametr wskazuje, czy typ zdarzenia jest błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub Inspekcja niepowodzeń.       Należy ustawić <xref:System.Diagnostics.EventLog.Source%2A>Właściwość <xref:System.Diagnostics.EventLog>składników przed przystąpieniem do napisania wpisy w dzienniku.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem.       Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A>metody.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.       Jeśli źródło jest określone w <xref:System.Diagnostics.EventLog.Source%2A>właściwości tego <xref:System.Diagnostics.EventLog>wystąpienie nie jest zarejestrowane na komputerze, który zapisuje składnika, <xref:System.Diagnostics.EventLog.WriteEntry%2A>wywołania <xref:System.Diagnostics.EventLog.CreateEventSource%2A>i rejestruje źródła.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>dla Twojego <xref:System.Diagnostics.EventLog>wystąpienia przed wywołaniem <xref:System.Diagnostics.EventLog.CreateEventSource%2A>lub <xref:System.Diagnostics.EventLog.WriteEntry%2A>, komputer lokalny (&quot;.&quot;) zakłada, że.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       Jeśli system musi zarejestrować <xref:System.Diagnostics.EventLog.Source%2A>za pomocą wywołania i <xref:System.Diagnostics.EventLog.WriteEntry%2A> <xref:System.Diagnostics.EventLog.Log%2A>właściwość nie została ustawiona na Twoje <xref:System.Diagnostics.EventLog>wystąpienie, domyślnie dziennika w dzienniku aplikacji.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Wiele wyjątków wymienionych powyżej są generowane z powodu błędów wywoływane podczas procesu rejestrowania <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>       Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. <xref:System.Diagnostics.EventLog.WriteEntry%2A>Metoda zapisuje dany ciąg znaków bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów komunikatów lokalizowalny.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A>metodę, aby zapisać zdarzeń przy użyciu pliku zasobów komunikatów zlokalizowanych.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład należy skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A>sposób zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A>metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Jeśli zapisu z komputerem zdalnym, wartość komunikatu (tekst) nie może być oczekiwać Jeśli komputer zdalny nie jest uruchomiony system .NET Framework.      > [!NOTE] > Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL."
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#3](~/add/codesnippet/cpp/597042ed-6d84-4ccf-a867-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#3](~/add/codesnippet/csharp/597042ed-6d84-4ccf-a867-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#3](~/add/codesnippet/visualbasic/597042ed-6d84-4ccf-a867-_1.vb)]
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);
    parameters:
    - id: message
      type: System.String
      description: "Ciąg do zapisu w dzienniku zdarzeń."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Jeden z <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> wartości."
    - id: eventID
      type: System.Int32
      description: "Identyfikator zdarzenia specyficzne dla aplikacji."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nie można otworzyć klucza rejestru dla dziennika zdarzeń."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>nie jest prawidłową <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Zapisuje błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub wpis inspekcji awarii tekstem danej wiadomości w dzienniku zdarzeń przy użyciu określonego zdarzenia zarejestrowanego źródła."
  remarks: "Ta metoda służy do zapisu w określonym <xref:System.Diagnostics.EventLogEntryType>dzienniku zdarzeń przy użyciu źródła już zarejestrowany jako źródło zdarzeń dla odpowiedniego dziennika.</xref:System.Diagnostics.EventLogEntryType> `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podglądzie zdarzeń dziennika.      > [!NOTE] > `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartością całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciągu wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to sekwencja znaków, nie możesz zalogować się komunikat zawierający adres IPv6.       Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem. Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A>metody.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.       Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. <xref:System.Diagnostics.EventLog.WriteEntry%2A>Metoda zapisuje dany ciąg znaków bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów komunikatów lokalizowalny.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A>metodę, aby zapisać zdarzeń przy użyciu pliku zasobów komunikatów zlokalizowanych.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład należy skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A>sposób zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A>metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL."
  example:
  - "The following example writes a warning entry to an event log, \"MyNewLog\", on the local computer.  \n  \n [!code-cs[Classic EventLog.WriteEntry3 Example#1](~/add/codesnippet/csharp/c03f903c-8fbd-441f-afe0-_1.cs)]\n [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/add/codesnippet/visualbasic/c03f903c-8fbd-441f-afe0-_1.vb)]\n [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/add/codesnippet/cpp/c03f903c-8fbd-441f-afe0-_1.cpp)]"
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);
    parameters:
    - id: source
      type: System.String
      description: "Źródło, za pomocą której aplikacja jest zarejestrowana na określonym komputerze."
    - id: message
      type: System.String
      description: "Ciąg do zapisu w dzienniku zdarzeń."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Jeden z <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> wartości."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nie można otworzyć klucza rejestru dla dziennika zdarzeń."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>nie jest prawidłową <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Zapisuje wpis z danej wiadomości tekstowych, identyfikator zdarzenia zdefiniowane przez aplikację i kategorii zdefiniowane aplikacji w dzienniku zdarzeń."
  remarks: "Ta metoda służy do zapisu z określonym przez aplikację `category` w dzienniku zdarzeń. Podgląd zdarzeń używa kategorię, aby filtrować zdarzenia zapisane przez źródło zdarzenia. Podgląd zdarzeń można wyświetlić kategorii jako wartość liczbowa lub można użyć kategorii jako identyfikator zasobu do wyświetlenia ciąg zlokalizowanej kategorii.      > [!NOTE] > `category` Parametr powinien być wartością dodatnią. Wartości ujemne kategorii są wyświetlane jako uzupełniające dodatnia podglądu zdarzeń. Na przykład –10 jest wyświetlany jako 65,526, -1 jako 65 535.      > [!NOTE] > `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartością całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciągu wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to sekwencja znaków, nie możesz zalogować się komunikat zawierający adres IPv6.       Aby wyświetlić kategorii zlokalizowanych ciągów w Podglądzie zdarzeń, należy użyć źródła zdarzenia konfigurowane przy użyciu pliku zasobu kategorii i ustaw `category` do identyfikatora zasobu w pliku zasobów kategorii. Jeśli źródło zdarzeń nie ma pliku zasobu kategorii skonfigurowany lub określony `category` nie indeksu ciągu w pliku zasobów kategorii, a następnie podglądu zdarzeń wyświetlane wartości liczbowe kategorię dla tego wpisu. Konfigurowanie pliku zasobu kategorii, wraz z liczbą ciągów kategorii w pliku zasobów za pomocą <xref:System.Diagnostics.EventLogInstaller>lub <xref:System.Diagnostics.EventSourceCreationData>klasy.</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller>       Oprócz kategorii można określić identyfikatora zdarzenia dla zdarzenia są zapisywane w dzienniku zdarzeń. Identyfikatory zdarzeń, wraz z źródło zdarzenia jednoznacznie zidentyfikować zdarzenia. Każda aplikacja może zdefiniować własne numerem zdarzenia i ciągi opisów, które mapują. Podglądy zdarzeń wyświetlać te wartości ciągu pomóc użytkownikowi zrozumieć, co poszło źle i zaproponuje jakie działania należy podjąć.       Ponadto można określić <xref:System.Diagnostics.EventLogEntryType>dla zdarzenia zapisywane w dzienniku zdarzeń.</xref:System.Diagnostics.EventLogEntryType> `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podglądzie zdarzeń dziennika. Ten parametr wskazuje, czy typ zdarzenia jest błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub Inspekcja niepowodzeń.       Należy ustawić <xref:System.Diagnostics.EventLog.Source%2A>Właściwość <xref:System.Diagnostics.EventLog>składników przed przystąpieniem do napisania wpisy w dzienniku.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem.       Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A>metody.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.       Jeśli źródło jest określone w <xref:System.Diagnostics.EventLog.Source%2A>właściwości tego <xref:System.Diagnostics.EventLog>wystąpienie nie jest zarejestrowane na komputerze, który zapisuje składnika, <xref:System.Diagnostics.EventLog.WriteEntry%2A>wywołania <xref:System.Diagnostics.EventLog.CreateEventSource%2A>i rejestruje źródła.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>dla Twojego <xref:System.Diagnostics.EventLog>wystąpienia przed wywołaniem <xref:System.Diagnostics.EventLog.CreateEventSource%2A>lub <xref:System.Diagnostics.EventLog.WriteEntry%2A>, komputer lokalny (&quot;.&quot;) zakłada, że.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       Jeśli system musi zarejestrować <xref:System.Diagnostics.EventLog.Source%2A>za pomocą wywołania i <xref:System.Diagnostics.EventLog.WriteEntry%2A> <xref:System.Diagnostics.EventLog.Log%2A>właściwość nie została ustawiona na Twoje <xref:System.Diagnostics.EventLog>wystąpienie, domyślnie dziennika w dzienniku aplikacji.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Wiele wyjątków wymienionych powyżej są generowane z powodu błędów wywoływane podczas procesu rejestrowania <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>       Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. <xref:System.Diagnostics.EventLog.WriteEntry%2A>Metoda zapisuje dany ciąg znaków bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów komunikatów lokalizowalny.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A>metodę, aby zapisać zdarzeń przy użyciu pliku zasobów komunikatów zlokalizowanych.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład należy skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A>sposób zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A>metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Jeśli zapisu z komputerem zdalnym, wartość komunikatu (tekst) nie może być oczekiwać Jeśli komputer zdalny nie jest uruchomiony system .NET Framework.      > [!NOTE] > Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL."
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#3](~/add/codesnippet/cpp/b3db94bc-a96c-4168-a8f0-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#3](~/add/codesnippet/csharp/b3db94bc-a96c-4168-a8f0-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#3](~/add/codesnippet/visualbasic/b3db94bc-a96c-4168-a8f0-_1.vb)]
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);
    parameters:
    - id: message
      type: System.String
      description: "Ciąg do zapisu w dzienniku zdarzeń."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Jeden z <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> wartości."
    - id: eventID
      type: System.Int32
      description: "Identyfikator zdarzenia specyficzne dla aplikacji."
    - id: category
      type: System.Int16
      description: "Podkategoria specyficzne dla aplikacji skojarzonych z wiadomością."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nie można otworzyć klucza rejestru dla dziennika zdarzeń."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>nie jest prawidłową <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Zapisuje wpis z tekstu podanym komunikatem i identyfikator zdefiniowanym przez aplikację zdarzeń w dzienniku zdarzeń przy użyciu określonego zdarzenia zarejestrowanego źródła."
  remarks: "Ta metoda służy do zapisu z określonym przez aplikację `eventID` w dzienniku zdarzeń przy użyciu źródła już zarejestrowany jako źródło zdarzenia w dzienniku odpowiednie. `eventID`, Wraz ze źródła, jednoznacznie zidentyfikować zdarzenia. Każda aplikacja może zdefiniować własne numerem zdarzenia i ciągi opisów, które mapują. Podglądy zdarzenia są wyświetlane te ciągi użytkownika pomóc użytkownikowi zrozumieć, co poszło źle i zaproponuje jakie działania należy podjąć.      > [!NOTE] > `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartością całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciągu wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to sekwencja znaków, nie możesz zalogować się komunikat zawierający adres IPv6.       Oprócz identyfikator zdarzenia to przeciążenie <xref:System.Diagnostics.EventLog.WriteEntry%2A>Umożliwia określenie <xref:System.Diagnostics.EventLogEntryType>dla zdarzenia zapisywane w dzienniku zdarzeń.</xref:System.Diagnostics.EventLogEntryType> </xref:System.Diagnostics.EventLog.WriteEntry%2A> `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podglądzie zdarzeń dziennika. Ten parametr wskazuje, czy typ zdarzenia jest błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub Inspekcja niepowodzeń.       Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem. Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A>metody.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.       Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. <xref:System.Diagnostics.EventLog.WriteEntry%2A>Metoda zapisuje dany ciąg znaków bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów komunikatów lokalizowalny.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A>metodę, aby zapisać zdarzeń przy użyciu pliku zasobów komunikatów zlokalizowanych.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład należy skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A>sposób zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A>metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL."
  example:
  - >-
    [!code-cs[EventLog_WriteEntry_4#1](~/add/codesnippet/csharp/2d8498b8-a54d-48c9-9ee7-_1.cs)]
     [!code-cpp[EventLog_WriteEntry_4#1](~/add/codesnippet/cpp/2d8498b8-a54d-48c9-9ee7-_1.cpp)]
     [!code-vb[EventLog_WriteEntry_4#1](~/add/codesnippet/visualbasic/2d8498b8-a54d-48c9-9ee7-_1.vb)]
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);
    parameters:
    - id: source
      type: System.String
      description: "Źródło, za pomocą której aplikacja jest zarejestrowana na określonym komputerze."
    - id: message
      type: System.String
      description: "Ciąg do zapisu w dzienniku zdarzeń."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Jeden z <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> wartości."
    - id: eventID
      type: System.Int32
      description: "Identyfikator zdarzenia specyficzne dla aplikacji."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nie można otworzyć klucza rejestru dla dziennika zdarzeń."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>nie jest prawidłową <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Zapisuje wpis z danej wiadomości tekstowych, identyfikator zdarzenia zdefiniowane przez aplikację i kategorii zdefiniowanym przez aplikację do dziennika zdarzeń i dołącza dane binarne do wiadomości."
  remarks: "To przeciążenie umożliwia zapis zdefiniowanym przez aplikację dane specyficzne dla zdarzenia w dzienniku zdarzeń. Podgląd zdarzeń nie ma możliwości interpretowania tych danych; nieprzetworzone dane są wyświetlane tylko w formacie łączna liczba szesnastkowa i tekst. Użyj dane specyficzne dla zdarzenia oszczędnie, włączając go tylko wtedy, gdy upewnij się, że mogą być przydatne dla kogoś debugowanie problemu. Umożliwia także dane specyficzne dla zdarzenia do przechowywania informacji, których aplikacja może przetwarzać niezależnie od podglądu zdarzeń. Można na przykład zapisać przeglądarka specjalnie dla zdarzeń, lub napisz program, który skanowania pliku dziennika i tworzy raporty zawierające informacje z dane specyficzne dla zdarzenia.       Oprócz danych binarnych można określić kategorię zdefiniowanym przez aplikację i identyfikator zdarzenia zdefiniowane przez aplikację. Podgląd zdarzeń używa kategorię, aby filtrować zdarzenia zapisane przez źródło zdarzenia. Podgląd zdarzeń można wyświetlić kategorii jako wartość liczbowa lub można użyć kategorii jako identyfikator zasobu do wyświetlenia ciąg zlokalizowanej kategorii.      > [!NOTE] > `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartością całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciągu wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to sekwencja znaków, nie możesz zalogować się komunikat zawierający adres IPv6.      > [!NOTE] > `category` Parametr powinien być wartością dodatnią. Wartości ujemne kategorii są wyświetlane jako uzupełniające dodatnia podglądu zdarzeń. Na przykład –10 jest wyświetlany jako 65,526, -1 jako 65 535.       Aby wyświetlić kategorii zlokalizowanych ciągów w Podglądzie zdarzeń, należy użyć źródła zdarzenia konfigurowane przy użyciu pliku zasobu kategorii i ustaw `category` do identyfikatora zasobu w pliku zasobów kategorii. Jeśli źródło zdarzeń nie ma pliku zasobu kategorii skonfigurowany lub określony `category` nie indeksu ciągu w pliku zasobów kategorii, a następnie podglądu zdarzeń wyświetlane wartości liczbowe kategorię dla tego wpisu. Konfigurowanie pliku zasobu kategorii, wraz z liczbą ciągów kategorii w pliku zasobów za pomocą <xref:System.Diagnostics.EventLogInstaller>lub <xref:System.Diagnostics.EventSourceCreationData>klasy.</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller>       Identyfikatory zdarzeń, wraz z źródło zdarzenia jednoznacznie zidentyfikować zdarzenia. Każda aplikacja może zdefiniować własne numerem zdarzenia i ciągi opisów, które mapują. Podglądy zdarzeń wyświetlać te wartości ciągu pomóc użytkownikowi zrozumieć, co poszło źle i zaproponuje jakie działania należy podjąć.       Ponadto można określić <xref:System.Diagnostics.EventLogEntryType>dla zdarzenia zapisywane w dzienniku zdarzeń.</xref:System.Diagnostics.EventLogEntryType> `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podglądzie zdarzeń dziennika. Ten parametr wskazuje, czy typ zdarzenia jest błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub Inspekcja niepowodzeń.       Należy ustawić <xref:System.Diagnostics.EventLog.Source%2A>Właściwość <xref:System.Diagnostics.EventLog>składników przed przystąpieniem do napisania wpisy w dzienniku.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem.       Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A>metody.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.       Jeśli źródło jest określone w <xref:System.Diagnostics.EventLog.Source%2A>właściwości tego <xref:System.Diagnostics.EventLog>wystąpienie nie jest zarejestrowane na komputerze, który zapisuje składnika, <xref:System.Diagnostics.EventLog.WriteEntry%2A>wywołania <xref:System.Diagnostics.EventLog.CreateEventSource%2A>i rejestruje źródła.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>dla Twojego <xref:System.Diagnostics.EventLog>wystąpienia przed wywołaniem <xref:System.Diagnostics.EventLog.CreateEventSource%2A>lub <xref:System.Diagnostics.EventLog.WriteEntry%2A>, komputer lokalny (&quot;.&quot;) zakłada, że.</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       Jeśli system musi zarejestrować <xref:System.Diagnostics.EventLog.Source%2A>za pomocą wywołania i <xref:System.Diagnostics.EventLog.WriteEntry%2A> <xref:System.Diagnostics.EventLog.Log%2A>właściwość nie została ustawiona na Twoje <xref:System.Diagnostics.EventLog>wystąpienie, domyślnie dziennika w dzienniku aplikacji.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > Wiele wyjątków wymienionych powyżej są generowane z powodu błędów wywoływane podczas procesu rejestrowania <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>       Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. <xref:System.Diagnostics.EventLog.WriteEntry%2A>Metoda zapisuje dany ciąg znaków bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów komunikatów lokalizowalny.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A>metodę, aby zapisać zdarzeń przy użyciu pliku zasobów komunikatów zlokalizowanych.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład należy skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A>sposób zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A>metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Jeśli zapisu z komputerem zdalnym, wartość komunikatu (tekst) nie może być oczekiwać Jeśli komputer zdalny nie jest uruchomiony system .NET Framework.      > [!NOTE] > Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL."
  example:
  - >-
    [!code-cs[EventLog_WriteEntry_5#1](~/add/codesnippet/csharp/1c6518b6-dc55-4c74-9028-_1.cs)]
     [!code-vb[EventLog_WriteEntry_5#1](~/add/codesnippet/visualbasic/1c6518b6-dc55-4c74-9028-_1.vb)]
     [!code-cpp[EventLog_WriteEntry_5#1](~/add/codesnippet/cpp/1c6518b6-dc55-4c74-9028-_1.cpp)]
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);
    parameters:
    - id: message
      type: System.String
      description: "Ciąg do zapisu w dzienniku zdarzeń."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Jeden z <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> wartości."
    - id: eventID
      type: System.Int32
      description: "Identyfikator zdarzenia specyficzne dla aplikacji."
    - id: category
      type: System.Int16
      description: "Podkategoria specyficzne dla aplikacji skojarzonych z wiadomością."
    - id: rawData
      type: System.Byte[]
      description: "Tablica bajtów przechowujący dane binarne skojarzone z danym wpisem."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nie można otworzyć klucza rejestru dla dziennika zdarzeń."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>nie jest prawidłową <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Zapisuje wpis z danej wiadomości tekstowych, identyfikator zdarzenia zdefiniowane przez aplikację i kategorii zdefiniowane aplikacji w dzienniku zdarzeń przy użyciu określonego zdarzenia zarejestrowanego źródła. <code> category </code> Mogą być używane przez Podgląd zdarzeń, aby filtrować zdarzenia w dzienniku."
  remarks: "Ta metoda służy do zapisu z określonym przez aplikację `category` w dzienniku zdarzeń przy użyciu źródła, które jest już zarejestrowany jako źródło zdarzenia w dzienniku odpowiednie. Podgląd zdarzeń używa kategorię, aby filtrować zdarzenia zapisane przez źródło zdarzenia. Podgląd zdarzeń można wyświetlić kategorii jako wartość liczbowa lub można użyć kategorii jako identyfikator zasobu do wyświetlenia ciąg zlokalizowanej kategorii.      > [!NOTE] > `category` Parametr powinien być wartością dodatnią. Wartości ujemne kategorii są wyświetlane jako uzupełniające dodatnia podglądu zdarzeń. Na przykład –10 jest wyświetlany jako 65,526, -1 jako 65 535.       Aby wyświetlić kategorii zlokalizowanych ciągów w Podglądzie zdarzeń, należy użyć źródła zdarzenia konfigurowane przy użyciu pliku zasobu kategorii i ustaw `category` do identyfikatora zasobu w pliku zasobów kategorii. Jeśli źródło zdarzeń nie ma pliku zasobu kategorii skonfigurowany lub określony `category` nie indeksu ciągu w pliku zasobów kategorii, a następnie podglądu zdarzeń wyświetlane wartości liczbowe kategorię dla tego wpisu. Konfigurowanie pliku zasobu kategorii, wraz z liczbą ciągów kategorii w pliku zasobów za pomocą <xref:System.Diagnostics.EventLogInstaller>lub <xref:System.Diagnostics.EventSourceCreationData>klasy.</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller>       Oprócz kategorii można określić identyfikatora zdarzenia dla zdarzenia są zapisywane w dzienniku zdarzeń. Identyfikatory zdarzeń, wraz z źródło zdarzenia jednoznacznie zidentyfikować zdarzenia. Każda aplikacja może zdefiniować własne numerem zdarzenia i ciągi opisów, które mapują. Podglądy zdarzeń wyświetlać te wartości ciągu pomóc użytkownikowi zrozumieć, co poszło źle i zaproponuje jakie działania należy podjąć.       Ponadto można określić <xref:System.Diagnostics.EventLogEntryType>dla zdarzenia zapisywane w dzienniku zdarzeń.</xref:System.Diagnostics.EventLogEntryType> `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podglądzie zdarzeń dziennika. Ten parametr wskazuje, czy typ zdarzenia jest błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub Inspekcja niepowodzeń.       Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem. Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A>metody.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.       Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. <xref:System.Diagnostics.EventLog.WriteEntry%2A>Metoda zapisuje dany ciąg znaków bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów komunikatów lokalizowalny.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A>metodę, aby zapisać zdarzeń przy użyciu pliku zasobów komunikatów zlokalizowanych.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład należy skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A>sposób zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A>metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL.   >> `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartością całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciągu wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to sekwencja znaków, nie możesz zalogować się komunikat zawierający adres IPv6."
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#1](~/add/codesnippet/cpp/189fd615-c100-4e72-9c0b-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#1](~/add/codesnippet/csharp/189fd615-c100-4e72-9c0b-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#1](~/add/codesnippet/visualbasic/189fd615-c100-4e72-9c0b-_1.vb)]
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);
    parameters:
    - id: source
      type: System.String
      description: "Źródło, za pomocą której aplikacja jest zarejestrowana na określonym komputerze."
    - id: message
      type: System.String
      description: "Ciąg do zapisu w dzienniku zdarzeń."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Jeden z <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> wartości."
    - id: eventID
      type: System.Int32
      description: "Identyfikator zdarzenia specyficzne dla aplikacji."
    - id: category
      type: System.Int16
      description: "Podkategoria specyficzne dla aplikacji skojarzonych z wiadomością."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nie można otworzyć klucza rejestru dla dziennika zdarzeń."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>nie jest prawidłową <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Zapisuje wpis z danej wiadomości tekstowych, identyfikator zdarzenia zdefiniowane przez aplikację i kategorii zdefiniowane aplikacji w dzienniku zdarzeń (przy użyciu źródła określonego zdarzenia zarejestrowane) i dołącza dane binarne do wiadomości."
  remarks: "Użyj tej metody do zapisu w dzienniku zdarzeń przy użyciu źródła już zarejestrowany jako źródło zdarzenia w dzienniku odpowiednie dane specyficzne dla zdarzenia zdefiniowane przez aplikację. Podgląd zdarzeń nie ma możliwości interpretowania tych danych; nieprzetworzone dane są wyświetlane tylko w formacie łączna liczba szesnastkowa i tekst. Użyj danych dotyczących zdarzeń oszczędnie; Dołącz ją tylko wtedy, gdy masz pewność, że są one przydatne. Umożliwia także dane specyficzne dla zdarzenia do przechowywania informacji, których aplikacja może przetwarzać niezależnie od podglądu zdarzeń. Można na przykład zapisać przeglądarka specjalnie dla zdarzeń, lub napisz program, który skanowania pliku dziennika i tworzy raporty zawierające informacje z dane specyficzne dla zdarzenia.       Oprócz danych binarnych można określić kategorię zdefiniowanym przez aplikację i identyfikator zdarzenia zdefiniowane przez aplikację. Podgląd zdarzeń używa kategorię, aby filtrować zdarzenia zapisane przez źródło zdarzenia. Podgląd zdarzeń można wyświetlić kategorii jako wartość liczbowa lub można użyć kategorii jako identyfikator zasobu do wyświetlenia ciąg zlokalizowanej kategorii.      > [!NOTE] > `category` Parametr powinien być wartością dodatnią. Wartości ujemne kategorii są wyświetlane jako uzupełniające dodatnia podglądu zdarzeń. Na przykład –10 będą wyświetlane jako 65,526, -1 jako 65 535.       Aby wyświetlić kategorii zlokalizowanych ciągów w Podglądzie zdarzeń, należy użyć źródła zdarzenia konfigurowane przy użyciu pliku zasobu kategorii i ustaw `category` do identyfikatora zasobu w pliku zasobów kategorii. Jeśli źródło zdarzeń nie ma pliku zasobu kategorii skonfigurowany lub określony `category` nie indeksu ciągu w pliku zasobów kategorii, a następnie podglądu zdarzeń wyświetlane wartości liczbowe kategorię dla tego wpisu. Konfigurowanie pliku zasobu kategorii, wraz z liczbą ciągów kategorii w pliku zasobów za pomocą <xref:System.Diagnostics.EventLogInstaller>lub <xref:System.Diagnostics.EventSourceCreationData>klasy.</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller>       Identyfikatory zdarzeń, wraz z źródło zdarzenia jednoznacznie zidentyfikować zdarzenia. Każda aplikacja może zdefiniować własne numerem zdarzenia i ciągi opisów, które mapują. Podglądy zdarzeń wyświetlać te wartości ciągu pomóc użytkownikowi zrozumieć, co poszło źle i zaproponuje jakie działania należy podjąć.       Ponadto można określić <xref:System.Diagnostics.EventLogEntryType>dla zdarzenia zapisywane w dzienniku zdarzeń.</xref:System.Diagnostics.EventLogEntryType> `type` Jest wskazywany przez ikonę i tekst w kolumnie Typ w Podglądzie zdarzeń dziennika. Ten parametr wskazuje, czy typ zdarzenia jest błąd, ostrzeżenie, informacje, Inspekcja sukcesów lub Inspekcja niepowodzeń.       Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem. Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A>metody.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.       Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. <xref:System.Diagnostics.EventLog.WriteEntry%2A>Metoda zapisuje dany ciąg znaków bezpośrednio do dziennika zdarzeń; nie używa pliku zasobów komunikatów lokalizowalny.</xref:System.Diagnostics.EventLog.WriteEntry%2A> Użyj <xref:System.Diagnostics.EventLog.WriteEvent%2A>metodę, aby zapisać zdarzeń przy użyciu pliku zasobów komunikatów zlokalizowanych.</xref:System.Diagnostics.EventLog.WriteEvent%2A>       Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład należy skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A>sposób zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A>metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Jeśli `message` parametr zawiera znak, NUL, komunikat w dzienniku zdarzeń jest kończona na znaków NUL.   >> `message` Ciąg nie może zawierać %*n*, gdzie *n* jest wartością całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciągu wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to sekwencja znaków, nie możesz zalogować się komunikat zawierający adres IPv6."
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#2](~/add/codesnippet/cpp/0b90a83a-dcc8-46e6-a8db-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#2](~/add/codesnippet/csharp/0b90a83a-dcc8-46e6-a8db-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#2](~/add/codesnippet/visualbasic/0b90a83a-dcc8-46e6-a8db-_1.vb)]
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);
    parameters:
    - id: source
      type: System.String
      description: "Źródło, za pomocą której aplikacja jest zarejestrowana na określonym komputerze."
    - id: message
      type: System.String
      description: "Ciąg do zapisu w dzienniku zdarzeń."
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "Jeden z <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref> wartości."
    - id: eventID
      type: System.Int32
      description: "Identyfikator zdarzenia specyficzne dla aplikacji."
    - id: category
      type: System.Int16
      description: "Podkategoria specyficzne dla aplikacji skojarzonych z wiadomością."
    - id: rawData
      type: System.Byte[]
      description: "Tablica bajtów przechowujący dane binarne skojarzone z danym wpisem."
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>nie jest prawidłową <xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nie można otworzyć klucza rejestru dla dziennika zdarzeń."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  id: WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Zapisuje zlokalizowanych wpisu w dzienniku zdarzeń."
  remarks: "Ta metoda zlokalizowanych zapisu w dzienniku zdarzeń. Można określić właściwości zdarzenia z identyfikatory zasobów, a nie wartości ciągu. Podgląd zdarzeń używa identyfikatory zasobów, aby wyświetlić odpowiednie ciągi z pliku zlokalizowanych zasobów dla <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A> Przed przystąpieniem do napisania zdarzenia przy użyciu identyfikatorów zasobów, należy zarejestrować źródło się odpowiedni plik zasobów.       Dane wejściowe `instance` określa wystąpienie komunikatu o zdarzeniu i właściwości. Ustaw <xref:System.Diagnostics.EventInstance.InstanceId%2A>z `instance` danych wejściowych dla wiadomości zdefiniowane w pliku zasobów komunikatów źródła.</xref:System.Diagnostics.EventInstance.InstanceId%2A> Opcjonalnie możesz ustawić <xref:System.Diagnostics.EventInstance.CategoryId%2A>i <xref:System.Diagnostics.EventInstance.EntryType%2A>z `instance` dane wejściowe do definiowania typu kategorii i zdarzeń wpis zdarzeń.</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> Można również określić tablicę ciągów niezależny od języka aby wstawiony tekst komunikatu zlokalizowane. Ustaw `values` do `null` Jeśli komunikaty o zdarzeniach nie zawiera symbole zastępcze ciągów zamiennych formatowania.       Należy ustawić <xref:System.Diagnostics.EventLog.Source%2A>Właściwość <xref:System.Diagnostics.EventLog>składnik przed użyciem <xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> Określone źródło musi być skonfigurowany do pisania zlokalizowanych wpisy w Dzienniku; co najmniej źródło musi mieć zdefiniowano pliku zasobów komunikatów.       Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem. Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A>metody.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.       Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. Należy użyć <xref:System.Diagnostics.EventLog.WriteEntry%2A>metody, jeśli aplikacja zapisuje wartości ciągu bezpośrednio do dziennika zdarzeń.</xref:System.Diagnostics.EventLog.WriteEntry%2A>       Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład należy skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A>sposób zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A>metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Możesz zapisać wpis z komputerem zdalnym, wartość `message` ciąg może nie być oczekiwać Jeśli komputer zdalny nie jest uruchomiony system .NET Framework. Ponadto `message` ciąg nie może zawierać %*n*, gdzie *n* jest wartością całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciągu wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to sekwencja znaków, nie możesz zalogować się komunikat zawierający adres IPv6."
  example:
  - "The following example writes two audit entries to the event log `myNewLog`. The example creates a new event source and a new event log if they do not exist on the local computer. The event message text is specified using a resource identifier in a resource file.  \n  \n [!code-cpp[EventLog_WriteEvent#7](~/add/codesnippet/cpp/6a714dbf-bcbc-4f5a-a8b4-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#7](~/add/codesnippet/visualbasic/6a714dbf-bcbc-4f5a-a8b4-_1.vb)]\n [!code-cs[EventLog_WriteEvent#7](~/add/codesnippet/csharp/6a714dbf-bcbc-4f5a-a8b4-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public void WriteEvent (System.Diagnostics.EventInstance instance, object[] values);
    parameters:
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "<xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref> Wystąpienie reprezentuje wpis dziennika zdarzeń zlokalizowane."
    - id: values
      type: System.Object[]
      description: "Tablica ciągów do scalenia w treści wiadomości wpisu dziennika zdarzeń."
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nie można otworzyć klucza rejestru dla dziennika zdarzeń."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  id: WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Byte[],Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Zapisuje wpis dziennika zdarzeń przy użyciu danych z określonych zdarzeń, ciągi zamienne wiadomości i skojarzone dane binarne."
  remarks: "Ta metoda zlokalizowanych zapisu o dodatkowe dane dotyczące zdarzeń w dzienniku zdarzeń. Można określić właściwości zdarzenia z identyfikatory zasobów, a nie wartości ciągu. Podgląd zdarzeń używa identyfikatory zasobów, aby wyświetlić odpowiednie ciągi z pliku zlokalizowanych zasobów dla <xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A> Przed przystąpieniem do napisania zdarzenia przy użyciu identyfikatorów zasobów, należy zarejestrować źródło się odpowiedni plik zasobów.       Dane wejściowe `instance` określa wystąpienie komunikatu o zdarzeniu i właściwości. Ustaw <xref:System.Diagnostics.EventInstance.InstanceId%2A>z `instance` danych wejściowych dla wiadomości zdefiniowane w pliku zasobów komunikatów źródła.</xref:System.Diagnostics.EventInstance.InstanceId%2A> Opcjonalnie możesz ustawić <xref:System.Diagnostics.EventInstance.CategoryId%2A>i <xref:System.Diagnostics.EventInstance.EntryType%2A>z `instance` dane wejściowe do definiowania typu kategorii i zdarzeń wpis zdarzeń.</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> Można również określić tablicę ciągów niezależny od języka aby wstawiony tekst komunikatu zlokalizowane. Ustaw `values` do `null` Jeśli komunikaty o zdarzeniach nie zawiera symbole zastępcze ciągów zamiennych formatowania.       Określ dane binarne do zdarzenia, gdy jest to niezbędne w celu dostarczenie dodatkowych szczegółów zdarzenia. Na przykład użyć `data` parametr, aby uwzględnić informacje na temat określonego błędu. Podgląd zdarzeń nie ma możliwości interpretowania danych skojarzone ze zdarzeniem; dane są wyświetlane w formacie łączna liczba szesnastkowa i tekst. Użyj danych dotyczących zdarzeń oszczędnie; Dołącz ją tylko wtedy, gdy masz pewność, że są one przydatne. Umożliwia także dane specyficzne dla zdarzenia do przechowywania informacji, których aplikacja może przetwarzać niezależnie od podglądu zdarzeń. Można na przykład zapisać przeglądarka specjalnie dla zdarzeń, lub napisz program, który skanowania dziennika zdarzeń i tworzy raporty zawierające informacje z dane specyficzne dla zdarzenia.       Należy ustawić <xref:System.Diagnostics.EventLog.Source%2A>Właściwość <xref:System.Diagnostics.EventLog>składnik przed składnik przed użyciem <xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> Określone źródło musi być skonfigurowany do pisania zlokalizowanych wpisy w Dzienniku; co najmniej źródło musi mieć zdefiniowano pliku zasobów komunikatów.       Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem. Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A>metody.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.      > [!NOTE] > Jeśli nie określisz <xref:System.Diagnostics.EventLog.MachineName%2A>dla Twojego <xref:System.Diagnostics.EventLog>wystąpienia przed wywołaniem <xref:System.Diagnostics.EventLog.WriteEvent%2A>, komputer lokalny (&quot;.&quot;) zakłada, że.</xref:System.Diagnostics.EventLog.WriteEvent%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. Należy użyć <xref:System.Diagnostics.EventLog.WriteEntry%2A>metody, jeśli aplikacja zapisuje wartości ciągu bezpośrednio do dziennika zdarzeń.</xref:System.Diagnostics.EventLog.WriteEntry%2A>       Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład należy skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A>sposób zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A>metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > Możesz zapisać wpis z komputerem zdalnym, wartość `message` ciąg może nie być oczekiwać Jeśli komputer zdalny nie jest uruchomiony system .NET Framework. Ponadto `message` ciąg nie może zawierać %*n*, gdzie *n* jest wartością całkowitą (na przykład %1), ponieważ w Podglądzie zdarzeń traktuje ją jako ciągu wstawiania. Ponieważ protokół internetowy w wersji 6 (IPv6) adres może zawierać to sekwencja znaków, nie możesz zalogować się komunikat zawierający adres IPv6."
  example:
  - "The following example writes two audit entries to the event log `myNewLog`. The example creates a new event source and a new event log if they do not exist on the local computer. The event message text is specified using a resource identifier in a resource file.  \n  \n [!code-cpp[EventLog_WriteEvent#7](~/add/codesnippet/cpp/9c997f17-0108-4c5c-b894-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#7](~/add/codesnippet/visualbasic/9c997f17-0108-4c5c-b894-_1.vb)]\n [!code-cs[EventLog_WriteEvent#7](~/add/codesnippet/csharp/9c997f17-0108-4c5c-b894-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, object[] values);
    parameters:
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "<xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref> Wystąpienie reprezentuje wpis dziennika zdarzeń zlokalizowane."
    - id: data
      type: System.Byte[]
      description: "Tablica bajtów przechowujący dane binarne skojarzone z danym wpisem."
    - id: values
      type: System.Object[]
      description: "Tablica ciągów do scalenia w treści wiadomości wpisu dziennika zdarzeń."
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nie można otworzyć klucza rejestru dla dziennika zdarzeń."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  id: WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(String,EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Zapisuje danych i komunikatów ciągów zamiennych przy użyciu źródła określonego zdarzenia w zarejestrowany wpis dziennika zdarzeń z określonych zdarzeń."
  remarks: "Ta metoda zlokalizowanych zapisu w dzienniku zdarzeń przy użyciu źródła już zarejestrowany jako źródło zdarzenia w dzienniku odpowiednie. Można określić właściwości zdarzenia z identyfikatory zasobów, a nie wartości ciągu. Podgląd zdarzeń używa identyfikatory zasobów, aby wyświetlić odpowiednie ciągi z pliku zlokalizowanych zasobów dla tego źródła. Przed przystąpieniem do napisania zdarzenia przy użyciu identyfikatorów zasobów, należy zarejestrować źródło się odpowiedni plik zasobów.       Dane wejściowe `instance` określa wystąpienie komunikatu o zdarzeniu i właściwości. Ustaw <xref:System.Diagnostics.EventInstance.InstanceId%2A>z `instance` danych wejściowych dla wiadomości zdefiniowane w pliku zasobów komunikatów źródła.</xref:System.Diagnostics.EventInstance.InstanceId%2A> Opcjonalnie możesz ustawić <xref:System.Diagnostics.EventInstance.CategoryId%2A>i <xref:System.Diagnostics.EventInstance.EntryType%2A>z `instance` dane wejściowe do definiowania typu kategorii i zdarzeń wpis zdarzeń.</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> Można również określić tablicę ciągów niezależny od języka aby wstawiony tekst komunikatu zlokalizowane. Ustaw `values` do `null` Jeśli komunikaty o zdarzeniach nie zawiera symbole zastępcze ciągów zamiennych formatowania.       Określone źródło musi być zarejestrowana do dziennika zdarzeń przed użyciem <xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Określone źródło musi być skonfigurowany do pisania zlokalizowanych wpisy w Dzienniku; co najmniej źródło musi mieć zdefiniowano pliku zasobów komunikatów.       Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem. Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A>metody.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.       Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. Należy użyć <xref:System.Diagnostics.EventLog.WriteEntry%2A>metody, jeśli aplikacja zapisuje wartości ciągu bezpośrednio do dziennika zdarzeń.</xref:System.Diagnostics.EventLog.WriteEntry%2A>       Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład należy skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A>sposób zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A>metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.</xref:System.Diagnostics.EventLog.WriteEntry%2A>"
  example:
  - "The following example writes an informational event entry and a warning event entry to an existing event log. The event message text is specified using a resource identifier in a resource file. The example assumes the corresponding resource file has been registered for the source.  \n  \n [!code-cpp[EventLog_WriteEvent#8](~/add/codesnippet/cpp/a57d89b3-94d2-4b9a-803c-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#8](~/add/codesnippet/visualbasic/a57d89b3-94d2-4b9a-803c-_1.vb)]\n [!code-cs[EventLog_WriteEvent#8](~/add/codesnippet/csharp/a57d89b3-94d2-4b9a-803c-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, object[] values);
    parameters:
    - id: source
      type: System.String
      description: "Nazwa źródła zdarzenia zarejestrowane dla aplikacji na określonym komputerze."
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "<xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref> Wystąpienie reprezentuje wpis dziennika zdarzeń zlokalizowane."
    - id: values
      type: System.Object[]
      description: "Tablica ciągów do scalenia w treści wiadomości wpisu dziennika zdarzeń."
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nie można otworzyć klucza rejestru dla dziennika zdarzeń."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  id: WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(String,EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Zapisuje zdarzenie wpis dziennika przy użyciu danych z określonych zdarzeń ciągów zamiennych wiadomości i skojarzone dane binarne i przy użyciu określonego zarejestrowane źródło zdarzenia."
  remarks: "Ta metoda zlokalizowanych zapisu o dodatkowe dane dotyczące zdarzeń w dzienniku zdarzeń przy użyciu źródła już zarejestrowany jako źródło zdarzenia w dzienniku odpowiednie. Można określić właściwości zdarzenia z identyfikatory zasobów, a nie wartości ciągu. Podgląd zdarzeń używa identyfikatory zasobów, aby wyświetlić odpowiednie ciągi z pliku zlokalizowanych zasobów dla tego źródła. Przed przystąpieniem do napisania zdarzenia przy użyciu identyfikatorów zasobów, należy zarejestrować źródło się odpowiedni plik zasobów.       Dane wejściowe `instance` określa wystąpienie komunikatu o zdarzeniu i właściwości. Ustaw <xref:System.Diagnostics.EventInstance.InstanceId%2A>z `instance` danych wejściowych dla wiadomości zdefiniowane w pliku zasobów komunikatów źródła.</xref:System.Diagnostics.EventInstance.InstanceId%2A> Opcjonalnie możesz ustawić <xref:System.Diagnostics.EventInstance.CategoryId%2A>i <xref:System.Diagnostics.EventInstance.EntryType%2A>z `instance` dane wejściowe do definiowania typu kategorii i zdarzeń wpis zdarzeń.</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> Można również określić tablicę ciągów niezależny od języka aby wstawiony tekst komunikatu zlokalizowane. Ustaw `values` do `null` Jeśli komunikaty o zdarzeniach nie zawiera symbole zastępcze ciągów zamiennych formatowania.       Określ dane binarne do zdarzenia, gdy jest to niezbędne w celu dostarczenie dodatkowych szczegółów zdarzenia. Na przykład użyć `data` parametr, aby uwzględnić informacje na temat określonego błędu. Podgląd zdarzeń nie ma możliwości interpretowania danych skojarzone ze zdarzeniem; dane są wyświetlane w formacie łączna liczba szesnastkowa i tekst. Użyj danych dotyczących zdarzeń oszczędnie; Dołącz ją tylko wtedy, gdy masz pewność, że są one przydatne. Umożliwia także dane specyficzne dla zdarzenia do przechowywania informacji, których aplikacja może przetwarzać niezależnie od podglądu zdarzeń. Można na przykład zapisać przeglądarka specjalnie dla zdarzeń, lub napisz program, który skanowania dziennika zdarzeń i tworzy raporty zawierające informacje z dane specyficzne dla zdarzenia.       Określone źródło musi być zarejestrowana do dziennika zdarzeń przed użyciem <xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Określone źródło musi być skonfigurowany do pisania zlokalizowanych wpisy w Dzienniku; co najmniej źródło musi mieć zdefiniowano pliku zasobów komunikatów.       Należy utworzyć i skonfigurować źródło zdarzeń przed zapisaniem pierwszej pozycji ze źródłem. Utwórz nowe źródło zdarzeń podczas instalacji aplikacji. Dzięki temu czas dla systemu operacyjnego odświeżyć jej lista źródeł zdarzeń zarejestrowanych i ich konfiguracji. Jeśli system operacyjny nie odświeżył jego lista źródeł zdarzeń, a następnie spróbuj zapisać zdarzenie z nowego źródła operacja zapisu zakończy się niepowodzeniem. Można skonfigurować, używając nowego źródła <xref:System.Diagnostics.EventLogInstaller>, lub za pomocą <xref:System.Diagnostics.EventLog.CreateEventSource%2A>metody.</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> Musi mieć uprawnienia administracyjne na komputerze, aby utworzyć nowe źródło zdarzeń.       Źródło musi być skonfigurowany zapisywania wpisów zlokalizowanych lub zapisywanie ciągów bezpośredniego. Należy użyć <xref:System.Diagnostics.EventLog.WriteEntry%2A>metody, jeśli aplikacja zapisuje wartości ciągu bezpośrednio do dziennika zdarzeń.</xref:System.Diagnostics.EventLog.WriteEntry%2A>       Jeśli aplikacja zapisuje wpisów przy użyciu zarówno identyfikatorów zasobów, jak i wartości ciągu, należy zarejestrować dwa oddzielne źródła. Na przykład należy skonfigurować jedno źródło z plikami zasobów, a następnie użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEvent%2A>sposób zapisywanie wpisów przy użyciu identyfikatorów zasobów w dzienniku zdarzeń.</xref:System.Diagnostics.EventLog.WriteEvent%2A> Następnie utwórz innego źródła bez plików zasobów i użyj tego źródła w <xref:System.Diagnostics.EventLog.WriteEntry%2A>metodę, aby zapisać parametry bezpośrednio do dziennika zdarzeń przy użyciu tego źródła.</xref:System.Diagnostics.EventLog.WriteEntry%2A>"
  example:
  - "The following example writes an informational event entry and a warning event entry to an existing event log. The event message text is specified using a resource identifier in a resource file. The example assumes the corresponding resource file has been registered for the source.  \n  \n [!code-cpp[EventLog_WriteEvent#8](~/add/codesnippet/cpp/d4971002-e0d1-493b-96f8-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#8](~/add/codesnippet/visualbasic/d4971002-e0d1-493b-96f8-_1.vb)]\n [!code-cs[EventLog_WriteEvent#8](~/add/codesnippet/csharp/d4971002-e0d1-493b-96f8-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, object[] values);
    parameters:
    - id: source
      type: System.String
      description: "Nazwa źródła zdarzenia zarejestrowane dla aplikacji na określonym komputerze."
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "<xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref> Wystąpienie reprezentuje wpis dziennika zdarzeń zlokalizowane."
    - id: data
      type: System.Byte[]
      description: "Tablica bajtów przechowujący dane binarne skojarzone z danym wpisem."
    - id: values
      type: System.Object[]
      description: "Tablica ciągów do scalenia w treści wiadomości wpisu dziennika zdarzeń."
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Nie można otworzyć klucza rejestru dla dziennika zdarzeń."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "System operacyjny zgłosił błąd podczas zapisywania wpisu zdarzenia w dzienniku zdarzeń. Kod błędu systemu Windows nie jest dostępna."
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ComponentModel.Win32Exception
  parent: System.ComponentModel
  isExternal: false
  name: Win32Exception
  nameWithType: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.Diagnostics.EventLog.#ctor
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog()
  nameWithType: EventLog.EventLog()
  fullName: System.Diagnostics.EventLog.EventLog()
- uid: System.Diagnostics.EventLog.#ctor(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog(String)
  nameWithType: EventLog.EventLog(String)
  fullName: System.Diagnostics.EventLog.EventLog(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog(String,String)
  nameWithType: EventLog.EventLog(String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String)
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog(String,String,String)
  nameWithType: EventLog.EventLog(String,String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String,String)
- uid: System.Diagnostics.EventLog.BeginInit
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: BeginInit()
  nameWithType: EventLog.BeginInit()
  fullName: System.Diagnostics.EventLog.BeginInit()
- uid: System.Diagnostics.EventLog.Clear
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Clear()
  nameWithType: EventLog.Clear()
  fullName: System.Diagnostics.EventLog.Clear()
- uid: System.Diagnostics.EventLog.Close
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Close()
  nameWithType: EventLog.Close()
  fullName: System.Diagnostics.EventLog.Close()
- uid: System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource(EventSourceCreationData)
  nameWithType: EventLog.CreateEventSource(EventSourceCreationData)
  fullName: System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData)
- uid: System.Diagnostics.EventSourceCreationData
  parent: System.Diagnostics
  isExternal: false
  name: EventSourceCreationData
  nameWithType: EventSourceCreationData
  fullName: System.Diagnostics.EventSourceCreationData
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource(String,String)
  nameWithType: EventLog.CreateEventSource(String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String)
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource(String,String,String)
  nameWithType: EventLog.CreateEventSource(String,String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String,String)
- uid: System.Diagnostics.EventLog.Delete(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Delete(String)
  nameWithType: EventLog.Delete(String)
  fullName: System.Diagnostics.EventLog.Delete(String)
- uid: System.Diagnostics.EventLog.Delete(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Delete(String,String)
  nameWithType: EventLog.Delete(String,String)
  fullName: System.Diagnostics.EventLog.Delete(String,String)
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: DeleteEventSource(String)
  nameWithType: EventLog.DeleteEventSource(String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String)
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: DeleteEventSource(String,String)
  nameWithType: EventLog.DeleteEventSource(String,String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String,String)
- uid: System.Diagnostics.EventLog.Dispose(System.Boolean)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: EventLog.Dispose(Boolean)
  fullName: System.Diagnostics.EventLog.Dispose(Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Diagnostics.EventLog.EnableRaisingEvents
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: EventLog.EnableRaisingEvents
  fullName: System.Diagnostics.EventLog.EnableRaisingEvents
- uid: System.Diagnostics.EventLog.EndInit
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EndInit()
  nameWithType: EventLog.EndInit()
  fullName: System.Diagnostics.EventLog.EndInit()
- uid: System.Diagnostics.EventLog.Entries
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Entries
  nameWithType: EventLog.Entries
  fullName: System.Diagnostics.EventLog.Entries
- uid: System.Diagnostics.EventLogEntryCollection
  parent: System.Diagnostics
  isExternal: false
  name: EventLogEntryCollection
  nameWithType: EventLogEntryCollection
  fullName: System.Diagnostics.EventLogEntryCollection
- uid: System.Diagnostics.EventLog.EntryWritten
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EntryWritten
  nameWithType: EventLog.EntryWritten
  fullName: System.Diagnostics.EventLog.EntryWritten
- uid: System.Diagnostics.EntryWrittenEventHandler
  parent: System.Diagnostics
  isExternal: false
  name: EntryWrittenEventHandler
  nameWithType: EntryWrittenEventHandler
  fullName: System.Diagnostics.EntryWrittenEventHandler
- uid: System.Diagnostics.EventLog.Exists(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Exists(String)
  nameWithType: EventLog.Exists(String)
  fullName: System.Diagnostics.EventLog.Exists(String)
- uid: System.Diagnostics.EventLog.Exists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Exists(String,String)
  nameWithType: EventLog.Exists(String,String)
  fullName: System.Diagnostics.EventLog.Exists(String,String)
- uid: System.Diagnostics.EventLog.GetEventLogs
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: GetEventLogs()
  nameWithType: EventLog.GetEventLogs()
  fullName: System.Diagnostics.EventLog.GetEventLogs()
- uid: System.Diagnostics.EventLog[]
  parent: System.Diagnostics
  isExternal: false
  name: EventLog
  nameWithType: EventLog
  fullName: System.Diagnostics.EventLog[]
  spec.csharp:
  - uid: System.Diagnostics.EventLog
    name: EventLog
    nameWithType: EventLog
    fullName: EventLog[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.EventLog.GetEventLogs(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: GetEventLogs(String)
  nameWithType: EventLog.GetEventLogs(String)
  fullName: System.Diagnostics.EventLog.GetEventLogs(String)
- uid: System.Diagnostics.EventLog.Log
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Log
  nameWithType: EventLog.Log
  fullName: System.Diagnostics.EventLog.Log
- uid: System.Diagnostics.EventLog.LogDisplayName
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogDisplayName
  nameWithType: EventLog.LogDisplayName
  fullName: System.Diagnostics.EventLog.LogDisplayName
- uid: System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogNameFromSourceName(String,String)
  nameWithType: EventLog.LogNameFromSourceName(String,String)
  fullName: System.Diagnostics.EventLog.LogNameFromSourceName(String,String)
- uid: System.Diagnostics.EventLog.MachineName
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MachineName
  nameWithType: EventLog.MachineName
  fullName: System.Diagnostics.EventLog.MachineName
- uid: System.Diagnostics.EventLog.MaximumKilobytes
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MaximumKilobytes
  nameWithType: EventLog.MaximumKilobytes
  fullName: System.Diagnostics.EventLog.MaximumKilobytes
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Diagnostics.EventLog.MinimumRetentionDays
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MinimumRetentionDays
  nameWithType: EventLog.MinimumRetentionDays
  fullName: System.Diagnostics.EventLog.MinimumRetentionDays
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: ModifyOverflowPolicy(OverflowAction,Int32)
  nameWithType: EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
  fullName: System.Diagnostics.EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
- uid: System.Diagnostics.OverflowAction
  parent: System.Diagnostics
  isExternal: false
  name: OverflowAction
  nameWithType: OverflowAction
  fullName: System.Diagnostics.OverflowAction
- uid: System.Diagnostics.EventLog.OverflowAction
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: OverflowAction
  nameWithType: EventLog.OverflowAction
  fullName: System.Diagnostics.EventLog.OverflowAction
- uid: System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: RegisterDisplayName(String,Int64)
  nameWithType: EventLog.RegisterDisplayName(String,Int64)
  fullName: System.Diagnostics.EventLog.RegisterDisplayName(String,Int64)
- uid: System.Diagnostics.EventLog.Source
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Source
  nameWithType: EventLog.Source
  fullName: System.Diagnostics.EventLog.Source
- uid: System.Diagnostics.EventLog.SourceExists(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SourceExists(String)
  nameWithType: EventLog.SourceExists(String)
  fullName: System.Diagnostics.EventLog.SourceExists(String)
- uid: System.Diagnostics.EventLog.SourceExists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SourceExists(String,String)
  nameWithType: EventLog.SourceExists(String,String)
  fullName: System.Diagnostics.EventLog.SourceExists(String,String)
- uid: System.Diagnostics.EventLog.SynchronizingObject
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SynchronizingObject
  nameWithType: EventLog.SynchronizingObject
  fullName: System.Diagnostics.EventLog.SynchronizingObject
- uid: System.ComponentModel.ISynchronizeInvoke
  parent: System.ComponentModel
  isExternal: false
  name: ISynchronizeInvoke
  nameWithType: ISynchronizeInvoke
  fullName: System.ComponentModel.ISynchronizeInvoke
- uid: System.Diagnostics.EventLog.WriteEntry(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String)
  nameWithType: EventLog.WriteEntry(String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType)
- uid: System.Diagnostics.EventLogEntryType
  parent: System.Diagnostics
  isExternal: false
  name: EventLogEntryType
  nameWithType: EventLogEntryType
  fullName: System.Diagnostics.EventLogEntryType
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String)
  nameWithType: EventLog.WriteEntry(String,String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Object[])
- uid: System.Diagnostics.EventInstance
  parent: System.Diagnostics
  isExternal: false
  name: EventInstance
  nameWithType: EventInstance
  fullName: System.Diagnostics.EventInstance
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Byte[],Object[])
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(String,EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Object[])
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(String,EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
- uid: System.Diagnostics.EventLog.#ctor*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog
  nameWithType: EventLog.EventLog
- uid: System.Diagnostics.EventLog.BeginInit*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: BeginInit
  nameWithType: EventLog.BeginInit
- uid: System.Diagnostics.EventLog.Clear*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Clear
  nameWithType: EventLog.Clear
- uid: System.Diagnostics.EventLog.Close*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Close
  nameWithType: EventLog.Close
- uid: System.Diagnostics.EventLog.CreateEventSource*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource
  nameWithType: EventLog.CreateEventSource
- uid: System.Diagnostics.EventLog.Delete*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Delete
  nameWithType: EventLog.Delete
- uid: System.Diagnostics.EventLog.DeleteEventSource*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: DeleteEventSource
  nameWithType: EventLog.DeleteEventSource
- uid: System.Diagnostics.EventLog.Dispose*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Dispose
  nameWithType: EventLog.Dispose
- uid: System.Diagnostics.EventLog.EnableRaisingEvents*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: EventLog.EnableRaisingEvents
- uid: System.Diagnostics.EventLog.EndInit*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EndInit
  nameWithType: EventLog.EndInit
- uid: System.Diagnostics.EventLog.Entries*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Entries
  nameWithType: EventLog.Entries
- uid: System.Diagnostics.EventLog.Exists*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Exists
  nameWithType: EventLog.Exists
- uid: System.Diagnostics.EventLog.GetEventLogs*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: GetEventLogs
  nameWithType: EventLog.GetEventLogs
- uid: System.Diagnostics.EventLog.Log*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Log
  nameWithType: EventLog.Log
- uid: System.Diagnostics.EventLog.LogDisplayName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogDisplayName
  nameWithType: EventLog.LogDisplayName
- uid: System.Diagnostics.EventLog.LogNameFromSourceName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogNameFromSourceName
  nameWithType: EventLog.LogNameFromSourceName
- uid: System.Diagnostics.EventLog.MachineName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MachineName
  nameWithType: EventLog.MachineName
- uid: System.Diagnostics.EventLog.MaximumKilobytes*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MaximumKilobytes
  nameWithType: EventLog.MaximumKilobytes
- uid: System.Diagnostics.EventLog.MinimumRetentionDays*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MinimumRetentionDays
  nameWithType: EventLog.MinimumRetentionDays
- uid: System.Diagnostics.EventLog.ModifyOverflowPolicy*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: ModifyOverflowPolicy
  nameWithType: EventLog.ModifyOverflowPolicy
- uid: System.Diagnostics.EventLog.OverflowAction*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: OverflowAction
  nameWithType: EventLog.OverflowAction
- uid: System.Diagnostics.EventLog.RegisterDisplayName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: RegisterDisplayName
  nameWithType: EventLog.RegisterDisplayName
- uid: System.Diagnostics.EventLog.Source*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Source
  nameWithType: EventLog.Source
- uid: System.Diagnostics.EventLog.SourceExists*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SourceExists
  nameWithType: EventLog.SourceExists
- uid: System.Diagnostics.EventLog.SynchronizingObject*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SynchronizingObject
  nameWithType: EventLog.SynchronizingObject
- uid: System.Diagnostics.EventLog.WriteEntry*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry
  nameWithType: EventLog.WriteEntry
- uid: System.Diagnostics.EventLog.WriteEvent*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent
  nameWithType: EventLog.WriteEvent
