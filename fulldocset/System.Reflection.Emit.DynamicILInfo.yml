### YamlMime:ManagedReference
items:
- uid: System.Reflection.Emit.DynamicILInfo
  id: DynamicILInfo
  children:
  - System.Reflection.Emit.DynamicILInfo.DynamicMethod
  - System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Byte[])
  - System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Reflection.Emit.DynamicMethod)
  - System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle)
  - System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle)
  - System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeTypeHandle)
  - System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.String)
  - System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle,System.RuntimeTypeHandle)
  - System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle,System.RuntimeTypeHandle)
  - System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte[],System.Int32)
  - System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte*,System.Int32,System.Int32)
  - System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte[])
  - System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte*,System.Int32)
  - System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte[])
  - System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte*,System.Int32)
  langs:
  - csharp
  name: DynamicILInfo
  nameWithType: DynamicILInfo
  fullName: System.Reflection.Emit.DynamicILInfo
  type: Class
  summary: "Zapewnia obsługę alternatywnych metod Generowanie język pośredni firmy Microsoft (MSIL) i metadanych dla metody dynamicznej, tym metody do tworzenia tokenów i wstawianie kodu, obsługa wyjątków i zmiennych podpisu lokalnego obiektów blob."
  remarks: "Klasa DynamicILInfo umożliwia deweloperom pisanie własnych generatory MSIL zamiast <xref:System.Reflection.Emit.ILGenerator>.</xref:System.Reflection.Emit.ILGenerator>       Aby utworzyć wystąpienia innych typów, wywoływanie metod i tak dalej, MSIL generowania musi zawierać tokeny dla tych jednostek. Klasa DynamicILInfo udostępnia kilka przeciążeń <xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%2A>metodę, która zwraca tokeny prawidłowe w zakresie bieżącego DynamicILInfo.</xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%2A> Na przykład, jeśli należy wywołać przeciążenia <xref:System.Console.WriteLine%2A?displayProperty=fullName>metody, można uzyskać <xref:System.RuntimeMethodHandle>który przeciążenia i przekaż go do <xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%2A>metody do uzyskania tokenu do osadzenia w Twojej MSIL.</xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%2A> </xref:System.RuntimeMethodHandle> </xref:System.Console.WriteLine%2A?displayProperty=fullName>       Po utworzeniu <xref:System.Byte>tablic zmiennych podpisu lokalnego, wyjątków i treść kodu, można użyć <xref:System.Reflection.Emit.DynamicILInfo.SetCode%2A>, <xref:System.Reflection.Emit.DynamicILInfo.SetExceptions%2A>, i <xref:System.Reflection.Emit.DynamicILInfo.SetLocalSignature%2A>metod, aby wstawić je do <xref:System.Reflection.Emit.DynamicMethod>skojarzone z obiektem DynamicILInfo.</xref:System.Reflection.Emit.DynamicMethod> </xref:System.Reflection.Emit.DynamicILInfo.SetLocalSignature%2A> </xref:System.Reflection.Emit.DynamicILInfo.SetExceptions%2A> </xref:System.Reflection.Emit.DynamicILInfo.SetCode%2A> </xref:System.Byte>       Generowanie własnego metadanych i MSIL wymaga znajomości dokumentacji infrastruktury języka wspólnego (CLI), szczególnie &quot;Partycji II: metadane definicji i semantyki&quot; i &quot;Partycji III: CIL instrukcji Set&quot;. Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma.      > [!NOTE] > DynamicILInfo nie jest używany do generowania kodu, który tworzy delegata do innej metody dynamicznej poprzez bezpośrednie wywoływanie konstruktora delegata. Zamiast tego należy użyć <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>metodę w celu utworzenia delegata.</xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> Delegata, który jest utworzony za pomocą konstruktora delegata nie ma odwołanie do docelowej metody dynamicznej. Metody dynamicznej może można odzyskać przez odzyskiwanie pamięci podczas delegat jest nadal używane."
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public class DynamicILInfo
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.DynamicMethod
  id: DynamicMethod
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: DynamicMethod
  nameWithType: DynamicILInfo.DynamicMethod
  fullName: System.Reflection.Emit.DynamicILInfo.DynamicMethod
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Pobiera metody dynamicznej, których treść jest generowany przez bieżące wystąpienie."
  remarks: "A <xref:System.Reflection.Emit.DynamicILInfo>obiekt zawsze jest skojarzony z metody dynamicznej.</xref:System.Reflection.Emit.DynamicILInfo> Celem <xref:System.Reflection.Emit.DynamicILInfo>jest klasa inny sposób wstawiania strumienia MSIL, obsługa wyjątków i zmiennych podpisu lokalnego do metody dynamicznej, dla deweloperów, którzy mają być Generowanie MSIL bez użycia <xref:System.Reflection.Emit.ILGenerator>klasy.</xref:System.Reflection.Emit.ILGenerator> </xref:System.Reflection.Emit.DynamicILInfo>"
  syntax:
    content: public System.Reflection.Emit.DynamicMethod DynamicMethod { get; }
    return:
      type: System.Reflection.Emit.DynamicMethod
      description: "A <xref:System.Reflection.Emit.DynamicMethod>obiekt reprezentujący metody dynamicznej, dla którego bieżący <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref> obiektu jest generowanie kodu.</xref:System.Reflection.Emit.DynamicMethod>"
  overload: System.Reflection.Emit.DynamicILInfo.DynamicMethod*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Byte[])
  id: GetTokenFor(System.Byte[])
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: GetTokenFor(Byte[])
  nameWithType: DynamicILInfo.GetTokenFor(Byte[])
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Pobiera token jest nieprawidłowy w zakresie bieżącego <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref>, reprezentujący podpis skojarzony metody dynamicznej."
  remarks: 'Uzyskać informacji o sygnaturze obiektów blob zobacz dokumentację infrastruktury języka wspólnego (CLI), szczególnie &quot;partycji II: metadane definicji i semantyki&quot;. Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma.'
  syntax:
    content: public int GetTokenFor (byte[] signature);
    parameters:
    - id: signature
      type: System.Byte[]
      description: "Tablica zawiera podpis."
    return:
      type: System.Int32
      description: "Token, który można ją osadzić w metadanych i strumienia MSIL skojarzone metody dynamicznej."
  overload: System.Reflection.Emit.DynamicILInfo.GetTokenFor*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Reflection.Emit.DynamicMethod)
  id: GetTokenFor(System.Reflection.Emit.DynamicMethod)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: GetTokenFor(DynamicMethod)
  nameWithType: DynamicILInfo.GetTokenFor(DynamicMethod)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(DynamicMethod)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Pobiera token jest nieprawidłowy w zakresie bieżącego <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref>, reprezentujący dynamiczne metoda wywoływana przez metodę skojarzone."
  remarks: "Token zwracany przez przeciążenie tej metody umożliwia wywołanie metody dynamicznej z metody dynamicznej skojarzone z bieżącym <xref:System.Reflection.Emit.DynamicILInfo>obiektu.</xref:System.Reflection.Emit.DynamicILInfo> Aby wywołać rekursywnie skojarzone metody dynamicznej, należy przekazać wartość <xref:System.Reflection.Emit.DynamicILInfo.DynamicMethod%2A>Właściwości.</xref:System.Reflection.Emit.DynamicILInfo.DynamicMethod%2A>"
  syntax:
    content: public int GetTokenFor (System.Reflection.Emit.DynamicMethod method);
    parameters:
    - id: method
      type: System.Reflection.Emit.DynamicMethod
      description: "Dynamiczne metody do wywołania."
    return:
      type: System.Int32
      description: "Token, który można ją osadzić w strumieniu MSIL skojarzone metody dynamicznej, jako element docelowy instrukcja MSIL."
  overload: System.Reflection.Emit.DynamicILInfo.GetTokenFor*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle)
  id: GetTokenFor(System.RuntimeFieldHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: GetTokenFor(RuntimeFieldHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeFieldHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeFieldHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Pobiera token jest nieprawidłowy w zakresie bieżącego <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref>, reprezentująca pole można uzyskać dostęp z skojarzone metody dynamicznej."
  remarks: "Należy uzyskać token dla dowolnego pola, w której będą mieli dostęp przez metodę dynamicznego skojarzone z bieżącym <xref:System.Reflection.Emit.DynamicILInfo>obiektu.</xref:System.Reflection.Emit.DynamicILInfo> Użyj <xref:System.Type.GetField%2A?displayProperty=fullName>metody <xref:System.Reflection.FieldInfo>pola, które chcesz uzyskać dostęp, a następnie użyj <xref:System.Reflection.FieldInfo.FieldHandle%2A>właściwości do pobrania <xref:System.RuntimeFieldHandle>.</xref:System.RuntimeFieldHandle> </xref:System.Reflection.FieldInfo.FieldHandle%2A> </xref:System.Reflection.FieldInfo> </xref:System.Type.GetField%2A?displayProperty=fullName>"
  syntax:
    content: public int GetTokenFor (RuntimeFieldHandle field);
    parameters:
    - id: field
      type: System.RuntimeFieldHandle
      description: "Pole ma być uzyskiwany dostęp."
    return:
      type: System.Int32
      description: "Token, który może być używany jako argument instrukcji MSIL, który uzyskuje dostęp do pól w zakresie bieżącego <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref> obiektu."
  overload: System.Reflection.Emit.DynamicILInfo.GetTokenFor*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle)
  id: GetTokenFor(System.RuntimeMethodHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: GetTokenFor(RuntimeMethodHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeMethodHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeMethodHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Pobiera token jest nieprawidłowy w zakresie bieżącego <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref>, reprezentujący metodę jako dostępne skojarzone metody dynamicznej."
  remarks: "Należy uzyskać token dla dowolnej metody, której będą mieli dostęp przez metodę dynamicznego skojarzone z bieżącym <xref:System.Reflection.Emit.DynamicILInfo>obiektu.</xref:System.Reflection.Emit.DynamicILInfo> Użyj <xref:System.Type.GetMethod%2A?displayProperty=fullName>metody <xref:System.Reflection.MethodInfo>dla metody, które chcesz uzyskać dostęp, a następnie użyj <xref:System.Reflection.MethodBase.MethodHandle%2A>właściwości do pobrania <xref:System.RuntimeMethodHandle>.</xref:System.RuntimeMethodHandle> </xref:System.Reflection.MethodBase.MethodHandle%2A> </xref:System.Reflection.MethodInfo> </xref:System.Type.GetMethod%2A?displayProperty=fullName>      > [!NOTE] > Metodę, która należy do typu ogólnego, użyj <xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%29>metoda przeciążenia i określ <xref:System.RuntimeTypeHandle>dla typu ogólnego.</xref:System.RuntimeTypeHandle> </xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%29>"
  syntax:
    content: public int GetTokenFor (RuntimeMethodHandle method);
    parameters:
    - id: method
      type: System.RuntimeMethodHandle
      description: "Metoda ma być uzyskiwany dostęp."
    return:
      type: System.Int32
      description: "Token, który może być używany jako argument instrukcji MSIL, który uzyskuje dostęp do metod, takich jak <xref:System.Reflection.Emit.OpCodes.Call>lub <xref:System.Reflection.Emit.OpCodes.Ldtoken>, w zakresie bieżącego <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref> obiektu.</xref:System.Reflection.Emit.OpCodes.Ldtoken> </xref:System.Reflection.Emit.OpCodes.Call>"
  overload: System.Reflection.Emit.DynamicILInfo.GetTokenFor*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeTypeHandle)
  id: GetTokenFor(System.RuntimeTypeHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: GetTokenFor(RuntimeTypeHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeTypeHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeTypeHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Pobiera token jest nieprawidłowy w zakresie bieżącego <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref>, reprezentujący typ ma być używana podczas skojarzone metody dynamicznej."
  remarks: "Token zwracany przez przeciążenie tej metody umożliwia definiowanie typu zmiennej lokalnej i Emituj MSIL do utworzenia wystąpienia typu w metodzie dynamiczne skojarzone z bieżącym <xref:System.Reflection.Emit.DynamicILInfo>obiektu.</xref:System.Reflection.Emit.DynamicILInfo>       Aby uzyskać <xref:System.RuntimeTypeHandle>reprezentujący typ, użyj <xref:System.Type.TypeHandle%2A?displayProperty=fullName>Właściwości.</xref:System.Type.TypeHandle%2A?displayProperty=fullName> </xref:System.RuntimeTypeHandle>"
  syntax:
    content: public int GetTokenFor (RuntimeTypeHandle type);
    parameters:
    - id: type
      type: System.RuntimeTypeHandle
      description: "Typ, który ma być używany."
    return:
      type: System.Int32
      description: "Token, który może być używany jako argument instrukcji MSIL, który wymaga typu, w zakresie bieżącego <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref> obiektu."
  overload: System.Reflection.Emit.DynamicILInfo.GetTokenFor*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.String)
  id: GetTokenFor(System.String)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: GetTokenFor(String)
  nameWithType: DynamicILInfo.GetTokenFor(String)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Pobiera token jest nieprawidłowy w zakresie bieżącego <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref>, reprezentujący do użycia w metodzie dynamiczne skojarzone literału ciągu."
  syntax:
    content: public int GetTokenFor (string literal);
    parameters:
    - id: literal
      type: System.String
      description: "Ciąg, który ma być używany."
    return:
      type: System.Int32
      description: "Token, który może być używany jako argument instrukcji MSIL, który wymaga parametrów, w zakresie bieżącego <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref> obiektu."
  overload: System.Reflection.Emit.DynamicILInfo.GetTokenFor*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle,System.RuntimeTypeHandle)
  id: GetTokenFor(System.RuntimeFieldHandle,System.RuntimeTypeHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: GetTokenFor(RuntimeFieldHandle,RuntimeTypeHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeFieldHandle,RuntimeTypeHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeFieldHandle,RuntimeTypeHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Pobiera token jest nieprawidłowy w zakresie bieżącego <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref>, reprezentująca pole można uzyskać dostęp z skojarzone metody dynamicznej; to pole jest w określonym typie ogólnym."
  remarks: "Należy uzyskać token dla dowolnego pola, w której będą mieli dostęp przez metodę dynamicznego skojarzone z bieżącym <xref:System.Reflection.Emit.DynamicILInfo>obiektu.</xref:System.Reflection.Emit.DynamicILInfo> Użyj <xref:System.Type.GetField%2A?displayProperty=fullName>metody <xref:System.Reflection.FieldInfo>pola, które chcesz uzyskać dostęp, a następnie użyj <xref:System.Reflection.FieldInfo.FieldHandle%2A>właściwości do pobrania <xref:System.RuntimeFieldHandle>.</xref:System.RuntimeFieldHandle> </xref:System.Reflection.FieldInfo.FieldHandle%2A> </xref:System.Reflection.FieldInfo> </xref:System.Type.GetField%2A?displayProperty=fullName>"
  syntax:
    content: public int GetTokenFor (RuntimeFieldHandle field, RuntimeTypeHandle contextType);
    parameters:
    - id: field
      type: System.RuntimeFieldHandle
      description: "Pole ma być uzyskiwany dostęp."
    - id: contextType
      type: System.RuntimeTypeHandle
      description: "Typ ogólny, których należy pole."
    return:
      type: System.Int32
      description: "Token, który może być używany jako argument instrukcji MSIL, który uzyskuje dostęp do pól w zakresie bieżącego <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref> obiektu."
  overload: System.Reflection.Emit.DynamicILInfo.GetTokenFor*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle,System.RuntimeTypeHandle)
  id: GetTokenFor(System.RuntimeMethodHandle,System.RuntimeTypeHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: GetTokenFor(RuntimeMethodHandle,RuntimeTypeHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeMethodHandle,RuntimeTypeHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeMethodHandle,RuntimeTypeHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Pobiera token jest nieprawidłowy w zakresie bieżącego <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref>, reprezentujący metody dla typu ogólnego."
  remarks: "Należy uzyskać token dla dowolnej metody, która będzie wywoływana przez metodę dynamicznego skojarzone z bieżącym <xref:System.Reflection.Emit.DynamicILInfo>obiektu.</xref:System.Reflection.Emit.DynamicILInfo> Użyj <xref:System.Type.GetMethod%2A?displayProperty=fullName>metody <xref:System.Reflection.MethodInfo>dla metody, którą chcesz wywołać, a następnie użyj <xref:System.Reflection.MethodBase.MethodHandle%2A>właściwości do pobrania <xref:System.RuntimeMethodHandle>.</xref:System.RuntimeMethodHandle> </xref:System.Reflection.MethodBase.MethodHandle%2A> </xref:System.Reflection.MethodInfo> </xref:System.Type.GetMethod%2A?displayProperty=fullName>"
  syntax:
    content: public int GetTokenFor (RuntimeMethodHandle method, RuntimeTypeHandle contextType);
    parameters:
    - id: method
      type: System.RuntimeMethodHandle
      description: "Metoda."
    - id: contextType
      type: System.RuntimeTypeHandle
      description: "Typ ogólny metoda należy do."
    return:
      type: System.Int32
      description: "Token, który może być używany jako argument instrukcji MSIL, który uzyskuje dostęp do metod, takich jak <xref:System.Reflection.Emit.OpCodes.Call>lub <xref:System.Reflection.Emit.OpCodes.Ldtoken>, w zakresie bieżącego <xref href=&quot;System.Reflection.Emit.DynamicILInfo&quot;> </xref> obiektu.</xref:System.Reflection.Emit.OpCodes.Ldtoken> </xref:System.Reflection.Emit.OpCodes.Call>"
  overload: System.Reflection.Emit.DynamicILInfo.GetTokenFor*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte[],System.Int32)
  id: SetCode(System.Byte[],System.Int32)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: SetCode(Byte[],Int32)
  nameWithType: DynamicILInfo.SetCode(Byte[],Int32)
  fullName: System.Reflection.Emit.DynamicILInfo.SetCode(Byte[],Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Ustawia treść kodu skojarzone metody dynamicznej."
  remarks: "Nie ważności są sprawdzane w strumieniu MSIL.       Wywołanie tej metody na drugim zamienia pierwszy strumienia MSIL drugiego.       Generowanie własnego metadanych i MSIL wymaga znajomości dokumentacji infrastruktury języka wspólnego (CLI), szczególnie &quot;Partycji II: metadane definicji i semantyki&quot; i &quot;Partycji III: CIL instrukcji Set&quot;. Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma."
  syntax:
    content: public void SetCode (byte[] code, int maxStackSize);
    parameters:
    - id: code
      type: System.Byte[]
      description: "Tablica zawiera strumienia MSIL."
    - id: maxStackSize
      type: System.Int32
      description: "Maksymalna liczba elementów na stosie operand podczas wykonywania metody."
  overload: System.Reflection.Emit.DynamicILInfo.SetCode*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte*,System.Int32,System.Int32)
  id: SetCode(System.Byte*,System.Int32,System.Int32)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: SetCode(Byte*,Int32,Int32)
  nameWithType: DynamicILInfo.SetCode(Byte*,Int32,Int32)
  fullName: System.Reflection.Emit.DynamicILInfo.SetCode(Byte*,Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Ustawia treść kodu skojarzone metody dynamicznej."
  remarks: "Nie ważności są sprawdzane w strumieniu MSIL.       Wywołanie tej metody na drugim zamienia pierwszy strumienia MSIL drugiego.       Generowanie własnego metadanych i MSIL wymaga znajomości dokumentacji infrastruktury języka wspólnego (CLI), szczególnie &quot;partycji II: metadane definicji i semantyki&quot; i &quot;partycji III: zestaw instrukcji CIL.&quot; Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma."
  syntax:
    content: public void SetCode (byte* code, int codeSize, int maxStackSize);
    parameters:
    - id: code
      type: System.Byte*
      description: "Wskaźnik do tablica bajtów zawierająca strumień MSIL."
    - id: codeSize
      type: System.Int32
      description: "Liczba bajtów w strumieniu MSIL."
    - id: maxStackSize
      type: System.Int32
      description: "Maksymalna liczba elementów na stosie operand podczas wykonywania metody."
  overload: System.Reflection.Emit.DynamicILInfo.SetCode*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>code</code>jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> i <code>codeSize</code> jest większa niż 0."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>codeSize</code>jest mniejsza niż 0."
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte[])
  id: SetExceptions(System.Byte[])
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: SetExceptions(Byte[])
  nameWithType: DynamicILInfo.SetExceptions(Byte[])
  fullName: System.Reflection.Emit.DynamicILInfo.SetExceptions(Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Ustawia wyjątek metadane skojarzone metody dynamicznej."
  remarks: 'Metadane wyjątku dla metody definiuje położenie i rozmiar wszystkich `try`, `catch`, `finally`, filtr i bloki błędów. Aby uzyskać informacje na układ metadanych w dokumentacji infrastruktury języka wspólnego (CLI), szczególnie &quot;partycji II: metadane definicji i semantyki&quot;. Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma.'
  syntax:
    content: public void SetExceptions (byte[] exceptions);
    parameters:
    - id: exceptions
      type: System.Byte[]
      description: "Tablica zawiera metadane wyjątku."
  overload: System.Reflection.Emit.DynamicILInfo.SetExceptions*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte*,System.Int32)
  id: SetExceptions(System.Byte*,System.Int32)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: SetExceptions(Byte*,Int32)
  nameWithType: DynamicILInfo.SetExceptions(Byte*,Int32)
  fullName: System.Reflection.Emit.DynamicILInfo.SetExceptions(Byte*,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Ustawia wyjątek metadane skojarzone metody dynamicznej."
  remarks: 'Metadane wyjątku dla metody definiuje położenie i rozmiar wszystkich `try`, `catch`, `finally`, filtr i bloki błędów. Aby uzyskać informacje na układ metadanych w dokumentacji infrastruktury języka wspólnego (CLI), szczególnie &quot;Partycji II: metadane definicji i semantyki&quot; i &quot;III: CIL instrukcji zestawu partycji&quot;. Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma.'
  syntax:
    content: public void SetExceptions (byte* exceptions, int exceptionsSize);
    parameters:
    - id: exceptions
      type: System.Byte*
      description: "Wskaźnik do tablicy typu byte, zawierający metadane wyjątku."
    - id: exceptionsSize
      type: System.Int32
      description: "Liczba bajtów wyjątek metadanych."
  overload: System.Reflection.Emit.DynamicILInfo.SetExceptions*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>exceptions</code>jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> i <code>exceptionSize</code> jest większa niż 0."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>exceptionSize</code>jest mniejsza niż 0."
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte[])
  id: SetLocalSignature(System.Byte[])
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: SetLocalSignature(Byte[])
  nameWithType: DynamicILInfo.SetLocalSignature(Byte[])
  fullName: System.Reflection.Emit.DynamicILInfo.SetLocalSignature(Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Ustawia lokalnej zmiennej podpisie, który opisano układ zmiennych lokalnych skojarzone metody dynamicznej."
  remarks: "Podpisu lokalnego zmiennej opisano układ metody zmiennych lokalnych. Aby uprościć konstruowania zmiennej podpisu lokalnego, należy użyć `static` (`Shared` w języku Visual Basic) <xref:System.Reflection.Emit.SignatureHelper.GetLocalVarSigHelper%2A?displayProperty=fullName>metodę, aby pobrać <xref:System.Reflection.Emit.SignatureHelper>dla podpisu lokalnego.</xref:System.Reflection.Emit.SignatureHelper> </xref:System.Reflection.Emit.SignatureHelper.GetLocalVarSigHelper%2A?displayProperty=fullName>       Informacji na temat podpisów zmiennych lokalnych w dokumentacji infrastruktury języka wspólnego (CLI), szczególnie &quot;partycji II: metadane definicji i semantyki&quot;. Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma."
  syntax:
    content: public void SetLocalSignature (byte[] localSignature);
    parameters:
    - id: localSignature
      type: System.Byte[]
      description: "Tablica zawierająca układ zmiennych lokalnych w dla skojarzonych <xref:System.Reflection.Emit.DynamicMethod>.</xref:System.Reflection.Emit.DynamicMethod>"
  overload: System.Reflection.Emit.DynamicILInfo.SetLocalSignature*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte*,System.Int32)
  id: SetLocalSignature(System.Byte*,System.Int32)
  parent: System.Reflection.Emit.DynamicILInfo
  langs:
  - csharp
  name: SetLocalSignature(Byte*,Int32)
  nameWithType: DynamicILInfo.SetLocalSignature(Byte*,Int32)
  fullName: System.Reflection.Emit.DynamicILInfo.SetLocalSignature(Byte*,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: "Ustawia lokalnej zmiennej podpisie, który opisano układ zmiennych lokalnych skojarzone metody dynamicznej."
  remarks: "Podpisu lokalnego zmiennej opisano układ metody zmiennych lokalnych. Aby uprościć konstruowania zmiennej podpisu lokalnego, należy użyć `static` (`Shared` w języku Visual Basic) <xref:System.Reflection.Emit.SignatureHelper.GetLocalVarSigHelper%2A?displayProperty=fullName>metodę, aby pobrać <xref:System.Reflection.Emit.SignatureHelper>dla podpisu lokalnego.</xref:System.Reflection.Emit.SignatureHelper> </xref:System.Reflection.Emit.SignatureHelper.GetLocalVarSigHelper%2A?displayProperty=fullName>       Informacji na temat podpisów zmiennych lokalnych w dokumentacji infrastruktury języka wspólnego (CLI), szczególnie &quot;partycji II: metadane definicji i semantyki&quot;. Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma."
  syntax:
    content: public void SetLocalSignature (byte* localSignature, int signatureSize);
    parameters:
    - id: localSignature
      type: System.Byte*
      description: "Tablica zawierająca układ zmiennych lokalnych w dla skojarzonych <xref:System.Reflection.Emit.DynamicMethod>.</xref:System.Reflection.Emit.DynamicMethod>"
    - id: signatureSize
      type: System.Int32
      description: "Liczba bajtów w podpisie."
  overload: System.Reflection.Emit.DynamicILInfo.SetLocalSignature*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>localSignature</code>jest <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> i <code>signatureSize</code> jest większa niż 0."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>signatureSize</code>jest mniejsza niż 0."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Reflection.Emit.DynamicILInfo.DynamicMethod
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: DynamicMethod
  nameWithType: DynamicILInfo.DynamicMethod
  fullName: System.Reflection.Emit.DynamicILInfo.DynamicMethod
- uid: System.Reflection.Emit.DynamicMethod
  parent: System.Reflection.Emit
  isExternal: true
  name: DynamicMethod
  nameWithType: DynamicMethod
  fullName: System.Reflection.Emit.DynamicMethod
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Byte[])
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: GetTokenFor(Byte[])
  nameWithType: DynamicILInfo.GetTokenFor(Byte[])
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(Byte[])
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Reflection.Emit.DynamicMethod)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: GetTokenFor(DynamicMethod)
  nameWithType: DynamicILInfo.GetTokenFor(DynamicMethod)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(DynamicMethod)
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: GetTokenFor(RuntimeFieldHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeFieldHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeFieldHandle)
- uid: System.RuntimeFieldHandle
  parent: System
  isExternal: true
  name: RuntimeFieldHandle
  nameWithType: RuntimeFieldHandle
  fullName: System.RuntimeFieldHandle
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: GetTokenFor(RuntimeMethodHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeMethodHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeMethodHandle)
- uid: System.RuntimeMethodHandle
  parent: System
  isExternal: true
  name: RuntimeMethodHandle
  nameWithType: RuntimeMethodHandle
  fullName: System.RuntimeMethodHandle
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeTypeHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: GetTokenFor(RuntimeTypeHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeTypeHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeTypeHandle)
- uid: System.RuntimeTypeHandle
  parent: System
  isExternal: true
  name: RuntimeTypeHandle
  nameWithType: RuntimeTypeHandle
  fullName: System.RuntimeTypeHandle
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.String)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: GetTokenFor(String)
  nameWithType: DynamicILInfo.GetTokenFor(String)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle,System.RuntimeTypeHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: GetTokenFor(RuntimeFieldHandle,RuntimeTypeHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeFieldHandle,RuntimeTypeHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeFieldHandle,RuntimeTypeHandle)
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle,System.RuntimeTypeHandle)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: GetTokenFor(RuntimeMethodHandle,RuntimeTypeHandle)
  nameWithType: DynamicILInfo.GetTokenFor(RuntimeMethodHandle,RuntimeTypeHandle)
  fullName: System.Reflection.Emit.DynamicILInfo.GetTokenFor(RuntimeMethodHandle,RuntimeTypeHandle)
- uid: System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte[],System.Int32)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: SetCode(Byte[],Int32)
  nameWithType: DynamicILInfo.SetCode(Byte[],Int32)
  fullName: System.Reflection.Emit.DynamicILInfo.SetCode(Byte[],Int32)
- uid: System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte*,System.Int32,System.Int32)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: SetCode(Byte*,Int32,Int32)
  nameWithType: DynamicILInfo.SetCode(Byte*,Int32,Int32)
  fullName: System.Reflection.Emit.DynamicILInfo.SetCode(Byte*,Int32,Int32)
- uid: System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte[])
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: SetExceptions(Byte[])
  nameWithType: DynamicILInfo.SetExceptions(Byte[])
  fullName: System.Reflection.Emit.DynamicILInfo.SetExceptions(Byte[])
- uid: System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte*,System.Int32)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: SetExceptions(Byte*,Int32)
  nameWithType: DynamicILInfo.SetExceptions(Byte*,Int32)
  fullName: System.Reflection.Emit.DynamicILInfo.SetExceptions(Byte*,Int32)
- uid: System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte[])
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: SetLocalSignature(Byte[])
  nameWithType: DynamicILInfo.SetLocalSignature(Byte[])
  fullName: System.Reflection.Emit.DynamicILInfo.SetLocalSignature(Byte[])
- uid: System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte*,System.Int32)
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: SetLocalSignature(Byte*,Int32)
  nameWithType: DynamicILInfo.SetLocalSignature(Byte*,Int32)
  fullName: System.Reflection.Emit.DynamicILInfo.SetLocalSignature(Byte*,Int32)
- uid: System.Reflection.Emit.DynamicILInfo.DynamicMethod*
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: DynamicMethod
  nameWithType: DynamicILInfo.DynamicMethod
- uid: System.Reflection.Emit.DynamicILInfo.GetTokenFor*
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: GetTokenFor
  nameWithType: DynamicILInfo.GetTokenFor
- uid: System.Reflection.Emit.DynamicILInfo.SetCode*
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: SetCode
  nameWithType: DynamicILInfo.SetCode
- uid: System.Reflection.Emit.DynamicILInfo.SetExceptions*
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: SetExceptions
  nameWithType: DynamicILInfo.SetExceptions
- uid: System.Reflection.Emit.DynamicILInfo.SetLocalSignature*
  parent: System.Reflection.Emit.DynamicILInfo
  isExternal: false
  name: SetLocalSignature
  nameWithType: DynamicILInfo.SetLocalSignature
