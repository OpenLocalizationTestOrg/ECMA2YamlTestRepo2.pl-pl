### YamlMime:ManagedReference
items:
- uid: System.Collections.Queue
  id: Queue
  children:
  - System.Collections.Queue.#ctor
  - System.Collections.Queue.#ctor(System.Collections.ICollection)
  - System.Collections.Queue.#ctor(System.Int32)
  - System.Collections.Queue.#ctor(System.Int32,System.Single)
  - System.Collections.Queue.Clear
  - System.Collections.Queue.Clone
  - System.Collections.Queue.Contains(System.Object)
  - System.Collections.Queue.CopyTo(System.Array,System.Int32)
  - System.Collections.Queue.Count
  - System.Collections.Queue.Dequeue
  - System.Collections.Queue.Enqueue(System.Object)
  - System.Collections.Queue.GetEnumerator
  - System.Collections.Queue.IsSynchronized
  - System.Collections.Queue.Peek
  - System.Collections.Queue.Synchronized(System.Collections.Queue)
  - System.Collections.Queue.SyncRoot
  - System.Collections.Queue.ToArray
  - System.Collections.Queue.TrimToSize
  langs:
  - csharp
  name: Queue
  nameWithType: Queue
  fullName: System.Collections.Queue
  type: Class
  summary: "Reprezentuje kolekcję FIFO pierwszy w, obiektów."
  remarks: "Ta klasa implementuje kolejki jako tablicę cykliczne. Obiekty przechowywane w kolejce są wstawiane na jednym końcu i usuwane z innych.       Stosów i kolejek są przydatne, gdy będziesz potrzebować tymczasowego przechowywania informacji; oznacza to, gdy można odrzucić elementu po pobraniu jej wartość. Użyj kolejki, aby uzyskać dostęp do informacji w tej samej kolejności, że jest on przechowywany w kolekcji. Użyj <xref:System.Collections.Stack>muszą uzyskać dostęp do informacji w odwrotnej kolejności.</xref:System.Collections.Stack> Użyj <xref:System.Collections.Concurrent.ConcurrentQueue%601>lub <xref:System.Collections.Concurrent.ConcurrentStack%601>trzeba uzyskać dostępu do kolekcji przez wiele wątków jednocześnie.</xref:System.Collections.Concurrent.ConcurrentStack%601> </xref:System.Collections.Concurrent.ConcurrentQueue%601>       Trzy główne operacje mogą być wykonywane w kolejce i jej elementów:- <xref:System.Collections.Queue.Enqueue%2A>dodaje element na końcu kolejki.</xref:System.Collections.Queue.Enqueue%2A>      - <xref:System.Collections.Queue.Dequeue%2A>usuwa najstarsze element od początku kolejki.</xref:System.Collections.Queue.Dequeue%2A>      - <xref:System.Collections.Queue.Peek%2A>zwraca najstarsze element, który jest na początku kolejki, ale nie powoduje usunięcia z kolejki.</xref:System.Collections.Queue.Peek%2A>       Pojemność kolejki jest liczba elementów, które może przechowywać kolejki. Jak elementy są dodawane do kolejki, pojemność jest automatycznie zwiększana co jest wymagane przez; Ponowna alokacja.  Można zmniejszyć pojemność przez wywołanie metody <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       Współczynnik wzrostu jest numerem, za pomocą którego bieżący jest mnożona gdy wymagana jest większej pojemności.  Współczynnik wzrostu jest określana, gdy kolejka jest utworzony. Współczynnik wzrostu domyślny jest wersja 2.0. Pojemność kolejki zawsze spowoduje zwiększenie przez co najmniej co najmniej&4;, niezależnie od tego, współczynnik wzrostu. Na przykład kolejki współczynnik wzrostu 1.0 zawsze spowoduje zwiększenie pojemności przez cztery, gdy wymagana jest większej pojemności.       Kolejka akceptuje `null` jako prawidłowa wartość i umożliwia zduplikowane elementy.       Ogólny wersję tej kolekcji zobacz<xref:System.Collections.Generic.Queue%601?displayProperty=fullName></xref:System.Collections.Generic.Queue%601?displayProperty=fullName>"
  example:
  - "The following example shows how to create and add values to a Queue and how to print out its values.  \n  \n [!code-cs[Classic Queue Example#1](~/add/codesnippet/csharp/t-system.collections.queue_1.cs)]\n [!code-cpp[Classic Queue Example#1](~/add/codesnippet/cpp/t-system.collections.queue_1.cpp)]\n [!code-vb[Classic Queue Example#1](~/add/codesnippet/visualbasic/t-system.collections.queue_1.vb)]"
  syntax:
    content: >-
      [System.Diagnostics.DebuggerDisplay("Count = {Count}")]

      [System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Queue/QueueDebugView))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public class Queue : ICloneable, System.Collections.ICollection
  inheritance:
  - System.Object
  implements:
  - System.Collections.ICollection
  - System.ICloneable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Collections.Queue.#ctor
  id: '#ctor'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue()
  nameWithType: Queue.Queue()
  fullName: System.Collections.Queue.Queue()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Collections.Queue&quot;> </xref> klasy, która jest pusta, ma domyślne początkowa pojemność i korzysta z domyślnego współczynnik wzrostu."
  remarks: "Pojemność <xref:System.Collections.Queue>jest liczba elementów <xref:System.Collections.Queue>może pomieścić.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Po dodaniu elementów do <xref:System.Collections.Queue>, automatycznie zostaje zwiększona wydajność co jest wymagane przez ponowne przydzielenie.</xref:System.Collections.Queue>  Można zmniejszyć pojemność przez wywołanie metody <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       Współczynnik wzrostu jest numerem, za pomocą którego bieżący jest mnożona gdy wymagana jest większej pojemności.  Współczynnik wzrostu jest określana podczas <xref:System.Collections.Queue>jest tworzony.</xref:System.Collections.Queue>       Ten konstruktor jest operacją O(1)."
  syntax:
    content: public Queue ();
    parameters: []
  overload: System.Collections.Queue.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Collections.ICollection)
  id: '#ctor(System.Collections.ICollection)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(ICollection)
  nameWithType: Queue.Queue(ICollection)
  fullName: System.Collections.Queue.Queue(ICollection)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Collections.Queue&quot;> </xref> klasę, która zawiera elementów kopiowanych z określonej kolekcji, ma tego samego początkowego pojemność jako liczbę elementów kopiowanych i używa współczynnik wzrostu domyślne."
  remarks: "Pojemność <xref:System.Collections.Queue>jest liczba elementów <xref:System.Collections.Queue>może pomieścić.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Po dodaniu elementów do <xref:System.Collections.Queue>, automatycznie zostaje zwiększona wydajność co jest wymagane przez ponowne przydzielenie.</xref:System.Collections.Queue>  Można zmniejszyć pojemność przez wywołanie metody <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       Współczynnik wzrostu jest numerem, za pomocą którego bieżący jest mnożona gdy wymagana jest większej pojemności.  Współczynnik wzrostu jest określana podczas <xref:System.Collections.Queue>jest tworzony.</xref:System.Collections.Queue>       Elementy są kopiowane na <xref:System.Collections.Queue>w tej samej kolejności odczytywania ich przez <xref:System.Collections.IEnumerator> <xref:System.Collections.ICollection>.</xref:System.Collections.ICollection> </xref:System.Collections.IEnumerator> </xref:System.Collections.Queue>       Ten konstruktor jest O (`n`) operację, której `n` jest liczba elementów w `col`."
  syntax:
    content: public Queue (System.Collections.ICollection col);
    parameters:
    - id: col
      type: System.Collections.ICollection
      description: "<xref:System.Collections.ICollection>Aby skopiować elementy z.</xref:System.Collections.ICollection>"
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>col</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(Int32)
  nameWithType: Queue.Queue(Int32)
  fullName: System.Collections.Queue.Queue(Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Collections.Queue&quot;> </xref> klasy, która jest pusta, ma określony początkowa pojemność i korzysta z domyślnego współczynnik wzrostu."
  remarks: "Pojemność <xref:System.Collections.Queue>jest liczba elementów <xref:System.Collections.Queue>może pomieścić.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Po dodaniu elementów do <xref:System.Collections.Queue>, automatycznie zostaje zwiększona wydajność co jest wymagane przez ponowne przydzielenie.</xref:System.Collections.Queue>  Można zmniejszyć pojemność przez wywołanie metody <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       Współczynnik wzrostu jest numerem, za pomocą którego bieżący jest mnożona gdy wymagana jest większej pojemności.  Współczynnik wzrostu jest określana podczas <xref:System.Collections.Queue>jest tworzony.</xref:System.Collections.Queue>       Jeśli rozmiar kolekcji można oszacować, określając początkowa pojemność eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Queue>.</xref:System.Collections.Queue>       Ten konstruktor jest O (`n`) operację, której `n` jest `capacity`."
  syntax:
    content: public Queue (int capacity);
    parameters:
    - id: capacity
      type: System.Int32
      description: "Początkowa liczba elementów który <xref href=&quot;System.Collections.Queue&quot;> </xref> może zawierać."
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>jest mniejsza od zera."
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Int32,System.Single)
  id: '#ctor(System.Int32,System.Single)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(Int32,Single)
  nameWithType: Queue.Queue(Int32,Single)
  fullName: System.Collections.Queue.Queue(Int32,Single)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Inicjuje nowe wystąpienie klasy <xref href=&quot;System.Collections.Queue&quot;> </xref> klasy, która jest pusta, ma określony początkowa pojemność i używa określonego współczynnik wzrostu."
  remarks: "Pojemność <xref:System.Collections.Queue>jest liczba elementów <xref:System.Collections.Queue>może pomieścić.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Po dodaniu elementów do <xref:System.Collections.Queue>, automatycznie zostaje zwiększona wydajność co jest wymagane przez ponowne przydzielenie.</xref:System.Collections.Queue>  Można zmniejszyć pojemność przez wywołanie metody <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       Współczynnik wzrostu jest numerem, za pomocą którego bieżący jest mnożona gdy wymagana jest większej pojemności.  Współczynnik wzrostu jest określana podczas <xref:System.Collections.Queue>jest tworzony.</xref:System.Collections.Queue> Pojemność <xref:System.Collections.Queue>zawsze spowoduje zwiększenie przez wartość minimalna, niezależnie od tego, współczynnik wzrostu; współczynnik wzrostu 1.0 nie zapobiega <xref:System.Collections.Queue>z się rozrasta.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       Jeśli rozmiar kolekcji można oszacować, określając początkowa pojemność eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Queue>.</xref:System.Collections.Queue>       Ten konstruktor jest O (`n`) operację, której `n` jest `capacity`."
  syntax:
    content: public Queue (int capacity, float growFactor);
    parameters:
    - id: capacity
      type: System.Int32
      description: "Początkowa liczba elementów który <xref href=&quot;System.Collections.Queue&quot;> </xref> może zawierać."
    - id: growFactor
      type: System.Single
      description: "Współczynnik za pomocą której pojemność <xref href=&quot;System.Collections.Queue&quot;> </xref> jest rozwinięta."
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>jest mniejsza od zera.       - lub - <code>growFactor</code> jest mniejsza niż wersji 1.0 lub nowszej niż 10.0."
  platform:
  - net462
- uid: System.Collections.Queue.Clear
  id: Clear
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Clear()
  nameWithType: Queue.Clear()
  fullName: System.Collections.Queue.Clear()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Usuwa wszystkie obiekty z <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "<xref:System.Collections.Queue.Count%2A>jest ustawiany na zero, a ponadto są również zwalniane odwołania do innych obiektów z elementów kolekcji.</xref:System.Collections.Queue.Count%2A>       Pojemność pozostaje niezmieniona. Aby zresetować pojemności <xref:System.Collections.Queue>należy wywołać <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A> </xref:System.Collections.Queue> Przycinanie pustą <xref:System.Collections.Queue>Ustawia pojemność <xref:System.Collections.Queue>do wydajności domyślnej.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       Ta metoda jest O (`n`) operację, której `n` <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to clear the values of the <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.Clear Example#1](~/add/codesnippet/cpp/m-system.collections.que_6_1.cpp)]\n [!code-cs[Classic Queue.Clear Example#1](~/add/codesnippet/csharp/m-system.collections.que_6_1.cs)]\n [!code-vb[Classic Queue.Clear Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_6_1.vb)]"
  syntax:
    content: public virtual void Clear ();
    parameters: []
  overload: System.Collections.Queue.Clear*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Clone
  id: Clone
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Clone()
  nameWithType: Queue.Clone()
  fullName: System.Collections.Queue.Clone()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Tworzy kopię pobieżną <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Kopię pobieżną kolekcji kopiuje elementy kolekcji, czy są typy odwołanie lub wartość, ale nie kopiuje obiektów, które dotyczą odwołania. Odwołania do nowej kolekcji wskazują te same obiekty, które wskazują odwołania w oryginalnej kolekcji.       Z kolei głęboką kopię kolekcji kopiuje elementy i wszystkich bezpośrednio lub pośrednio odwołuje się elementów.       Ta metoda jest O (`n`) operację, której `n` <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  syntax:
    content: public virtual object Clone ();
    parameters: []
    return:
      type: System.Object
      description: "Kopia pobieżna <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Contains(System.Object)
  id: Contains(System.Object)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Contains(Object)
  nameWithType: Queue.Contains(Object)
  fullName: System.Collections.Queue.Contains(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Określa, czy element jest <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Ta metoda określa równości, wywołując <xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>       Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym ta metoda jest O (`n`) operację, której `n` <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>       Począwszy od programu .NET Framework 2.0, ta metoda używa kolekcji obiektów <xref:System.Object.Equals%2A>i <xref:System.IComparable.CompareTo%2A>metody `obj` ustalenie, czy `item` istnieje.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> We wcześniejszych wersjach programu .NET Framework, oznaczanie został utworzony przy użyciu <xref:System.Object.Equals%2A>i <xref:System.IComparable.CompareTo%2A>metody `obj` parametrów dla obiektów w kolekcji.</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  syntax:
    content: public virtual bool Contains (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "<xref:System.Object>Do zlokalizowania w <xref href=&quot;System.Collections.Queue&quot;> </xref>.</xref:System.Object> Wartość może być <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>if <code>obj</code> is found in the <xref href=&quot;System.Collections.Queue&quot;></xref>; otherwise, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>."
  overload: System.Collections.Queue.Contains*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.CopyTo(System.Array,System.Int32)
  id: CopyTo(System.Array,System.Int32)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: CopyTo(Array,Int32)
  nameWithType: Queue.CopyTo(Array,Int32)
  fullName: System.Collections.Queue.CopyTo(Array,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Kopie <xref href=&quot;System.Collections.Queue&quot;> </xref> elementy do istniejącej jednowymiarowej tablicy <xref:System.Array>, rozpoczynając od określonego indeksu tablicy.</xref:System.Array>"
  remarks: "<xref:System.Array>w tej samej kolejności, w której moduł wyliczający iteruje <xref:System.Collections.Queue>.</xref:System.Collections.Queue> </xref:System.Array> są kopiowane elementy       Ta metoda jest O (`n`) operację, której `n` <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Queue> into a one-dimensional array.  \n  \n [!code-cpp[Classic Queue.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.que_4_1.cpp)]\n [!code-cs[Classic Queue.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.que_4_1.cs)]\n [!code-vb[Classic Queue.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_4_1.vb)]"
  syntax:
    content: public virtual void CopyTo (Array array, int index);
    parameters:
    - id: array
      type: System.Array
      description: "Jednowymiarowa <xref:System.Array>który jest miejscem docelowym elementów kopiowanych z <xref href=&quot;System.Collections.Queue&quot;> </xref>.</xref:System.Array> <xref:System.Array>Musi mieć indeksowania liczony od zera.</xref:System.Array>"
    - id: index
      type: System.Int32
      description: "Liczony od zera indeks w `array` od rozpoczyna się kopiowanie które."
  overload: System.Collections.Queue.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>jest mniejsza od zera."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>jest wielowymiarowy.       - lub - liczba elementów w źródle <xref href=&quot;System.Collections.Queue&quot;> </xref> jest większa niż dostępne miejsce od <code>index</code> do końca tablicy docelowej <code>array</code>."
  - type: System.ArrayTypeMismatchException
    commentId: T:System.ArrayTypeMismatchException
    description: "Typ źródła <xref href=&quot;System.Collections.Queue&quot;> </xref> nie można automatycznie rzutować na typ docelowy <code> array </code>."
  platform:
  - net462
- uid: System.Collections.Queue.Count
  id: Count
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Count
  nameWithType: Queue.Count
  fullName: System.Collections.Queue.Count
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Pobiera liczbę elementów zawartych w <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Pojemność <xref:System.Collections.Queue>jest liczba elementów który <xref:System.Collections.Queue>może przechowywać.</xref:System.Collections.Queue> </xref:System.Collections.Queue> Liczba jest liczba elementów, które są rzeczywiście <xref:System.Collections.Queue>.</xref:System.Collections.Queue>       Pojemność <xref:System.Collections.Queue>zawsze jest większa lub równa wartości Count.</xref:System.Collections.Queue> Jeżeli liczba przekracza pojemność podczas dodawania elementów, pojemność jest automatycznie zwiększany o ponowne przydzielanie tablicy wewnętrznej przed skopiowaniem starych elementów i dodawanie nowych elementów. Nowego miejsca jest określany przez pomnożenie pojemność bieżąca przez współczynnik wzrostu, który jest określany podczas <xref:System.Collections.Queue>jest tworzony.</xref:System.Collections.Queue> Pojemność <xref:System.Collections.Queue>zawsze spowoduje zwiększenie przez wartość minimalna, niezależnie od tego, współczynnik wzrostu; współczynnik wzrostu 1.0 nie zapobiega <xref:System.Collections.Queue>z się rozrasta.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       Można zmniejszyć pojemność przez wywołanie metody <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       Pobieranie wartości tej właściwości jest operacją O(1)."
  syntax:
    content: public virtual int Count { get; }
    return:
      type: System.Int32
      description: "Liczba elementów zawartych w <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.Count*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Dequeue
  id: Dequeue
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Dequeue()
  nameWithType: Queue.Dequeue()
  fullName: System.Collections.Queue.Dequeue()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Usuwa i zwraca obiekt na początku <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Ta metoda jest podobna do <xref:System.Collections.Queue.Peek%2A>metody, ale <xref:System.Collections.Queue.Peek%2A>nie modyfikuje <xref:System.Collections.Queue>.</xref:System.Collections.Queue> </xref:System.Collections.Queue.Peek%2A> </xref:System.Collections.Queue.Peek%2A>       `null`można dodać do <xref:System.Collections.Queue>jako wartość.</xref:System.Collections.Queue> Aby odróżnić wartości null końcu <xref:System.Collections.Queue>, sprawdź <xref:System.Collections.Queue.Count%2A>Właściwości lub catch <xref:System.InvalidOperationException>, który jest zgłaszany, gdy <xref:System.Collections.Queue>jest pusta.</xref:System.Collections.Queue> </xref:System.InvalidOperationException> </xref:System.Collections.Queue.Count%2A> </xref:System.Collections.Queue>       Ta metoda jest operacją O(1)."
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_0_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_0_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_0_1.cpp)]"
  syntax:
    content: public virtual object Dequeue ();
    parameters: []
    return:
      type: System.Object
      description: "Obiekt, który zostanie usunięty z początku <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.Dequeue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Collections.Queue&quot;> </xref> Jest pusta."
  platform:
  - net462
- uid: System.Collections.Queue.Enqueue(System.Object)
  id: Enqueue(System.Object)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Enqueue(Object)
  nameWithType: Queue.Enqueue(Object)
  fullName: System.Collections.Queue.Enqueue(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Dodaje obiekt na koniec <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Pojemność <xref:System.Collections.Queue>jest liczba elementów <xref:System.Collections.Queue>może pomieścić.</xref:System.Collections.Queue> </xref:System.Collections.Queue>  Po dodaniu elementów do <xref:System.Collections.Queue>, automatycznie zostaje zwiększona wydajność co jest wymagane przez ponowne przydzielenie.</xref:System.Collections.Queue>  Można zmniejszyć pojemność przez wywołanie metody <xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>       Współczynnik wzrostu jest numerem, za pomocą którego bieżący jest mnożona gdy wymagana jest większej pojemności.  Współczynnik wzrostu jest określana podczas <xref:System.Collections.Queue>jest tworzony.</xref:System.Collections.Queue> Pojemność <xref:System.Collections.Queue>zawsze spowoduje zwiększenie przez wartość minimalna, niezależnie od tego, współczynnik wzrostu; współczynnik wzrostu 1.0 nie zapobiega <xref:System.Collections.Queue>z się rozrasta.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       Jeśli <xref:System.Collections.Queue.Count%2A>jest mniejsza niż pojemność tablicy wewnętrznej, ta metoda jest operacją O(1).</xref:System.Collections.Queue.Count%2A> Jeśli tablicy wewnętrznej musi można przydzielić, aby pomieścić nowy element, ta metoda staje się O (`n`) operację, której `n` <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_5_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_5_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_5_1.cpp)]"
  syntax:
    content: public virtual void Enqueue (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "Obiekt do dodania do <xref href=&quot;System.Collections.Queue&quot;> </xref>. Wartość może być <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Queue.Enqueue*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.GetEnumerator
  id: GetEnumerator
  parent: System.Collections.Queue
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: Queue.GetEnumerator()
  fullName: System.Collections.Queue.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Zwraca moduł wyliczający, który iteruje po <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "`foreach` Instrukcji języka C# (`for each` w języku Visual Basic) ukrywa złożoność wyliczenia.  W związku z tym przy użyciu `foreach` jest zalecane, zamiast bezpośrednie manipulowanie modułu wyliczającego.       Moduły wyliczające może służyć do odczytywania danych w kolekcji, ale nie może służyć do modyfikowania kolekcji źródłowej.       Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A>również wprowadzono moduł wyliczający wróć do tej pozycji.</xref:System.Collections.IEnumerator.Reset%2A>  W tym miejscu <xref:System.Collections.IEnumerator.Current%2A>jest niezdefiniowany.</xref:System.Collections.IEnumerator.Current%2A> W związku z tym należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A>można poprawić modułu wyliczającego pierwszy element do kolekcji przed odczytaniem wartość <xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>zwraca ten sam obiekt do momentu <xref:System.Collections.IEnumerator.MoveNext%2A>lub <xref:System.Collections.IEnumerator.Reset%2A>jest wywoływana.</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>Ustawia <xref:System.Collections.IEnumerator.Current%2A>do następnego elementu.</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A>przekazuje końcem kolekcji, moduł wyliczający jest umieszczony za ostatnim elementem w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A>zwraca `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Gdy moduł wyliczający jest w tym miejscu kolejnych wywołań <xref:System.Collections.IEnumerator.MoveNext%2A>zwracają również `false`.</xref:System.Collections.IEnumerator.MoveNext%2A> Jeśli przez ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A>zwrócił `false`, <xref:System.Collections.IEnumerator.Current%2A>jest niezdefiniowany.</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> Aby ustawić <xref:System.Collections.IEnumerator.Current%2A>pierwszy element w kolekcji, należy wywołać, <xref:System.Collections.IEnumerator.Reset%2A>następuje <xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A>       Moduł wyliczający pozostaje ważny tak długo, jak kolekcji pozostaje niezmieniona. Jeśli wprowadzono zmiany w kolekcji, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający jest bezpowrotnie nieważne i jego zachowanie jest niezdefiniowana.       Moduł wyliczający nie ma wyłączny dostęp do kolekcji; w związku z tym wyliczania kolekcji leżą nie jest bezpieczne wątkowo procedurą.  W celu zagwarantowania bezpieczeństwa wątków podczas wyliczania, można zablokować kolekcję podczas całej wyliczenia.  Aby zezwolić na dostęp przez wiele wątków do odczytu i zapisu do kolekcji, musi implementować własne synchronizacji.       Ta metoda jest operacją O(1)."
  syntax:
    content: public virtual System.Collections.IEnumerator GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "An <xref:System.Collections.IEnumerator> for the <xref href=&quot;System.Collections.Queue&quot;></xref>.</xref:System.Collections.IEnumerator>"
  overload: System.Collections.Queue.GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.IsSynchronized
  id: IsSynchronized
  parent: System.Collections.Queue
  langs:
  - csharp
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
  fullName: System.Collections.Queue.IsSynchronized
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Pobiera wartość wskazującą czy uzyskują dostęp do <xref href=&quot;System.Collections.Queue&quot;> </xref> jest synchronizowane (wielowątkowość)."
  remarks: "W celu zagwarantowania bezpieczeństwa wątków <xref:System.Collections.Queue>, wszystkie operacje muszą być wykonywane przez otoki zwrócony przez <xref:System.Collections.Queue.Synchronized%2A>metody.</xref:System.Collections.Queue.Synchronized%2A> </xref:System.Collections.Queue>       Wyliczanie za pomocą kolekcji leżą nie jest procedurą wątkowo. Nawet jeśli kolekcja jest synchronizowane, inne wątki mogą modyfikować kolekcji, co powoduje, że moduł wyliczający, który ma zostać zgłoszony wyjątek. W celu zagwarantowania bezpieczeństwa wątków podczas wyliczania, możesz zablokować kolekcji podczas wyliczania całego lub przechwytują wyjątki wynikające ze zmian wprowadzonych przez inne wątki."
  example:
  - "The following code example shows how to lock the collection using the <xref:System.Collections.Queue.SyncRoot%2A> during the entire enumeration. Retrieving the value of this property is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/p-system.collections.que_0_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/p-system.collections.que_0_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/p-system.collections.que_0_1.vb)]  \n  \n The following example shows how to synchronize a <xref:System.Collections.Queue>, determine if a <xref:System.Collections.Queue> is synchronized, and use a synchronized <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/cpp/p-system.collections.que_0_2.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/csharp/p-system.collections.que_0_2.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/visualbasic/p-system.collections.que_0_2.vb)]"
  syntax:
    content: public virtual bool IsSynchronized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Jeśli dostęp do <xref href=&quot;System.Collections.Queue&quot;> </xref> jest synchronizowane (wielowątkowość); w przeciwnym razie <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Wartość domyślna to <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Collections.Queue.IsSynchronized*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Peek
  id: Peek
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Peek()
  nameWithType: Queue.Peek()
  fullName: System.Collections.Queue.Peek()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Zwraca obiekt na początku <xref href=&quot;System.Collections.Queue&quot;> </xref> bez usuwania go."
  remarks: "Ta metoda jest podobna do <xref:System.Collections.Queue.Dequeue%2A>metody, ale Peek nie modyfikuje <xref:System.Collections.Queue>.</xref:System.Collections.Queue> </xref:System.Collections.Queue.Dequeue%2A>       `null`można dodać do <xref:System.Collections.Queue>jako wartość.</xref:System.Collections.Queue> Aby odróżnić wartości null końcu <xref:System.Collections.Queue>, sprawdź <xref:System.Collections.Queue.Count%2A>Właściwości lub catch <xref:System.InvalidOperationException>, który jest zgłaszany, gdy <xref:System.Collections.Queue>jest pusta.</xref:System.Collections.Queue> </xref:System.InvalidOperationException> </xref:System.Collections.Queue.Count%2A> </xref:System.Collections.Queue>       Ta metoda jest operacją O(1)."
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_1_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_1_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_1_1.cpp)]"
  syntax:
    content: public virtual object Peek ();
    parameters: []
    return:
      type: System.Object
      description: "Obiekt na początku <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.Peek*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Collections.Queue&quot;> </xref> Jest pusta."
  platform:
  - net462
- uid: System.Collections.Queue.Synchronized(System.Collections.Queue)
  id: Synchronized(System.Collections.Queue)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Synchronized(Queue)
  nameWithType: Queue.Synchronized(Queue)
  fullName: System.Collections.Queue.Synchronized(Queue)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Zwraca nowy <xref href=&quot;System.Collections.Queue&quot;> </xref> opakowuje oryginalną kolejkę i zapewnia bezpieczeństwa wątkowego."
  remarks: "Otoka zwracane przez tę metodę blokuje kolejki, przed wykonaniem operacji tak, aby odbywa się w sposób wątkowo.       W celu zagwarantowania bezpieczeństwa wątków <xref:System.Collections.Queue>, wszystkie operacje musi odbywać się za pomocą tylko tej otoki.</xref:System.Collections.Queue>       Wyliczanie za pomocą kolekcji leżą nie jest procedurą wątkowo. Nawet jeśli kolekcja jest synchronizowane, inne wątki mogą modyfikować kolekcji, co powoduje, że moduł wyliczający, który ma zostać zgłoszony wyjątek. W celu zagwarantowania bezpieczeństwa wątków podczas wyliczania, możesz zablokować kolekcji podczas wyliczania całego lub przechwytują wyjątki wynikające ze zmian wprowadzonych przez inne wątki."
  example:
  - "The following code example shows how to lock the collection using the <xref:System.Collections.Queue.SyncRoot%2A> during the entire enumeration. This method is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/m-system.collections.que_3_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/m-system.collections.que_3_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/m-system.collections.que_3_1.vb)]  \n  \n The following example shows how to synchronize a <xref:System.Collections.Queue>, determine if a <xref:System.Collections.Queue> is synchronized and use a synchronized <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/cpp/m-system.collections.que_3_2.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/csharp/m-system.collections.que_3_2.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_3_2.vb)]"
  syntax:
    content: public static System.Collections.Queue Synchronized (System.Collections.Queue queue);
    parameters:
    - id: queue
      type: System.Collections.Queue
      description: "<xref href=&quot;System.Collections.Queue&quot;> </xref> Do synchronizacji."
    return:
      type: System.Collections.Queue
      description: "A <xref href=&quot;System.Collections.Queue&quot;> </xref> otoki, który jest synchronizowane (wielowątkowość)."
  overload: System.Collections.Queue.Synchronized*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>queue</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Queue.SyncRoot
  id: SyncRoot
  parent: System.Collections.Queue
  langs:
  - csharp
  name: SyncRoot
  nameWithType: Queue.SyncRoot
  fullName: System.Collections.Queue.SyncRoot
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Pobiera obiekt, który może służyć do synchronizujący dostęp do <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Aby utworzyć zsynchronizowaną wersję <xref:System.Collections.Queue>, użyj <xref:System.Collections.Queue.Synchronized%2A>metody.</xref:System.Collections.Queue.Synchronized%2A> </xref:System.Collections.Queue> Jednak klasy pochodne zapewniają własne zsynchronizowanej wersji <xref:System.Collections.Queue>za pomocą właściwości SyncRoot.</xref:System.Collections.Queue> Synchronizowanie kodu musi wykonywać operacje na SyncRoot z <xref:System.Collections.Queue>, bezpośrednio na <xref:System.Collections.Queue>.</xref:System.Collections.Queue> </xref:System.Collections.Queue> Zapewnia to poprawne działanie kolekcje, które pochodzą od innych obiektów. W szczególności przechowuje prawidłowego synchronizacji z innych wątków, które mogą być jednocześnie modyfikowanie <xref:System.Collections.Queue>obiektu.</xref:System.Collections.Queue>       Wyliczanie za pomocą kolekcji leżą nie jest procedurą wątkowo. Nawet jeśli kolekcja jest synchronizowane, inne wątki mogą modyfikować kolekcji, co powoduje, że moduł wyliczający, który ma zostać zgłoszony wyjątek. W celu zagwarantowania bezpieczeństwa wątków podczas wyliczania, możesz zablokować kolekcji podczas wyliczania całego lub przechwytują wyjątki wynikające ze zmian wprowadzonych przez inne wątki."
  example:
  - "The following code example shows how to lock the collection using the SyncRoot during the entire enumeration. Retrieving the value of this property is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/p-system.collections.que_1_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/p-system.collections.que_1_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/p-system.collections.que_1_1.vb)]"
  syntax:
    content: public virtual object SyncRoot { get; }
    return:
      type: System.Object
      description: "Obiekt, który może służyć do synchronizujący dostęp do <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.SyncRoot*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.ToArray
  id: ToArray
  parent: System.Collections.Queue
  langs:
  - csharp
  name: ToArray()
  nameWithType: Queue.ToArray()
  fullName: System.Collections.Queue.ToArray()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Kopie <xref href=&quot;System.Collections.Queue&quot;> </xref> elementy do nowej tablicy."
  remarks: "<xref:System.Collections.Queue>Nie jest modyfikowany.</xref:System.Collections.Queue> Kolejność elementów w nowej tablicy jest taka sama jak kolejność elementów od początku <xref:System.Collections.Queue>do końca.</xref:System.Collections.Queue>       Ta metoda jest O (`n`) operację, której `n` <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Queue> into a one-dimensional array.  \n  \n [!code-cpp[Classic Queue.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.que_2_1.cpp)]\n [!code-cs[Classic Queue.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.que_2_1.cs)]\n [!code-vb[Classic Queue.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_2_1.vb)]"
  syntax:
    content: public virtual object[] ToArray ();
    parameters: []
    return:
      type: System.Object[]
      description: "Nowe tablica zawierająca elementów kopiowanych z <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  overload: System.Collections.Queue.ToArray*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.TrimToSize
  id: TrimToSize
  parent: System.Collections.Queue
  langs:
  - csharp
  name: TrimToSize()
  nameWithType: Queue.TrimToSize()
  fullName: System.Collections.Queue.TrimToSize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "Ustawia pojemność na rzeczywistą liczbę elementów w <xref href=&quot;System.Collections.Queue&quot;> </xref>."
  remarks: "Tej metody można zminimalizować obciążenie pamięci kolejki, jeśli żadne nowe elementy, które zostaną dodane do kolejki.       Aby zresetować <xref:System.Collections.Queue>do stanu początkowego wywołać <xref:System.Collections.Queue.Clear%2A>Metoda przed wywołaniem TrimToSize.</xref:System.Collections.Queue.Clear%2A> </xref:System.Collections.Queue> Przycinanie pustą <xref:System.Collections.Queue>Ustawia pojemność <xref:System.Collections.Queue>do wydajności domyślnej.</xref:System.Collections.Queue> </xref:System.Collections.Queue>       Ta metoda jest O (`n`) operację, której `n` <xref:System.Collections.Queue.Count%2A>.</xref:System.Collections.Queue.Count%2A>"
  syntax:
    content: public virtual void TrimToSize ();
    parameters: []
  overload: System.Collections.Queue.TrimToSize*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.Queue&quot;> </xref> Jest tylko do odczytu."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArrayTypeMismatchException
  isExternal: true
  name: System.ArrayTypeMismatchException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.Collections.Queue.#ctor
  parent: System.Collections.Queue
  isExternal: false
  name: Queue()
  nameWithType: Queue.Queue()
  fullName: System.Collections.Queue.Queue()
- uid: System.Collections.Queue.#ctor(System.Collections.ICollection)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(ICollection)
  nameWithType: Queue.Queue(ICollection)
  fullName: System.Collections.Queue.Queue(ICollection)
- uid: System.Collections.ICollection
  parent: System.Collections
  isExternal: true
  name: ICollection
  nameWithType: ICollection
  fullName: System.Collections.ICollection
- uid: System.Collections.Queue.#ctor(System.Int32)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(Int32)
  nameWithType: Queue.Queue(Int32)
  fullName: System.Collections.Queue.Queue(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Collections.Queue.#ctor(System.Int32,System.Single)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(Int32,Single)
  nameWithType: Queue.Queue(Int32,Single)
  fullName: System.Collections.Queue.Queue(Int32,Single)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: System.Collections.Queue.Clear
  parent: System.Collections.Queue
  isExternal: false
  name: Clear()
  nameWithType: Queue.Clear()
  fullName: System.Collections.Queue.Clear()
- uid: System.Collections.Queue.Clone
  parent: System.Collections.Queue
  isExternal: false
  name: Clone()
  nameWithType: Queue.Clone()
  fullName: System.Collections.Queue.Clone()
- uid: System.Collections.Queue.Contains(System.Object)
  parent: System.Collections.Queue
  isExternal: false
  name: Contains(Object)
  nameWithType: Queue.Contains(Object)
  fullName: System.Collections.Queue.Contains(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Collections.Queue.CopyTo(System.Array,System.Int32)
  parent: System.Collections.Queue
  isExternal: false
  name: CopyTo(Array,Int32)
  nameWithType: Queue.CopyTo(Array,Int32)
  fullName: System.Collections.Queue.CopyTo(Array,Int32)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: System.Collections.Queue.Count
  parent: System.Collections.Queue
  isExternal: false
  name: Count
  nameWithType: Queue.Count
  fullName: System.Collections.Queue.Count
- uid: System.Collections.Queue.Dequeue
  parent: System.Collections.Queue
  isExternal: false
  name: Dequeue()
  nameWithType: Queue.Dequeue()
  fullName: System.Collections.Queue.Dequeue()
- uid: System.Collections.Queue.Enqueue(System.Object)
  parent: System.Collections.Queue
  isExternal: false
  name: Enqueue(Object)
  nameWithType: Queue.Enqueue(Object)
  fullName: System.Collections.Queue.Enqueue(Object)
- uid: System.Collections.Queue.GetEnumerator
  parent: System.Collections.Queue
  isExternal: false
  name: GetEnumerator()
  nameWithType: Queue.GetEnumerator()
  fullName: System.Collections.Queue.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Collections.Queue.IsSynchronized
  parent: System.Collections.Queue
  isExternal: false
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
  fullName: System.Collections.Queue.IsSynchronized
- uid: System.Collections.Queue.Peek
  parent: System.Collections.Queue
  isExternal: false
  name: Peek()
  nameWithType: Queue.Peek()
  fullName: System.Collections.Queue.Peek()
- uid: System.Collections.Queue.Synchronized(System.Collections.Queue)
  parent: System.Collections.Queue
  isExternal: false
  name: Synchronized(Queue)
  nameWithType: Queue.Synchronized(Queue)
  fullName: System.Collections.Queue.Synchronized(Queue)
- uid: System.Collections.Queue
  parent: System.Collections
  isExternal: false
  name: Queue
  nameWithType: Queue
  fullName: System.Collections.Queue
- uid: System.Collections.Queue.SyncRoot
  parent: System.Collections.Queue
  isExternal: false
  name: SyncRoot
  nameWithType: Queue.SyncRoot
  fullName: System.Collections.Queue.SyncRoot
- uid: System.Collections.Queue.ToArray
  parent: System.Collections.Queue
  isExternal: false
  name: ToArray()
  nameWithType: Queue.ToArray()
  fullName: System.Collections.Queue.ToArray()
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Collections.Queue.TrimToSize
  parent: System.Collections.Queue
  isExternal: false
  name: TrimToSize()
  nameWithType: Queue.TrimToSize()
  fullName: System.Collections.Queue.TrimToSize()
- uid: System.Collections.Queue.#ctor*
  parent: System.Collections.Queue
  isExternal: false
  name: Queue
  nameWithType: Queue.Queue
- uid: System.Collections.Queue.Clear*
  parent: System.Collections.Queue
  isExternal: false
  name: Clear
  nameWithType: Queue.Clear
- uid: System.Collections.Queue.Clone*
  parent: System.Collections.Queue
  isExternal: false
  name: Clone
  nameWithType: Queue.Clone
- uid: System.Collections.Queue.Contains*
  parent: System.Collections.Queue
  isExternal: false
  name: Contains
  nameWithType: Queue.Contains
- uid: System.Collections.Queue.CopyTo*
  parent: System.Collections.Queue
  isExternal: false
  name: CopyTo
  nameWithType: Queue.CopyTo
- uid: System.Collections.Queue.Count*
  parent: System.Collections.Queue
  isExternal: false
  name: Count
  nameWithType: Queue.Count
- uid: System.Collections.Queue.Dequeue*
  parent: System.Collections.Queue
  isExternal: false
  name: Dequeue
  nameWithType: Queue.Dequeue
- uid: System.Collections.Queue.Enqueue*
  parent: System.Collections.Queue
  isExternal: false
  name: Enqueue
  nameWithType: Queue.Enqueue
- uid: System.Collections.Queue.GetEnumerator*
  parent: System.Collections.Queue
  isExternal: false
  name: GetEnumerator
  nameWithType: Queue.GetEnumerator
- uid: System.Collections.Queue.IsSynchronized*
  parent: System.Collections.Queue
  isExternal: false
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
- uid: System.Collections.Queue.Peek*
  parent: System.Collections.Queue
  isExternal: false
  name: Peek
  nameWithType: Queue.Peek
- uid: System.Collections.Queue.Synchronized*
  parent: System.Collections.Queue
  isExternal: false
  name: Synchronized
  nameWithType: Queue.Synchronized
- uid: System.Collections.Queue.SyncRoot*
  parent: System.Collections.Queue
  isExternal: false
  name: SyncRoot
  nameWithType: Queue.SyncRoot
- uid: System.Collections.Queue.ToArray*
  parent: System.Collections.Queue
  isExternal: false
  name: ToArray
  nameWithType: Queue.ToArray
- uid: System.Collections.Queue.TrimToSize*
  parent: System.Collections.Queue
  isExternal: false
  name: TrimToSize
  nameWithType: Queue.TrimToSize
